<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article simulates a memory leak program to explain the working principles of eBPF and the challenges it faces, particularly its limitations when dealing with incomplete call stacks. It also discusses how to trace tcmalloc using gdb and generate memory leak flame graphs using FlameGraph. Finally, it addresses the controversy of enabling frame pointers by default during compilation."><title>In-depth Understanding of eBPF-based C/C++ Memory Leak Analysis</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">In-depth Understanding of eBPF-based C/C++ Memory Leak Analysis</h1><div class="post-meta">2023/11/08<span> | </span><span class="category"><a href="/categories/Programming/">Programming</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2023/11/08/memory_leak_ebpf/" href="/en/2023/11/08/memory_leak_ebpf/#disqus_thread"></a><div class="post-content"><p>For C/C++ programmers, memory leak is a perennial issue. There are many methods to troubleshoot memory leaks, such as using tools like valgrind, gdb, asan, tsan, etc., but each of these tools has its limitations. For example, valgrind slows down program execution, gdb requires understanding of the code and manual breakpoint setting, while asan and tsan require recompiling the program. For complex services that are already running, these methods are not very convenient.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231030_memory_leak_ebpf_index.png/webp" alt="Memory leak flame graph obtained through eBPF analysis" srcset="https://slefboot-1251736664.file.myqcloud.com/20231030_memory_leak_ebpf_index.png/webp 2382w, https://slefboot-1251736664.file.myqcloud.com/20231030_memory_leak_ebpf_index.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231030_memory_leak_ebpf_index.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231030_memory_leak_ebpf_index.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2382" height="832"></p>
<p>Fortunately, with eBPF, we can analyze memory leak problems without recompiling the program and with minimal impact on program execution speed. The power of eBPF is evident, but <strong>eBPF is not a silver bullet</strong>. There are still <strong>many issues to be resolved</strong> when using it to analyze memory leaks. This article will discuss the common problems encountered in eBPF-based detection.</p>
<span id="more"></span>

<h2 id="Memory-Leak-Simulation"><a href="#Memory-Leak-Simulation" class="headerlink" title="Memory Leak Simulation"></a>Memory Leak Simulation</h2><p>In C/C++, a memory leak refers to a situation where the program, for some reason, <strong>fails to release memory that is no longer in use</strong> during its execution, resulting in a waste of system memory. Once a memory leak occurs, it can cause the program to run slower or even be killed by OOM (Out of Memory). Memory leaks often occur due to <strong>not releasing memory in a timely manner</strong> when writing programs, or due to design flaws that prevent the program from releasing memory that is no longer in use during execution.</p>
<p>Below is a simple memory leak simulation program. The program allocates memory in a loop but doesn’t release it, leading to a memory leak. The main program is as follows, with the leaking function call chain being <code>main-&gt;caller-&gt;slowMemoryLeak</code>:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LeakLib {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slowMemoryLeak</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">caller</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"In caller"</span> &lt;&lt; std::endl;</span><br><span class="line">    LeakLib::<span class="built_in">slowMemoryLeak</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Starting slow memory leak program..."</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">caller</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The memory-leaking code is in the <code>slowMemoryLeak</code> function, specifically as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LeakLib {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slowMemoryLeak</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> arrSize = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[arrSize];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; ++i) {</span><br><span class="line">                p[i] = i; <span class="comment">// Assign values to occupy physical memory</span></span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// wait for 1 second</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Note that during compilation, the frame pointer option is included (controlled by the <code>-fno-omit-frame-pointer</code> option). This is because eBPF tools need to use the frame pointer for call stack tracing. If we ignore the frame pointer here (<code>-fomit-frame-pointer</code>), eBPF-based tools won’t be able to get the stack information of the memory leak. The complete compilation command is as follows (-g can be omitted, but it’s added here to facilitate viewing some information with gdb):</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ main.cpp leak_lib.cpp -o main -fno-omit-frame-pointer -g</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="memleak-Analysis"><a href="#memleak-Analysis" class="headerlink" title="memleak Analysis"></a>memleak Analysis</h2><p>Next, let’s perform memory leak analysis based on eBPF. <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">BCC</a> comes with a <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/memleak.py">memleak</a> memory analysis tool that can be used to analyze the call stack of memory leaks. For the example leak code above, after compilation and execution of the program, run the memory leak detection <code>memleak -p $(pgrep main) --combined-only</code>.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231101_memory_leak_ebpf_bcc_new.png/webp" alt="eBPF bcc memleak memory leak analysis" srcset="https://slefboot-1251736664.file.myqcloud.com/20231101_memory_leak_ebpf_bcc_new.png/webp 2058w, https://slefboot-1251736664.file.myqcloud.com/20231101_memory_leak_ebpf_bcc_new.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231101_memory_leak_ebpf_bcc_new.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231101_memory_leak_ebpf_bcc_new.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2058" height="1056"></p>
<p>The <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/24822c2e9459f4508fb7071071c26a80d4c9dc5b/tools/memleak.py">current version of the memleak tool</a> has a bug that causes an error when printing with <code>--combined-only</code>. The fix is simple, and I’ve submitted <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/pull/4769/files">PR #4769</a>, which has been merged into master. Looking closely at the script’s output, we can see that the call stack here is actually incomplete, missing the <code>slowMemoryLeak</code> function call.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[11:19:44] Top 10 stacks with outstanding allocations:</span><br><span class="line">	480 bytes in 12 allocations from stack</span><br><span class="line">		operator new(unsigned long)+0x1c [libstdc++.so.6.0.30]</span><br><span class="line">		caller()+0x31 [main]</span><br><span class="line">		main+0x31 [main]</span><br><span class="line">		__libc_start_call_main+0x7a [libc.so.6]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Incomplete-Call-Chain"><a href="#Incomplete-Call-Chain" class="headerlink" title="Incomplete Call Chain"></a>Incomplete Call Chain</h3><p>Why is the intermediate function call lost here? We know that eBPF-related tools use the <code>frame pointer</code> to trace the call stack. For the specific principle, you can refer to my friend’s article <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WWqPO9Q4BCO5SgyuMk8Ddg">The Disappearing Call Stack Frame - Principle Analysis of FP-based Stack Tracing</a>. If you encounter an incomplete call chain, it’s usually due to a missing frame pointer. Let’s verify this.</p>
<p>First, use <code>objdump -d -S main &gt; main_with_source.asm</code> to generate assembly instructions with source code. Find the assembly code for the <code>slowMemoryLeak</code> function, as shown in the following image:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231102_memory_leak_ebpf_src_assembly_code.png/webp" alt="Assembly code corresponding to the main function in eBPF bcc" srcset="https://slefboot-1251736664.file.myqcloud.com/20231102_memory_leak_ebpf_src_assembly_code.png/webp 2176w, https://slefboot-1251736664.file.myqcloud.com/20231102_memory_leak_ebpf_src_assembly_code.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231102_memory_leak_ebpf_src_assembly_code.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231102_memory_leak_ebpf_src_assembly_code.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2176" height="1286"></p>
<p>From this assembly code, we can see that <code>new int[]</code> corresponds to a call to <code>_Znam@plt</code>. This is the name-mangled form of C++’s operator new[], as follows:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _Znam</span></span><br><span class="line">operator new[](unsigned long)</span><br></pre></td></tr></tbody></table></figure>

<p>We know that in C++, the new operation is used for dynamic memory allocation and usually ends up calling underlying memory allocation functions like malloc. Here, <code>_Znam@plt</code> is done through the <code>PLT (Procedure Linkage Table)</code>, which is a dynamically resolved symbol, typically implemented as <code>operator new[]</code> in libstdc++ (or other C++ standard library implementations). The assembly code corresponding to <code>_Znam@plt</code> is as follows:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000001030 &lt;_Znam@plt&gt;:</span><br><span class="line">    1030:       ff 25 ca 2f 00 00       jmp    *0x2fca(%rip)        # 4000 &lt;_Znam@GLIBCXX_3.4&gt;</span><br><span class="line">    1036:       68 00 00 00 00          push   $0x0</span><br><span class="line">    103b:       e9 e0 ff ff ff          jmp    1020 &lt;_init+0x20&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>There’s no <code>push %rbp</code> operation here like in the slowMemoryLeak call, so stack information will be lost. Why isn’t the frame pointer retained here? The <code>-fno-omit-frame-pointer</code> we used during compilation ensures that our own code includes frame pointers, but we have no control over the standard libraries we depend on, like libstdc++. The C++ standard library on the current system wasn’t compiled with frame pointers, possibly to reduce the overhead of function calls (by reducing the number of instructions executed). Whether to include -fno-omit-frame-pointer by default during compilation is quite controversial. There’s a <a href="#enabling-frame-pointers-by-default">dedicated section: Enabling Frame Pointers by Default</a> at the end of the article to discuss this.</p>
<h2 id="tcmalloc-Leak-Analysis"><a href="#tcmalloc-Leak-Analysis" class="headerlink" title="tcmalloc Leak Analysis"></a>tcmalloc Leak Analysis</h2><p>If you want to get the complete memory leak function call chain, you can recompile <code>libstdc++</code> with frame pointers, although recompiling the standard library is quite troublesome. In fact, tcmalloc is more commonly used in daily work, with more efficient memory allocation management. To verify the performance of the above code under tcmalloc, I compiled the <code>tcmalloc</code> library with the -fno-omit-frame-pointer frame pointer. As follows:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/gperftools/gperftools.git</span><br><span class="line">cd gperftools</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure CXXFLAGS="-fno-omit-frame-pointer" --prefix=/path/to/install/dir</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure>

<p>Then run the above binary and use memleak to check for memory leaks again. <strong>Note that -O is used here to pass the path of the libtcmalloc.so dynamic library to memleak.</strong> The parameter value is stored in obj and used in attach_uprobe to specify the binary object to attach uprobes or uretprobes to, which can be the library path or executable file of the function to be traced. For detailed documentation, refer to <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#4-attach_uprobe">bcc: 4. attach_uprobe</a>. For example, the following call method:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set a breakpoint at the entry of the getaddrinfo function in libc. When entering the function, it will call the custom do_entry function</span></span><br><span class="line">b.attach_uprobe(name=<span class="string">"c"</span>, sym=<span class="string">"getaddrinfo"</span>, fn_name=<span class="string">"do_entry"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>Note that in the previous example, -O was not specified, so the default was “c”, which means using libc for memory allocation. When using the tcmalloc dynamic library, <code>attach_uprobe</code> and <code>attach_uretprobe</code> must specify the library path:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bpf.attach_uprobe(name=obj, sym=sym, fn_name=fn_prefix + <span class="string">"_enter"</span>, pid=pid)</span><br><span class="line">bpf.attach_uretprobe(name=obj, sym=sym, fn_name=fn_prefix + <span class="string">"_exit"</span>, pid=pid)</span><br></pre></td></tr></tbody></table></figure>

<p>However, the tool’s output is a bit surprising, as it <strong>doesn’t output any leaking stack</strong>:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">memleak -p $(pgrep main) --combined-only -O /usr/local/lib/libtcmalloc.so</span></span><br><span class="line">Attaching to pid 1409827, Ctrl+C to quit.</span><br><span class="line">[19:55:45] Top 10 stacks with outstanding allocations:</span><br><span class="line"></span><br><span class="line">[19:55:50] Top 10 stacks with outstanding allocations:</span><br></pre></td></tr></tbody></table></figure>

<p>The memory allocated by new is clearly not being released, <strong>so why can’t the eBPF tool detect it</strong>?</p>
<h3 id="Deep-Dive-into-Tool-Implementation"><a href="#Deep-Dive-into-Tool-Implementation" class="headerlink" title="Deep Dive into Tool Implementation"></a>Deep Dive into Tool Implementation</h3><p>Before guessing the reason, let’s take a closer look at the <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/memleak.py">code of the memleak tool</a> and fully understand the tool’s implementation principle. First, we can be clear that the final output of the tool is <strong>each call stack and its leaked memory amount</strong>. To get this result, eBPF <strong>sets breakpoints at both memory allocation and deallocation, records the memory allocation/deallocation amount of the current call stack</strong>, and then performs statistics. The core logic is as follows:</p>
<ol>
<li><code>gen_alloc_enter</code>: Set breakpoints (<code>attach_uprobe</code>) at various memory allocation points, such as the entry of malloc, cmalloc, realloc, and other functions (malloc_enter), get the current call stack ID and the size of allocated memory, and record them in a dictionary named sizes;</li>
<li><code>gen_alloc_exit2</code>: Set breakpoints (<code>attach_uretprobe</code>) at the exit of memory allocation functions (malloc_exit), get the starting address of this memory allocation, and at the same time get the size of allocated memory from the sizes field, record (address, stack_info) in the allocs dictionary; meanwhile, use <code>update_statistics_add</code> to update the final result dictionary combined_allocs, storing stack information and allocated memory size, count information;</li>
<li><code>gen_free_enter</code>: Set breakpoints at the entry of memory deallocation functions (gen_free_enter), get the corresponding stack information from the previous allocs dictionary based on the starting address of the memory to be freed, then use <code>update_statistics_del</code> to update the result dictionary combined_allocs, that is, in the statistics, subtract the total memory allocation and count of the current stack.</li>
</ol>
<h3 id="GDB-Stack-Tracing"><a href="#GDB-Stack-Tracing" class="headerlink" title="GDB Stack Tracing"></a>GDB Stack Tracing</h3><p>Now back to the previous question, why can’t the memory allocated by new through tcmalloc be counted? There’s a high possibility that the underlying functions for allocating and freeing memory in tcmalloc are not malloc/free, and are not within the functions where the memleak tool sets probes. So how do we know the memory allocation call chain in the previous example code? A simple method is to use GDB debugging to trace. Note that when compiling the tcmalloc library, include debug information, as follows:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure CXXFLAGS=<span class="string">"-g -fno-omit-frame-pointer"</span> CFLAGS=<span class="string">"-g -fno-omit-frame-pointer"</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>After compilation, you can use objdump to view the header information of the ELF file and the list of each section to verify if there is debug information in the dynamic library, as follows:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -h /usr/local/lib/libtcmalloc_debug.so.4 | grep debug</span></span><br><span class="line">/usr/local/lib/libtcmalloc_debug.so.4:     file format elf64-x86-64</span><br><span class="line"> 29 .debug_aranges 000082c0  0000000000000000  0000000000000000  000b8c67  2**0</span><br><span class="line"> 30 .debug_info   00157418  0000000000000000  0000000000000000  000c0f27  2**0</span><br><span class="line"> 31 .debug_abbrev 00018a9b  0000000000000000  0000000000000000  0021833f  2**0</span><br><span class="line"> 32 .debug_line   00028924  0000000000000000  0000000000000000  00230dda  2**0</span><br><span class="line"> 33 .debug_str    0009695d  0000000000000000  0000000000000000  002596fe  2**0</span><br><span class="line"> 34 .debug_ranges 00008b30  0000000000000000  0000000000000000  002f005b  2**0</span><br></pre></td></tr></tbody></table></figure>

<p>Then recompile the binary with the debug version of the dynamic library, use gdb to trace into the internal of the new operator, and get the result as shown in the following figure. We can see that indeed the malloc function is not called.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231106_memory_leak_ebpf_tcmalloc_gdb.png/webp" alt="Function calls corresponding to tcmalloc new operator" srcset="https://slefboot-1251736664.file.myqcloud.com/20231106_memory_leak_ebpf_tcmalloc_gdb.png/webp 2398w, https://slefboot-1251736664.file.myqcloud.com/20231106_memory_leak_ebpf_tcmalloc_gdb.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231106_memory_leak_ebpf_tcmalloc_gdb.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231106_memory_leak_ebpf_tcmalloc_gdb.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2398" height="802"></p>
<p>In fact, tcmalloc’s memory allocation strategy is quite complex, with various pre-allocated memory lists inside. When requesting memory spaces of different sizes, there are many strategies to choose the appropriate memory address.</p>
<h2 id="Normal-Memory-Leak-Analysis"><a href="#Normal-Memory-Leak-Analysis" class="headerlink" title="Normal Memory Leak Analysis"></a>Normal Memory Leak Analysis</h2><p>In the previous examples, whether using glibc or tcmalloc, when using new to allocate memory, the analysis results obtained by memleak were not perfect. This is because using eBPF to analyze memory leaks must meet two prerequisites:</p>
<ol>
<li>When compiling the binary, include the frame pointer. If there are dependencies on standard libraries or third-party libraries, they must also include frame pointers;</li>
<li>The actual memory allocation function must be within the functions where the tool sets probes, such as malloc, cmalloc, realloc, etc.</li>
</ol>
<p>So let’s look at the memory leak analysis results after satisfying these two conditions. Modify the memory allocation code in leak_lib.cpp above:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int* p = new int[arrSize];</span></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(arrSize * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></tbody></table></figure>

<p>Then recompile and run the program. Now memleak can get <strong>the complete call stack information</strong>, as follows:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ main.cpp leak_lib.cpp -o main -fno-omit-frame-pointer -g</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run main binary here</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">memleak -p $(pgrep main) --combined-only</span></span><br><span class="line">Attaching to pid 2025595, Ctrl+C to quit.</span><br><span class="line">[10:21:09] Top 10 stacks with outstanding allocations:</span><br><span class="line">	200 bytes in 5 allocations from stack</span><br><span class="line">		LeakLib::slowMemoryLeak()+0x20 [main]</span><br><span class="line">		caller()+0x31 [main]</span><br><span class="line">		main+0x31 [main]</span><br><span class="line">		__libc_start_call_main+0x7a [libc.so.6]</span><br><span class="line">[10:21:14] Top 10 stacks with outstanding allocations:</span><br><span class="line">	400 bytes in 10 allocations from stack</span><br><span class="line">		LeakLib::slowMemoryLeak()+0x20 [main]</span><br><span class="line">		caller()+0x31 [main]</span><br><span class="line">		main+0x31 [main]</span><br><span class="line">		__libc_start_call_main+0x7a [libc.so.6]</span><br></pre></td></tr></tbody></table></figure>

<p>If tcmalloc is used when allocating memory, it’s also possible to get the complete leak stack.</p>
<h2 id="Memory-Flame-Graph-Visualization"><a href="#Memory-Flame-Graph-Visualization" class="headerlink" title="Memory Flame Graph Visualization"></a>Memory Flame Graph Visualization</h2><p>In my previous article <a href="https://selfboot.cn/2023/10/17/c++_frame_pointer/">Frame Pointer Retention and eBPF Performance Analysis in Complex C++ Projects</a>, when using BCC tools for CPU profiling, we could use <a target="_blank" rel="noopener" href="https://github.com/brendangregg/FlameGraph/tree/master">FlameGraph</a> to convert the output results into a CPU flame graph, clearly identifying the hot spots in CPU usage. For memory leaks, we can similarly generate <strong>memory flame graphs</strong>.</p>
<p>The steps to generate a memory flame graph are similar to those for CPU. First, use a collection tool like a BCC script to collect data, then convert the collected data into a format that FlameGraph can understand, and finally use the FlameGraph script to generate an SVG image from the converted data. <strong>Each function call corresponds to a block in the image, with the width of the block representing the frequency of that function in the samples, thus identifying resource usage hotspots</strong>. The format of each line of data that FlameGraph recognizes is typically as follows:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Stack trace] [Sample value]</span><br><span class="line">main;foo;bar 58</span><br></pre></td></tr></tbody></table></figure>

<p>Here, the “<strong>stack trace</strong>“ refers to a snapshot of the function call stack, usually a semicolon-separated list of function names representing the path from the bottom of the call stack (usually the main function or the thread’s starting point) to the top (the currently executing function). The “sample value” could be CPU time spent on that call stack, memory usage, or other resource metrics. For memory leak analysis, <strong>the sample value can be the amount of memory leaked or the number of memory leak occurrences</strong>.</p>
<p>Unfortunately, the current memleak doesn’t support generating data formats that can be converted into flame graphs. However, this is not difficult to modify. <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/pull/4766">PR 4766</a> has implemented a simple version. Let’s use the code in this PR as an example to generate a memory leak flame graph.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_svg.png/webp" alt="Modified memleak generates collection files supporting flame graph format" srcset="https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_svg.png/webp 2412w, https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_svg.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_svg.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_svg.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2412" height="936"></p>
<p>As you can see, the collection file generated here is very simple, in the format mentioned above:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__libc_start_call_main+0x7a [libc.so.6];main+0x31 [main];caller()+0x31 [main];LeakLib::slowMemoryLeak()+0x20 [main] 480</span><br></pre></td></tr></tbody></table></figure>

<p>Finally, use the FlameGraph script to generate a flame graph, as follows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_demo.svg" alt="Memory leak flame graph generated from the collection file"></p>
<h2 id="Enabling-Frame-Pointers-by-Default"><a href="#Enabling-Frame-Pointers-by-Default" class="headerlink" title="Enabling Frame Pointers by Default"></a>Enabling Frame Pointers by Default</h2><p>At the end of the article, let’s address a controversial topic we left earlier: whether to enable frame pointers by default during compilation. We know that eBPF tools rely on frame pointers to perform call stack tracing. In fact, there are several methods for stack tracing, such as:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dwarfstd.org/">DWARF</a>: Adds stack information to debug information, allowing for tracing without frame pointers, but the downside is poor performance as stack information needs to be copied to user space for tracing;</li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v5.3/x86/orc-unwinder.html">ORC</a>: A format created in the kernel for unwinding the stack, with the same purpose as DWARF but much simpler. <strong>It cannot be used in user space</strong>;</li>
<li><a target="_blank" rel="noopener" href="https://sourceware.org/pipermail/binutils/2022-June/121478.html">CTF Frame</a>: A new format that is more compact than eh_frame, unwinds the stack faster, and is easier to implement. It’s still in development, and it’s uncertain when it will be available for use.</li>
</ul>
<p>So if you want to <strong>get complete stack information with relatively low overhead, frame pointers are currently the best method</strong>. If frame pointers are so good, why aren’t they enabled by default in some places? In the Linux Fedora distribution community, whether to enable this option by default sparked intense discussion. Eventually, a consensus was reached that in Fedora Linux 38, all libraries would be compiled with -fno-omit-frame-pointer by default. For detailed process, see <a target="_blank" rel="noopener" href="https://fedoraproject.org/wiki/Changes/fno-omit-frame-pointer">Fedora wiki: Changes/fno-omit-frame-pointer</a>.</p>
<p>The wiki above has a <strong>performance benchmark</strong> on the impact of enabling frame pointers. The results show:</p>
<ul>
<li>Kernels compiled with GCC using frame pointers are 2.4% slower;</li>
<li>Building libraries like openssl/botan/zstd with frame pointers didn’t have a significant impact;</li>
<li>For CPython’s benchmark tests, the performance impact is between 1-10%;</li>
<li>Redis benchmark tests showed virtually no performance impact;</li>
</ul>
<p>Of course, it’s not just the Fedora community that tends to enable this by default. Famous performance optimization expert <a target="_blank" rel="noopener" href="https://www.brendangregg.com/">Brendan Gregg</a> suggested in a <a target="_blank" rel="noopener" href="https://www.brendangregg.com/Slides/SCALE2015_Linux_perf_profiling.pdf">presentation</a> that -fno-omit-frame-pointer should be set as the <strong>default compilation option</strong> in gcc:</p>
<blockquote>
<p>• Once upon a time, x86 had fewer registers, and the frame pointer register was reused for general purpose to improve performance. This breaks system stack walking.<br>• gcc provides -fno-omit-frame-pointer to fix this – <strong>Please make this the default in gcc!</strong> </p>
</blockquote>
<p>Additionally, in <a target="_blank" rel="noopener" href="https://inria.hal.science/hal-02297690/document">a paper about DWARF unwinding</a>, it’s mentioned that a Google developer shared that Google’s core code is compiled with frame pointers.</p>
<h2 id="Reference-Articles"><a href="#Reference-Articles" class="headerlink" title="Reference Articles"></a>Reference Articles</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/652850051">Exploration of General Analysis Methods for Memory Leaks (Growth) Based on eBPF</a><br><a target="_blank" rel="noopener" href="https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html">Memory Leak (and Growth) Flame Graphs</a><br><a target="_blank" rel="noopener" href="https://www.polarsignals.com/blog/posts/2022/11/29/dwarf-based-stack-walking-using-ebpf">DWARF-based Stack Walking Using eBPF</a><br><a target="_blank" rel="noopener" href="https://www.reddit.com/r/linuxquestions/comments/piq9tx/trace_all_functions_in_program_with_bpftrace/">Trace all functions in program with bpftrace</a><br><a target="_blank" rel="noopener" href="https://github.com/goldshtn/linux-tracing-workshop/blob/master/bpf-memleak.md">Using BPF Tools: Chasing a Memory Leak</a><br><a target="_blank" rel="noopener" href="https://google.github.io/tcmalloc/overview.html">TCMalloc Overview</a></p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/ChatGPT/"><i class="fa fa-tag"></i>ChatGPT</a><a href="/tags/eBPF/"><i class="fa fa-tag"></i>eBPF</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2023/11/08/memory_leak_ebpf/';
    this.page.identifier = 'en/2023/11/08/memory_leak_ebpf/';
    this.page.title = 'In-depth Understanding of eBPF-based C/C++ Memory Leak Analysis';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (21)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (14)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2023/11/08/memory_leak_ebpf/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/06/27/leveldb_source_table_build/" title="LevelDB Explained - A Step by Step Guide to SSTable Build">LevelDB Explained - A Step by Step Guide to SSTable Build</a></li><li><a href="/en/2025/06/13/leveldb_source_LRU_cache/" title="LevelDB Explained - The Implementation Details of a High-Performance LRU Cache">LevelDB Explained - The Implementation Details of a High-Performance LRU Cache</a></li><li><a href="/en/2025/06/11/leveldb_source_memtable/" title="LevelDB Explained - The Implementation Details of MemTable">LevelDB Explained - The Implementation Details of MemTable</a></li><li><a href="/en/2025/06/10/leveldb_mvcc_intro/" title="LevelDB Explained - Understanding Multi-Version Concurrency Control (MVCC)">LevelDB Explained - Understanding Multi-Version Concurrency Control (MVCC)</a></li><li><a href="/en/2025/05/23/mcp_user_report/" title="In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?">In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?</a></li><li><a href="/en/2025/01/24/leveldb_source_writedb/" title="LevelDB Explained - Implementation and Optimization Details of Key-Value Writing">LevelDB Explained - Implementation and Optimization Details of Key-Value Writing</a></li><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Leak-Simulation"><span class="toc-number">1.</span> <span class="toc-text">Memory Leak Simulation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memleak-Analysis"><span class="toc-number">2.</span> <span class="toc-text">memleak Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Incomplete-Call-Chain"><span class="toc-number">2.1.</span> <span class="toc-text">Incomplete Call Chain</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcmalloc-Leak-Analysis"><span class="toc-number">3.</span> <span class="toc-text">tcmalloc Leak Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Deep-Dive-into-Tool-Implementation"><span class="toc-number">3.1.</span> <span class="toc-text">Deep Dive into Tool Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB-Stack-Tracing"><span class="toc-number">3.2.</span> <span class="toc-text">GDB Stack Tracing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Normal-Memory-Leak-Analysis"><span class="toc-number">4.</span> <span class="toc-text">Normal Memory Leak Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Flame-Graph-Visualization"><span class="toc-number">5.</span> <span class="toc-text">Memory Flame Graph Visualization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Enabling-Frame-Pointers-by-Default"><span class="toc-number">6.</span> <span class="toc-text">Enabling Frame Pointers by Default</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-Articles"><span class="toc-number">7.</span> <span class="toc-text">Reference Articles</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p><p>Friend Link:<a rel="dofollow" target="_blank" href="https://puzzles-game.com/">Puzzle Games</a></p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>