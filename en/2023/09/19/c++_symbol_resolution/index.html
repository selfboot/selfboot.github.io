<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article deeply analyzes the symbol resolution mechanism during C++ static library linking, using symbol redefinition errors as an entry point. Through simple examples, it gradually explains the key to full linking of object files in static libraries. It points out that the linker resolves symbols from left to right, and once a symbol in a library's object file is needed, it will introduce the entire object file. This is then compared and verified with classic textbook content."><title>The Surprising Truth Behind C++ Symbol Redefinition</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">The Surprising Truth Behind C++ Symbol Redefinition</h1><div class="post-meta">2023/09/19<span> | </span><span class="category"><a href="/categories/Programming/">Programming</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2023/09/19/c++_symbol_resolution/" href="/en/2023/09/19/c++_symbol_resolution/#disqus_thread"></a><div class="post-content"><p>In the article <a href="https://selfboot.cn/en/2023/09/07/protobuf_redefine/">Investigating the Mysterious Field Loss Problem When Using Protobuf in C++</a>, we analyzed how two identical proto files led to linking the wrong pb, ultimately causing some fields to be lost during deserialization. At that time, we also mentioned the process of symbol resolution, where whether it’s dynamic linking or static linking, the symbol definition from the library listed earlier is actually used. I thought I had a deep understanding of this, until I recently encountered another strange “<strong>symbol redefinition</strong>“ problem.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_index.webp/webp" alt="C++ Symbol Compilation and Linking Overview" srcset="https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_index.webp/webp 1400w, https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_index.webp/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_index.webp/webp800 800w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1400" height="902"></p>
<span id="more"></span>

<h2 id="Problem-Background"><a href="#Problem-Background" class="headerlink" title="Problem Background"></a>Problem Background</h2><p>Initially, there was a utils directory containing some basic code, compiled into a static library A. Later, another copy was made in another directory of the project, compiled into another static library B. Due to the project’s complex dependency relationships (it’s a tangled mess), some target targets would depend on both A and B, but compilation and linking had always been OK.</p>
<p>Recently, in a cpp file in module B, one of the classes was modified, adding a default parameter to the constructor. Then, when calling it, a specific parameter was passed in. As a result, when compiling the target, an error was reported: <code>multiple definition</code>.</p>
<p>According to my previous understanding, for symbols in static libraries, during link resolution, the linker scans from left to right, and if a symbol definition is already found earlier, it will ignore the later ones. For the above static libraries A and B, although there are indeed duplicate function definitions, each symbol should be able to find a definition, then discard the later occurrences, and linking should not fail.</p>
<h2 id="Reproduction-Steps"><a href="#Reproduction-Steps" class="headerlink" title="Reproduction Steps"></a>Reproduction Steps</h2><p>The project code is too complex to analyze directly, so let’s see if we can write a simple example to reproduce this problem. The structure of the reproduction code is as follows:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ tree</span><br><span class="line">.</span><br><span class="line">├── demoA</span><br><span class="line">│   ├── libDemoA.a</span><br><span class="line">│   ├── sum.cpp</span><br><span class="line">│   ├── sum.h</span><br><span class="line">│   └── sum.o</span><br><span class="line">├── demoB</span><br><span class="line">│   ├── libDemoB.a</span><br><span class="line">│   ├── sum.cpp</span><br><span class="line">│   ├── sum.h</span><br><span class="line">│   └── sum.o</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Simple-Function-Call"><a href="#Simple-Function-Call" class="headerlink" title="Simple Function Call"></a>Simple Function Call</h3><p>Starting with the simplest example, the sum.h in demoA and demoB declares the function as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>The specific implementation is in each cpp file, with the output in DemoB being “DemoB”, so we know which library’s implementation is being used. The cpp definition in DemoA is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"sum.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"DemoA"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>main.cpp is simple, just calling sum:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"demoB/sum.h"</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Compile the two directories into static libraries, then compile and link main.cpp. Under different linking orders, it can normally link to generate binaries and output normally.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ g++ -c -o demoA/sum.o demoA/sum.cpp</span><br><span class="line">➜ ar rcs demoA/libDemoA.a demoA/sum.o</span><br><span class="line">➜ g++ -c -o demoB/sum.o demoB/sum.cpp</span><br><span class="line">➜ ar rcs demoB/libDemoB.a demoB/sum.o</span><br><span class="line">➜ g++ main.cpp -o main -LdemoA -LdemoB -lDemoA -lDemoB</span><br><span class="line">➜ ./main</span><br><span class="line">DemoA</span><br><span class="line">➜ g++ main.cpp -o main -LdemoA -LdemoB -lDemoB -lDemoA</span><br><span class="line">➜ ./main</span><br><span class="line">DemoB</span><br></pre></td></tr></tbody></table></figure>

<p>This conforms to previous understanding. Although there are two definitions of the sum function, when linking static libraries, the one found first will be used preferentially, and the later ones will be discarded. No matter in which order they are linked here, there will be no duplicate definition error.</p>
<h3 id="Reproducing-Redefinition"><a href="#Reproducing-Redefinition" class="headerlink" title="Reproducing Redefinition"></a>Reproducing Redefinition</h3><p>The reproduction code above is still a bit different from the code in the project. Next, let’s try to simulate the changes in the project. Add a class in demoA’s sum.h as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Demo</span>(<span class="type">int</span> a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.cpp</span></span><br><span class="line">Demo::<span class="built_in">Demo</span>(<span class="type">int</span> a){</span><br><span class="line">    num = a;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"DemoA init"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Then for the constructor of the class in DemoB, add a default parameter b:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Demo</span>(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.cpp</span></span><br><span class="line">Demo::<span class="built_in">Demo</span>(<span class="type">int</span> a, <span class="type">int</span> b){</span><br><span class="line">    num = a;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"DemoB init"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Then add a class object definition in main:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="function">Demo <span class="title">de</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Now we’ve reproduced the symbol redefinition problem! If the order is <code>-lDemoA -lDemoB</code>, it will report a redefinition of sum. But if it’s reversed to <code>-lDemoB -lDemoA</code>, everything is normal, and the output also conforms to previous understanding.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_multiple_definition.png/webp" alt="C++ Symbol Compilation and Linking Overview" srcset="https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_multiple_definition.png/webp 2400w, https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_multiple_definition.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_multiple_definition.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_multiple_definition.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2400" height="404"></p>
<p>The problem has been reproduced, but I’m indeed a bit confused. If DemoA library is in front, it should first get sum from here, and when it gets to DemoB later, <strong>the linker should just discard sum</strong>, why would it report a duplicate definition? After all, <strong>in the previous example with only functions, it linked like this</strong>.</p>
<h2 id="Speculating-the-Reason"><a href="#Speculating-the-Reason" class="headerlink" title="Speculating the Reason"></a>Speculating the Reason</h2><p>After having ChatGPT, I don’t use search much anymore, I directly give the problem to ChatGPT to see how it explains. In fact, during the previous reproduction process, I’ve been communicating with ChatGPT, letting it understand the context.</p>
<h3 id="ChatGPT’s-Explanation"><a href="#ChatGPT’s-Explanation" class="headerlink" title="ChatGPT’s Explanation"></a>ChatGPT’s Explanation</h3><p>To make it fully understand the problem details, I fed it the reproduction code, compilation and linking, and error messages from the redefinition part above, and it explained as follows.</p>
<p>The linker first looks for libDemoA.a, finding sum(int, int) and Demo::Demo(int). Then the linker will look for symbols in libDemoB.a. At this point, since main.cpp actually uses the DemoB version of Demo::Demo(int, int) (note there are two parameters here), the linker will try to resolve this new symbol from libDemoB.a. In libDemoB.a, the linker finds sum(int, int) that conflicts with the one in libDemoA.a, thus reporting “multiple definition”.</p>
<p>However, I still have questions, <strong>when the linker first looks for libDemoA.a and finds sum(int, int), sum has already been found, so shouldn’t it ignore this symbol later in libDemoB.a</strong>? Asking ChatGPT directly, it started to “repent”:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_error.png/webp" alt="ChatGPT's incorrect answer about C++ symbol linking process" srcset="https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_error.png/webp 1742w, https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_error.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_error.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_error.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1742" height="956"></p>
<p>Then I asked it to explain why there was no error in the initial reproduction, as follows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt.png/webp" alt="ChatGPT's incorrect explanation of C++ symbol linking process" srcset="https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt.png/webp 1724w, https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1724" height="1020"></p>
<p>It seems this direct questioning approach isn’t working. Then I thought about whether I could print some intermediate processes of linking, so I added the <code>-Wl,--verbose</code> option for linking, but didn’t find any useful information. I thought if I could print the unresolved symbol set and resolved symbol set during the ld linking process, as well as the specific steps of resolving symbols, I could figure it out. But I couldn’t find any way to print these.</p>
<h3 id="Bold-Guess"><a href="#Bold-Guess" class="headerlink" title="Bold Guess"></a>Bold Guess</h3><p>The best thing here would be to directly look at the implementation of the linker, after all, <strong>there are no secrets under the source code</strong>. However, I reviewed the differences between the two test processes above and made a guess, which I asked ChatGPT:</p>
<blockquote>
<p>Here’s how I tested: if demoA/sum.h and demoB/sum.h both only have the sum function, there won’t be any problem no matter which one is linked first.<br>But once there’s a class in them with different definitions, an error occurs. <strong>Is “first wins” only applicable when no symbol from the later library is needed?</strong></p>
<p><strong>As long as one symbol from the later library is needed, will there be a redefinition?</strong></p>
</blockquote>
<p>Finally, I got a plausible explanation:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_right.png/webp" alt="Detailed explanation of C++ symbol redefinition when linking static libraries" srcset="https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_right.png/webp 1866w, https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_right.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_right.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_right.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1866" height="1424"></p>
<p>In other words, <strong>when the linker references a symbol from a .o file in a static library, it actually links the entire object file containing that symbol to the final executable</strong>. To verify this, I split the constructor definition of the Demo class in demoB/sum.cpp into a new compilation unit demo.cpp, as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cat demoB/demo.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"sum.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">Demo::<span class="built_in">Demo</span>(<span class="type">int</span> a, <span class="type">int</span> b){</span><br><span class="line">    num = a;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"DemoB init"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Then recompile the DemoB static library, compile and link main, and find that there’s no symbol redefinition anymore. The result is as follows:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜ g++ main.cpp -o main -LdemoA -LdemoB -lDemoB -lDemoA</span><br><span class="line">(base) ➜  link_check ./main</span><br><span class="line">DemoB</span><br><span class="line">DemoB init</span><br><span class="line">(base) ➜  link_check g++ main.cpp -o main -LdemoA -LdemoB -lDemoA -lDemoB</span><br><span class="line">(base) ➜  link_check ./main</span><br><span class="line">DemoA</span><br><span class="line">DemoB init</span><br></pre></td></tr></tbody></table></figure>

<p>Here, because the Demo used has a separate relocatable object file demo.o in static library B, and there are no symbols that need to be introduced in sum.o, it’s not linked in, so there’s no symbol redefinition.</p>
<h2 id="Rereading-the-Classic"><a href="#Rereading-the-Classic" class="headerlink" title="Rereading the Classic"></a>Rereading the Classic</h2><p>After verifying the guess above, when I reread the “7.6 Symbol Resolution” section of “Computer Systems: A Programmer’s Perspective”, I fully understood the content of this section. The core steps of the entire linking process are as follows.</p>
<p>The linker reads a set of relocatable object files and links them together to form an output executable file. If multiple object files define global symbols with the same name, the linker either flags an error or chooses one definition in some way and discards the others.</p>
<p>The compiler outputs each global symbol to the assembler as either strong or weak, and the assembler implicitly encodes this information in the symbol table of the relocatable object file. Functions and initialized global variables are strong symbols, while uninitialized global variables are weak symbols. The Linux linker uses the following rules to handle multiply-defined symbol names:</p>
<ul>
<li>Rule 1: Multiple strong symbols with the same name are not allowed.</li>
<li>Rule 2: Given a strong symbol and multiple weak symbols with the same name, choose the strong symbol.</li>
<li>Rule 3: Given multiple weak symbols with the same name, choose any of the weak symbols.</li>
</ul>
<p>The above assumes that the linker reads a set of relocatable object files, but in reality, it can link libraries. For static libraries, it’s a collection of linked relocatable object files, with a header describing the size and location of each member object file, identified by the suffix <code>.a</code>.</p>
<p>During the symbol resolution phase, the linker scans relocatable object files and archive files <strong>from left to right</strong> in the order they appear on the compiler driver program command line. During the scan, the linker maintains a <strong>set E</strong> of relocatable object files. If the input file is an object file, <strong>as long as one symbol in the object file is used, the entire object file is placed in set E. If all symbols in the object file are not referenced, then the object file is discarded</strong>. If the input file is a static library (archive) file, then each relocatable object file in it is traversed using the above method.</p>
<p>After scanning all files, the linker <strong>merges and relocates the object files in E</strong> to construct the output executable file. At this time, if two object files have the same symbol definition, a duplicate definition error will be reported.</p>
<p>Going back to the redefinition problem at the beginning of the article. There’s a util.o object file in both libraries A and B, which were completely identical at the beginning, so the B/util.o that’s later in the linking order would be discarded, which is fine. Later, B/util.cpp was modified, adding symbols that A doesn’t have, and because these symbols are used elsewhere, B/util.o is also included in the linking process. This is equivalent to linking both A/util.o and B/util.o at the same time, and these two object files have many duplicate function definitions, so a symbol redefinition will be reported.</p>
<h2 id="Some-Discussions"><a href="#Some-Discussions" class="headerlink" title="Some Discussions"></a>Some Discussions</h2><p>The article sparked some discussions among readers on <a target="_blank" rel="noopener" href="https://www.v2ex.com/t/975233">V2EX</a>, and some of the viewpoints were quite good. I’ll record them here. <a target="_blank" rel="noopener" href="https://www.v2ex.com/t/975233#r_13670523">geelaw</a> said:</p>
<blockquote>
<p>Whether it’s looking at code or <strong>asking ChatGPT without verification</strong>, both are very poor learning methods. The first step should be to understand how the C++ standard specifies it.<br>Both int sum(int, int) and class Demo in the article are very serious ODR (One-definition rule) violations.</p>
<p>[basic.def.odr]/14 stipulates that (14.1) when a non-inline non-template function has definitions in multiple translation units, (14) the program is ill-formed, and no error needs to be reported in non-modules. This applies to the sum situation.</p>
<p>[basic.def.odr]/14 stipulates that (14.2) for a class defined in multiple translation units, if it doesn’t satisfy (14.4) the definitions are the same token sequence in all reachable translation units, then (14) the program is ill-formed, and no error needs to be reported in non-modules. This applies to the class Demo situation.</p>
</blockquote>
<p>As for what behavior a specific compiler or linker produces, it’s just a coincidence. Here’s the link to the C++ standard document: <a target="_blank" rel="noopener" href="https://eel.is/c++draft/basic.def.odr#14">basic.def.odr#14</a>. Even if something like sum can be compiled and linked successfully, it’s a very bad coding habit. Even if it can run normally and the results meet expectations, it doesn’t necessarily mean it’s the correct implementation. It might be a coincidental behavior of the compiler, and it might not work later. In actual projects, you can avoid such ODR problems by <strong>using namespaces, or refactoring duplicate code parts, adjusting code results</strong>.</p>
<p>Of course, the above uses GNU ld for linking. As <a target="_blank" rel="noopener" href="https://www.v2ex.com/t/975233#r_13670827">tool2d</a> said:</p>
<blockquote>
<p>This is considered a gcc problem. If you switch to vc, sum can’t be linked successfully from the beginning.<br>For Microsoft, the idea of the function body in front overriding the function body behind when symbols are the same is completely non-existent.<br>Another point is that symbols in Linux so dynamic link libraries can be unresolved, but if a dll is missing a function, it can’t be generated at all. Just on this point, Microsoft is already 100 years ahead.</p>
</blockquote>
<p>I haven’t tried linking with vc here, this is just for reference.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a target="_blank" rel="noopener" href="https://hansimov.gitbook.io/csapp/part2/ch07-linking/7.6-symbol-resolution">Computer Systems: A Programmer’s Perspective: 7.6 Symbol Resolution</a><br><a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking">Library order in static linking</a></p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2023/09/19/c++_symbol_resolution/';
    this.page.identifier = 'en/2023/09/19/c++_symbol_resolution/';
    this.page.title = 'The Surprising Truth Behind C++ Symbol Redefinition';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (18)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (15)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (13)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2023/09/19/c++_symbol_resolution/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li><li><a href="/en/2024/09/09/leveldb_source_skiplist/" title="LevelDB Explained - How to implement SkipList">LevelDB Explained - How to implement SkipList</a></li><li><a href="/en/2024/09/05/claude35_prompt/" title="Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...">Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...</a></li><li><a href="/en/2024/08/29/leveldb_source_utils/" title="LevelDB Explained - Arena, Random, CRC32, and More.">LevelDB Explained - Arena, Random, CRC32, and More.</a></li><li><a href="/en/2024/08/14/leveldb_source_wal_log/" title="LevelDB Explained - How To Read and Write WAL Logs">LevelDB Explained - How To Read and Write WAL Logs</a></li><li><a href="/en/2024/08/13/leveldb_source_unstand_c++/" title="LevelDB Explained -  Understanding Advanced C++ Techniques">LevelDB Explained -  Understanding Advanced C++ Techniques</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Problem-Background"><span class="toc-number">1.</span> <span class="toc-text">Problem Background</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reproduction-Steps"><span class="toc-number">2.</span> <span class="toc-text">Reproduction Steps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Simple-Function-Call"><span class="toc-number">2.1.</span> <span class="toc-text">Simple Function Call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reproducing-Redefinition"><span class="toc-number">2.2.</span> <span class="toc-text">Reproducing Redefinition</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Speculating-the-Reason"><span class="toc-number">3.</span> <span class="toc-text">Speculating the Reason</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ChatGPT%E2%80%99s-Explanation"><span class="toc-number">3.1.</span> <span class="toc-text">ChatGPT’s Explanation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bold-Guess"><span class="toc-number">3.2.</span> <span class="toc-text">Bold Guess</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rereading-the-Classic"><span class="toc-number">4.</span> <span class="toc-text">Rereading the Classic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Some-Discussions"><span class="toc-number">5.</span> <span class="toc-text">Some Discussions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">6.</span> <span class="toc-text">References</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>