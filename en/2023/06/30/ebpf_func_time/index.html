<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Explore how to use eBPF and BCC to analyze service function execution time non-intrusively, including average and P99 latency, to optimize code performance and service response time without modifying or redeploying code."><title>Using eBPF BCC for Non-Intrusive Analysis of Function Execution Time</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Using eBPF BCC for Non-Intrusive Analysis of Function Execution Time</h1><div class="post-meta">2023/06/30<span> | </span><span class="category"><a href="/categories/Programming/">Programming</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2023/06/30/ebpf_func_time/" href="/en/2023/06/30/ebpf_func_time/#disqus_thread"></a><div class="post-content"><p>We all know that monitoring function execution time is crucial when developing and maintaining backend services. Through monitoring, we can promptly identify performance bottlenecks, optimize code, and ensure service stability and response speed. However, traditional methods often involve adding statistics to the code and reporting them, which, although effective, typically only target functions considered to be on the critical path.</p>
<p>Suppose at some point, we suddenly need to monitor the execution time of a function that wasn’t a focus of attention. In this case, modifying the code and redeploying the service can be a cumbersome and time-consuming task. This is where eBPF (extended Berkeley Packet Filter) and BCC (BPF Compiler Collection) come in handy. By using eBPF, we can <span style="color:red;">dynamically insert probes to monitor function execution time without modifying code or redeploying services</span>. This not only greatly simplifies the monitoring process but also reduces the impact on service performance.</p>
<p>In the following article, we will detail how to use eBPF BCC to analyze service function execution time non-intrusively, and demonstrate its powerful capabilities through practical examples.</p>
<span id="more"></span>

<h2 id="Principle-of-eBPF-Function-Execution-Time-Analysis"><a href="#Principle-of-eBPF-Function-Execution-Time-Analysis" class="headerlink" title="Principle of eBPF Function Execution Time Analysis"></a>Principle of eBPF Function Execution Time Analysis</h2><p><a target="_blank" rel="noopener" href="https://ebpf.io/what-is-ebpf/">eBPF</a> is a very powerful technology that allows developers to execute custom code in the Linux kernel without modifying the kernel or loading kernel modules. This flexibility makes eBPF applicable to various scenarios, including network monitoring, security, and performance analysis.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_function_time_ebpf.png/webp" alt="ebpf allows users to execute code in the kernel" srcset="https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_function_time_ebpf.png/webp 1508w, https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_function_time_ebpf.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_function_time_ebpf.png/webp800 800w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1508" height="777"></p>
<p>eBPF supports user space tracing (uprobes), allowing us to attach eBPF programs to user space applications. This means we can monitor and analyze the behavior of user space applications very precisely without modifying the application code. We can define code to be executed at function entry and exit points. When a function is called, the entry probe (kprobe/uprobe) is triggered, and when the function returns, the exit probe is triggered.</p>
<p>To calculate the execution time of a function, we can record the current timestamp in the eBPF program at the function entry. In the eBPF program at the function exit, we record the timestamp again and calculate the difference between the two, which is the function’s execution time. The function’s execution time is then stored in BPF Maps for further analysis and visualization in user space, helping us understand the performance characteristics of the function.</p>
<p>Writing eBPF directly can be a bit cumbersome, but fortunately, we can use BCC to simplify the development process. <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/tree/master">BCC (BPF Compiler Collection)</a> is a development toolkit that simplifies the process of writing and compiling BPF programs, allowing developers to use languages like Python and C to write scripts that control the behavior of eBPF programs.</p>
<h2 id="Simulating-Time-Consuming-Functions"><a href="#Simulating-Time-Consuming-Functions" class="headerlink" title="Simulating Time-Consuming Functions"></a>Simulating Time-Consuming Functions</h2><p>To use eBPF BCC to analyze function execution time, we first need to create a test process with a specific function that simulates the time consumption of functions in real scenarios. In common business scenarios, the distribution of function execution times is usually uneven, so we’ve intentionally designed a function here to make its P99 latency significantly greater than its average latency. This simulates actual business scenarios where most requests can be processed quickly, but in some cases (such as large data volumes, cache misses, or resource contention), processing time increases significantly.</p>
<p>To add a bit more explanation, P99 latency is a performance metric that describes the 99th percentile of execution times in a system or function. You can understand it simply like this: if you have 100 requests, the P99 latency is the execution time of the slowest one among these 100 requests. However, different tools may calculate P99 slightly differently. For example, if a function is executed 100 times, with 99 executions taking between 1ms and 2ms, and one execution taking 100ms, the P99 could be either 2ms or 100ms, depending on the specific algorithm implementation. This doesn’t affect our understanding of the P99 metric here.</p>
<p>Here’s the implementation of our simulated time-consuming function:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">int</span> iteration)</span> </span>{</span><br><span class="line">    <span class="comment">// Simulate a function that usually executes quickly, but takes longer every 100th iteration</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">long</span> iterations = (iteration % <span class="number">100</span> == <span class="number">99</span>) ? <span class="number">10000000</span> : <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; iterations; ++i) {</span><br><span class="line">        result += std::<span class="built_in">sqrt</span>(std::<span class="built_in">atan</span>(i));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>To provide a baseline for time consumption, we’ve also added time statistics in our test code to calculate the function’s average and P99 latency. Specifically, in an infinite loop, it calls the function each time and records the execution time. Whenever the cumulative execution time exceeds one second, it calculates and outputs the average and P99 times of the function executions during this period. Then, it clears all recorded execution times, ready to start the next round of data collection and analysis. Here’s the implementation:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; timings;</span><br><span class="line">    <span class="type">int</span> iteration = <span class="number">0</span>;</span><br><span class="line">    Timer overall_timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="built_in">someFunction</span>(iteration);</span><br><span class="line">        timings.<span class="built_in">push_back</span>(timer.<span class="built_in">elapsed</span>());</span><br><span class="line">        iteration++;</span><br><span class="line">        <span class="keyword">if</span> (overall_timer.<span class="built_in">elapsed</span>() &gt;= <span class="number">1000.0</span>) {</span><br><span class="line">            <span class="type">double</span> average = std::<span class="built_in">accumulate</span>(timings.<span class="built_in">begin</span>(), timings.<span class="built_in">end</span>(), <span class="number">0.0</span>) / timings.<span class="built_in">size</span>();</span><br><span class="line">            std::<span class="built_in">sort</span>(timings.<span class="built_in">begin</span>(), timings.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">double</span> p99 = timings[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(timings.<span class="built_in">size</span>() * <span class="number">0.99</span>)];</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"Average execution time: "</span> &lt;&lt; average &lt;&lt; <span class="string">" ms"</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"P99 execution time: "</span> &lt;&lt; p99 &lt;&lt; <span class="string">" ms"</span> &lt;&lt; std::endl;</span><br><span class="line">            timings.<span class="built_in">clear</span>();</span><br><span class="line">            overall_timer = <span class="built_in">Timer</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The complete code <code>func_time.cpp</code> is available on <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/8b1d3661f5df974eb68df03a4687dcfa">gist</a>. On my server, the execution results are as follows (note that function execution time is related to machine performance and load):</p>
<blockquote>
<p>Average execution time: 3.95762 ms<br>P99 execution time: 190.968 ms<br>Average execution time: 3.90211 ms<br>P99 execution time: 191.292 ms<br>…</p>
</blockquote>
<h2 id="BCC-Function-Execution-Time-Histogram"><a href="#BCC-Function-Execution-Time-Histogram" class="headerlink" title="BCC Function Execution Time Histogram"></a>BCC Function Execution Time Histogram</h2><p>Note that the latency monitoring script here depends on the BCC tool. You can find installation instructions on BCC’s <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">GitHub page</a>. Additionally, ensure that your system kernel supports BPF. For Linux kernel versions, typically 4.8 or above is needed for the best BPF functionality support.</p>
<p>BCC provides convenient methods for us to statistics the distribution of function execution times. First, it obtains the target process PID and the function name to be traced by parsing command line arguments. Then it builds and loads a BPF program, attaching user-space probes (uprobes) and user-space return probes (uretprobes) to the specified process and function to capture timestamps at the beginning and end of the function.</p>
<p>The probe function <code>trace_start</code> captures the current timestamp each time a function call begins, and stores it in the BPF hash map <code>start</code> along with a key representing the current process. When the function call ends, the <code>trace_end</code> probe function looks up the start timestamp and calculates the time difference of the function execution. This time difference is recorded in the BPF histogram <code>dist</code> for subsequent performance analysis. The complete script <code>func_time_hist.py</code> is available on <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/3c78f4c50c70bce22e1ce61b7d72dbda">gist</a>.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trace_start</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">key_t</span> key = {};</span><br><span class="line">    u64 ts;</span><br><span class="line">    key.pid = <span class="built_in">bpf_get_current_pid_tgid</span>();</span><br><span class="line">    <span class="built_in">bpf_get_current_comm</span>(&amp;(key.comm), <span class="built_in">sizeof</span>(key.comm));</span><br><span class="line">    ts = <span class="built_in">bpf_ktime_get_ns</span>();</span><br><span class="line">    start.<span class="built_in">update</span>(&amp;key, &amp;ts);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trace_end</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">key_t</span> key = {};</span><br><span class="line">    u64 *tsp, delta;</span><br><span class="line">    key.pid = <span class="built_in">bpf_get_current_pid_tgid</span>();</span><br><span class="line">    <span class="built_in">bpf_get_current_comm</span>(&amp;(key.comm), <span class="built_in">sizeof</span>(key.comm));</span><br><span class="line">    tsp = start.<span class="built_in">lookup</span>(&amp;key);</span><br><span class="line">    <span class="keyword">if</span> (tsp != <span class="number">0</span>) {</span><br><span class="line">        delta = <span class="built_in">bpf_ktime_get_ns</span>() - *tsp;</span><br><span class="line">        dist.<span class="built_in">increment</span>(<span class="built_in">bpf_log2l</span>(delta / <span class="number">1000</span>));</span><br><span class="line">        start.<span class="built_in">delete</span>(&amp;key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>We compile <code>func_time.cpp</code> with -g, and use nm to get the name-mangled function name. Run the program, get the process pid, and then we can use the tool to view the execution time distribution.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ func_time.cpp -g -o func_time</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm func_time| grep <span class="string">'T'</span> | grep someFunction</span></span><br><span class="line">0000000000001235 T _Z12someFunctioni</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python func_time_hist.py 832965  _Z12someFunctioni</span></span><br></pre></td></tr></tbody></table></figure>

<p>When you press Ctrl-C to abort the program, it will print out the <code>dist</code> histogram, showing the distribution of function execution times on a logarithmic scale. This allows us to quickly understand the general performance of function execution, such as the most common execution time and the range of time distribution, as shown in the following figure:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_func_time_hist.png/webp" alt="BCC script analyzing function call time distribution" srcset="https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_func_time_hist.png/webp 2214w, https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_func_time_hist.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_func_time_hist.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_func_time_hist.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2214" height="1022"></p>
<p>We can see that most function calls have execution times distributed between 1024-2047us, with 11 function calls having execution times distributed between 131702-262143us. This function proportion is about 1%, which matches the characteristics of our simulated function.</p>
<h2 id="BCC-Function-Average-Execution-Time"><a href="#BCC-Function-Average-Execution-Time" class="headerlink" title="BCC Function Average Execution Time"></a>BCC Function Average Execution Time</h2><p>Often, we not only want to see the distribution of function execution times but also want to know the average and P99 latency. This can be achieved by making slight modifications to the above BCC script. After each function execution, use BPF’s PERF output interface to collect execution times to user space. Specifically, this is implemented by using the <code>perf_submit</code> helper function in the <code>trace_end</code> function of the BPF program.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trace_end</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">key_t</span> key = {};</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_t</span> data = {};</span><br><span class="line">    u64 *tsp, delta;</span><br><span class="line"></span><br><span class="line">    key.pid = <span class="built_in">bpf_get_current_pid_tgid</span>();</span><br><span class="line">    <span class="built_in">bpf_get_current_comm</span>(&amp;(key.comm), <span class="built_in">sizeof</span>(key.comm));</span><br><span class="line"></span><br><span class="line">    tsp = start.<span class="built_in">lookup</span>(&amp;key);</span><br><span class="line">    <span class="keyword">if</span> (tsp != <span class="number">0</span>) {</span><br><span class="line">        delta = <span class="built_in">bpf_ktime_get_ns</span>() - *tsp;</span><br><span class="line">        data.pid = key.pid;</span><br><span class="line">        data.duration = delta;</span><br><span class="line">        times.<span class="built_in">perf_submit</span>(ctx, &amp;data, <span class="built_in">sizeof</span>(data));</span><br><span class="line">        start.<span class="built_in">delete</span>(&amp;key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Next, in the Python script in user space, calculate the average and P99 within each specified time interval. The complete code <code>func_time.py</code> is available on <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/38526f556698d9263a2751feadf73efb">gist</a>, with execution results as follows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_func_time_avg_p99.png/webp" alt="BCC script analyzing function call average and P99 latency" srcset="https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_func_time_avg_p99.png/webp 1980w, https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_func_time_avg_p99.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_func_time_avg_p99.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230630_ebpf_func_time_avg_p99.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1980" height="562"></p>
<p>Overall, using eBPF and BCC for this kind of non-intrusive performance analysis has enormous value for troubleshooting and performance optimization in production environments. It <strong>allows us to collect and analyze critical performance metrics in real-time without interrupting services or redeploying code</strong>. This capability is crucial for maintaining high-performance and high-availability systems.</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/ChatGPT/"><i class="fa fa-tag"></i>ChatGPT</a><a href="/tags/Debug/"><i class="fa fa-tag"></i>Debug</a><a href="/tags/eBPF/"><i class="fa fa-tag"></i>eBPF</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2023/06/30/ebpf_func_time/';
    this.page.identifier = 'en/2023/06/30/ebpf_func_time/';
    this.page.title = 'Using eBPF BCC for Non-Intrusive Analysis of Function Execution Time';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (18)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (15)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (13)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2023/06/30/ebpf_func_time/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li><li><a href="/en/2024/09/09/leveldb_source_skiplist/" title="LevelDB Explained - How to implement SkipList">LevelDB Explained - How to implement SkipList</a></li><li><a href="/en/2024/09/05/claude35_prompt/" title="Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...">Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...</a></li><li><a href="/en/2024/08/29/leveldb_source_utils/" title="LevelDB Explained - Arena, Random, CRC32, and More.">LevelDB Explained - Arena, Random, CRC32, and More.</a></li><li><a href="/en/2024/08/14/leveldb_source_wal_log/" title="LevelDB Explained - How To Read and Write WAL Logs">LevelDB Explained - How To Read and Write WAL Logs</a></li><li><a href="/en/2024/08/13/leveldb_source_unstand_c++/" title="LevelDB Explained -  Understanding Advanced C++ Techniques">LevelDB Explained -  Understanding Advanced C++ Techniques</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Principle-of-eBPF-Function-Execution-Time-Analysis"><span class="toc-number">1.</span> <span class="toc-text">Principle of eBPF Function Execution Time Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Simulating-Time-Consuming-Functions"><span class="toc-number">2.</span> <span class="toc-text">Simulating Time-Consuming Functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BCC-Function-Execution-Time-Histogram"><span class="toc-number">3.</span> <span class="toc-text">BCC Function Execution Time Histogram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BCC-Function-Average-Execution-Time"><span class="toc-number">4.</span> <span class="toc-text">BCC Function Average Execution Time</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>