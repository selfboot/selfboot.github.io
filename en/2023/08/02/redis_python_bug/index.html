<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article provides an in-depth analysis of the Redis client bug that led to the ChatGPT outage. When an asynchronous command is cancelled, the connection state becomes confused, causing subsequent requests to read incorrect data. The final fix involves immediately closing the connection when encountering a cancellation, with subsequent requests establishing a new connection to avoid reusing problematic connections. The article outlines the bug's causes, reproduction, and fixing process, and offers developers experience in debugging asynchronous connection issues."><title>Dive into the ChatGPT Data Leak caused by Redis Bug</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Dive into the ChatGPT Data Leak caused by Redis Bug</h1><div class="post-meta">2023/08/02<span> | </span><span class="category"><a href="/categories/Source-Code-Analysis/">Source Code Analysis</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2023/08/02/redis_python_bug/" href="/en/2023/08/02/redis_python_bug/#disqus_thread"></a><div class="post-content"><p>On March 20, 2023, OpenAI’s ChatGPT service was interrupted for a period of time. Subsequently, OpenAI published an announcement <a target="_blank" rel="noopener" href="https://openai.com/blog/march-20-chatgpt-outage">March 20 ChatGPT outage: Here’s what happened</a> explaining the ins and outs of this incident. In the announcement, OpenAI detailed the scope of impact, remediation strategies, some technical details, and improvement measures for this incident, which is quite worth learning from.</p>
<p>The specific timeline of this incident handling is also publicly available on <a target="_blank" rel="noopener" href="https://status.openai.com/incidents/jq9232rcmktd">ChatGPT Web Interface Incident</a>, as shown in the following image:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_incident.png/webp" alt="Overall timeline of ChatGPT fault repair" srcset="https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_incident.png/webp 1444w, https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_incident.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_incident.png/webp800 800w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1444" height="1108"></p>
<p>This fault was caused by a bug in Redis’s Python client, and there are discussions about this bug on Github. The fixing process of this bug was not smooth, with many discussions and fix attempts, such as <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/issues/2624">Issue 2624</a>, <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/pull/2641">PR 2641</a>, <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/issues/2665">Issue 2665</a>, <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/pull/2695">PR 2695</a>. After reading these, I still couldn’t fully understand the fix here, so I had to delve into the code to see what exactly happened with the bug’s cause and fixing process, and organize it into this article.</p>
<span id="more"></span>

<h2 id="Public-Disclosure-of-the-Incident"><a href="#Public-Disclosure-of-the-Incident" class="headerlink" title="Public Disclosure of the Incident"></a>Public Disclosure of the Incident</h2><p>Before starting to analyze the Python bug, I’d like to talk about OpenAI’s incident dashboard. OpenAI provides a <a target="_blank" rel="noopener" href="https://status.openai.com/">status check page</a> where you can see the current health status of various services. This is done quite well in foreign countries, with many services having status dashboards, such as <a target="_blank" rel="noopener" href="https://www.githubstatus.com/">Github</a> and <a target="_blank" rel="noopener" href="https://status.cloud.google.com/">Google Cloud</a>.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_status.png/webp" alt="OpenAI status dashboard, incident disclosure" srcset="https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_status.png/webp 1806w, https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_status.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_status.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_status.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1806" height="1130"></p>
<p>When encountering ChatGPT not working, you can come here first to check the current service status. If the service has no problems, it’s generally your own network or account issues. Once there’s a service problem, you can see the progress of the incident here. In contrast, many services in China tend to cover up problems if possible, fearing that users will know about the fault.</p>
<p>This incident was quite serious, and OpenAI CEO <a target="_blank" rel="noopener" href="https://twitter.com/sama">Sam Altman</a> also made a brief <a target="_blank" rel="noopener" href="https://twitter.com/sama/status/1638635717462200320">statement</a>:</p>
<blockquote>
<p>we had a significant issue in ChatGPT due to a bug in an open source library, for which a fix has now been released and we have just finished validating.</p>
<p>a small percentage of users were able to see the titles of other users’ conversation history.</p>
<p>we feel awful about this.</p>
</blockquote>
<h3 id="Incident-Details"><a href="#Incident-Details" class="headerlink" title="Incident Details"></a>Incident Details</h3><p>OpenAI later wrote an article: <a target="_blank" rel="noopener" href="https://openai.com/blog/march-20-chatgpt-outage">March 20 ChatGPT outage: Here’s what happened</a> detailing this incident. Initially, it was discovered that some users could view titles from other users’ chat conversations, and if two users were active at the same time, the first message of a new conversation might also be seen by others. Later, it was found that during a specific 9-hour period, about 1.2% of active ChatGPT Plus users had their payment information seen by others. This payment information included: name, email address, payment address, credit card type and the <strong>last four digits</strong> of the credit card number, and credit card expiration date.</p>
<p>Of course, the number of people whose payment information was leaked was actually extremely small, as the trigger conditions were quite strict, only in the following two situations:</p>
<ol>
<li>Opening the subscription confirmation email sent by OpenAI between 1 am and 10 am on March 30, 2023, which might contain other people’s credit card type and the last four digits of the card number (fortunately not the full card number).</li>
<li>Clicking on “My Account” on the ChatGPT chat page between 1 am and 10 am on March 30, 2023, and entering “Manage My Subscription”. At this time, one might see other Plus users’ first and last names, email addresses, payment addresses, credit card types and the last four digits of the credit card number (only), as well as credit card expiration dates.</li>
</ol>
<p>The entire incident handling timeline is publicly available at <a target="_blank" rel="noopener" href="https://status.openai.com/incidents/jq9232rcmktd">ChatGPT Web Interface Incident</a>.</p>
<h3 id="Cause-of-the-Incident"><a href="#Cause-of-the-Incident" class="headerlink" title="Cause of the Incident"></a>Cause of the Incident</h3><p>OpenAI provided some technical details about how this incident occurred:</p>
<ol>
<li>User information was cached in Redis to avoid querying the database each time.</li>
<li>Redis was deployed in cluster mode, with the load distributed across many Redis instances.</li>
<li>The service was developed in Python, using the Asyncio asynchronous I/O library and the redis-py library to access Redis.</li>
<li>The service maintained a connection pool to the Redis cluster using the redis-py library, reusing connections to handle requests.</li>
<li>When using Asyncio to asynchronously handle redis-py requests, requests and responses can be viewed as two queues, with each request and response corresponding one-to-one in the two queues.</li>
<li>If a request has already been queued to the Redis server but is cancelled before the response is dequeued, the correspondence between requests and responses in this connection will be confused. Subsequent requests may read responses from completely unrelated previous requests.</li>
<li>In most cases, because the read data is inconsistent with the expected request, an error will be returned.</li>
<li>In some coincidental cases, the erroneously read data happens to be consistent with the expected data type of the request, and although it’s not information from the same user, it will be displayed normally.</li>
<li>At 1 am on March 20, 2023, after a service change, the number of redis request cancellations surged, leading to instances of returning incorrect data (with a very low probability);</li>
</ol>
<p>The key points are in the 5th and 6th points, and we’ll delve deeper into the reproduction and fixing process of this bug in redis-py later.</p>
<h3 id="Incident-Handling"><a href="#Incident-Handling" class="headerlink" title="Incident Handling"></a>Incident Handling</h3><p>OpenAI’s handling of this incident is also worth learning from. First, they emphasized protecting users’ privacy and data security, acknowledged that they failed to do so this time, sincerely apologized, and sent emails to notify all affected users (not sure if there was any substantial compensation).</p>
<p>On the technical side, after finding the specific cause, they also reinforced the protection here. Specifically:</p>
<ol>
<li>Tested whether the fix was effective;</li>
<li>Added data validation to ensure that the requested user and the user in the Redis cache are the same;</li>
<li>Analyzed logs to ensure messages are not seen by unauthorized people;</li>
<li>Accurately identified affected users through multiple data sources, then notified them;</li>
<li>Added some logs to ensure the problem was thoroughly resolved, and if this problem occurs again, it can be discovered immediately;</li>
<li>Improved the robustness of the Redis cluster to reduce connection errors under extreme load conditions.</li>
</ol>
<p>Next, we will focus on this bug in redis-py to see how to reproduce and fix it.</p>
<h2 id="Bug-Reproduction"><a href="#Bug-Reproduction" class="headerlink" title="Bug Reproduction"></a>Bug Reproduction</h2><p><a target="_blank" rel="noopener" href="https://github.com/drago-balto">drago-balto</a> reported this bug in the redis-py client on March 17 in <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/issues/2624">Issue 2624</a>. Simply put, <strong>if the Redis client sends an asynchronous request and cancels it before receiving and parsing the response, subsequent commands on this connection will fail</strong>.</p>
<blockquote>
<p>If async Redis request is canceled at the right time, after the command was sent but before the response was received and parsed, the connection is left in an unsafe state for future commands.</p>
</blockquote>
<p>To reproduce this issue, we first need a redis server, which can be installed locally and started with the default configuration. Note that if your local redis is not configured with a password and ssl, you need to change the redis connection part to the commented code. Then create a Python virtual environment using <code>conda</code>, install version 4.5.1 of redis-py with <code>pip install redis==4.5.1</code>. After that, you can use the following script to reproduce the bug:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> redis.asyncio <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># local redis server without passwd and ssl support</span></span><br><span class="line">    <span class="comment"># myhost = sys.argv[1]</span></span><br><span class="line">    <span class="comment"># async with Redis(host=myhost, ssl=False, single_connection_client=True) as r:</span></span><br><span class="line">    myhost, mypassword = sys.argv[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> Redis(host=myhost, password=mypassword, ssl=<span class="literal">True</span>, single_connection_client=<span class="literal">True</span>) <span class="keyword">as</span> r:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> r.<span class="built_in">set</span>(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line">        <span class="keyword">await</span> r.<span class="built_in">set</span>(<span class="string">'bar'</span>, <span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line">        t = asyncio.create_task(r.get(<span class="string">'foo'</span>))</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.001</span>)</span><br><span class="line">        <span class="comment"># may change to some other value</span></span><br><span class="line">        <span class="comment"># await asyncio.sleep(0.000001)</span></span><br><span class="line">        t.cancel()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">await</span> t</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'try again, we did not cancel the task in time'</span>)</span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'managed to cancel the task, connection is left open with unread response'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'bar:'</span>, <span class="keyword">await</span> r.get(<span class="string">'bar'</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'ping:'</span>, <span class="keyword">await</span> r.ping())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'foo:'</span>, <span class="keyword">await</span> r.get(<span class="string">'foo'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></tbody></table></figure>

<p>The above script uses the same client connection to execute multiple commands in succession. Among them, it asynchronously executes <code>r.get('foo')</code> and calls <code>cancel</code> to cancel this query during execution, then executes other commands. By observing the results of subsequent commands, we can know if there’s a problem here. Note that when <code>await t</code>, it tries to catch the exception <code>asyncio.CancelledError</code>. If this exception is caught, it means the asynchronous task was successfully cancelled before <code>r.get('foo')</code> completed. If there’s no exception, it means the redis read task has already completed, and cancel did not successfully cancel the asynchronous task. A key point here is <code>asyncio.sleep(0.001)</code>, which waits for a period of time to allow the asynchronous read request to be received and executed by the server, but be successfully cancelled before receiving the server’s response.</p>
<p>If the Redis server is in a cloud environment with latency &gt; 5ms, then <code>sleep(0.001)</code> here can reproduce the problem. My Redis client and server are both on the same machine, so network latency can be ignored. Through continuous experimentation, I found that <code>asyncio.sleep(0.000001)</code> here can stably reproduce the issue. Below are the execution results with different sleep times on my local machine:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_reproduce.png/webp" alt="Bug reproduction process" srcset="https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_reproduce.png/webp 2166w, https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_reproduce.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_reproduce.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230726_redis_python_bug_reproduce.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2166" height="700"></p>
<p>We can see that in the case of <code>sleep(0.000001)</code>, all subsequent Redis command results are incorrect, with each command being the result of the previous command. Going back to OpenAI’s fault description, this explains why one person saw another person’s data. Because there were cancelled redis asynchronous request tasks in between, causing the results to be mixed up and read incorrectly.</p>
<h2 id="Source-Code-Analysis"><a href="#Source-Code-Analysis" class="headerlink" title="Source Code Analysis"></a>Source Code Analysis</h2><p>I hadn’t really understood the implementation of redis-py before, so to quickly locate the cause of this bug, the best way is to <strong>add logs</strong>. To immediately see the effect of code changes, first clone the redis-py repository locally, then use the <code>git checkout v4.5.1</code> command to switch to the 4.5.1 branch. Then create a new virtual environment with conda, install the local library in this new environment using <code>pip install -e .</code>, with <code>-e</code> ensuring that local code changes will take effect immediately.</p>
<p>The official redis-py library is written quite clearly, and starting from <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/blob/v4.5.1/redis/asyncio/client.py">client.py</a>, we can quickly find some clues. For example, the <code>execute_command</code> function should be executing a specific command, and we can confirm this by adding a log <code>print("execute_command finally", *args)</code> in the finally code block.</p>
<h3 id="Command-Parsing-Process"><a href="#Command-Parsing-Process" class="headerlink" title="Command Parsing Process"></a>Command Parsing Process</h3><p>The next critical part should be in <code>_send_command_parse_response</code>, where we can see that it first sends the command and then parses the response.</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_send_command_parse_response</span>(<span class="params">self, conn, command_name, *args, **options</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Send a command and parse the response</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">await</span> conn.send_command(*args)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> se</span><br><span class="line">    lf.parse_response(conn, command_name, **options)</span><br></pre></td></tr></tbody></table></figure>

<p>There’s no problem with the part that sends the command, it’s irrelevant to our bug, so we can skip it and mainly look at the response parsing part. Looking directly at the code, there are too many interfering factors, and it’s difficult to see all the branches. We can combine the code while continuously adding debug logs to organize the processing steps of a request. Finally, by printing the function stack in <code>_read_response</code>, the specific code is as follows:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"_read_response"</span>, <span class="string">""</span>.join(traceback.format_stack()))</span><br></pre></td></tr></tbody></table></figure>

<p>Through the stack, we can see that the processing chain of an asynchronous redis get request is as follows:</p>
<ol>
<li>blog_script/redis_bug.py (line 29) - <code>main</code></li>
<li>redis-py/redis/asyncio/client.py (line 514) - <code>execute_command</code></li>
<li>redis-py/redis/asyncio/retry.py (line 59) - <code>call_with_retry</code></li>
<li>redis-py/redis/asyncio/client.py (line 488) - <code>_send_command_parse_response</code></li>
<li>redis-py/redis/asyncio/client.py (line 535) - <code>parse_response</code></li>
<li>redis-py/redis/asyncio/connection.py (line 840) - <code>read_response</code></li>
<li>redis-py/redis/asyncio/connection.py (line 256) - <code>_parser.read_response</code></li>
<li>redis-py/redis/asyncio/connection.py (line 267) - <code>_read_response</code></li>
</ol>
<p>Note that the line numbers in the <code>connection.py</code> part may not match the <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/tree/v4.5.1">actual code</a> because some debug code was added, affecting the line number calculation. When cancelling an asynchronous task, we can see that an <code>asyncio.CancelledError</code> exception is thrown, so where exactly is this exception thrown?</p>
<h3 id="Exception-Throwing-Location"><a href="#Exception-Throwing-Location" class="headerlink" title="Exception Throwing Location"></a>Exception Throwing Location</h3><p>Still through continuous addition of logs, we located <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/blob/v4.5.1/redis/asyncio/connection.py#L341C12-L341C12">connection.py</a>, intuitively it should be in <code>data = await self._stream.readline()</code>, where <code>_stream</code> is an <code>asyncio.StreamReader</code> object, which threw an exception when reading a line of content. How to confirm this? We can try to add a try here to catch the exception, but initially when trying to catch the <code>Exception</code> exception here, it couldn’t be caught. Later I asked ChatGPT and learned that in Python 3.8 and higher versions, <code>asyncio.CancelledError</code> no longer derives from the Exception base class, but directly from <code>BaseException</code>. So I changed to the following code, which verified the guess.</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis/asyncio/connection.py</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_readline</span>(<span class="params">self</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = <span class="keyword">await</span> self._stream.readline()</span><br><span class="line">    <span class="comment"># Verify that the exception was indeed thrown here</span></span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Task was cancelled"</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Reason-for-Data-Confusion"><a href="#Reason-for-Data-Confusion" class="headerlink" title="Reason for Data Confusion"></a>Reason for Data Confusion</h3><p>The execution flow of a request is now very clear, but we haven’t resolved our question, <strong>why does cancelling a task cause subsequent requests to read incorrectly</strong>. Let’s continue to add logs here, print the request command at the beginning of each request (add logs in execute_command), and then print the parsed response (_read_response add logs), the result after execution is as follows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_log.png/webp" alt="The correspondence between requests and replies became confused" srcset="https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_log.png/webp 2290w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_log.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_log.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_log.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2290" height="722"></p>
<p>This involves parsing the Redis reply protocol. Redis uses the <code>RESP (Redis Serialization Protocol)</code>, which is a simple, efficient, and human-readable text-based protocol. It supports various data types, including strings, arrays, and integers. Both client command requests and server responses follow this protocol. For specific format technical details, you can refer to the official documentation <a target="_blank" rel="noopener" href="https://redis.io/docs/reference/protocol-spec/">RESP protocol spec</a>.</p>
<p>From the above screenshot, we can see that the root cause of this bug is that <strong>if an asynchronous request is successfully processed by the server, an exception is thrown before the reply is read by readline. Subsequent requests will read the reply of this cancelled request when calling readline</strong>.</p>
<h2 id="Bug-Fix"><a href="#Bug-Fix" class="headerlink" title="Bug Fix"></a>Bug Fix</h2><p>As I’m not very familiar with the implementation details of Python’s asyncio library and redis-py, I’ll directly look at the official fix code here. However, the official fixing process wasn’t very smooth either, with some <strong>problematic fix code and test code</strong> in between. Let’s take a look.</p>
<h3 id="Incorrect-Fix-Attempt"><a href="#Incorrect-Fix-Attempt" class="headerlink" title="Incorrect Fix Attempt"></a>Incorrect Fix Attempt</h3><p>The first fix attempt was in <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/pull/2641">PR 2641</a>, where someone submitted a fix proposal. The key part is:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_repair_error.png/webp" alt="Code comparison of the fix" srcset="https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_repair_error.png/webp 3078w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_repair_error.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_repair_error.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_repair_error.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3078" height="778"></p>
<p>The core idea here is that since cancelling an asynchronous operation would cause the server’s reply to be missed, we should ensure that once we enter the read operation, we don’t allow the asynchronous task (which is actually a coroutine) to be cancelled until this part of the reply is read out. This uses the <code>asyncio.shield</code> function, which is used to <strong>protect an asynchronous operation from being cancelled</strong>. If an operation is in progress within the asyncio.shield function and other parts attempt to cancel this operation, the cancellation operation will be ignored until the operation within the asyncio.shield function completes and then throws an exception. For a detailed explanation of asyncio.shield, you can refer to the official documentation <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-task.html#shielding-from-cancellation">Shielding From Cancellation</a>.</p>
<p>This fix was merged into version <code>v4.5.3</code>, but the bug could still be reproduced under this version. Looking at the code, the reason is that this fix only added protection for cancellation of the <code>execute</code> function, but not for <code>execute_command</code> in the reproduction script’s execution path. Moreover, this protection scheme itself is problematic, as the modification <strong>prevents cancelling a blocked asynchronous request</strong>, which in severe cases could even cause read requests to get stuck.</p>
<p>The submitter of this solution also provided test cases, but there were problems with the test cases, which failed to detect this bug.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_repair_error_test.png/webp" alt="Incorrect test case" srcset="https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_repair_error_test.png/webp 1316w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_repair_error_test.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_repair_error_test.png/webp800 800w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1316" height="790"></p>
<p>The <code>sleep</code> time here is 1s, by which time this read request has already completed, so the cancellation operation doesn’t actually take effect. A key point in reproducing this is to <strong>hit a very precise time point</strong>, ensuring that the request is processed but the reply content hasn’t been parsed yet. This raises an important question: how should the test hit this time point to make the bug stably reproducible in problematic versions?</p>
<h3 id="Stable-Reproduction-and-Improvement"><a href="#Stable-Reproduction-and-Improvement" class="headerlink" title="Stable Reproduction and Improvement"></a>Stable Reproduction and Improvement</h3><p>Subsequently, a developer raised a new <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/issues/2665">Issue 2665</a> to discuss how to <strong>stably reproduce</strong> this issue. The approach is simple: start a proxy server to relay communication between the client and server. During the relay, both requests and responses are delayed by 0.1s. This is equivalent to simulating a network environment with a communication delay of 0.1s, and then the timing of cancelling asynchronous operations can be stably controlled.</p>
<p>The code for the relay proxy part is as follows:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelayProxy</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr, redis_addr, delay: <span class="built_in">float</span></span>):</span><br><span class="line">        self.addr = addr</span><br><span class="line">        self.redis_addr = redis_addr</span><br><span class="line">        self.delay = delay</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        server = <span class="keyword">await</span> asyncio.start_server(self.handle, *self.addr)</span><br><span class="line">        asyncio.create_task(server.serve_forever())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self, reader, writer</span>):</span><br><span class="line">        <span class="comment"># establish connection to redis</span></span><br><span class="line">        redis_reader, redis_writer = <span class="keyword">await</span> asyncio.open_connection(*self.redis_addr)</span><br><span class="line">        pipe1 = asyncio.create_task(pipe(reader, redis_writer, self.delay, <span class="string">'to redis:'</span>))</span><br><span class="line">        pipe2 = asyncio.create_task(pipe(redis_reader, writer, self.delay, <span class="string">'from redis:'</span>))</span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(pipe1, pipe2)</span><br></pre></td></tr></tbody></table></figure>

<p>The complete reproduction code can be found at <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/9cb19090008d0d560f22fba31e82c2cc">redis_cancel.py</a>.</p>
<p>In response to this reproduction, chayim submitted <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/pull/2666">PR 2666</a>, corresponding to commit <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/commit/5acbde355058ab7d9c2f95bcef3993ab4134e342">5acbde3</a> which was placed in v4.5.4, using <code>asyncio.shield</code> to prohibit cancellation operations in all command operation scenarios. The key part of the change is as follows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230802_redis_python_bug_shield_everywhere.png/webp" alt="asyncio.shield added protection" srcset="https://slefboot-1251736664.file.myqcloud.com/20230802_redis_python_bug_shield_everywhere.png/webp 3048w, https://slefboot-1251736664.file.myqcloud.com/20230802_redis_python_bug_shield_everywhere.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230802_redis_python_bug_shield_everywhere.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230802_redis_python_bug_shield_everywhere.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3048" height="1260"></p>
<p>This is essentially a patch for the previous fix, which indeed fixes the bug of reading jumbled data, and the new test script can’t reproduce it. We can slightly modify the fix code below to better understand the principle of this fix. Let’s extract the <code>asyncio.shield</code> part from the code, print the result, and try to catch exceptions. The modified part is as follows:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute_command</span>(<span class="params">self, *args, **options</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    result = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        result = <span class="keyword">await</span> asyncio.shield(</span><br><span class="line">            self._try_send_command_parse_response(conn, *args, **options)</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"[log] <span class="subst">{args}</span> <span class="subst">{result}</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"[EXCEPTION] <span class="subst">{args}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>Re-running the test script, we can see that for the request part where the asynchronous read is cancelled, the output is as follows:</p>
<blockquote>
<p>[EXCEPTION] (‘GET’, ‘foo’)<br>try again, we did not cancel the task in time</p>
</blockquote>
<p>We can see that after adding <code>asyncio.shield</code>, the asynchronous task didn’t throw an exception at the original <code>data = await self._stream.readline()</code> position (see the previous explanation of this), but instead normally completed the asynchronous get operation, got the result ‘foo’, and then finally threw the asyncio.CancelledError exception at <code>await asyncio.shield</code>. This PR also submitted test cases that can stably reproduce the issue, in <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/pull/2666/files#diff-a90c3a19dad7803c9726358f223a3b7b8fb23ccb1d573d580d6640f04fdd3f27">tests/test_asyncio/test_cwe_404.py</a>, with the basic idea still being to use a proxy to simulate delay time.</p>
<h3 id="Background-and-Final-Fix"><a href="#Background-and-Final-Fix" class="headerlink" title="Background and Final Fix"></a>Background and Final Fix</h3><p>The above fix seemed to solve the problem, but <a target="_blank" rel="noopener" href="https://github.com/kristjanvalur">kristjanvalur</a> was very dissatisfied with this fix solution and directly commented on <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/pull/2666">PR 2666</a>. As mentioned earlier, this approach of delaying exception throwing makes it impossible to truly cancel an asynchronous request, and in some scenarios, it can even lead to deadlock. kristjanvalur also provided an example code in this PR to prove that deadlock is entirely possible.</p>
<p>To finish the job, kristjanvalur then submitted a new <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/pull/2695">PR 2695</a>. This PR contains quite a lot, including rolling back the shield-related code in <code>v4.5.3</code> and <code>4.5.4</code>, then fixing <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/issues/2624">Issue 2624</a> that caused ChatGPT to read incorrect data, and providing a unit test.</p>
<p>To provide a bit more background, kristjanvalur contributed a lot of code to <code>asyncio/client.py</code> in 2022, including <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/pull/2104">PR 2104: Catch Exception and not BaseException in the Connection</a>, which only closes the connection when encountering an Exception situation. It was this change that led to connections containing erroneous data being put back into the connection pool in certain scenarios. The specific discussion can be seen in <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/issues/2499">Issue 2499: BaseException at I/O corrupts Connection</a>, and this bug was also brought about by this change.</p>
<p>The core code of the specific fix solution is as follows, adding exception handling for BaseException in <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/blob/f056118224e851915922de02ec40f2d16c9e4dd7/redis/asyncio/connection.py#L831C15-L831C28">read_response</a>, with the default being to directly disconnect the connection.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230802_redis_python_bug_disconnect.png/webp" alt="Exception directly disconnects the connection" srcset="https://slefboot-1251736664.file.myqcloud.com/20230802_redis_python_bug_disconnect.png/webp 3212w, https://slefboot-1251736664.file.myqcloud.com/20230802_redis_python_bug_disconnect.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230802_redis_python_bug_disconnect.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230802_redis_python_bug_disconnect.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3212" height="1348"></p>
<h3 id="Final-Verification-Process"><a href="#Final-Verification-Process" class="headerlink" title="Final Verification Process"></a>Final Verification Process</h3><p>According to the version log on the <a target="_blank" rel="noopener" href="https://github.com/redis/redis-py/releases">Release</a> page, we can see that version 4.5.5 merged PR 2695, as shown in the following image:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230728_redis_python_bug_release.png/webp" alt="Fix record of Redis python" srcset="https://slefboot-1251736664.file.myqcloud.com/20230728_redis_python_bug_release.png/webp 1884w, https://slefboot-1251736664.file.myqcloud.com/20230728_redis_python_bug_release.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230728_redis_python_bug_release.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230728_redis_python_bug_release.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1884" height="1406"></p>
<p>Switch to the <code>v4.5.5</code> branch, and then try to verify again using the reproduction script above, obtaining the following result:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_log_succ.png/webp" alt="Output after successful fix" srcset="https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_log_succ.png/webp 2058w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_log_succ.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_log_succ.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230731_redis_python_bug_log_succ.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2058" height="730"></p>
<p>At this point, the bug has been thoroughly fixed. Let’s add some logs to verify our understanding process above, such as:</p>
<ol>
<li>When cancelling a task, the connection will be disconnected here;</li>
<li>The next time a connection is obtained, a new connection will be used;</li>
</ol>
<p>Here, add logs at the places where the connection is about to be disconnected and a new connection is created, using <code>id(self._reader)</code> to verify that a new <code>asyncio.StreamReader</code> object is indeed created. As follows:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--- a/redis/asyncio/connection.py</span><br><span class="line">+++ b/redis/asyncio/connection.py</span><br><span class="line"><span class="meta">@@ -<span class="number">638</span>,<span class="number">6</span> +<span class="number">638</span>,<span class="number">8</span> @@ class Connection:</span></span><br><span class="line">             task = callback(self)</span><br><span class="line">             <span class="keyword">if</span> task <span class="keyword">and</span> inspect.isawaitable(task):</span><br><span class="line">                 <span class="keyword">await</span> task</span><br><span class="line">+</span><br><span class="line">+        <span class="built_in">print</span>(<span class="string">f'[log] New Connection <span class="subst">{<span class="built_in">id</span>(self._reader)}</span> <span class="subst">{<span class="built_in">id</span>(self._writer)}</span>'</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_connect</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="string">"""Create a TCP socket connection"""</span></span><br><span class="line"><span class="meta">@@ -<span class="number">866</span>,<span class="number">6</span> +<span class="number">868</span>,<span class="number">7</span> @@ class Connection:</span></span><br><span class="line">             <span class="comment"># relies on this behaviour when doing Command/Response pairs.</span></span><br><span class="line">             <span class="comment"># See #1128.</span></span><br><span class="line">             <span class="keyword">if</span> disconnect_on_error:</span><br><span class="line">+                <span class="built_in">print</span>(<span class="string">f'[log] disconnecting <span class="subst">{<span class="built_in">id</span>(self._reader)}</span> <span class="subst">{<span class="built_in">id</span>(self._writer)}</span>'</span>)</span><br><span class="line">                 <span class="keyword">await</span> self.disconnect(nowait=<span class="literal">True</span>)</span><br><span class="line">             <span class="keyword">raise</span></span><br></pre></td></tr></tbody></table></figure>

<p>The output obtained is as follows, we can see that when cancelling a task, the connection is immediately disconnected, at which point the stream read with id=4388303056 is destroyed. The next redis operation creates a new connection and allocates a new stream read with id=4388321104.</p>
<blockquote>
<p>[log] New Connection 4388303056 4385849616<br>[log] disconnecting 4388303056 4385849616<br>managed to cancel the task, connection is left open with unread response<br>[log] New Connection 4388321104 4385849616<br>bar: b’bar’<br>ping: True<br>foo: b’foo’</p>
</blockquote>
<p>The overall fix idea is clear, which is to directly close the connection for abnormal request clients, which will clear the read and write streams. The next time there’s a new request, a new stream is used, avoiding the problem of misreading.</p>
<h2 id="Brief-Summary"><a href="#Brief-Summary" class="headerlink" title="Brief Summary"></a>Brief Summary</h2><p>OpenAI has made public a <strong>status page</strong> that displays the real-time operational status of various services. When ChatGPT is unavailable, users can immediately confirm this on the status page, rather than blindly guessing that the problem is on their end. This high-transparency approach is worth learning from. Firstly, it demonstrates respect and responsibility towards users, not easily blocking information. Secondly, it also helps the company proactively address issues rather than avoiding or concealing them.</p>
<p>The <strong>technical details published</strong> by OpenAI are quite comprehensive, which also reflects their highly transparent attitude. The report also specifically stated that the problem only existed within a very short window, and listed various remedial and preventive measures, including adding new verification logic, log recording, improving fault tolerance, etc. These details all show OpenAI’s high regard for user privacy and product quality. Then, through a detailed analysis of the technical reasons for this ChatGPT service interruption, we can gain the following insights:</p>
<p>First, this fully demonstrates the greatness of the open-source community’s power. From the initial problem report, to the submission of error fix proposals, to providing stable reproduction methods, and finally to the implementation of reasonable fix solutions, the entire process involved contributions from open-source community participants. It is because of such collaboration that a serious bug could be systematically analyzed and fixed in a short time.</p>
<p>Secondly, this also reflects that locating bugs that are difficult to reproduce stably requires skill. Using a proxy server to simulate network delay and create a time window for triggering errors provided important support for confirming and locating bugs. This approach has reference significance for handling various types of intermittent anomaly issues.</p>
<p>Additionally, this also demonstrates the difficulties of asynchronous programming. Understanding the execution of an asynchronous task flow requires a very strong grasp of code details. Printing logs and adding breakpoints are necessary means, and a thorough understanding of language and library behaviors is needed to analyze the root cause of the problem.</p>
<p>Finally, this case also highlights the value of excellent open-source projects. Not only do they need to provide reliable functional implementations, but they also need comprehensive documentation, comments, and test code. This is the cornerstone for the long-term development of open-source projects. Readers can master techniques for locating difficult problems and improve their programming skills through this kind of source code-level debugging analysis. It is also hoped that this article will provide inspiration and help for readers who need to deeply understand the implementation of open-source projects.</p>
<blockquote>
<p>The final summary part was written by claude2, and it feels okay? Although it has a bit of a preachy feel.</p>
</blockquote>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/Python/"><i class="fa fa-tag"></i>Python</a><a href="/tags/ChatGPT/"><i class="fa fa-tag"></i>ChatGPT</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2023/08/02/redis_python_bug/';
    this.page.identifier = 'en/2023/08/02/redis_python_bug/';
    this.page.title = 'Dive into the ChatGPT Data Leak caused by Redis Bug';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (17)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (13)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2023/08/02/redis_python_bug/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/01/24/leveldb_source_writedb/" title="LevelDB Explained - Implementation and Optimization Details of Key-Value Writing">LevelDB Explained - Implementation and Optimization Details of Key-Value Writing</a></li><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li><li><a href="/en/2024/09/09/leveldb_source_skiplist/" title="LevelDB Explained - How to implement SkipList">LevelDB Explained - How to implement SkipList</a></li><li><a href="/en/2024/09/05/claude35_prompt/" title="Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...">Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Public-Disclosure-of-the-Incident"><span class="toc-number">1.</span> <span class="toc-text">Public Disclosure of the Incident</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Incident-Details"><span class="toc-number">1.1.</span> <span class="toc-text">Incident Details</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cause-of-the-Incident"><span class="toc-number">1.2.</span> <span class="toc-text">Cause of the Incident</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Incident-Handling"><span class="toc-number">1.3.</span> <span class="toc-text">Incident Handling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bug-Reproduction"><span class="toc-number">2.</span> <span class="toc-text">Bug Reproduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Source-Code-Analysis"><span class="toc-number">3.</span> <span class="toc-text">Source Code Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Command-Parsing-Process"><span class="toc-number">3.1.</span> <span class="toc-text">Command Parsing Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception-Throwing-Location"><span class="toc-number">3.2.</span> <span class="toc-text">Exception Throwing Location</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reason-for-Data-Confusion"><span class="toc-number">3.3.</span> <span class="toc-text">Reason for Data Confusion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bug-Fix"><span class="toc-number">4.</span> <span class="toc-text">Bug Fix</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Incorrect-Fix-Attempt"><span class="toc-number">4.1.</span> <span class="toc-text">Incorrect Fix Attempt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stable-Reproduction-and-Improvement"><span class="toc-number">4.2.</span> <span class="toc-text">Stable Reproduction and Improvement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Background-and-Final-Fix"><span class="toc-number">4.3.</span> <span class="toc-text">Background and Final Fix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Final-Verification-Process"><span class="toc-number">4.4.</span> <span class="toc-text">Final Verification Process</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Brief-Summary"><span class="toc-number">5.</span> <span class="toc-text">Brief Summary</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>