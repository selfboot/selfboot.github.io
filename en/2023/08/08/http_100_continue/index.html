<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article documents the entire process of troubleshooting HTTP request timeout issues when a C++ client requests a Go server. Through comparative packet capture analysis, it was found to be related to the Expect 100-continue request header, and the implementation mechanism of this header was deeply analyzed. Finally, it was located that the Mesh layer did not properly handle this header, causing the problem, and a code-level solution was provided."><title>Troubleshooting HTTP Request Timeout Issues Caused by HTTP Headers</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Troubleshooting HTTP Request Timeout Issues Caused by HTTP Headers</h1><div class="post-meta">2023/08/08<span> | </span><span class="category"><a href="/categories/Programming/">Programming</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2023/08/08/http_100_continue/" href="/en/2023/08/08/http_100_continue/#disqus_thread"></a><div class="post-content"><p>In actual business, we encountered a very strange problem: when service A accessed Go language service B through HTTP requests, a small portion of the requests would time out. Further analysis revealed that if a request timed out, its retry would definitely time out as well, indicating that for specific request content, the timeout was an inevitable problem. By checking the processing logs of service B, it was found that for timed-out requests, the processing time of the business logic was normal.</p>
<p>Initially, we used the process of elimination to analyze, gradually replacing suspected problematic modules, but we couldn’t locate the problem. Later, through packet capture, we analyzed the differences between normal packets and timeout packets, made reasonable guesses about the problematic parts, and verified them. We finally located that it was the <code>Expect: 100-continue</code> request HTTP header that caused the timeout here. The entire troubleshooting and fixing process encountered many pitfalls, which are recorded here for everyone’s reference.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_summary.png/webp" alt="WireShark packet capture of HTTP expect: 100-continue" srcset="https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_summary.png/webp 2762w, https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_summary.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_summary.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_summary.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2762" height="1390"></p>
<span id="more"></span>

<h2 id="Process-of-Elimination"><a href="#Process-of-Elimination" class="headerlink" title="Process of Elimination"></a>Process of Elimination</h2><p>The business usually develops in C++, and the HTTP Client library used here is <a target="_blank" rel="noopener" href="https://curl.se/libcurl/">libcurl</a>, which has been quite stable and hasn’t had any problems. So at first, we suspected it was a problem with Go service B. The Go service is actually quite simple, it’s an HTTP protocol proxy implemented using the <a target="_blank" rel="noopener" href="https://github.com/gin-gonic/gin">gin framework</a>, used to unpack business requests and then repackage them according to third-party protocols before forwarding to the third party. By adding logs and other methods, we ruled out problems with the business logic part of the code and initially suspected that we were using gin incorrectly. To quickly verify, I wrote a simple go server using gin and used the business client to request the mock server.</p>
<h3 id="Replacing-the-Go-Server"><a href="#Replacing-the-Go-Server" class="headerlink" title="Replacing the Go Server"></a>Replacing the Go Server</h3><p>Writing a simple HTTP server with gin is quite simple. To <strong>simulate the business scenario as much as possible</strong>, we read the content from the request package and then reply with a relatively long random content. The complete code is in <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/7d45051f39785adc6f46a92eb585af43">gist: mock_server.go</a>, and the core part of the code is as follows:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MeshCall</span><span class="params">(meshPath <span class="type">string</span>, c *gin.Context)</span></span> {</span><br><span class="line">        start := time.Now()</span><br><span class="line"></span><br><span class="line">        uinStr := c.Query(<span class="string">"uin"</span>)</span><br><span class="line">        uin, err := strconv.ParseUint(uinStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">                c.Status(http.StatusBadRequest)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        body, _ := ioutil.ReadAll(c.Request.Body)</span><br><span class="line">        log.Println(<span class="string">"Request Body: "</span>, <span class="type">string</span>(body))</span><br><span class="line"></span><br><span class="line">        c.Status(http.StatusOK)</span><br><span class="line">        c.Writer.Header().Add(<span class="string">"code"</span>, strconv.FormatInt(<span class="type">int64</span>(uin), <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate a 1MB random string</span></span><br><span class="line">        randomStr := StringWithCharset(<span class="number">1024</span>*<span class="number">1024</span>, charset)</span><br><span class="line">        c.Writer.Write([]<span class="type">byte</span>(randomStr))</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">"Request processed in %s\n"</span>, time.Since(start))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The above mock server code includes the core logic in business service B, such as using <code>ReadAll</code> to get request data and <code>c.Writer</code> to write back package content. After starting the service on port 8089, whether using the command-line curl tool directly or using the C++ client to call, we could get a normal HTTP reply. It seems that the usage of gin in the business go service is not a problem, and we can basically rule out issues with gin itself. After replacing the server and not finding any problems, should we replace the client next?</p>
<h3 id="Replacing-the-Go-Client"><a href="#Replacing-the-Go-Client" class="headerlink" title="Replacing the Go Client"></a>Replacing the Go Client</h3><p>The C++ client logic is very simple: it sets an image to a field in protobuf, serializes it, and then uses libcurl to initiate an HTTP request, and then waits for the response. With the help of ChatGPT, we quickly wrote a client in go with the same request logic. The complete code is in <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/a88f2c4cc8f7bd5ef99097be34b988f6">gist: mock_client.go</a>, omitting the proto part here. The core code is as follows:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    req, err: = http.NewRequestWithContext(context.Background(), http.MethodPost, <span class="string">"http://localhost:8089"</span>, bytes.NewBuffer(serializedImageDataTwice))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatalf(<span class="string">"failed to create request: %v"</span>, err)</span><br><span class="line">    }</span><br><span class="line">    req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/x-protobuf"</span>)</span><br><span class="line"></span><br><span class="line">    client: = &amp; http.Client {}</span><br><span class="line">    resp, err: = client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        log.Fatalf(<span class="string">"failed to send request: %v"</span>, err)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">"response header: %v"</span>, resp.Header)</span><br><span class="line">    log.Printf(<span class="string">"response body: %v"</span>, resp.Body)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Using this go client to request the previously mocked go server, we could normally parse the response. Then, <strong>when requesting the problematic business service B, we found that it no longer timed out and could normally read the response</strong>. This was a bit confusing. Let’s summarize the results of the previous experiments:</p>
<table>
<thead>
<tr>
<th>Caller</th>
<th>Callee</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>C++ Client A</td>
<td>Go Server B</td>
<td>Specific requests always timeout</td>
</tr>
<tr>
<td>C++ Client A</td>
<td>Go Mock Server</td>
<td>Everything normal</td>
</tr>
<tr>
<td>Go Client</td>
<td>Go Server B</td>
<td>Everything normal</td>
</tr>
<tr>
<td>Go Client</td>
<td>Go Mock Server</td>
<td>Everything normal</td>
</tr>
</tbody></table>
<p><strong>Only when <code>C++ Client A</code> and <code>Go Server B</code> are together, specific requests would timeout</strong>. There were no good ideas left to investigate, so we could only try to capture packets and see what differences there were between TCP/HTTP packets in normal situations and timeout situations.</p>
<h2 id="Tcpdump-Packet-Capture-Analysis"><a href="#Tcpdump-Packet-Capture-Analysis" class="headerlink" title="Tcpdump Packet Capture Analysis"></a>Tcpdump Packet Capture Analysis</h2><p>Packet capture under Linux is simple, just use tcpdump directly, although it usually requires root privileges. The following command filters packets for specified IP and port and saves them in <code>pcap</code> format for later analysis with <code>Wireshark</code>.</p>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> tcpdump -i any -s <span class="number">0</span> -w output.pcap 'host <span class="number">11</span>.**.**.** and port <span class="number">1</span>***'</span><br></pre></td></tr></tbody></table></figure>

<p>First, we captured packets between the go client (IP ending with 143) and Go Server B (IP ending with 239). The entire request-response was completely as expected. We could see that around 0.35s, the TCP request was fully sent, and then around 1.8s, it started receiving the response. The HTTP request took about 1.5s, and the response content was also completely correct.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_go_client_succ.png/webp" alt="WireShark capturing normal response packets" srcset="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_go_client_succ.png/webp 2788w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_go_client_succ.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_go_client_succ.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_go_client_succ.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2788" height="1366"></p>
<p>Next were the packets between the C++ client and Go Server B. Here, the C++ client’s timeout was set to 10 seconds. We could see that a 100 continue HTTP response was received in the middle, and then after 10s, the client closed the TCP connection.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_fail.png/webp" alt="WireShark capturing timeout packets" srcset="https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_fail.png/webp 2744w, https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_fail.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_fail.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_fail.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2744" height="1474"></p>
<p>Where did this <code>100 continue</code> come from? Why didn’t the Go client request to the service have it, while the C++ client request did?</p>
<h3 id="Header-Comparison"><a href="#Header-Comparison" class="headerlink" title="Header Comparison"></a>Header Comparison</h3><p>Different responses are usually due to different requests. Comparing the header parts of these two requests, we found that the <code>Content-Type</code> was different, but this generally doesn’t have much effect, at most affecting server parsing, and wouldn’t cause a timeout. In addition to this, the C++ request header also had an extra <code>Expect: 100-continue</code>, which matched the continue in the above response. It seems that there’s a high probability that this header is the problem.</p>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Go client header part</span></span><br><span class="line"><span class="attribute">POST</span> /*** HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Host</span>: **.<span class="number">239</span>:***</span><br><span class="line"><span class="attribute">User</span>-Agent: Go-http-client/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Content</span>-Length: <span class="number">1189188</span></span><br><span class="line"><span class="attribute">Content</span>-Type: application/x-protobuf</span><br><span class="line"><span class="attribute">Accept</span>-Encoding: gzip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># C++ client header part</span></span><br><span class="line"><span class="attribute">POST</span> /*** HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Host</span>: **.<span class="number">239</span>:***</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Content</span>-Type: application/octet-stream</span><br><span class="line"><span class="attribute">Content</span>-Length: <span class="number">1189193</span></span><br><span class="line"><span class="attribute">Expect</span>: <span class="number">100</span>-continue</span><br></pre></td></tr></tbody></table></figure>

<p>To quickly verify, we <strong>added this header in the go client</strong> and then initiated a request, which also timed out. It seems that it was indeed caused by this header, but what exactly does this header do? Why does it cause the request to timeout?</p>
<h2 id="Expect-100-continue"><a href="#Expect-100-continue" class="headerlink" title="Expect: 100-continue"></a>Expect: 100-continue</h2><p>To answer the above questions, we need to have a further understanding of HTTP headers. In the HTTP protocol, when a client wants to send a request containing a large amount of data (usually a POST or PUT request), if the server cannot handle this request (for example, because the format of the requested data is incorrect or there is no permission), then the client would waste a lot of resources sending this data. To solve this problem, HTTP/1.1 introduced the <code>Expect: 100-continue</code> header, allowing the client to ask the server if it’s willing to receive the request <strong>before sending the request body</strong>. If the server cannot handle the request, the client can avoid sending a large amount of data, thus saving resources.</p>
<p>The specific implementation principle here is to send a complete HTTP request in two phases. The first phase only sends the header of the HTTP request, and the second phase only sends the body of the HTTP request after receiving server confirmation. From the HTTP perspective, it’s still a single HTTP request, just changing the way the request is sent.</p>
<p>This is generally implemented by the network library and the underlying TCP protocol. When using the “Expect: 100-continue” header, the network library (such as libcurl) will first only send the TCP data of the Expect part, and then wait for the server’s 100 Continue response. After receiving the TCP reply, the network library will continue to send the TCP data packets of the request body. If the server doesn’t return a 100 Continue response, the network library might choose to wait for a while, then send the request body, or close the connection.</p>
<h3 id="libcurl-Implementation"><a href="#libcurl-Implementation" class="headerlink" title="libcurl Implementation"></a>libcurl Implementation</h3><p>Specifically in the libcurl network library, there’s a detailed explanation in <a target="_blank" rel="noopener" href="https://everything.curl.dev/http/post/expect100">Expect 100-continue</a>. <strong>When using Post or Put methods, if the request body exceeds a certain size (generally 1024 bytes), libcurl automatically adds the “Expect: 100-continue” request header</strong>. For the packet capture above, there was a relatively large image in the request body, so the C++ libcurl client request included this header.</p>
<p>Now there’s only one question left: <strong>why does having this header cause the request to timeout?</strong> The libcurl documentation mentions the following:</p>
<blockquote>
<p>Unfortunately, lots of servers in the world do not properly support the Expect: header or do not handle it correctly, so curl will only wait 1000 milliseconds for that first response before it will continue anyway.</p>
</blockquote>
<p>We can see that many services don’t support the <code>Expect: 100-continue</code> header well, but libcurl has also considered this situation and will continue to send the body after waiting for a 1s timeout. This can also be verified from the previous packet capture:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_wait1000.png/webp" alt="WireShark Expect: 100-continue waiting for 1s" srcset="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_wait1000.png/webp 2750w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_wait1000.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_wait1000.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_wait1000.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2750" height="1210"></p>
<p>Here, after the libcurl client (IP ending with 253) sent the header, it didn’t receive a reply from the server, so it waited for about 1s before continuing to send the request body. Under normal circumstances, the server would process and then respond after receiving the complete response, at most wasting 1s of waiting time. However, our server behaved quite peculiarly here. After receiving the complete package, it first replied with 100-continue, and then had no reaction. This caused the client to keep waiting until it timed out after 10s. What caused this?</p>
<h2 id="Timeout-Cause-and-Fix"><a href="#Timeout-Cause-and-Fix" class="headerlink" title="Timeout Cause and Fix"></a>Timeout Cause and Fix</h2><p>Let’s first review the experiments we’ve done. We already know that when C++ Client A requests Go Mock Server with the Expect:100-continue header, the HTTP server of the gin framework can respond normally. The entire request and response process is as follows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_continue_succ.png/webp" alt="WireShark Expect: 100-continue normal processing flow" srcset="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_continue_succ.png/webp 2834w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_continue_succ.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_continue_succ.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_continue_succ.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2834" height="1100"></p>
<p>We can see that after receiving the header, the gin service directly replied with 100-continue, then the client continued to transmit the body. After the gin service received it completely, it also gave a normal 200 response. <strong>Why does requesting our business Go service B timeout when it’s the same gin service?</strong></p>
<p>After careful consideration, we found that there are differences between these two. The gin service mocked in this experiment was opened on a port on the local machine, and requests were directly processed at this port. However, <strong>the traffic of the business Go service is taken over and forwarded by the mesh</strong>, and if the mesh layer doesn’t handle 100-continue well, there could indeed be problems (we can analyze the implementation of mesh later to see where the problem is).</p>
<h3 id="Problem-Fix"><a href="#Problem-Fix" class="headerlink" title="Problem Fix"></a>Problem Fix</h3><p>The code at the Mesh layer is maintained by dedicated personnel, and it’s difficult to determine when it can be fixed after submitting an Issue, while the business urgently needs to solve this problem. So we had no choice but to change the libcurl calling method to remove this request header when making requests. I asked ChatGPT how to remove this header when sending network requests using libcurl, and got the following method.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_del.png/webp" alt="C++ libcurl request removing Expect: 100-continue header" srcset="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_del.png/webp 1608w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_del.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_del.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_del.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1608" height="1368"></p>
<p>So I happily went to change the code for the business request part, setting the header before initiating the network request. The changes are as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// Disable "Expect: 100-continue" header</span></span><br><span class="line">    curl_slist *headers = <span class="literal">NULL</span>;</span><br><span class="line">    headers = <span class="built_in">curl_slist_append</span>(headers, <span class="string">"Expect:"</span>);</span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_HTTPHEADER, headers);</span><br><span class="line"></span><br><span class="line">    defer {</span><br><span class="line">        <span class="built_in">curl_slist_free_all</span>(headers);  <span class="comment">// remember to free the headers</span></span><br><span class="line">    };</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>After making the changes, I verified that the HTTP request to service B could indeed receive a normal response. However, when deploying, we found parameter error alerts for network requests to other third parties. After rolling back, the failures disappeared, so it seems to be related to the changes in this HTTP request. Looking carefully at the <code>CURLOPT_HTTPHEADER</code> part of libcurl settings here, we found that the business also sets it, and <strong>this modification would completely overwrite the previously set header</strong>.</p>
<p>ChatGPT told me that I could clear this Expect header, and even reminded me to be careful about memory leaks, but ChatGPT couldn’t consider everything comprehensively and didn’t consider that this method would directly overwrite my original header. ChatGPT can indeed provide us with very useful suggestions and solutions, but its answers are based on the context given by the user. It doesn’t know the details of the entire system and can’t predict all business scenarios. Therefore, when accepting and applying its suggestions, we need to be very cautious and ensure that its suggestions are combined with actual business scenarios.</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/Debug/"><i class="fa fa-tag"></i>Debug</a><a href="/tags/Go/"><i class="fa fa-tag"></i>Go</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2023/08/08/http_100_continue/';
    this.page.identifier = 'en/2023/08/08/http_100_continue/';
    this.page.title = 'Troubleshooting HTTP Request Timeout Issues Caused by HTTP Headers';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (17)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (13)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2023/08/08/http_100_continue/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/01/24/leveldb_source_writedb/" title="LevelDB Explained - Implementation and Optimization Details of Key-Value Writing">LevelDB Explained - Implementation and Optimization Details of Key-Value Writing</a></li><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li><li><a href="/en/2024/09/09/leveldb_source_skiplist/" title="LevelDB Explained - How to implement SkipList">LevelDB Explained - How to implement SkipList</a></li><li><a href="/en/2024/09/05/claude35_prompt/" title="Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...">Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Process-of-Elimination"><span class="toc-number">1.</span> <span class="toc-text">Process of Elimination</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Replacing-the-Go-Server"><span class="toc-number">1.1.</span> <span class="toc-text">Replacing the Go Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Replacing-the-Go-Client"><span class="toc-number">1.2.</span> <span class="toc-text">Replacing the Go Client</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tcpdump-Packet-Capture-Analysis"><span class="toc-number">2.</span> <span class="toc-text">Tcpdump Packet Capture Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Header-Comparison"><span class="toc-number">2.1.</span> <span class="toc-text">Header Comparison</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Expect-100-continue"><span class="toc-number">3.</span> <span class="toc-text">Expect: 100-continue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libcurl-Implementation"><span class="toc-number">3.1.</span> <span class="toc-text">libcurl Implementation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Timeout-Cause-and-Fix"><span class="toc-number">4.</span> <span class="toc-text">Timeout Cause and Fix</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Problem-Fix"><span class="toc-number">4.1.</span> <span class="toc-text">Problem Fix</span></a></li></ol></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>