<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article explores stack availability under different compilation methods. In static linking scenarios, even if intermediate libraries lose stack information, the overall call stack becomes jumbled. The same applies to dynamic linking. Retaining frame pointers is key to obtaining the stack, requiring additional compilation options."><title>Stack Preservation in Complex C++ Projects and eBPF Performance Analysis</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Stack Preservation in Complex C++ Projects and eBPF Performance Analysis</h1><div class="post-meta">2023/10/17<span> | </span><span class="category"><a href="/categories/Programming/">Programming</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2023/10/17/c++_frame_pointer/" href="/en/2023/10/17/c++_frame_pointer/#disqus_thread"></a><div class="post-content"><p>When building and maintaining complex C++ projects, performance optimization and memory management are crucial. When faced with performance bottlenecks or memory leaks, we can use eBPF (Extended Berkeley Packet Filter) and BCC (BPF Compiler Collection) tools for analysis. As we saw in <a href="https://selfboot.cn/2023/06/14/bug_redis_deadlock_1/">Redis Issue Analysis: “Deadlock” Problem Caused by Stream Data Read and Write (1)</a>, we used BCC’s profile tool to analyze Redis’s CPU usage, drew a CPU flame graph, and then could easily find the functions with high time consumption and their call chains.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230613_bug_redis_deadlock_cpu.svg" alt="CPU Flame Graph"></p>
<span id="more"></span>

<p>A major prerequisite for using profile for analysis is that the binary file of the service must retain the stack information of functions. Stack information is a record of function calls and local variables during program execution. By looking at the stack information when the program executes to a certain point, we can know which functions have been called and how they are interrelated. This is crucial for debugging and optimizing code, especially when dealing with performance issues and memory leaks.</p>
<p>However, in actual projects, when we use eBPF to analyze service performance bottlenecks or memory leaks, we often cannot get the function call stack and encounter various <code>unknown</code> function call chains. This is because production environments usually do not include debugging information to reduce the size of binary files. Moreover, even if debugging information is generated with <code>-g</code> when compiling C++ code in the production environment, we may not be able to get a complete function call stack. The reasons for this are complex, and this article will expand on this issue.</p>
<h2 id="Program-Stack-Information"><a href="#Program-Stack-Information" class="headerlink" title="Program Stack Information"></a>Program Stack Information</h2><p>In computer science, a <code>stack</code> is a basic data structure that follows the Last-In-First-Out (LIFO) principle. This means that the last element added to the stack is the first to be removed. Stacks have many uses in program design, with the most common being their application in function calls and local variable storage.</p>
<p>During program execution, the stack is used to manage function calls, which is called the <code>"call stack"</code> or <code>"execution stack"</code>. When a function is called, a new stack frame is created and pushed onto the call stack. This stack frame includes:</p>
<ol>
<li>Return address: The memory address where the program should continue executing after the function completes.</li>
<li>Function parameters: The arguments passed to the function.</li>
<li>Local variables: Variables defined within the function.</li>
<li>Frame pointer: A pointer to the previous stack frame, to restore the context of the previous stack frame when the current function returns.</li>
</ol>
<p>When a function completes execution, its stack frame is popped off, and control returns to the saved return address. The distribution of the stack in memory is shown in the following figure:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230702_c++_frame_pointer_stack_mem.png/webp" alt="Function Call Stack Memory Distribution" srcset="https://slefboot-1251736664.file.myqcloud.com/20230702_c++_frame_pointer_stack_mem.png/webp 836w, https://slefboot-1251736664.file.myqcloud.com/20230702_c++_frame_pointer_stack_mem.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230702_c++_frame_pointer_stack_mem.png/webp800 800w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="836" height="1236"></p>
<h3 id="Stack-Information-in-DWARF-Format"><a href="#Stack-Information-in-DWARF-Format" class="headerlink" title="Stack Information in DWARF Format"></a>Stack Information in DWARF Format</h3><p>Function call stack information is saved in binary files in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> format. DWARF is a standard format for representing debugging information for programs, widely used in Unix and Linux systems. It is a very flexible and extensible format that can represent rich debugging information, including but not limited to source code line numbers, variable names, data types, stack frames, and their relationships.</p>
<p>DWARF consists of a series of “debug sections”, each containing specific types of debugging information. For example, <code>.debug_info</code>: contains information about program structure, such as variables, types, and procedures. <code>.debug_line</code>: contains mappings of source code line numbers and addresses, which is very useful for locating source code positions in debuggers. You can see the specific format standards on the <a target="_blank" rel="noopener" href="https://dwarfstd.org/index.html">DWARF official website</a>, such as the current <a target="_blank" rel="noopener" href="https://dwarfstd.org/dwarf5std.html">Version 5</a>, which has a <a target="_blank" rel="noopener" href="https://dwarfstd.org/doc/DWARF5.pdf">PDF</a> recording detailed specifications.</p>
<p>The article <a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information">How debuggers work: Part 3 - Debugging information</a> uses actual code, combined with objdump and readelf tools, to delve into the DWARF debugging information format, which is worth reading.</p>
<p>For C++ projects, to generate binary files containing DWARF debugging information during compilation, compiler compilation options need to be used. For GCC and Clang compilers, this is usually done using the <code>-g</code> flag. Here’s a simple example code:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dwarf.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>In the generated ELF binary file, we can use objdump’s <code>[-h|--section-headers|--headers]</code> option to print all section headers. If compiled with <code>-g</code>, the generated file contains DWARF debugging information, mainly with sections like <code>debug_aranges</code>, <code>.debug_info</code>, etc. Without the <code>-g</code> option, the generated binary file does not have these sections.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_dwarf.png/webp" alt="ELF Sections with DWARF Debugging Information" srcset="https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_dwarf.png/webp 2190w, https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_dwarf.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_dwarf.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_dwarf.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2190" height="886"></p>
<p>If the binary ELF file carries DWARF information, when debugging with GDB, you can set function line breakpoints, step through code, check variable values, and view function call stacks, etc. In addition, traditional performance analysis tools like perf can also read DWARF information to parse function call stacks, as shown in the following command:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">perf record --call-graph dwarf ./my_program</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Parsing-Stack-with-Frame-Pointer"><a href="#Parsing-Stack-with-Frame-Pointer" class="headerlink" title="Parsing Stack with Frame Pointer"></a>Parsing Stack with Frame Pointer</h3><p>Although DWARF information is very useful for debugging, eBPF-based tools cannot read stack information from DWARF. In eBPF, another method is used to read stack information, which is the frame pointer. Frame pointers can provide us with complete stack traces. Frame pointers are perf’s default stack traversal and currently the only stack traversal technology supported by bcc-tools or bpftrace.</p>
<p>To retain frame pointers in the generated binary file, ensure that frame pointers are enabled when compiling the program. This can be done using compiler flags, such as <code>-fno-omit-frame-pointer</code> in GCC. Here’s a simple example code:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fp_demo_write.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionA</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">"Inside functionA\n"</span>;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, message, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// The function call stack of cout is not in main;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "Inside functionA" &lt;&lt; std::endl;</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionB</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">functionA</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">"Inside functionB\n"</span>;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, message, <span class="number">16</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionC</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">functionB</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">"Inside functionC\n"</span>;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, message, <span class="number">16</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="built_in">functionC</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>After compiling with <code>-fno-omit-frame-pointer</code>, we can use profile to get the function call stack of CPU time consumption, and then use FlameGraph to get the CPU flame graph.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ fp_demo_write.cpp -fno-omit-frame-pointer -o fp_demo_write</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">profile -F 999 -U -f --pid $(pgrep fp_demo_write)  60 &gt; fp_demo_write.stack</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">../FlameGraph/flamegraph.pl fp_demo_write.stack &gt; fp_demo_write.svg</span></span><br></pre></td></tr></tbody></table></figure>

<p>Here’s the CPU flame graph, which shows the overall function call chain and the time consumption of various operations:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_fp_demo_write.svg" alt="Complete Function Stack with fno-omit-frame-pointer"></p>
<p>In the example function above, we used <code>write(STDOUT_FILENO, message, 16);</code> to print strings. Initially, we used C++’s <code>std::cout</code> to print, but the CPU flame graph was a bit different from expected. We can see that at the same level as <code>__libc_start_call_main</code>, there’s an unknown function frame, and within it are the <code>write</code> and <code>std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::~basic_ostream()</code> functions.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_fp_demo_cout.svg" alt="Function Stack with Unknown Part when Using cout"></p>
<p>Theoretically, all functions here should be in the function stack of main, but now there’s a parallel <code>unknown</code> call stack. This might be related to the internal workings and buffering mechanism of the C++ standard library glibc. When using <code>std::cout</code> to write data, the data is not immediately written to standard output, but stored in an internal buffer until the buffer is full or explicitly flushed. The output here is controlled by glibc, so the call stack is not in main.</p>
<p>If you want to verify whether our binary file has frame pointer information, we can use <code>objdump</code> to get the disassembled content, and then check if the starting instruction of the function is <code>push %rbp; mov %rsp,%rbp</code>. For the previous example, we can see the disassembled result as follows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_rbp.png/webp" alt="Verifying Frame Pointer rbp in Binary Assembly" srcset="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_rbp.png/webp 2230w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_rbp.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_rbp.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_rbp.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2230" height="886"></p>
<p>In the GCC/G++ compiler, whether the <code>-fno-omit-frame-pointer</code> option is used by default depends on the version of the compiler and the target architecture. On some versions and/or architectures, frame pointers may be retained by default. If frame pointers are not retained, the generated binary assembly code will not have the relevant rbp parts. On my machine, the default compilation also has frame pointers. After enabling compilation optimization with <code>-O2</code>, the generated binary does not have frame pointers, as shown below:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_no_rbp.png/webp" alt="No Frame Pointer rbp in Binary Assembly" srcset="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_no_rbp.png/webp 2320w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_no_rbp.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_no_rbp.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_no_rbp.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2320" height="636"></p>
<p>If we use <code>profile</code> to analyze again, we won’t be able to get complete function call stack information, as shown in the following figure:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_fp_demo_write_no.svg" alt="Failed to Get Function Stack Without Frame Pointers"></p>
<p>In actual project development, it is recommended to add <code>-fno-omit-frame-pointer</code> to the default compilation options to facilitate subsequent analysis. On the wiki of the Linux distribution Fedora, you can see that someone has proposed to enable <a target="_blank" rel="noopener" href="https://fedoraproject.org/wiki/Changes/fno-omit-frame-pointer">Changes/fno-omit-frame-pointer</a> by default, listing the benefits of doing so and the possible performance losses.</p>
<h2 id="Compilation-of-Complex-C-Projects"><a href="#Compilation-of-Complex-C-Projects" class="headerlink" title="Compilation of Complex C++ Projects"></a>Compilation of Complex C++ Projects</h2><p>In the examples above, we’re compiling a simple cpp file. For actual projects, there might be many cpp files and various complex third-party library dependencies. How to ensure that the finally compiled binary file retains complete stack information becomes challenging. Next, we’ll focus on how the compilation option <code>-fno-omit-frame-pointer</code> affects the final generated binary file for projects with complex third-party dependencies.</p>
<h3 id="Dynamic-Linking-and-Static-Linking"><a href="#Dynamic-Linking-and-Static-Linking" class="headerlink" title="Dynamic Linking and Static Linking"></a>Dynamic Linking and Static Linking</h3><p>C++ projects have two ways of linking third-party libraries: static linking and dynamic linking. Static linking merges the code of all library files into a single executable file at compile time, meaning the executable file contains all the code it needs and doesn’t depend on external library files. Unlike static linking, dynamic linking doesn’t merge library code into the executable file. Instead, it dynamically loads libraries at runtime, meaning the executable file only contains references to libraries, not the actual library code.</p>
<p>Here are some characteristics of static linking and dynamic linking:</p>
<table>
<thead>
<tr>
<th>Characteristic</th>
<th>Static Linking</th>
<th>Dynamic Linking</th>
</tr>
</thead>
<tbody><tr>
<td>Deployment difficulty</td>
<td>Simple, only one file needs to be distributed</td>
<td>More complex, need to ensure the executable can find dependent libraries</td>
</tr>
<tr>
<td>Startup time</td>
<td>Usually faster, as there’s no additional loading overhead</td>
<td>May be slower, as libraries need to be loaded at runtime</td>
</tr>
<tr>
<td>File size</td>
<td>Usually larger, as it includes code for all dependencies</td>
<td>Usually smaller, as it only includes references to libraries</td>
</tr>
<tr>
<td>Memory usage</td>
<td>Usually higher, each instance has its own copy of the library</td>
<td>Usually lower, multiple instances can share the same library memory</td>
</tr>
<tr>
<td>Compatibility</td>
<td>Can better control versions, as libraries are embedded and not affected by external library updates</td>
<td>May face compatibility issues if external libraries update and are not backward compatible</td>
</tr>
</tbody></table>
<p>For a large C++ project, the specific choice of linking method may depend on the team’s trade-offs. Overall, all possible dependency relationships between project modules can be categorized into several situations as shown in the following figure:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_depend.svg" alt="Dependency Relationships in C++ Projects"></p>
<p>The image is rendered by <a target="_blank" rel="noopener" href="https://graphviz.org/">Graphviz</a>, with the image source code as follows:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    // Set the layout direction of the graph from left to right</span><br><span class="line">    // rankdir=LR;</span><br><span class="line">    </span><br><span class="line">    // Set the shape and style of nodes</span><br><span class="line">    node [shape=box, style=filled, color=lightblue];</span><br><span class="line">    </span><br><span class="line">    // Set the style of edges</span><br><span class="line">    edge [color=blue, fontcolor=black];</span><br><span class="line">    </span><br><span class="line">    // Define nodes and edges</span><br><span class="line">    main -&gt; static_X;</span><br><span class="line">    main -&gt; static_A;</span><br><span class="line">    main -&gt; dynalic_Y;</span><br><span class="line">    main -&gt; dynalic_B;</span><br><span class="line">    main -&gt; utils_cpp;</span><br><span class="line">    </span><br><span class="line">    static_X -&gt; static_X1;</span><br><span class="line">    static_A -&gt; dynalic_A1;</span><br><span class="line">    dynalic_Y -&gt; dynalic_Y1;</span><br><span class="line">    dynalic_B -&gt; static_B1;</span><br><span class="line">    </span><br><span class="line">    // Set rank to make related nodes on the same level</span><br><span class="line">    {rank=same; static_X; static_A; dynalic_Y; dynalic_B;utils_cpp}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Among these, the most common dependency methods are <strong>static libraries depending on other static libraries, and dynamic libraries depending on other dynamic libraries</strong>. The following analysis will be based on these two dependency relationships. It is feasible for dynamic library A to depend on static library B, and in some cases, it makes sense. For example, if static library B contains some code that doesn’t change frequently, while dynamic library A contains some code that is frequently updated. It is not recommended to depend on dynamic library A in static library B, because static libraries are usually viewed as independent code blocks that do not depend on external dynamic linking.</p>
<h3 id="Stack-in-Static-Linking"><a href="#Stack-in-Static-Linking" class="headerlink" title="Stack in Static Linking"></a>Stack in Static Linking</h3><p>Next, we’ll analyze what impact it will have in the case of static linking if some intermediate third-party dependencies are not compiled with the <code>-fno-omit-frame-pointer</code> option.</p>
<p>Suppose a main.cpp depends on utils.cpp and static library static_A, static library static_A depends on static library static_B, and static_A is compiled without -fno-omit-frame-pointer, but all others are compiled with -fno-omit-frame-pointer. In the final generated binary file, will the functions in each static library and cpp file have frame pointers? In this case, can eBPF and BCC tools parse out stack information to the maximum extent?</p>
<p>We create a complete example project locally, including all the dependency relationships mentioned above. The code structure is as follows, with the complete code available on <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/f4943c0a09fe8b333df64f2098eeed16">Gist</a>:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">FP_static_demo tree</span></span><br><span class="line">.</span><br><span class="line">├── main.cpp</span><br><span class="line">├── Makefile</span><br><span class="line">├── static_A</span><br><span class="line">│   ├── static_A.cpp</span><br><span class="line">│   └── static_A.h</span><br><span class="line">└── static_B</span><br><span class="line">    ├── static_B.cpp</span><br><span class="line">    └── static_B.h</span><br><span class="line">├── utils.cpp</span><br><span class="line">└── utils.h</span><br></pre></td></tr></tbody></table></figure>

<p>Then in the compiled binary file, we find that the functions in static_A don’t have frame pointers, but static_B and other functions do have frame pointers. After running the binary, we use the eBPF profile command to analyze the CPU time stack, with the following command:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">profile -F 999 -U -f --pid $(pgrep main)  60 &gt; depend_main.stack</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./FlameGraph/flamegraph.pl depend_main.stack &gt; depend_main.svg</span></span><br></pre></td></tr></tbody></table></figure>

<p>In the generated CPU flame graph, the function call stack obtained is jumbled, as shown in the following figure:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_depend_main.svg" alt="Frame Pointers Lost in Intermediate Static Library"></p>
<p>Normally, if no frame pointers are lost, the flame graph should look like this:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_depend_main_fp.svg" alt="No Frame Pointers Lost Overall"></p>
<p>Through the above experiment, we can see that the profile tool relies on frame pointers to reconstruct the call stack when analyzing performance. Even if <strong>only the frame pointers of some intermediate dependent libraries are lost</strong>, the overall function call stack becomes jumbled, not just losing the function call stack of this intermediate part.</p>
<p>Still in the above scenario, if we <strong>don’t save stack information when compiling the bottom-most static_B</strong>, but all other parts do save it, then in the generated binary file, only the functions in static_B don’t have frame pointers. Using profile to analyze the CPU stack again, we find that although only the last layer of function calls doesn’t have frame pointers, the stack information obtained by BCC tools is still problematic, as shown in the following figure, where <code>printStaticA</code> and <code>function_entry</code> are mixed at the same level. Running multiple times here might result in different stack information graphs, but they are all incorrect.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_depend_main_error.svg" alt="Frame Pointers Not Lost Overall"></p>
<h3 id="Stack-in-Dynamic-Linking"><a href="#Stack-in-Dynamic-Linking" class="headerlink" title="Stack in Dynamic Linking"></a>Stack in Dynamic Linking</h3><p>In the case of dynamic linking, if some intermediate third-party dependencies are not compiled with the <code>-fno-omit-frame-pointer</code> option, theoretically, it should be the same as static linking, where stack information becomes jumbled. However, let’s write an example to verify this. We’ll use the same main.cpp and function call relationships as above, changing all static dependencies to dynamic dependencies. The revised directory structure is as follows:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── dynamic_A</span><br><span class="line">│   ├── dynamic_A.cpp</span><br><span class="line">│   └── dynamic_A.h</span><br><span class="line">├── dynamic_B</span><br><span class="line">│   ├── dynamic_B.cpp</span><br><span class="line">│   └── dynamic_B.h</span><br><span class="line">├── main.cpp</span><br><span class="line">├── Makefile</span><br><span class="line">├── utils.cpp</span><br><span class="line">└── utils.h</span><br></pre></td></tr></tbody></table></figure>

<p>The complete code is still available on <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/e790432ec050646ec3c307b03c6a6784">Gist</a>. The normal stack looks like this:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231017_c++_frame_pointer_dynamic_normal.svg" alt="Flame Graph with Normal Stack in Dynamic Linking"></p>
<p>Modify the Makefile to ignore the stack only when compiling dynamic_A, and the resulting CPU flame graph is as follows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231017_c++_frame_pointer_dynamic_lack_A.svg" alt="Flame Graph Missing Dynamic Library A"></p>
<p>Modify the Makefile to ignore the stack only when compiling dynamic_B, and the resulting CPU flame graph is as follows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231017_c++_frame_pointer_dynamic_lack_B.svg" alt="Flame Graph Missing Dynamic Library B"></p>
<p>Consistent with our earlier guess, once some stack information is lost, the analyzed stack graph becomes jumbled.</p>
<h2 id="Reference-Articles"><a href="#Reference-Articles" class="headerlink" title="Reference Articles"></a>Reference Articles</h2><p><a target="_blank" rel="noopener" href="https://medium.com/coccoc-engineering-blog/things-you-should-know-to-begin-playing-with-linux-tracing-tools-part-i-x-225aae1aaf13">Practical Linux tracing ( Part 1/5) : symbols, debug symbols and stack unwinding</a><br><a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information">How debuggers work: Part 3 - Debugging information</a><br><a target="_blank" rel="noopener" href="https://zhu45.org/posts/2017/Jul/30/understanding-how-function-call-works/">Understanding how function call works</a><br><a target="_blank" rel="noopener" href="https://kuafu1994.github.io/HackWithGDB/ASM.html">Hacking With GDB</a></p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/ChatGPT/"><i class="fa fa-tag"></i>ChatGPT</a><a href="/tags/eBPF/"><i class="fa fa-tag"></i>eBPF</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2023/10/17/c++_frame_pointer/';
    this.page.identifier = 'en/2023/10/17/c++_frame_pointer/';
    this.page.title = 'Stack Preservation in Complex C++ Projects and eBPF Performance Analysis';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (18)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (14)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2023/10/17/c++_frame_pointer/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/06/10/leveldb_mvcc_intro/" title="LevelDB Explained - Understanding Multi-Version Concurrency Control (MVCC)">LevelDB Explained - Understanding Multi-Version Concurrency Control (MVCC)</a></li><li><a href="/en/2025/05/23/mcp_user_report/" title="In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?">In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?</a></li><li><a href="/en/2025/01/24/leveldb_source_writedb/" title="LevelDB Explained - Implementation and Optimization Details of Key-Value Writing">LevelDB Explained - Implementation and Optimization Details of Key-Value Writing</a></li><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Program-Stack-Information"><span class="toc-number">1.</span> <span class="toc-text">Program Stack Information</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack-Information-in-DWARF-Format"><span class="toc-number">1.1.</span> <span class="toc-text">Stack Information in DWARF Format</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parsing-Stack-with-Frame-Pointer"><span class="toc-number">1.2.</span> <span class="toc-text">Parsing Stack with Frame Pointer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Compilation-of-Complex-C-Projects"><span class="toc-number">2.</span> <span class="toc-text">Compilation of Complex C++ Projects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic-Linking-and-Static-Linking"><span class="toc-number">2.1.</span> <span class="toc-text">Dynamic Linking and Static Linking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack-in-Static-Linking"><span class="toc-number">2.2.</span> <span class="toc-text">Stack in Static Linking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack-in-Dynamic-Linking"><span class="toc-number">2.3.</span> <span class="toc-text">Stack in Dynamic Linking</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-Articles"><span class="toc-number">3.</span> <span class="toc-text">Reference Articles</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>