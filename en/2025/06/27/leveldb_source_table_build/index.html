<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="A deep dive into the creation process and internal structure of SSTable files in LevelDB. This article takes a problem-driven approach to analyze how SSTable achieves high read/write performance through mechanisms like block storage, index optimization, and filters. It focuses on the implementation details of the TableBuilder class, including the construction of DataBlocks, IndexBlocks, and FilterBlocks, as well as engineering techniques like index key optimization and compression strategies. Through source code analysis, it demonstrates how LevelDB solves key problems in large-scale data storage, quickly locating data blocks, reducing unnecessary disk I/O, and balancing storage space with query efficiency. With concrete code examples and flowcharts, the article helps readers deeply understand the ingenious design of the SSTable file format and the core implementation principles of LevelDB as a high-performance key-value storage engine."><title>LevelDB Explained - A Step by Step Guide to SSTable Build</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB Explained - A Step by Step Guide to SSTable Build</h1><div class="post-meta">2025/06/27<span> | </span><span class="category"><a href="/categories/Source-Code-Analysis/">Source Code Analysis</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2025/06/27/leveldb_source_table_build/" href="/en/2025/06/27/leveldb_source_table_build/#disqus_thread"></a><div class="post-content"><p>In LevelDB, when the key-value pairs in the in-memory table (MemTable) reach a certain size, they are flushed to disk as an SSTable file. The disk files are also layered, with each layer containing multiple SSTable files. During runtime, LevelDB will merge and reorganize SSTable files at appropriate times, continuously compacting data into lower layers.</p>
<p>SSTable has a specific format for organizing data, aiming to ensure data is sorted and can be looked up quickly. So, how does SSTable store these key-value pairs internally, and how does it improve read and write performance? What are the optimization points in the implementation of the entire SSTable file?</p>
<p>In this article, we will carefully analyze the creation process of SSTable files, breaking it down step by step to see how it’s implemented. Before we begin, here’s a high-level diagram to give you a general idea.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total_en.webp/webp" alt="Overview of SSTable file building steps" srcset="https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total_en.webp/webp 3840w, https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total_en.webp/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total_en.webp/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total_en.webp/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3840" height="1281"></p>
<span id="more"></span>

<h2 id="The-Rationale-Behind-SSTable-File-Format-Design"><a href="#The-Rationale-Behind-SSTable-File-Format-Design" class="headerlink" title="The Rationale Behind SSTable File Format Design"></a>The Rationale Behind SSTable File Format Design</h2><p>Before we start, we need to understand a key question: <strong><span style="color: red;">How should a file format be designed to balance efficient writes and fast reads?</span></strong> Let’s start with a few fundamental questions to deduce how the author designed the data format.</p>
<h3 id="Question-1-How-should-key-value-pairs-be-stored"><a href="#Question-1-How-should-key-value-pairs-be-stored" class="headerlink" title="Question 1: How should key-value pairs be stored?"></a>Question 1: How should key-value pairs be stored?</h3><p>First, the core data, the user’s key-value pairs, needs a place to be stored. The simplest method is to put all key-value pairs sequentially into one large SSTable file. What’s the problem with this? First, when reading, if you want to find a specific key, you have to scan the entire large file. Second, during writes, if every key-value pair addition triggers a disk write, the write I/O pressure would be huge, and throughput would suffer.</p>
<p>Since a single large file is not ideal, let’s break it into blocks. The “divide and conquer” principle from computer science is well-reflected in LevelDB. We can split the large file into different data blocks and store key-value pairs at the block granularity. Each block is about 4KB by default. When a block is full, it’s written to the file as a whole, and then we start writing to the next one. Writing in larger chunks reduces a lot of disk I/O.</p>
<p>Let me add one more point here. Block-based storage not only reduces the number of disk write I/Os but also works in conjunction with…</p>
<p>However, the lookup problem isn’t solved yet. We still have to iterate through all the blocks to find a key.</p>
<p>If we could quickly locate which DataBlock a key is in, we would only need to scan a single block, which would greatly improve efficiency.</p>
<h3 id="Question-2-How-to-quickly-locate-a-specific-Data-Block"><a href="#Question-2-How-to-quickly-locate-a-specific-Data-Block" class="headerlink" title="Question 2: How to quickly locate a specific Data Block?"></a>Question 2: How to quickly locate a specific Data Block?</h3><p>To solve this problem, we need a “directory.” In computer science, this is called an index, and thus the Index Block was born. This block stores a series of index entries, each pointing to a Data Block. With this record, we can quickly determine which DataBlock a key belongs to.</p>
<p>This way, when looking up a key, we can perform a binary search in the Index Block to quickly locate the DataBlock where the key might be. Since the Index Block only contains index data, it’s much smaller and can usually be loaded into memory, making lookups much faster.</p>
<p>With the Index Block, we’ve transformed a full file scan into a “look up the index -&gt; read a specific small block” operation, greatly improving efficiency. We’ll ignore the specific design of the index for now and analyze it in detail later.</p>
<h3 id="Question-3-How-to-avoid-unnecessary-disk-reads"><a href="#Question-3-How-to-avoid-unnecessary-disk-reads" class="headerlink" title="Question 3: How to avoid unnecessary disk reads?"></a>Question 3: How to avoid unnecessary disk reads?</h3><p>With the Index Block, we can find the block where a key <em>might</em> be, but it’s not 100% certain. Why? Because the Index Block only records key ranges, it doesn’t guarantee the key is definitely within that range. This will become clearer when we look at the code. This leads to a problem: what if we excitedly read a Data Block from disk into memory, only to find that the key we’re looking for doesn’t exist? That’s a wasted, precious disk I/O. This waste can be significant, especially in scenarios with many lookups for non-existent keys.</p>
<p>Computer science has long had a solution for this kind of existence check: the Bloom filter. A Bloom filter is a combination of a bit array and hash functions that can quickly determine if an element is in a set. A previous article in this series, <a href="https://selfboot.cn/en/2024/08/08/leveldb_source_bloom_filter/">LevelDB Explained - Bloom Filter Implementation and Visualization</a>, provides a detailed introduction to the principles and implementation of Bloom filters.</p>
<p>LevelDB uses a similar approach. It supports an optional Filter Block. Before reading a Data Block, we can first check the Filter Block to see if the key exists. If it says the key is not present, we can return immediately. If it says the key might be present, we then proceed to read the Data Block for confirmation. This approach significantly reduces unnecessary queries for non-existent keys.</p>
<p>This all sounds great, but wait, there’s another problem. How do we know where the Index Block and Filter Block are located within the SSTable file?</p>
<h3 id="Question-4-How-to-locate-the-Index-and-Filter-Blocks"><a href="#Question-4-How-to-locate-the-Index-and-Filter-Blocks" class="headerlink" title="Question 4: How to locate the Index and Filter Blocks?"></a>Question 4: How to locate the Index and Filter Blocks?</h3><p>So now we have many data blocks, an Index Block, and a Filter Block. Another question arises: when we open an SSTable file, how do we know the locations of the Index Block and Filter Block?</p>
<p>The most straightforward idea is to place this metadata at a <strong>fixed offset in the file</strong>. However, if we put it at the beginning of the file, any change to this metadata would require moving the entire file’s data, which is obviously not acceptable.</p>
<p>What about putting it at the end of the file? That seems feasible, and it’s how LevelDB is designed. At the end of the file, there’s a fixed-size 48-byte Footer area. It records the offset of the Index Block and another block we haven’t mentioned, the Meta-Index Block.</p>
<p>Logically, the Footer could just store the locations of the Index Block and Filter Block. Why introduce a Meta-Index Block? The author mentioned in the code comments that it’s for extensibility. The Footer has a fixed size and cannot be expanded to include more information. What if future versions need more types of metadata blocks, like statistics blocks?</p>
<p>So the author added an index for metadata—the Meta-Index Block. This block acts as a directory for metadata. Its keys are the names of the metadata (e.g., “filter.leveldb.BuiltinBloomFilter2”), and its values are the offsets of the corresponding metadata blocks (like the Filter Block). Currently, it only contains filter block information, but it can be extended to include any number of metadata blocks in the future.</p>
<p>This ties the whole lookup process together. First, we read the fixed 48 bytes from the end of the file. From there, we parse the offsets of the Index Block and the Meta-Index Block. Then, from the Meta-Index Block, we get the offset of the Filter Block. Finally, we read the content of the Filter Block based on its offset. With the Index Block and Filter Block, we can quickly and efficiently “follow the map” to find key-value pairs.</p>
<h3 id="The-Answer-SSTable-Structure-Diagram"><a href="#The-Answer-SSTable-Structure-Diagram" class="headerlink" title="The Answer: SSTable Structure Diagram"></a>The Answer: SSTable Structure Diagram</h3><p>Now that we’ve analyzed how data blocks are organized in an SSTable, here’s a simple ASCII diagram to describe the various blocks in an SSTable for better understanding:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+</span><br><span class="line">|   Data Block 0    |</span><br><span class="line">+-------------------+</span><br><span class="line">|   Data Block 1    |</span><br><span class="line">+-------------------+</span><br><span class="line">|       ...         |</span><br><span class="line">+-------------------+</span><br><span class="line">|   Data Block N    |</span><br><span class="line">+-------------------+</span><br><span class="line">|   Filter Block    |  (optional) &lt;-- Indexed by Meta-Index Block</span><br><span class="line">+-------------------+</span><br><span class="line">| Meta Index Block  | &lt;-- Indexed by Footer</span><br><span class="line">+-------------------+</span><br><span class="line">|   Index Block     | &lt;-- Indexed by Footer</span><br><span class="line">+-------------------+</span><br><span class="line">|      Footer       | (Fixed size at the end of the file)</span><br><span class="line">+-------------------+</span><br></pre></td></tr></tbody></table></figure>

<p>However, providing the interface and saving key-value pairs in the above format involves many engineering details. By the way, <strong><span style="color: red;">the layered abstraction in LevelDB’s code is really well done, with one layer wrapping another, making the complex logic easy to understand and maintain</span></strong>. For example, how each block builds its data is encapsulated in a separate implementation, which I will detail in other articles.</p>
<p>In this article, we’ll focus on the engineering details of the SSTable file construction process. This part is implemented in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/table/table_builder.cc">table/table_builder.cc</a>, mainly in the TableBuilder class.</p>
<p>This class has only one private member variable, a Rep* pointer, which stores various state information, such as the current DataBlock, IndexBlock, etc. The <code>Rep*</code> uses the Pimpl design pattern. You can learn more about Pimpl in this series’ article <a href="https://selfboot.cn/en/2024/08/13/leveldb_source_unstand_c++/#Pimpl-Class-Design">LevelDB Explained - Understanding Advanced C++ Techniques</a>.</p>
<p>The most important interface of this class is Add, which in turn calls other encapsulated functions to complete the addition of key-value pairs. Let’s start with this interface to analyze the implementation of the TableBuilder class.</p>
<h2 id="Add-Adding-Key-Value-Pairs"><a href="#Add-Adding-Key-Value-Pairs" class="headerlink" title="Add: Adding Key-Value Pairs"></a>Add: Adding Key-Value Pairs</h2><p>The <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/table/table_builder.cc#L94">TableBuilder::Add</a> method is the core function for adding key-value pairs to an SSTable file. Adding a key-value pair requires modifying the various blocks mentioned above, such as the DataBlock, IndexBlock, and FilterBlock. To improve efficiency, there are many engineering optimization details. To better understand it, I’ve divided it into four main parts, which I’ll discuss one by one.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>{</span><br><span class="line">  <span class="comment">// 1. Pre-checks</span></span><br><span class="line">  <span class="comment">// 2. Handle index block</span></span><br><span class="line">  <span class="comment">// 3. Handle filter block</span></span><br><span class="line">  <span class="comment">// 4. Handle data block</span></span><br><span class="line">  <span class="comment">// 5. Flush to disk at the right time</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Pre-checks"><a href="#Pre-checks" class="headerlink" title="Pre-checks"></a>Pre-checks</h3><p>In the <code>Add</code> method, the first step is to read the data from <code>rep_</code> and perform some pre-checks, such as verifying that the file has not been closed and ensuring that the key-value pairs are in order.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rep* r = rep_;</span><br><span class="line"><span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (r-&gt;num_entries &gt; <span class="number">0</span>) {</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;options.comparator-&gt;<span class="built_in">Compare</span>(key, <span class="built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>LevelDB includes <strong><span style="color: red;">a lot of validation logic in its code to ensure that if there’s a problem, it fails early</span></strong>, a philosophy that is essential for a low-level library. The assert in the Add method here checks that subsequently inserted keys are always greater, which of course needs to be guaranteed by the caller. To implement this check, each TableBuilder’s Rep stores a last_key to record the last inserted key. This key is also used in index key optimization, which will be detailed later.</p>
<h3 id="Handling-Index-Records"><a href="#Handling-Index-Records" class="headerlink" title="Handling Index Records"></a>Handling Index Records</h3><p>Next, it adds a <strong>new index record at the appropriate time</strong>. We know that index records are used to quickly find the offset of the DataBlock where a key is located. Each complete DataBlock corresponds to one index record. Let’s first look at the <strong>timing of adding an index record</strong>. When a DataBlock is finished, <code>pending_index_entry</code> is set to true. Then, when the first key of the next new DataBlock is added, the index record for the previously completed DataBlock is updated.</p>
<p>Here is the core code for this part:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;pending_index_entry) {</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">  r-&gt;options.comparator-&gt;<span class="built_in">FindShortestSeparator</span>(&amp;r-&gt;last_key, key);</span><br><span class="line">  std::string handle_encoding;</span><br><span class="line">  r-&gt;pending_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">  r-&gt;index_block.<span class="built_in">Add</span>(r-&gt;last_key, <span class="built_in">Slice</span>(handle_encoding));</span><br><span class="line">  r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The reason for waiting until the first key of a new DataBlock is added to update the index block is <strong><span style="color: red;">to minimize the length of the index key as much as possible, thereby reducing the size of the index block</span></strong>. This is another engineering optimization detail in LevelDB.</p>
<p>Let me expand on the background to make it easier to understand. Each index record in an SSTable consists of a separator key and a BlockHandle (offset + size) pointing to a data block. The purpose of this separator key is to partition the key space of different DataBlocks. For the N-th data block (Block N), its index key separator_key_N must satisfy the following conditions:</p>
<ul>
<li>separator_key_N &gt;= any key in Block N</li>
<li>separator_key_N &lt; any key in Block N+1</li>
</ul>
<p>This way, when searching for a target key, if you find the first entry where separator_key_N &gt; target_key in the index block, then the target_key, if it exists, must be in the previous data block (Block N-1).</p>
<p>Intuitively, the simplest implementation of the index is to directly use the last key of Block N (last_key_N) as separator_key_N. But the problem is that last_key_N itself can be very long. This leads to long index entries, which in turn makes the entire index block large. <strong>The index block is usually loaded into memory, so the smaller the index block, the less memory it occupies, the higher the cache efficiency, and the faster the lookup speed.</strong></p>
<p>If we think about it, we don’t actually need a real key as the separating index key; we just need a “separator” that can separate the two blocks. This key only needs to satisfy last_key_N &lt;= separator_key &lt; first_key_N+1. LevelDB does just that. It calls options.comparator-&gt;FindShortestSeparator to <strong>find the shortest separator string between the last key of the previous block and the first key of the next block</strong>. The default implementation of FindShortestSeparator is in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/comparator.cc#L31C8-L31C29">util/comparator.cc</a>, which I won’t list here.</p>
<p>To better understand this optimization process, here’s a concrete example:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey_en.webp/webp" alt="SSTable DataBlock index separator key optimization" srcset="https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey_en.webp/webp 3840w, https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey_en.webp/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey_en.webp/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey_en.webp/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3840" height="1710"></p>
<p>Finally, let’s talk about the value of each index record here. It is the <strong>offset and size of the block within the file</strong>, which is recorded by pending_handle. When a DataBlock is written to the file via WriteRawBlock, the offset and size of pending_handle are updated. Then, when writing the index, EncodeTo is used to encode the offset and size into a string, which is inserted into the IndexBlock along with the preceding index key.</p>
<h3 id="Handling-Filter-Records"><a href="#Handling-Filter-Records" class="headerlink" title="Handling Filter Records"></a>Handling Filter Records</h3><p>Next is handling the FilterBlock. The index block we just discussed can only find the <strong>location of the block where the key should be</strong>. We still need to read the block’s content to know if the key actually exists. To quickly determine if a key is present, LevelDB supports a filter index block, which <strong>can quickly determine if a key exists in the current SSTable</strong>. If the filter index block is enabled, the index is added synchronously when a key is added. The core code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) {</span><br><span class="line">  r-&gt;filter_block-&gt;<span class="built_in">AddKey</span>(key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>After adding the key here, the index is only stored in memory. The FilterBlock is not written to the file until after TableBuilder has finished writing all the blocks. <strong>The FilterBlock itself is optional</strong>, and is set via options.filter_policy. When initializing TableBuilder::Rep, the FilterBlockBuilder pointer is initialized based on options.filter_policy, as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Rep</span>(<span class="type">const</span> Options&amp; opt, WritableFile* f)</span><br><span class="line">    : <span class="built_in">options</span>(opt),</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="built_in">filter_block</span>(opt.filter_policy == <span class="literal">nullptr</span></span><br><span class="line">                       ? <span class="literal">nullptr</span></span><br><span class="line">                       : <span class="keyword">new</span> <span class="built_in">FilterBlockBuilder</span>(opt.filter_policy)),</span><br><span class="line">      <span class="built_in">pending_index_entry</span>(<span class="literal">false</span>) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>It’s worth noting here that filter_block is a pointer mainly because, in addition to the default Bloom filter, you can also <strong>use your own filter through polymorphism</strong>. The object is created on the heap using new. To <strong>prevent memory leaks</strong>, the filter_block is deleted first in the TableBuilder destructor, followed by rep_.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TableBuilder::~<span class="built_in">TableBuilder</span>() {</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;closed);  <span class="comment">// Catch errors where caller forgot to call Finish()</span></span><br><span class="line">  <span class="keyword">delete</span> rep_-&gt;filter_block;</span><br><span class="line">  <span class="keyword">delete</span> rep_;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The reason rep_ needs to be deleted is because it was created on the heap in the TableBuilder constructor, as shown below:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TableBuilder::<span class="built_in">TableBuilder</span>(<span class="type">const</span> Options&amp; options, WritableFile* file)</span><br><span class="line">    : <span class="built_in">rep_</span>(<span class="keyword">new</span> <span class="built_in">Rep</span>(options, file)) {</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;filter_block != <span class="literal">nullptr</span>) {</span><br><span class="line">    rep_-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>For the implementation of LevelDB’s default Bloom filter, you can refer to <a href="/leveldb_source_filterblock">LevelDB Source Code Walkthrough: Bloom Filter Implementation</a>. I will write a separate article to detail the construction of the index block, so we won’t go into the details here.</p>
<h3 id="Handling-Data-Blocks"><a href="#Handling-Data-Blocks" class="headerlink" title="Handling Data Blocks"></a>Handling Data Blocks</h3><p>Next, the key-value pairs need to be added to the DataBlock. The DataBlock is where the actual key-value pairs are stored in the SSTable file. The code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">r-&gt;num_entries++;</span><br><span class="line">r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> estimated_block_size = r-&gt;data_block.<span class="built_in">CurrentSizeEstimate</span>();</span><br><span class="line"><span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) {</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, the Add method in BlockBuilder is called to add the key-value pair to the DataBlock. The implementation of BlockBuilder will be described in a separate article later. Haha, <strong>LevelDB’s layered abstraction is so well done here that our articles have to be layered as well</strong>. After each key-value pair is added, it checks if the current DataBlock size has exceeded block_size. If it has, the Flush method is called to write the DataBlock to the disk file. The block_size is set in options, with a default of 4KB. This is the size before key-value compression. If compression is enabled, the actual size written to the file will be smaller than block_size.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approximate size of user data packed per block.  Note that the</span></span><br><span class="line"><span class="comment">// block size specified here corresponds to uncompressed data.  The</span></span><br><span class="line"><span class="comment">// actual size of the unit read from disk may be smaller if</span></span><br><span class="line"><span class="comment">// compression is enabled.  This parameter can be changed dynamically.</span></span><br><span class="line"><span class="type">size_t</span> block_size = <span class="number">4</span> * <span class="number">1024</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>So how does Flush write to disk? Let’s continue.</p>
<h3 id="Flush-Writing-Data-Blocks"><a href="#Flush-Writing-Data-Blocks" class="headerlink" title="Flush: Writing Data Blocks"></a>Flush: Writing Data Blocks</h3><p>In the previous Add method, if a block’s size reaches 4KB, the Flush method is called to write it to the disk file. The implementation of Flush is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>{</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;pending_index_entry);</span><br><span class="line">  <span class="built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) {</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) {</span><br><span class="line">    r-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(r-&gt;offset);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The beginning part is just some pre-checks. Note that Flush is only for flushing the DataBlock part. If data_block is empty, it returns directly. Then it calls the WriteBlock method (detailed later) to write the DataBlock to the file, and then <strong>updates pending_index_entry to true, indicating that the index block needs to be updated when the next key is added</strong>.</p>
<p>Finally, it calls file-&gt;Flush() to have the system write the current in-memory data to disk. Note that this doesn’t guarantee that the data has been synchronized to the physical disk. The data might still be in the system cache, and if the operating system crashes, the unwritten data could be lost. For more details on file operations and flushing to disk, you can refer to this series’ article <a href="/2024/08/02/leveldb_source_env_posixfile/">LevelDB Source Code Walkthrough: Posix File Operation Interface Implementation Details</a>. If there is a filter_block, the StartBlock method also needs to be called. This method is also quite interesting and we will discuss it in detail when we specifically write about filter blocks.</p>
<h2 id="WriteBlock-Writing-to-a-File"><a href="#WriteBlock-Writing-to-a-File" class="headerlink" title="WriteBlock: Writing to a File"></a>WriteBlock: Writing to a File</h2><p>As mentioned above, Flush calls the WriteBlock method to write the DataBlock to the file. This method is also called by Finish, which we’ll discuss later, to write the index block, filter block, etc., at the end. The implementation of WriteBlock is relatively simple. It mainly handles the compression logic and then calls the actual file writing function WriteRawBlock to write the block content to the file.</p>
<p>Compression is not mandatory. If compression is enabled when calling LevelDB and the compression library is linked, the corresponding compression algorithm will be chosen to compress the Block. LevelDB also strikes a <strong>balance between compression performance and effectiveness. If the compression ratio is less than or equal to 0.85, the compressed data will be written to the file; otherwise, the original data will be written directly</strong>. The actual file writing part calls the WriteRawBlock method, with the main code as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="type">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 CompressionType type, BlockHandle* handle)</span> </span>{</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  handle-&gt;<span class="built_in">set_offset</span>(r-&gt;offset);</span><br><span class="line">  handle-&gt;<span class="built_in">set_size</span>(block_contents.<span class="built_in">size</span>());</span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(block_contents);</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>()) {</span><br><span class="line">    <span class="type">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;</span><br><span class="line">    <span class="type">uint32_t</span> crc = crc32c::<span class="built_in">Value</span>(block_contents.<span class="built_in">data</span>(), block_contents.<span class="built_in">size</span>());</span><br><span class="line">    crc = crc32c::<span class="built_in">Extend</span>(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></span><br><span class="line">    <span class="built_in">EncodeFixed32</span>(trailer + <span class="number">1</span>, crc32c::<span class="built_in">Mask</span>(crc));</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>()) {</span><br><span class="line">      r-&gt;offset += block_contents.<span class="built_in">size</span>() + kBlockTrailerSize;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, a 5-byte trailer is placed at the end of each block to verify data integrity. The first byte is the compression type; currently, the supported compression algorithms are Snappy and Zstd. The next 4 bytes are the CRC32 checksum. <code>crc32c::Value</code> is used to calculate the checksum of the data block, and then the compression type is also included in the checksum calculation. For more details on the CRC32 part, you can refer to this series’ article <a href="/2024/08/29/leveldb_source_utils/">LevelDB Source Code Walkthrough: Memory Allocator, Random Number Generator, CRC32, Integer Encoding/Decoding</a>.</p>
<h2 id="Finish-Actively-Triggering-Disk-Flush"><a href="#Finish-Actively-Triggering-Disk-Flush" class="headerlink" title="Finish: Actively Triggering Disk Flush"></a>Finish: Actively Triggering Disk Flush</h2><p>All the operations above are mainly for continuously adding key-value pairs to the data block. If the DataBlock’s size limit is reached during this process, a flush of the DataBlock to disk is triggered. But the entire SSTable file also has an index block, a filter block, etc., which <strong>need to be actively triggered to be flushed to disk</strong>. So at what point is this triggered, and how is it flushed?</p>
<p>There are many occasions when an SSTable file is generated in LevelDB. Let’s take the flush triggered when saving an immutable MemTable as an example. When saving an immutable MemTable as an SSTable file, the process is as follows: first, iterate through the key-value pairs in the immutable MemTable, then call the Add method above to add them. The Add method will update the content of the relevant blocks. Whenever a DataBlock exceeds block_size, the Flush method is called to write the DataBlock to the file.</p>
<p>After all key-value pairs have been written, the Finish method is actively called to perform some <strong>finishing touches</strong>, such as writing the data of the last DataBlock to the file, and writing the IndexBlock, FilterBlock, etc.</p>
<p>The implementation of Finish is as follows. Before it begins, it first uses Flush to write the remaining DataBlock part to the disk file. Then it processes the other blocks and adds a fixed-size footer at the end of the file to record index information.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>{</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">  r-&gt;closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write filter block</span></span><br><span class="line">  <span class="comment">// Write metaindex block</span></span><br><span class="line">  <span class="comment">// Write index block</span></span><br><span class="line">  <span class="comment">// Write footer</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The way the various blocks are constructed here is also quite interesting. A builder is used to handle the content, while a handler is used to record the block’s offset and size. Let’s look at them separately.</p>
<h3 id="BlockBuilder-for-Block-Construction"><a href="#BlockBuilder-for-Block-Construction" class="headerlink" title="BlockBuilder for Block Construction"></a>BlockBuilder for Block Construction</h3><p>First, let’s consider a question: <strong>with so many types of blocks, does each block need its own Builder to assemble the data?</strong></p>
<p>To answer this, we need to look at the data structure of each block. The Data, Index, and MetaIndex Blocks all share the following common features:</p>
<ul>
<li><strong>Key-value structure</strong>: They all store data in a key-value format. Although the meaning of the keys and values in each block is different, they are all in a key-value format.</li>
<li><strong>Order requirement</strong>: The keys must be sorted because binary search or sequential scanning is required for lookups.</li>
</ul>
<p>Therefore, the construction logic for these three types of blocks is similar, and LevelDB uses the same BlockBuilder to handle them. The implementation is in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/table/block_builder.h">table/block_builder.h</a>, and it also has many optimization details. For example, prefix compression optimization saves space by storing only the different parts of similar keys. The restart point mechanism sets a restart point every few entries to support binary search. I will write a separate article to detail this later. After encapsulation, it’s quite simple to use. Taking the MetaIndex Block as an example, you use Add to add key-values and then WriteBlock to flush to disk. The code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) {</span><br><span class="line">      <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></span><br><span class="line">      std::string key = <span class="string">"filter."</span>;</span><br><span class="line">      key.<span class="built_in">append</span>(r-&gt;options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">      std::string handle_encoding;</span><br><span class="line">      filter_block_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">      meta_index_block.<span class="built_in">Add</span>(key, handle_encoding);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>On the other hand, the data structure of the filter block is different from the others. It stores the binary data of the Bloom filter, grouped by file offset, with one filter for every 2KB file range. Therefore, the construction logic of the filter block is different from the others and needs to be handled separately. The implementation is in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/table/filter_block.cc">table/filter_block.cc</a>, which I will analyze separately later. Its usage is quite simple, as shown below:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write filter block</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) {</span><br><span class="line">  <span class="built_in">WriteRawBlock</span>(r-&gt;filter_block-&gt;<span class="built_in">Finish</span>(), kNoCompression,</span><br><span class="line">                &amp;filter_block_handle);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, the Finish method returns the binary data of the filter block, and then the WriteRawBlock method is called to write the data to the file.</p>
<h3 id="BlockHandle-for-Recording-Offset-and-Size"><a href="#BlockHandle-for-Recording-Offset-and-Size" class="headerlink" title="BlockHandle for Recording Offset and Size"></a>BlockHandle for Recording Offset and Size</h3><p>The two builders above are used to construct the blocks, but the same handler class is used to record the offset and size of the blocks. The code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>The implementation of BlockHandle is in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/table/format.h#L23">table/format.h</a>. It mainly tells the system that there is a block of size Y bytes at position X bytes in the file, and that’s it. However, in conjunction with the handle information of different blocks, it can conveniently store the offset and size of different blocks.</p>
<p>At this point, we have used two builders to construct various index blocks, and at the same time, used one handler to assist in recording the offset and size of the blocks. This completes the construction of the entire block.</p>
<h2 id="Complete-Steps-for-Creating-an-SSTable-File"><a href="#Complete-Steps-for-Creating-an-SSTable-File" class="headerlink" title="Complete Steps for Creating an SSTable File"></a>Complete Steps for Creating an SSTable File</h2><p>Finally, let’s see how the upper-level caller uses TableBuilder to construct an SSTable file.</p>
<p>A function BuildTable is encapsulated in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/builder.cc#L17">db/builder.cc</a> to create an SSTable file, which is implemented by calling the interface of the TableBuilder class. Omitting other irrelevant code, the core code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BuildTable</span><span class="params">(<span class="type">const</span> std::string&amp; dbname, Env* env, <span class="type">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    TableBuilder* builder = <span class="keyword">new</span> <span class="built_in">TableBuilder</span>(options, file);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Slice key;</span><br><span class="line">    <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) {</span><br><span class="line">      key = iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      builder-&gt;<span class="built_in">Add</span>(key, iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Finish and check for builder errors</span></span><br><span class="line">    s = builder-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, an iterator iter is used to traverse the key-value pairs in the immutable MemTable, and then the Add method of TableBuilder is called to add the key-value pairs to the SSTable file. The size limit of the MemTable is 4MB by default (write_buffer_size = 4<em>1024</em>1024). When adding key-value pairs with TableBuilder, the data is divided into data blocks according to block_size (4*1024). Whenever a DataBlock is filled, the data of the corresponding block is assembled, and then appended to the SSTable file on disk using flush. Finally, the Finish method of TableBuilder is called to write other blocks and complete the writing of the entire SSTable file.</p>
<p>Besides BuildTable writing data from an immutable MemTable to a level-0 SSTable file, there is another scenario during the Compact process, where multiple SSTable files are merged into a single SSTable file. This process is implemented in the DoCompactionWork function in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L897">db/db_impl.cc</a>. The overall flow is slightly more complex and the calls are deeper. We will analyze it in detail when we talk about Compact later.</p>
<p>However, let’s just mention one point here. During the Compact process, the Abandon method of TableBuilder is called in some failure scenarios to abandon the current TableBuilder writing process.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compact-&gt;builder-&gt;<span class="built_in">Abandon</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>Abandon mainly sets the closed flag in the TableBuilder’s Rep to true. The caller will then discard this TableBuilder instance and will not use it for any write operations (there are a bunch of assertions to check this state during writing).</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Returning to the question we raised at the beginning, how should a file format be designed to balance efficient writes and fast reads? Through a deep analysis of LevelDB’s SSTable file creation process, we can see how the author solved this problem step by step. First, the SSTable data format design has several important design principles:</p>
<ol>
<li><strong>Block-based storage</strong>: Splitting large files into 4KB DataBlocks makes them easier to manage, reduces unnecessary disk I/O, and facilitates caching of hot data.</li>
<li><strong>Index acceleration</strong>: Using an IndexBlock turns a “full scan” into a “directory lookup + precise read,” reducing the number of disk I/O operations.</li>
<li><strong>Filter optimization</strong>: Using a FilterBlock at the source reduces unnecessary disk reads, improving read performance.</li>
<li><strong>Centralized metadata management</strong>: The design of the Footer + Meta-IndexBlock ensures extensibility, making it easy to add more metadata blocks in the future.</li>
</ol>
<p>In the implementation of TableBuilder, we also saw many engineering details worth learning from, such as:</p>
<ul>
<li><strong>Index key optimization</strong>: Delaying the update of the index until the next block starts, and generating the shortest separator key using the FindShortestSeparator algorithm, significantly reduces the size of the index block. This optimization may seem minor, but its effect is significant with large-scale data.</li>
<li><strong>Error handling</strong>: The large number of assert statements in the code reflects the “fail fast, fail early” philosophy, which is crucial for a low-level storage system.</li>
<li><strong>Layered abstraction</strong>: The layered design of TableBuilder → BlockBuilder → FilterBlockBuilder makes the construction of a complex file format organized and orderly. Each layer has a clear boundary of responsibility.</li>
<li><strong>Performance balance</strong>: The 0.85 compression ratio threshold in the compression strategy reflects a trade-off between performance and effectiveness.</li>
</ul>
<p>In fact, the design of SSTable answers several fundamental questions in storage systems. It uses sequential writes to ensure write throughput and an index structure to ensure read performance. It uses block-based storage, on-demand loading, and caching to handle massive amounts of data with limited memory. At the same time, it uses compression and filters to balance storage space and query efficiency, and layered metadata to ensure system extensibility. These are all classic designs that have been refined over many years in computer software systems and are worth learning from.</p>
<p>After understanding the creation process of an SSTable, you may have some new questions: How is data organized within a DataBlock? What is the process for reading an SSTable? How do multiple SSTable files work together?</p>
<p>The answers to these questions form the complete picture of the ingenious storage engine that is LevelDB. I will continue to analyze them in depth in future articles, so stay tuned.</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2025/06/27/leveldb_source_table_build/';
    this.page.identifier = 'en/2025/06/27/leveldb_source_table_build/';
    this.page.title = 'LevelDB Explained - A Step by Step Guide to SSTable Build';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (21)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (14)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2025/06/27/leveldb_source_table_build/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/06/27/leveldb_source_table_build/" title="LevelDB Explained - A Step by Step Guide to SSTable Build">LevelDB Explained - A Step by Step Guide to SSTable Build</a></li><li><a href="/en/2025/06/13/leveldb_source_LRU_cache/" title="LevelDB Explained - The Implementation Details of a High-Performance LRU Cache">LevelDB Explained - The Implementation Details of a High-Performance LRU Cache</a></li><li><a href="/en/2025/06/11/leveldb_source_memtable/" title="LevelDB Explained - The Implementation Details of MemTable">LevelDB Explained - The Implementation Details of MemTable</a></li><li><a href="/en/2025/06/10/leveldb_mvcc_intro/" title="LevelDB Explained - Understanding Multi-Version Concurrency Control (MVCC)">LevelDB Explained - Understanding Multi-Version Concurrency Control (MVCC)</a></li><li><a href="/en/2025/05/23/mcp_user_report/" title="In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?">In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?</a></li><li><a href="/en/2025/01/24/leveldb_source_writedb/" title="LevelDB Explained - Implementation and Optimization Details of Key-Value Writing">LevelDB Explained - Implementation and Optimization Details of Key-Value Writing</a></li><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Rationale-Behind-SSTable-File-Format-Design"><span class="toc-number">1.</span> <span class="toc-text">The Rationale Behind SSTable File Format Design</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-1-How-should-key-value-pairs-be-stored"><span class="toc-number">1.1.</span> <span class="toc-text">Question 1: How should key-value pairs be stored?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-2-How-to-quickly-locate-a-specific-Data-Block"><span class="toc-number">1.2.</span> <span class="toc-text">Question 2: How to quickly locate a specific Data Block?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-3-How-to-avoid-unnecessary-disk-reads"><span class="toc-number">1.3.</span> <span class="toc-text">Question 3: How to avoid unnecessary disk reads?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-4-How-to-locate-the-Index-and-Filter-Blocks"><span class="toc-number">1.4.</span> <span class="toc-text">Question 4: How to locate the Index and Filter Blocks?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Answer-SSTable-Structure-Diagram"><span class="toc-number">1.5.</span> <span class="toc-text">The Answer: SSTable Structure Diagram</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Add-Adding-Key-Value-Pairs"><span class="toc-number">2.</span> <span class="toc-text">Add: Adding Key-Value Pairs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pre-checks"><span class="toc-number">2.1.</span> <span class="toc-text">Pre-checks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-Index-Records"><span class="toc-number">2.2.</span> <span class="toc-text">Handling Index Records</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-Filter-Records"><span class="toc-number">2.3.</span> <span class="toc-text">Handling Filter Records</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-Data-Blocks"><span class="toc-number">2.4.</span> <span class="toc-text">Handling Data Blocks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flush-Writing-Data-Blocks"><span class="toc-number">2.5.</span> <span class="toc-text">Flush: Writing Data Blocks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WriteBlock-Writing-to-a-File"><span class="toc-number">3.</span> <span class="toc-text">WriteBlock: Writing to a File</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finish-Actively-Triggering-Disk-Flush"><span class="toc-number">4.</span> <span class="toc-text">Finish: Actively Triggering Disk Flush</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockBuilder-for-Block-Construction"><span class="toc-number">4.1.</span> <span class="toc-text">BlockBuilder for Block Construction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockHandle-for-Recording-Offset-and-Size"><span class="toc-number">4.2.</span> <span class="toc-text">BlockHandle for Recording Offset and Size</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Complete-Steps-for-Creating-an-SSTable-File"><span class="toc-number">5.</span> <span class="toc-text">Complete Steps for Creating an SSTable File</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">6.</span> <span class="toc-text">Summary</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p><p>Friend Link:<a rel="dofollow" target="_blank" href="https://puzzles-game.com/">Puzzle Games</a></p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>