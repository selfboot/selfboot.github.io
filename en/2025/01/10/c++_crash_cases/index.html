<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article analyzes 5 common types of process crashes in C++ development, including uncaught exceptions, array bounds violations, iterator invalidation, concurrent data races, and stack overflow issues. Through real-world code examples, it explains the root causes, debugging methods, and solutions for each problem. The article also covers how to analyze coredump issues using tools like GDB and Valgrind, serving as a practical C++ reference guide."><title>5 Real-world Cases of C++ Process Crashes from Production</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">5 Real-world Cases of C++ Process Crashes from Production</h1><div class="post-meta">2025/01/10<span> | </span><span class="category"><a href="/categories/Programming/">Programming</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2025/01/10/c++_crash_cases/" href="/en/2025/01/10/c++_crash_cases/#disqus_thread"></a><div class="post-content"><p>If you’ve worked on any non-trivial C++ project, you’ve likely encountered process coredumps. A coredump is a mechanism where the operating system records the current memory state of a program when it encounters a severe error during execution.</p>
<p>There are many reasons why a C++ process might coredump, including:</p>
<ol>
<li><strong>Illegal Memory Access</strong>: This includes dereferencing null pointers, accessing freed memory, array bounds violations, etc.</li>
<li><strong>Stack Overflow</strong>: Caused by infinite recursion or large arrays allocated on the stack</li>
<li><strong>Segmentation Fault</strong>: Attempting to write to read-only memory or accessing unmapped memory regions</li>
<li><strong>Uncaught Exceptions</strong>: Program termination due to unhandled exceptions</li>
</ol>
<p>When encountering a coredump, we typically need to examine the core file for problem analysis and debugging. Analyzing core files can be challenging as it requires a deep understanding of C++’s memory model, exception handling mechanisms, and system calls.</p>
<p>Rather than focusing on core file analysis methods, this article will present several real-world cases to help developers proactively avoid these errors in their code.</p>
<span id="more"></span>

<h2 id="Uncaught-Exceptions"><a href="#Uncaught-Exceptions" class="headerlink" title="Uncaught Exceptions"></a>Uncaught Exceptions</h2><p>One of the most common causes of process crashes in production code is throwing exceptions without proper catch handlers. For example, when using <a target="_blank" rel="noopener" href="https://cplusplus.com/reference/string/stoi/">std::stoi</a> to convert a string to an integer, if the string cannot be converted to a number, it throws a <code>std::invalid_argument</code> exception. If neither the framework nor the caller catches this exception, the process will crash.</p>
<p>The C++ standard library has quite a few functions that may throw exceptions. Common examples include:</p>
<ul>
<li>std::vector::at(): Throws <code>std::out_of_range</code> for out-of-bounds access</li>
<li>std::vector::push_back(): Throws <code>std::bad_alloc</code> if memory allocation fails</li>
<li>std::map::at(): Throws <code>std::out_of_range</code> if the key doesn’t exist</li>
</ul>
<p>When using these potentially throwing functions from the standard library, proper exception handling is crucial. <strong>For custom classes, it’s recommended to use error codes rather than exceptions for error handling. While there’s ongoing debate about exceptions versus error codes, you should follow what you’re comfortable with or your project’s conventions</strong>. For functions that are guaranteed not to throw, you can mark them with noexcept to inform both the compiler and users.</p>
<p>It’s worth noting that some function calls won’t throw exceptions but may lead to <a href="https://selfboot.cn/en/2016/09/18/c++_undefined_behaviours/">undefined behavior</a>, which can also cause process crashes. For example, the <a target="_blank" rel="noopener" href="https://cplusplus.com/reference/cstdlib/atoi/?kw=atoi">atoi function</a> exhibits undefined behavior if the string can’t be converted to a number, potentially leading to crashes in certain scenarios.</p>
<p>When using basic functions, if you’re unsure about their behavior, consult the <a target="_blank" rel="noopener" href="https://cplusplus.com/">cplusplus</a> documentation to determine whether they might throw exceptions or lead to undefined behavior. For example, regarding vector:</p>
<blockquote>
<p>std::vector::front()<br> Calling this function on an empty container causes undefined behavior.</p>
<p>std::vector::push_back()<br> If a reallocation happens, the storage is allocated using the container’s allocator, which may throw exceptions on failure (for the default allocator, bad_alloc is thrown if the allocation request does not succeed).</p>
</blockquote>
<h2 id="Array-Bounds-Violations"><a href="#Array-Bounds-Violations" class="headerlink" title="Array Bounds Violations"></a>Array Bounds Violations</h2><p>Beyond exceptions, another common issue is array bounds violations. We all know that in C++, accessing an array with an out-of-bounds index leads to illegal memory access, potentially causing a process crash. You might think, “How could array access go out of bounds? I just need to check the length when iterating!”</p>
<p>Let’s look at a real example from production code. For demonstration purposes, I’ve simplified the actual business logic to show just the core issue:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; src = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; src.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="comment">// Filtering logic possibly added later</span></span><br><span class="line">        <span class="keyword">if</span>(src[i] == <span class="number">8</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        dest.<span class="built_in">push_back</span>(src[i] * <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... Continue processing based on src content</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; src.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="comment">// Other processing of src</span></span><br><span class="line">        <span class="comment">// This usage is problematic, but might not crash as memory is on heap</span></span><br><span class="line">        <span class="comment">// dest[i] -= 5; </span></span><br><span class="line">        dest.<span class="built_in">at</span>(i) -= <span class="number">5</span>; <span class="comment">// This will crash</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Initially, the first loop initializes dest from src. After some intervening code, another loop processes dest based on src’s content.</p>
<p>This worked fine at first, but then a requirement was added to filter out certain values from src, leading to the addition of the if statement to skip some elements. The person making this change might not have noticed the subsequent iteration over src and dest, not realizing that filtering would cause dest’s length to differ from src’s.</p>
<p>This scenario can be tricky to trigger as a coredump, as it only occurs in rare cases where filtering actually results in different lengths. Moreover, even when accessing an out-of-bounds index in the second loop, using [] might not cause a crash. The example code deliberately uses at() to force a crash on out-of-bounds access.</p>
<h2 id="Iterator-Invalidation"><a href="#Iterator-Invalidation" class="headerlink" title="Iterator Invalidation"></a>Iterator Invalidation</h2><p>Beyond array bounds violations, another common issue is iterator invalidation. The iterator pattern provides a way to access elements in a container without exposing its internal representation. In C++, iterators are a crucial concept, serving as a bridge between containers and algorithms.</p>
<p>Many containers in the C++ standard library provide iterators, such as vector, list, and map. <strong>When accessing these container iterators, if the iterator has been invalidated, it leads to undefined behavior and potentially causes a process crash</strong>.</p>
<p>There are several ways iterators can become invalid. For example, when a vector reallocates memory during expansion, all previous iterators become invalid. A classic example is trying to remove even-numbered elements from a vector, where beginners might write something like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">        numbers.<span class="built_in">erase</span>(it);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, when <code>erase</code> is called to remove an element, it <strong>invalidates all iterators at and after the deletion point</strong>. So continuing to use <code>it</code> in the loop leads to undefined behavior. The correct approach is to use the return value from erase to update the iterator, or use remove_if and erase to remove elements.</p>
<p>While this example is relatively simple, we’ve encountered more subtle iterator invalidation issues in production. In one case, we had a batch processing task using a coroutine pool to handle IO-intensive tasks and write results back to a vector. Here’s a simplified version of the code:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simulated async processing function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncProcess</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>{</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    value += <span class="number">1</span>;  <span class="comment">// Might access an invalid reference</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        values.<span class="built_in">push_back</span>(i);</span><br><span class="line">        results.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span>&amp; result = results.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;result]() {</span></span></span><br><span class="line"><span class="params"><span class="function">            AsyncProcess(result);  <span class="comment">// Using reference in async task</span></span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Wait for tasks to complete</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, we store a reference to <code>results.back()</code> and use it in an async task. While the async task is executing, the results vector continues to add new elements. When the vector needs to reallocate, the original memory is freed and new memory is allocated. At this point, the reference held by the async task becomes dangling, and accessing it leads to undefined behavior.</p>
<p>The correct approach would be to either use <code>reserve</code> to pre-allocate space to avoid reallocation, or store indices instead of references.</p>
<h2 id="Data-Races-in-Concurrent-Code"><a href="#Data-Races-in-Concurrent-Code" class="headerlink" title="Data Races in Concurrent Code"></a>Data Races in Concurrent Code</h2><p>Another category of crashes comes from data races in concurrent code. A common scenario is having a background thread in a service that pulls configuration updates from a configuration center and updates them locally. Meanwhile, multiple business threads concurrently read this configuration.</p>
<p>Since this is a classic read-heavy scenario, it’s typically implemented using a read-write lock. Multiple reader threads can hold the read lock simultaneously, while the writer thread needs exclusive access, ensuring no other read or write operations during writing. New read operations must wait during write operations. A possible execution sequence might look like this:</p>
<figure class="highlight nestedtext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Time ──────────────────────────────────────────────────────▶</span></span><br><span class="line"><span class="attribute">Reader 1</span><span class="punctuation">:</span> <span class="string">     RRRR      RRRR      </span></span><br><span class="line"><span class="attribute">Reader 2</span><span class="punctuation">:</span> <span class="string">        RRRR        RRRR</span></span><br><span class="line"><span class="attribute">Reader 3</span><span class="punctuation">:</span> <span class="string">           RRRR         RRRR</span></span><br><span class="line"><span class="attribute">Writer A</span><span class="punctuation">:</span> <span class="string"> W                 W</span></span><br></pre></td></tr></tbody></table></figure>

<p>Here, W represents a write operation, and R represents a read operation. As you can see, new read operations must wait during write operations. We encountered a crash in production due to incorrect use of read-write locks. While the actual scenario was more complex, here’s the core code simplified:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataManager</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_mutex mutex_;</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num_keys = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadData</span><span class="params">()</span> </span>{</span><br><span class="line">        std::unordered_map&lt;std::string, std::string&gt; localdata;</span><br><span class="line">        std::vector&lt;std::string&gt; keys;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_keys; i++) {</span><br><span class="line">            keys.<span class="built_in">push_back</span>(<span class="string">"test"</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_keys; i++) {</span><br><span class="line">            localdata[keys[i]] = <span class="string">"test"</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        }</span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            m_data.<span class="built_in">swap</span>(localdata);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function">std::string <span class="title">readData</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>{</span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> m_data[key];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>The complete demonstration code is available in <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/dc0d9450ded391bc28a43aecd1045694">core_share.cpp</a>. In loadData, we prepare the configuration data and then use a write lock to update it. In readData, we use a read lock to read the configuration.</p>
<p>Seems fine, right? The crash was very intermittent, and the code hadn’t been modified for a long time. We could only analyze it using the core file. Surprisingly, the core stack showed the crash occurring during the <strong>destruction of localdata</strong> in the loadData method. localdata is a local variable that swaps with m_data before destruction. This suggested that m_data’s memory layout was problematic, and <strong>m_data is only written here, with all other access being “read”</strong>.</p>
<p>Upon closer inspection of the code, we discovered that m_data was being read using the [] operator for unordered_map. <strong>For unordered_map, if a key doesn’t exist, [] will insert a default value</strong>. Aha! While we intended to protect read-only operations with a read lock, we accidentally performed write operations. As we know, concurrent writes to unordered_map cause data races, which explains the crashes.</p>
<p>Of course, the core stack might not always show the destruction point. For example, in our demonstration code, the stack shows the crash in the reader thread’s readData, as shown in this image:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png/webp" alt="Reader Thread Crash Stack" srcset="https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png/webp 2408w, https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2408" height="1132"></p>
<h2 id="Catastrophic-Backtracking-Leading-to-Stack-Overflow"><a href="#Catastrophic-Backtracking-Leading-to-Stack-Overflow" class="headerlink" title="Catastrophic Backtracking Leading to Stack Overflow"></a>Catastrophic Backtracking Leading to Stack Overflow</h2><p>The examples above are relatively easy to avoid with proper attention. However, the following issue is less well-known and easier to overlook.</p>
<p>We needed to check if a string contained a pair of parentheses, so we used C++ regular expressions. Here’s a simplified version of the code:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string problematic = <span class="string">"(((("</span>;</span><br><span class="line">    problematic += std::<span class="built_in">string</span>(<span class="number">100000</span>, <span class="string">'a'</span>);</span><br><span class="line">    problematic += <span class="string">"))))"</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">re</span><span class="params">(<span class="string">R"(\([^\)]+\))"</span>)</span></span>;</span><br><span class="line">    std::smatch matches;</span><br><span class="line">    <span class="type">bool</span> found = std::<span class="built_in">regex_search</span>(problematic, matches, re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>In this code, we construct a very long string and use a regular expression to match it. When compiled with g++ and executed, the program crashes. Looking at the stack trace in gdb shows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png/webp" alt="Stack Overflow Due to Catastrophic Backtracking" srcset="https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png/webp 2412w, https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2412" height="1104"></p>
<p>This happens because the regex engine performs extensive backtracking, creating new stack frames for each backtrack operation. Eventually, the stack depth exceeds the stack size limit, causing the process to crash.</p>
<p>This is known as <strong>Catastrophic Backtracking</strong>. In real-world development, it’s best to limit input length when dealing with complex text processing. If possible, use loops or other non-recursive solutions instead of regular expressions. If regular expressions are necessary, limit repetition counts (use {n,m} instead of + or *) and avoid nested repetitions (like (.+)+).</p>
<p>The regular expression could be modified to:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">re</span><span class="params">(<span class="string">R"(\([^\)]{1,100}\))"</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>Of course, beyond recursive backtracking, other scenarios can cause stack overflow, such as infinite recursion or large arrays allocated on the stack. Fortunately, stack overflow issues are relatively easy to diagnose when you have a core file.</p>
<h2 id="Analyzing-Coredump-Issues"><a href="#Analyzing-Coredump-Issues" class="headerlink" title="Analyzing Coredump Issues"></a>Analyzing Coredump Issues</h2><p>When encountering crashes, we typically need to examine the core file. In production environments, if the business process uses significant memory, saving a core file after a crash might take considerable time. Production environments usually have watchdog processes that periodically check business processes, and if a process becomes unresponsive, some watchdogs use <code>kill -9</code> to terminate and restart the process. <strong>In such cases, we might get an incomplete core file that was only partially written</strong>. The solution is to modify the watchdog process to wait for the core file to complete before restarting the process.</p>
<p>Once we have the core file, we analyze it using gdb. If the stack trace is clear, we can usually identify the issue quickly. However, often the stack trace might be incomplete, showing a series of ??. For example, with the iterator invalidation issue above, running with gdb shows this stack trace:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png/webp" alt="Iterator Invalidation Stack Trace" srcset="https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png/webp 2054w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2054" height="1192"></p>
<p>This stack trace provides little useful information and is difficult to analyze. For issues that can be reliably reproduced like our example, using <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Valgrind">Valgrind</a> for analysis can make it easier to locate the problem. The analysis results for the above code show:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png/webp" alt="Valgrind Analysis of Iterator Invalidation" srcset="https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png/webp 2408w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2408" height="1014"></p>
<p>The analysis results show two main issues: Invalid read and Invalid write. The problematic code lines are clearly indicated, making it easy to locate the issue.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>This article has covered five classic cases of process crashes that I’ve encountered:</p>
<ol>
<li><p><strong>Uncaught Exceptions</strong>: When using standard library functions, be aware of potential exceptions. Handle exceptions properly for functions that might throw them. For custom classes, consider using error codes instead of exceptions.</p>
</li>
<li><p><strong>Array Bounds Violations</strong>: When working with arrays or containers, carefully check index validity. Especially when iterating over the same container multiple times, ensure its size hasn’t changed. Consider using the <code>at()</code> method for bounds-checked access.</p>
</li>
<li><p><strong>Iterator Invalidation</strong>: When using iterators, be aware that container operations (like deletion or insertion) can invalidate them. For vectors, reallocation invalidates all iterators; understand the invalidation rules for other containers as well.</p>
</li>
<li><p><strong>Data Races in Concurrent Code</strong>: In multi-threaded environments, pay special attention to concurrent data access. Even seemingly read-only operations (like map’s [] operator) might modify container contents. Use appropriate synchronization mechanisms (like mutexes or read-write locks) to protect shared data.</p>
</li>
<li><p><strong>Stack Overflow from Catastrophic Backtracking</strong>: When using regular expressions or other potentially recursive operations, be mindful of input limitations. For complex text processing, prefer non-recursive solutions or limit recursion depth.</p>
</li>
</ol>
<p>Of course, there are other less common causes of crashes, such as the one I previously encountered: <a href="https://selfboot.cn/en/2024/03/15/object_memory_coredump/">C++ Process Coredump Analysis Due to Missing Bazel Dependencies</a>. If you’ve encountered any memorable crash cases, feel free to share them in the comments.</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2025/01/10/c++_crash_cases/';
    this.page.identifier = 'en/2025/01/10/c++_crash_cases/';
    this.page.title = '5 Real-world Cases of C++ Process Crashes from Production';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (16)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (13)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2025/01/10/c++_crash_cases/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li><li><a href="/en/2024/09/09/leveldb_source_skiplist/" title="LevelDB Explained - How to implement SkipList">LevelDB Explained - How to implement SkipList</a></li><li><a href="/en/2024/09/05/claude35_prompt/" title="Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...">Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...</a></li><li><a href="/en/2024/08/29/leveldb_source_utils/" title="LevelDB Explained - Arena, Random, CRC32, and More.">LevelDB Explained - Arena, Random, CRC32, and More.</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Uncaught-Exceptions"><span class="toc-number">1.</span> <span class="toc-text">Uncaught Exceptions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-Bounds-Violations"><span class="toc-number">2.</span> <span class="toc-text">Array Bounds Violations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-Invalidation"><span class="toc-number">3.</span> <span class="toc-text">Iterator Invalidation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Races-in-Concurrent-Code"><span class="toc-number">4.</span> <span class="toc-text">Data Races in Concurrent Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Catastrophic-Backtracking-Leading-to-Stack-Overflow"><span class="toc-number">5.</span> <span class="toc-text">Catastrophic Backtracking Leading to Stack Overflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Analyzing-Coredump-Issues"><span class="toc-number">6.</span> <span class="toc-text">Analyzing Coredump Issues</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">7.</span> <span class="toc-text">Summary</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>