<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article provides an in-depth analysis of WriteBatch design and implementation in LevelDB, detailing how it improves performance through batch write and delete operations. The article explores WriteBatch's interface design, sequence number mechanism, operation record storage format, and other aspects, examining core functionalities like global sequence number increment, operation counting, and data format validation through source code analysis. Additionally, it demonstrates practical usage scenarios through test cases, making it valuable reading for developers interested in LevelDB or storage system design."><title>LevelDB Explained - Elegant Merging of Write and Delete Operations</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB Explained - Elegant Merging of Write and Delete Operations</h1><div class="post-meta">2025/01/13<span> | </span><span class="category"><a href="/categories/Source-Code-Analysis/">Source Code Analysis</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2025/01/13/leveldb_source_write_batch/" href="/en/2025/01/13/leveldb_source_write_batch/#disqus_thread"></a><div class="post-content"><p>LevelDB supports both single key-value writes and batch writes. These two types of operations are essentially handled the same way - they’re both encapsulated in a WriteBatch object, which helps improve write operation efficiency.</p>
<p>In LevelDB, WriteBatch is implemented using a simple data structure that contains a series of write operations. These operations are serialized (converted to byte streams) and stored in an internal string. Each operation includes an operation type (such as insert or delete), key, and value (for insert operations).</p>
<p>When a WriteBatch is committed to the database, its contents are parsed and applied to both the WAL log and memtable. Regardless of how many operations a WriteBatch contains, they are processed and logged as a single unit.</p>
<span id="more"></span>

<p>WriteBatch’s implementation primarily involves 4 files, let’s examine them:</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/include/leveldb/write_batch.h">include/leveldb/write_batch.h</a>: The public interface file defining the WriteBatch class interface.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch_internal.h">db/write_batch_internal.h</a>: Internal implementation file defining the WriteBatchInternal class, providing methods to manipulate WriteBatch.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch.cc">db/write_batch.cc</a>: The implementation file for the WriteBatch class.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch_test.cc">db/write_batch_test.cc</a>: Test file for WriteBatch functionality.</li>
</ol>
<h2 id="WriteBatch-Interface-Design"><a href="#WriteBatch-Interface-Design" class="headerlink" title="WriteBatch Interface Design"></a>WriteBatch Interface Design</h2><p>Let’s first look at write_batch.h, which defines the public interfaces of the WriteBatch class. While LevelDB’s code comments are very clear, we’ll skip them for now:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> WriteBatch {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> Handler {</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Handler</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WriteBatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Intentionally copyable.</span></span><br><span class="line">  <span class="built_in">WriteBatch</span>(<span class="type">const</span> WriteBatch&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  WriteBatch&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WriteBatch&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">WriteBatch</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">ApproximateSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> WriteBatch&amp; source)</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">Iterate</span><span class="params">(Handler* handler)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteBatchInternal</span>;</span><br><span class="line"></span><br><span class="line">  std::string rep_;  <span class="comment">// See comment in write_batch.cc for the format of rep_</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>The <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/include/leveldb/write_batch.h#L35">WriteBatch::Handler</a> is an abstract base class that defines interfaces for handling key-value operations, containing only Put and Delete methods. This design allows the WriteBatch class implementation to be decoupled from <strong>specific storage operations</strong>, meaning WriteBatch doesn’t need to know directly how to apply operations to underlying storage (like MemTable).</p>
<p><strong>By inheriting from the Handler class, various handlers can be created that implement these methods differently</strong>. For example:</p>
<ol>
<li>MemTableInserter: Defined in db/write_batch.cc, stores key-value operations in MemTable.</li>
<li>WriteBatchItemPrinter: Defined in db/dumpfile.cc, prints key-value operations to a file for testing.</li>
</ol>
<p>Additionally, there’s a <code>friend class WriteBatchInternal</code> that can access WriteBatch’s private and protected members. <strong>WriteBatchInternal mainly encapsulates internal operations that don’t need to be exposed publicly and are only used internally. By hiding internal operation methods in WriteBatchInternal, the object’s interface remains clean, and internal implementations can be modified freely without affecting code that uses these objects</strong>.</p>
<h3 id="WriteBatch-Usage"><a href="#WriteBatch-Usage" class="headerlink" title="WriteBatch Usage"></a>WriteBatch Usage</h3><p>At the application level, we can use WriteBatch to write multiple key-value pairs in batch, then write the WriteBatch to the database using the <code>DB::Write</code> method.</p>
<p>WriteBatch supports Put and Delete operations and can merge multiple WriteBatches. Here’s a usage example:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WriteBatch batch;</span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">batch.<span class="built_in">Delete</span>(<span class="string">"key3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge another batch</span></span><br><span class="line">WriteBatch another_batch;</span><br><span class="line">another_batch.<span class="built_in">Put</span>(<span class="string">"key4"</span>, <span class="string">"value4"</span>);</span><br><span class="line">batch.<span class="built_in">Append</span>(another_batch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write to database</span></span><br><span class="line">db-&gt;<span class="built_in">Write</span>(writeOptions, &amp;batch);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="WriteBatch-Implementation-Details"><a href="#WriteBatch-Implementation-Details" class="headerlink" title="WriteBatch Implementation Details"></a>WriteBatch Implementation Details</h2><p>So how is WriteBatch implemented? The key lies in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch.cc">db/write_batch.cc</a>, where the class has a private member <code>std::string rep_</code> to store serialized key-value operations. Let’s first look at the storage data protocol:</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------------+----------------------------------------+</span><br><span class="line">|<span class="string">   Sequence    </span>|<span class="string">     Count     </span>|<span class="string">                Data                    </span>|</span><br><span class="line">|<span class="string">  (8 bytes)    </span>|<span class="string">   (4 bytes)   </span>|<span class="string">                                        </span>|</span><br><span class="line">+---------------+---------------+----------------------------------------+</span><br><span class="line">                                   |<span class="string">                 </span>|<span class="string">                   </span>|</span><br><span class="line">                                   v                 v                   v</span><br><span class="line">                               +-------+         +-------+          +-------+</span><br><span class="line">                               |<span class="string">Record1</span>|<span class="string">         </span>|<span class="string">Record2</span>|<span class="string">   ...    </span>|<span class="string">RecordN</span>|</span><br><span class="line">                               +-------+         +-------+          +-------+</span><br><span class="line">                                  |<span class="string">                 </span>|</span><br><span class="line">                                  v                 v</span><br><span class="line">                        +-----------------+ +-----------------+</span><br><span class="line">                        |<span class="string"> kTypeValue      </span>|<span class="string"> </span>|<span class="string"> kTypeDeletion   </span>|</span><br><span class="line">                        |<span class="string"> Varstring Key   </span>|<span class="string"> </span>|<span class="string"> Varstring Key   </span>|</span><br><span class="line">                        |<span class="string"> Varstring Value </span>|<span class="string"> </span>|<span class="string">                 </span>|</span><br><span class="line">                        +-----------------+ +-----------------+</span><br><span class="line">                        </span><br><span class="line">Varstring (variable-length string):</span><br><span class="line">+-------------+-----------------------+</span><br><span class="line">|<span class="string"> Length (varint32) </span>|<span class="string"> Data (uint8[])  </span>|</span><br><span class="line">+-------------+-----------------------+</span><br></pre></td></tr></tbody></table></figure>

<p>The first 12 bytes of this string are header metadata, including 8 bytes for sequence number and 4 bytes for count. Following that are one or more operation records, each containing an operation type and key-value pair. The operation type is a single byte, which can be either Put or Delete. Keys and values are variable-length strings in varstring format.</p>
<h3 id="LevelDB’s-Sequence-Number-Mechanism"><a href="#LevelDB’s-Sequence-Number-Mechanism" class="headerlink" title="LevelDB’s Sequence Number Mechanism"></a>LevelDB’s Sequence Number Mechanism</h3><p>The first 8 bytes of rep_ represent a 64-bit sequence number. The WriteBatchInternal friend class provides two methods to get and set the sequence number, internally using <a href="https://selfboot.cn/en/2024/08/29/leveldb_source_utils/#Integer-Encoding-and-Decoding">EncodeFixed64 and DecodeFixed64</a> methods to encode and decode the 64-bit sequence number.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SequenceNumber <span class="title">WriteBatchInternal::Sequence</span><span class="params">(<span class="type">const</span> WriteBatch* b)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SequenceNumber</span>(<span class="built_in">DecodeFixed64</span>(b-&gt;rep_.<span class="built_in">data</span>()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::SetSequence</span><span class="params">(WriteBatch* b, SequenceNumber seq)</span> </span>{</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(&amp;b-&gt;rep_[<span class="number">0</span>], seq);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Sequence numbers are globally incrementing identifiers in LevelDB, used for version control and operation ordering</strong>. Each WriteBatch receives a consecutive range of sequence numbers during execution, with each operation (Put/Delete) within the batch being assigned one of these numbers. Sequence numbers serve three core purposes in LevelDB:</p>
<ol>
<li><p><strong>Version Control</strong>: Each key in LevelDB can have multiple versions, each corresponding to a sequence number. When reading, sequence numbers are compared to determine which version to return. Higher sequence numbers indicate newer versions.</p>
</li>
<li><p><strong>Multi-Version Concurrency Control (MVCC)</strong>: Write operations get new sequence numbers and create new versions of keys. Read operations can specify a sequence number to access data snapshots at that point in time. This mechanism allows concurrent execution of read and write operations without blocking each other.</p>
</li>
<li><p><strong>Crash Recovery</strong>: WAL (Write-Ahead Log) records operation sequence numbers. During system restart, sequence numbers help accurately rebuild the data state at the time of crash, avoiding duplicate application of already persisted operations.</p>
</li>
</ol>
<p>This design allows LevelDB to maintain data consistency while implementing efficient concurrency control.</p>
<p>The sequence number setting logic is in the <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1222">DBImpl::Write</a> method, which first gets the current maximum sequence number, then allocates a new sequence number for the WriteBatch.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">uint64_t</span> last_sequence = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; updates != <span class="literal">nullptr</span>) {  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">    WriteBatch* write_batch = <span class="built_in">BuildBatchGroup</span>(&amp;last_writer);</span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">    last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>If a WriteBatch contains multiple operations, these operations are assigned sequence numbers consecutively. When writing to the WAL log, the WriteBatch’s sequence number is written to the log, allowing operations to be recovered in order during recovery. After writing to the memtable, the current maximum sequence number is updated for the next allocation.</p>
<h3 id="Count-for-Operation-Tracking"><a href="#Count-for-Operation-Tracking" class="headerlink" title="Count for Operation Tracking"></a>Count for Operation Tracking</h3><p>The header also includes 4 bytes for count, which records the number of operations in the WriteBatch. The count is incremented for each put or delete operation. For example:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WriteBatch batch;</span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">"key1"</span>, <span class="string">"value1"</span>);  <span class="comment">// count = 1</span></span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">"key2"</span>, <span class="string">"value2"</span>);  <span class="comment">// count = 2</span></span><br><span class="line">batch.<span class="built_in">Delete</span>(<span class="string">"key3"</span>);         <span class="comment">// count = 3</span></span><br><span class="line"><span class="type">int</span> num_ops = WriteBatchInternal::<span class="built_in">Count</span>(&amp;batch);  <span class="comment">// = 3</span></span><br></pre></td></tr></tbody></table></figure>

<p>When merging two WriteBatches, their counts are also accumulated, as shown in the <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch.cc#L144">WriteBatchInternal::Append</a> method:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::Append</span><span class="params">(WriteBatch* dst, <span class="type">const</span> WriteBatch* src)</span> </span>{</span><br><span class="line">  <span class="built_in">SetCount</span>(dst, <span class="built_in">Count</span>(dst) + <span class="built_in">Count</span>(src));</span><br><span class="line">  <span class="built_in">assert</span>(src-&gt;rep_.<span class="built_in">size</span>() &gt;= kHeader);</span><br><span class="line">  dst-&gt;rep_.<span class="built_in">append</span>(src-&gt;rep_.<span class="built_in">data</span>() + kHeader, src-&gt;rep_.<span class="built_in">size</span>() - kHeader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The count is used primarily in two places. First, when iterating through each record, it’s used for <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch.cc#L75">integrity checking</a> to ensure no operations are missed.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatch::Iterate</span><span class="params">(Handler* handler)</span> <span class="type">const</span> </span>{</span><br><span class="line">  <span class="function">Slice <span class="title">input</span><span class="params">(rep_)</span></span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (found != WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>)) {</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"WriteBatch has wrong count"</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Second, during database writes, the count helps pre-determine how many sequence numbers need to be allocated, ensuring sequence number continuity. As shown in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L449">DBImpl::Write</a>:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Supported-Operations"><a href="#Supported-Operations" class="headerlink" title="Supported Operations"></a>Supported Operations</h3><p>After the header’s sequence and count, rep_ contains a series of records, each including an operation type and key-value pair. Records can be added through Put and Delete methods. Here’s the implementation of Put:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>{</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeValue));</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>This updates the count, adds the kTypeValue operation type, then adds the key and value. The Delete operation is similar - it increments the count, uses kTypeDeletion as the operation type, and only needs to add the key.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>{</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeDeletion));</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Above shows how records are added to rep_, but how are these records parsed from rep_? The WriteBatch class provides an <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch.cc#L42">Iterate</a> method that traverses each record in rep_ and flexibly handles these records through the passed Handler interface.</p>
<p>Additionally, the implementation includes <strong>data format validation, checking header size, operation type, and operation count matching</strong>. It can return Corruption errors indicating incorrect data format. Here’s the core code of Iterate:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatch::Iterate</span><span class="params">(Handler* handler)</span> <span class="type">const</span> </span>{</span><br><span class="line">  <span class="function">Slice <span class="title">input</span><span class="params">(rep_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (input.<span class="built_in">size</span>() &lt; kHeader) {</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"malformed WriteBatch (too small)"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  input.<span class="built_in">remove_prefix</span>(kHeader);</span><br><span class="line">  Slice key, value;</span><br><span class="line">  <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!input.<span class="built_in">empty</span>()) {</span><br><span class="line">    found++;</span><br><span class="line">    <span class="type">char</span> tag = input[<span class="number">0</span>];</span><br><span class="line">    input.<span class="built_in">remove_prefix</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">switch</span> (tag) {</span><br><span class="line">      <span class="keyword">case</span> kTypeValue:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key) &amp;&amp;</span><br><span class="line">            <span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;value)) {</span><br><span class="line">          handler-&gt;<span class="built_in">Put</span>(key, value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"bad WriteBatch Put"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key)) {</span><br><span class="line">          handler-&gt;<span class="built_in">Delete</span>(key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"bad WriteBatch Delete"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"unknown WriteBatch tag"</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>As mentioned earlier, Handler is WriteBatch’s abstract base class and can accept different implementations. When writing data in LevelDB, the MemTableInserter class is passed in, which stores operation data in MemTable. Here’s the specific implementation:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatchInternal::InsertInto</span><span class="params">(<span class="type">const</span> WriteBatch* b, MemTable* memtable)</span> </span>{</span><br><span class="line">  MemTableInserter inserter;</span><br><span class="line">  inserter.sequence_ = WriteBatchInternal::<span class="built_in">Sequence</span>(b);</span><br><span class="line">  inserter.mem_ = memtable;</span><br><span class="line">  <span class="keyword">return</span> b-&gt;<span class="built_in">Iterate</span>(&amp;inserter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Overall, WriteBatch is responsible for storing key-value operation data and handling encoding/decoding, while Handler is responsible for processing each piece of data specifically. This allows WriteBatch operations to be flexibly applied to different scenarios, facilitating extension.</p>
<h2 id="Test-Case-Analysis"><a href="#Test-Case-Analysis" class="headerlink" title="Test Case Analysis"></a>Test Case Analysis</h2><p>Finally, let’s look at <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch_test.cc">write_batch_test.cc</a>, which provides test cases for WriteBatch functionality.</p>
<p>First, it defines a PrintContents function to output all operation records in WriteBatch. It uses MemTableInserter to store WriteBatch operation records in MemTable, then traverses all records using MemTable’s iterator and saves them to a string.</p>
<p>The test cases cover the following scenarios:</p>
<ol>
<li>Empty: Tests if an empty WriteBatch works normally</li>
<li>Multiple: Tests multiple Put and Delete operations</li>
<li>Corruption: Writes data then deliberately truncates some records to test reading as many normal records as possible</li>
<li>Append: Tests merging two WriteBatches, including sequence numbers and empty WriteBatch cases</li>
<li>ApproximateSize: Tests the ApproximateSize method for calculating approximate WriteBatch size</li>
</ol>
<p>Through these test cases, we can understand how to use WriteBatch. Interestingly, when looking at the Append code earlier, we didn’t notice whose sequence number is used after merging. Looking at the test cases, we discover it uses the target WriteBatch’s sequence number:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(WriteBatchTest, Append) {</span><br><span class="line">  WriteBatch b1, b2;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetSequence</span>(&amp;b1, <span class="number">200</span>);</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetSequence</span>(&amp;b2, <span class="number">300</span>);</span><br><span class="line">  b<span class="number">1.</span><span class="built_in">Append</span>(b2);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">""</span>, <span class="built_in">PrintContents</span>(&amp;b1));</span><br><span class="line">  b<span class="number">2.</span><span class="built_in">Put</span>(<span class="string">"a"</span>, <span class="string">"va"</span>);</span><br><span class="line">  b<span class="number">1.</span><span class="built_in">Append</span>(b2);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">"Put(a, va)@200"</span>, <span class="built_in">PrintContents</span>(&amp;b1));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>By delving into the implementation of LevelDB’s WriteBatch, we can clearly see the ingenuity of its design. WriteBatch improves the efficiency of write operations and simplifies the implementation of concurrency control and fault recovery by encapsulating multiple write and delete operations together. Several highlights are worth noting:</p>
<ol>
<li><strong>Batch Operations</strong>: WriteBatch allows combining multiple Put and Delete operations into a single batch, reducing frequent I/O operations and enhancing write performance.</li>
<li><strong>Sequence Number Mechanism</strong>: Through globally incrementing sequence numbers, LevelDB achieves Multi-Version Concurrency Control (MVCC), ensuring consistency in read and write operations.</li>
<li><strong>Handler Abstraction</strong>: The Handler interface decouples the specific implementation of operations from storage logic, making the code more flexible and extensible.</li>
<li><strong>Data Format Validation</strong>: When parsing WriteBatch, LevelDB performs strict data format validation to ensure data integrity and correctness.</li>
</ol>
<p>Of course, this article only analyzes the implementation of WriteBatch and does not cover the entire write process of LevelDB. In future articles, we will continue to explore the complete flow of writing a key.</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2025/01/13/leveldb_source_write_batch/';
    this.page.identifier = 'en/2025/01/13/leveldb_source_write_batch/';
    this.page.title = 'LevelDB Explained - Elegant Merging of Write and Delete Operations';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (17)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (14)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2025/01/13/leveldb_source_write_batch/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/05/23/mcp_user_report/" title="In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?">In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?</a></li><li><a href="/en/2025/01/24/leveldb_source_writedb/" title="LevelDB Explained - Implementation and Optimization Details of Key-Value Writing">LevelDB Explained - Implementation and Optimization Details of Key-Value Writing</a></li><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li><li><a href="/en/2024/09/09/leveldb_source_skiplist/" title="LevelDB Explained - How to implement SkipList">LevelDB Explained - How to implement SkipList</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#WriteBatch-Interface-Design"><span class="toc-number">1.</span> <span class="toc-text">WriteBatch Interface Design</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WriteBatch-Usage"><span class="toc-number">1.1.</span> <span class="toc-text">WriteBatch Usage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WriteBatch-Implementation-Details"><span class="toc-number">2.</span> <span class="toc-text">WriteBatch Implementation Details</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LevelDB%E2%80%99s-Sequence-Number-Mechanism"><span class="toc-number">2.1.</span> <span class="toc-text">LevelDB’s Sequence Number Mechanism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Count-for-Operation-Tracking"><span class="toc-number">2.2.</span> <span class="toc-text">Count for Operation Tracking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Supported-Operations"><span class="toc-number">2.3.</span> <span class="toc-text">Supported Operations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Test-Case-Analysis"><span class="toc-number">3.</span> <span class="toc-text">Test Case Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">4.</span> <span class="toc-text">Summary</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>