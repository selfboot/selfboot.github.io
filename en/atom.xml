<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Just For Fun</title>
    <link>https://selfboot.cn/</link>
    
    <image>
      <url>https://www.gravatar.com/avatar/0de0c23d97c75300e32f8494b1485fb8</url>
      <title>Just For Fun</title>
      <link>https://selfboot.cn/</link>
    </image>
    
    <atom:link href="https://selfboot.cn/en/atom.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 02 Sep 2024 13:31:08 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    
    <item>
      <title>LevelDB Explained - Arena, Random, CRC32, and More.</title>
      <link>https://selfboot.cn/en/2024/08/29/leveldb_source_utils/</link>
      <guid>https://selfboot.cn/en/2024/08/29/leveldb_source_utils/</guid>
      <pubDate>Thu, 29 Aug 2024 20:36:37 GMT</pubDate>
      
      <description>This article explores the implementation of core utility components in LevelDB, including the Arena memory allocator, Random number generator, CRC32 cyclic redundancy check, and integer encoding/decoding tools. It analyzes the design considerations, implementation details, and optimization strategies of these components, demonstrating how they efficiently support various operations in LevelDB.</description>
      
      
      
      <content:encoded><![CDATA[<p>LevelDB implements several utility tools, such as the custom memory allocator Arena and the random number generation class Random. These implementations consider specific use cases, making optimizations and trade-offs that are worth studying. This article will mainly discuss the implementation of the following parts:</p><ul><li>Memory management Arena, a simple and efficient memory allocation manager suitable for LevelDB;</li><li>Random number generator Random, a good <strong>linear congruential pseudorandom generation</strong> algorithm that uses bitwise operations instead of modulo to optimize execution efficiency.</li><li>CRC32 cyclic redundancy check, used to detect errors during data transmission or storage;</li><li>Integer encoding and decoding, used to store numbers in byte streams or parse numbers from byte streams.</li></ul><p>In addition, there are some more complex utils components that will be discussed in separate articles, such as:</p><ul><li><a href="https://selfboot.cn/en/2024/07/22/leveldb_source_nodestructor/">LevelDB Source Code Reading: Preventing Object Destruction</a> discusses how to prevent an object from being destructed in C++ and the reasons for doing so.</li></ul><span id="more"></span><h2 id="Memory-Management-Arena"><a href="#Memory-Management-Arena" class="headerlink" title="Memory Management Arena"></a>Memory Management Arena</h2><p>LevelDB <strong>does not directly use</strong> the system’s default malloc to allocate memory, nor does it use third-party libraries like tcmalloc to manage memory allocation and deallocation. Instead, it implements a simple memory allocator of its own. This memory allocator can be said to be <strong>tailor-made</strong>, mainly based on the following considerations:</p><ol><li>Primarily used in memtable, there will be a large number of allocations, possibly many small memory allocations;</li><li>Unified recovery timing, all memory will be reclaimed together after the memtable data is written to disk;</li></ol><p>The data in the memory memtable is actually stored in a skiplist. Each time a key is inserted, a node needs to be inserted into the skiplist, and the memory used by these nodes is allocated by arena. For small keys, it will prioritize taking from the remaining memory of the current block, and only go to the allocation logic if there’s not enough. The code for <a href="https://github.com/google/leveldb/blob/main/util/arena.h#L55">Allocate</a> is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="type">char</span>* result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The logic for allocating memory through system calls is in AllocateFallback. If the required memory is greater than kBlockSize &#x2F; 4, it allocates according to the actual need. Otherwise, it directly allocates memory for one block and then updates the usage. The unused memory remaining here can be used the next time memory is allocated. If it’s not enough for the next required amount, it will again go through system calls to allocate.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></span><br><span class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We waste the remaining space in the current block.</span></span><br><span class="line">  alloc_ptr_ = <span class="built_in">AllocateNewBlock</span>(kBlockSize);</span><br><span class="line">  alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* result = alloc_ptr_;</span><br><span class="line">  alloc_ptr_ += bytes;</span><br><span class="line">  alloc_bytes_remaining_ -= bytes;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method may lead to some <strong>memory waste</strong>. For example, if 496 bytes are used the first time, it will actually allocate 4096 bytes, leaving 3600 bytes. Then if more than 3600 bytes are used the next time, it will allocate new memory, wasting the remaining 3600 bytes from the last allocation. Although this wastes some memory usage, the overall code is relatively simple, and the allocation efficiency is quite high. This wasted memory will also be reclaimed when the memtable is written to disk.</p><p>By the way, let’s mention the final memory reclamation here. Each time <code>new []</code> is called to allocate memory, the starting address is placed in a vector, and then when the Arena class is destructed, all memory blocks are retrieved by traversing and uniformly released.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span>* result = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">  blocks_.<span class="built_in">push_back</span>(result);</span><br><span class="line">  memory_usage_.<span class="built_in">fetch_add</span>(block_bytes + <span class="built_in">sizeof</span>(<span class="type">char</span>*),</span><br><span class="line">                          std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">Arena::~<span class="built_in">Arena</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] blocks_[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In addition, this class also provides an atomic counter <code>memory_usage_</code>, which keeps track of the amount of memory currently occupied by this class.</p><h2 id="Random-Number-Generator"><a href="#Random-Number-Generator" class="headerlink" title="Random Number Generator"></a>Random Number Generator</h2><p>LevelDB’s <a href="https://github.com/google/leveldb/blob/main/util/random.h">util&#x2F;random.h</a> implements a <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">Pseudorandom Number Generator (PRNG)</a> class Random, used in scenarios such as <strong>generating skip list height</strong>. This random number generator is implemented based on a linear congruential generator (LCG), with the following formula for generating random numbers:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seed_ = (seed_ * A) % M</span><br></pre></td></tr></table></figure><p>According to congruence theory, as long as A and M are appropriately chosen, the above recursive formula will be able to generate a pseudorandom number sequence with a period of M, and there will be no repeated numbers in this sequence (except for the initial value). The modulus M value of $ 2^{31}-1 $ here is a common choice because it is a <strong>Mersenne prime</strong>, which is conducive to generating random sequences with good periodicity.</p><p>The constructor takes a 32-bit unsigned integer as a seed (seed_) and ensures that the seed falls within a valid range (non-zero and not equal to 2147483647L, i.e., $ 2^{31}-1 $). This is because the value of the seed directly affects the random number generation process, and these two specific values (0 and $ 2^{31}-1 $) would cause the generated sequence to lose randomness in the calculation process.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Random</span><span class="params">(<span class="type">uint32_t</span> s)</span> : seed_(s &amp; <span class="number">0x7fffffff</span>u) &#123;</span></span><br><span class="line">  <span class="comment">// Avoid bad seeds.</span></span><br><span class="line">  <span class="keyword">if</span> (seed_ == <span class="number">0</span> || seed_ == <span class="number">2147483647L</span>) &#123;</span><br><span class="line">    seed_ = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code for generating random numbers is very concise, as follows (ignoring the original comments):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> M = <span class="number">2147483647L</span>;  <span class="comment">// 2^31-1</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> A = <span class="number">16807</span>;        <span class="comment">// bits 14, 8, 7, 5, 2, 1, 0</span></span><br><span class="line">  <span class="type">uint64_t</span> product = seed_ * A;</span><br><span class="line">  seed_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;((product &gt;&gt; <span class="number">31</span>) + (product &amp; M));</span><br><span class="line">  <span class="keyword">if</span> (seed_ &gt; M) &#123;</span><br><span class="line">    seed_ -= M;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> seed_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First, <code>product = seed_ * A</code>, where the product might exceed the range of 32 bits. To <strong>prevent overflow</strong>, uint64_t is used to hold this intermediate result. As a reminder of a painful lesson, <strong>integer addition, subtraction, multiplication, and division must always consider overflow scenarios; many software vulnerabilities are caused by overflow</strong>. Then, the modulo operation product%M here <strong>uses bitwise operations and addition to replace</strong> it, to improve computational efficiency.</p><p>This is mainly based on the <strong>distributive property of modulo operations</strong>: $ (a + b) \mod m &#x3D; ((a \mod m) + (b \mod m)) \mod m $, dividing product into <code>product &gt;&gt; 31 + product &amp; M</code>, because M &#x3D; $ 2^{31}-1 $, the AND operation here takes the lower 31 bits of product.</p><p>In addition to basic random number generation, the Random class also provides methods like <code>Uniform()</code> for generating random numbers within a specific range, <code>OneIn()</code> for probabilistically returning true or false, and <code>Skewed()</code> for generating numbers biased towards smaller values. These are all very useful utility functions in specific scenarios.</p><p>The implementation of Skewed is quite interesting. It first uniformly selects a base from the range [0, max_log], then uses <code>Uniform(1 &lt;&lt; base)</code> to return a random number in the range $ [0, 2^{base} - 1]$. The probability of selecting the base here is uniform, which means that choosing a smaller base (thus generating smaller random numbers) has the same probability as choosing a larger base (thus generating larger random numbers). However, since the smaller the value of base, the smaller the range of random numbers that can be generated, this naturally leads to the <strong>function tending to generate smaller values</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Skewed: pick &quot;base&quot; uniformly from range [0,max_log] and then</span></span><br><span class="line"><span class="comment">// return &quot;base&quot; random bits.  The effect is to pick a number in the</span></span><br><span class="line"><span class="comment">// range [0,2^max_log-1] with exponential bias towards smaller numbers.</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Skewed</span><span class="params">(<span class="type">int</span> max_log)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Uniform</span>(<span class="number">1</span> &lt;&lt; <span class="built_in">Uniform</span>(max_log + <span class="number">1</span>)); &#125;</span><br></pre></td></tr></table></figure><h2 id="CRC32"><a href="#CRC32" class="headerlink" title="CRC32"></a>CRC32</h2><p>CRC (<strong>Cyclic Redundancy Check</strong>) is a method of calculating a check code for data through a specific algorithm, widely used in <strong>network communication and data storage systems</strong> to detect whether errors occurred during data transmission or storage. CRC32 is a common CRC algorithm that uses a 32-bit checksum.</p><p>The calculation of CRC is based on <strong>polynomial division</strong>, where the processed data is viewed as a huge polynomial, <strong>divided by another predefined “generator polynomial”</strong>, and then the remainder is taken as the output CRC value. The CRC algorithm has a natural <strong>streaming calculation characteristic</strong>, allowing for the CRC of part of a message to be calculated first, and then using this result as the initial value (init_crc) for the calculation of the next part. The following <code>Extend</code> function accepts an initial CRC value (which could be the CRC result of a previous data block) and then calculates the CRC value after adding the new data block. This allows LevelDB to continuously calculate CRC as data is appended, without needing to start from the beginning each time.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the crc32c of concat(A, data[0,n-1]) where init_crc is the</span></span><br><span class="line"><span class="comment">// crc32c of some string A.  Extend() is often used to maintain the</span></span><br><span class="line"><span class="comment">// crc32c of a stream of data.</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Extend</span><span class="params">(<span class="type">uint32_t</span> init_crc, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the crc32c of data[0,n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Value</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Extend</span>(<span class="number">0</span>, data, n); &#125;</span><br></pre></td></tr></table></figure><p>The implementation in <a href="https://github.com/google/leveldb/blob/main/util/crc32c.cc">crc32c.cc</a> is quite complex, involving lookup tables (table-driven approach), data alignment, and possible hardware acceleration. The specific principles can be referred to in <a href="http://www.ross.net/crc/download/crc_v3.txt">A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS</a>. The choice of <strong>generator polynomial</strong> is crucial to the effectiveness and error detection capability of the CRC algorithm. Generator polynomials are not arbitrarily chosen; they are typically designed through mathematical and computer simulation experiments to ensure maximum error detection capability for specific data lengths and application scenarios. The common generator polynomial <code>0x04C11DB7</code> was selected for the CRC-32 algorithm in the IEEE 802.3 standard.</p><p>It’s worth adding that CRC is only used to <strong>detect random errors</strong>, such as bit flips in network transmission or disk storage. It is not an error-correcting code; it can only detect errors and <strong>cannot correct errors</strong>. We can deliberately tamper with the content and ensure the same CRC result. If protection against tampering is needed, more complex cryptographic hash functions or digital signature techniques must be used.</p><p>Additionally, in <a href="https://github.com/google/leveldb/blob/main/util/crc32c.h">crc32c.h</a>, we see a Mask. The code comments explain this clearly: if the data itself contains CRC values, then directly calculating CRC on data that includes CRC might reduce the error detection capability of CRC. Therefore, LevelDB “masks” the original CRC value by swapping the high and low bits and adding a constant (kMaskDelta). This transformed CRC value can be stored in files. When verifying data integrity, the Unmask function is used to convert the masked CRC value back to the original CRC value, which is then compared with the CRC calculation result of the current data.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a masked representation of crc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Motivation: it is problematic to compute the CRC of a string that</span></span><br><span class="line"><span class="comment">// contains embedded CRCs.  Therefore we recommend that CRCs stored</span></span><br><span class="line"><span class="comment">// somewhere (e.g., in files) should be masked before being stored.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Mask</span><span class="params">(<span class="type">uint32_t</span> crc)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Rotate right by 15 bits and add a constant.</span></span><br><span class="line">  <span class="keyword">return</span> ((crc &gt;&gt; <span class="number">15</span>) | (crc &lt;&lt; <span class="number">17</span>)) + kMaskDelta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the crc whose masked representation is masked_crc.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Unmask</span><span class="params">(<span class="type">uint32_t</span> masked_crc)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> rot = masked_crc - kMaskDelta;</span><br><span class="line">  <span class="keyword">return</span> ((rot &gt;&gt; <span class="number">17</span>) | (rot &lt;&lt; <span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s an interesting point here: after swapping the high 15 bits of the original CRC32 value and adding a constant, it might exceed the maximum value of uint32_t, <strong>causing overflow</strong>. <strong>In C++, the overflow behavior of unsigned integers is well-defined and handled as modulo operation</strong>. For example, if the current crc is 32767, after shifting and adding the constant, the result is 7021325016, which becomes 2726357720 after taking modulo $ 2^{32} $. The subtraction operation in Unmask will also overflow, which is handled as a modulo operation in C++ as well. Here, $ 2726357720-kMaskDelta &#x3D; -131072 $ becomes 4294836224 after taking modulo $ 2^{32} $, and after swapping the high and low bits, we get back the original CRC 32767. So <strong>the overflow here won’t cause any bugs</strong>.</p><h2 id="Integer-Encoding-and-Decoding"><a href="#Integer-Encoding-and-Decoding" class="headerlink" title="Integer Encoding and Decoding"></a>Integer Encoding and Decoding</h2><p>LevelDB often needs to store numbers in byte streams or parse numbers from byte streams, such as storing length information in keys or sequence numbers in batch write tasks. In <a href="https://github.com/google/leveldb/blob/main/util/coding.h">util&#x2F;coding.h</a>, a series of encoding and decoding utility functions are defined to facilitate storing and parsing numbers in byte streams. First, let’s look at fixed-length encoding and decoding, which mainly includes the following functions:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed32</span><span class="params">(std::string* dst, <span class="type">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed64</span><span class="params">(std::string* dst, <span class="type">uint64_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> value)</span></span>;</span><br></pre></td></tr></table></figure><p>Taking 32-bit encoding as an example, the <code>PutFixed32</code> function encodes a 32-bit unsigned integer value into 4 bytes and then appends it to the end of the dst string. The <code>EncodeFixed32</code> function encodes value into 4 bytes and stores them in the memory pointed to by dst. PutFixed32 is based on EncodeFixed32 at the bottom layer, but it appends the result to the dst string.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint8_t</span>* <span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  buffer[<span class="number">0</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value);</span><br><span class="line">  buffer[<span class="number">1</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buffer[<span class="number">2</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  buffer[<span class="number">3</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First, <code>reinterpret_cast&lt;uint8_t*&gt;(dst)</code> converts the <code>char*</code> type pointer to a <code>uint8_t*</code> type, allowing direct manipulation of individual bytes. Then, using shift and mask operations, each byte of value is written into the buffer array separately, with <strong>value’s low-order bytes stored at low addresses (little-endian)</strong>. Suppose we have a uint32_t value 0x12345678 (in hexadecimal), and we want to encode this value into a character array and then decode it back from the array.</p><ul><li>buffer[0] stores the lowest 8 bits of value, i.e., 0x78.</li><li>buffer[1] stores the second lowest 8 bits of value, i.e., 0x56.</li><li>buffer[2] stores the second highest 8 bits of value, i.e., 0x34.</li><li>buffer[3] stores the highest 8 bits of value, i.e., 0x12.</li></ul><p>After encoding, the content in dst will be: <code>78 56 34 12</code>. The decoding process is to combine these 4 bytes in the reverse order to obtain the original value.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">DecodeFixed32</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* <span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / ldr instruction.</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">0</span>])) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In addition to encoding integers as fixed-length bytes, LevelDB also supports using variable-length integer (Varint) encoding to store numbers. This is because often, the values that need to be stored have a wide range but are frequently small, and using 4 bytes to store all integers would be wasteful. Varint is an efficient data compression method where smaller values occupy fewer bytes, saving space.</p><p>The principle of Varint is simple: it uses one or more bytes to store integers, where <strong>the highest bit (8th bit) of each byte is used to indicate whether there are more bytes</strong>. If this bit is 1, it means there are more bytes; if it’s 0, it means this is the last byte. The remaining 7 bits are used to store the actual numeric value. The following table shows the Varint encoding from one to three bytes (more bytes follow a similar pattern, not listed here):</p><table><thead><tr><th>Value Range</th><th>Varint Byte Expression</th></tr></thead><tbody><tr><td>1-127</td><td>0xxxxxxx</td></tr><tr><td>128-16383</td><td>1xxxxxxx 0xxxxxxx</td></tr><tr><td>16384-2097151</td><td>1xxxxxxx 1xxxxxxx 0xxxxxxx</td></tr></tbody></table><p>In the specific implementation, EncodeVarint32 and EncodeVarint64 differ slightly. The 32-bit version first determines the number of bytes needed and then hard-codes the writing. The 64-bit version uses a loop to write, processing 7 bits each time until the value is less than 128.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="type">uint8_t</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Of course, this is encoding, and there’s a corresponding implementation for decoding Varint from byte streams. The main implementation is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetVarint64Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">const</span> <span class="type">char</span>* limit, <span class="type">uint64_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">63</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> byte = *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is the reverse process of encoding. After successfully decoding an integer, it returns a new pointer pointing to the position in the byte stream immediately following the decoded integer. The GetVarint64 function uses this implementation. After parsing a 64-bit integer from input, it also updates the state of input, <strong>making it point to the remaining unprocessed data</strong>. Updating the byte stream here is very useful for continuously processing multiple data items in a data stream, for example, when parsing a data stream composed of multiple Varint-encoded integers, input is updated after each call to GetVarint64, ready to parse the next integer.</p><p>There’s also a class of helper functions, such as PutLengthPrefixedSlice for encoding a string as a combination of a length prefix and string content, and GetLengthPrefixedSlice as the corresponding decoding function. These encoding and decoding functions are widely used in LevelDB for storing and parsing various data structures, such as keys and values in memtable, block data in SSTable files, etc.</p><p>The integer encoding and decoding here are accompanied by a large number of test cases, placed in <a href="https://github.com/google/leveldb/blob/main/util/coding_test.cc">util&#x2F;coding_test.cc</a>. There are normal encoding and verification tests, such as Fixed32 encoding and decoding verification for 0 to 100000. In addition, there are some <strong>abnormal tests</strong>, such as the Varint32Overflow decoding case for incorrect Varint32, using GetVarint32Ptr to decode “\x81\x82\x83\x84\x85\x11”.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>The utils components in LevelDB are all designed to better adapt to LevelDB’s usage scenarios. For example, the Arena memory allocator is suitable for a large number of small memory allocations in memtable, the Random number generator is used for generating skip list heights, CRC32 is used for error detection during data transmission or storage, and encoding&#x2F;decoding utility functions are used for storing and parsing numbers.</p><p>This article only briefly introduces the implementation of these components and doesn’t delve too much into the mathematical knowledge behind these components, such as the linear congruential algorithm of the random number generator and the polynomial division of CRC32. If you’re interested, you can continue to explore these topics in depth.</p>]]></content:encoded>
      
      
      <category domain="https://selfboot.cn/categories/Source-Code-Analysis/">Source Code Analysis</category>
      
      
      <category domain="https://selfboot.cn/tags/C/">C++</category>
      
      <category domain="https://selfboot.cn/tags/LevelDB/">LevelDB</category>
      
      
      <comments>https://selfboot.cn/en/2024/08/29/leveldb_source_utils/#disqus_thread</comments>
      
    </item>
    
    
    
    
    
    <item>
      <title>LevelDB Explained - How To Read and Write WAL Logs</title>
      <link>https://selfboot.cn/en/2024/08/14/leveldb_source_wal_log/</link>
      <guid>https://selfboot.cn/en/2024/08/14/leveldb_source_wal_log/</guid>
      <pubDate>Wed, 14 Aug 2024 21:05:31 GMT</pubDate>
      
      <description>This article explores the Write-Ahead Logging (WAL) log read and write interfaces in LevelDB. It provides a detailed analysis of the WAL log writing process, including data segmentation, record format, and storage methods. It also explains the complex logic of log reading, including how to handle cross-block records and abnormal situations. Additionally, it showcases relevant test cases to verify the correctness of WAL logs in various scenarios.</description>
      
      
      
      <content:encoded><![CDATA[<p>LevelDB uses Write-Ahead Logging (WAL) to ensure data durability. When a write operation occurs, LevelDB first writes the data to the log file, and then applies it to the in-memory data structure (such as MemTable). When the system or database restarts after a crash, LevelDB checks the records in the WAL log file. By reading and replaying these log records, LevelDB can rebuild the data state that had not been fully written to disk when the crash occurred.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_leveldb_source_wal_log_cover.svg" alt="LevelDB WAL Log Writing Process"></p><p>The overall WAL log-related operation process is as follows:</p><ol><li>LevelDB first writes the data to the WAL log. This ensures that the data won’t be lost even in the event of a system crash.</li><li>The data is written to the MemTable in memory, which is a fast memory operation.</li><li>LevelDB confirms the write completion to the client.</li><li>Over time, when the MemTable is full, it is flushed to SSTable files on disk.</li><li>Once the MemTable has been successfully flushed to SSTable, the corresponding WAL log can be cleared.</li></ol><p>Let’s take a detailed look at the implementation.</p><span id="more"></span><h2 id="Writing-WAL-Logs"><a href="#Writing-WAL-Logs" class="headerlink" title="Writing WAL Logs"></a>Writing WAL Logs</h2><p>First, let’s see how LevelDB writes WAL logs. In LevelDB, a Writer class is defined in <a href="https://github.com/google/leveldb/blob/main/db/log_writer.h">db&#x2F;log_writer.h</a> for writing to WAL log files. The main method of the Writer class is <code>AddRecord</code>, used to append a record to the log file. The main data member is <code>WritableFile* dest_;</code>, which points to the log file that supports append writes. Here, WritableFile is an abstract class interface defined in <a href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h#L277">include&#x2F;leveldb&#x2F;env.h</a>, used to encapsulate sequential file write operations. For specific interfaces and implementations, refer to <a href="https://selfboot.cn/en/2024/08/02/leveldb_source_env_posixfile/#%E9%A1%BA%E5%BA%8F%E5%86%99%E6%96%87%E4%BB%B6">LevelDB Source Code Reading: Posix File Operation Interface Implementation Details</a>.</p><p>The main implementation of WAL log writing is in the <a href="https://github.com/google/leveldb/blob/main/db/log_writer.cc">db&#x2F;log_writer.cc</a> file, and the overall process is quite clear. The AddRecord method handles data of different sizes, ensuring they are segmented according to the correct format and type, and then calls <a href="https://github.com/google/leveldb/blob/main/db/log_writer.cc#L82">EmitPhysicalRecord</a> to set the header and store a single record.</p><h3 id="Single-Record-Storage-Format"><a href="#Single-Record-Storage-Format" class="headerlink" title="Single Record Storage Format"></a>Single Record Storage Format</h3><p>The single record storage format is quite clear, with a complete implementation in EmitPhysicalRecord. Each record consists of two parts: a <strong>fixed-length 7-byte</strong> Header and a Data part of variable length. The Header part includes 1 byte for record type, 2 bytes for record length, and 4 bytes for checksum. Specifically:</p><ul><li>Record Type: Identifies whether it’s a complete record, first part, middle part, or last part.</li><li>Length: The length of a single record, referring to the length of the data part, not including the header length. The maximum length of a single record is kBlockSize - kHeaderSize, which can be adequately expressed with 2 bytes.</li><li>CRC32: Cyclic redundancy check code, used to check if the data has changed during storage or transmission.</li></ul><p>As shown in the following diagram:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+--------------------------------------------------+</span><br><span class="line">|     Header      |                     Data/Payload                  |</span><br><span class="line">+-----------------+--------------------------------------------------+</span><br><span class="line">| Record Type (1B)| Actual data written by the application...         |</span><br><span class="line">| Length (2B)     |                                                  |</span><br><span class="line">| CRC (4B)        |                                                  |</span><br><span class="line">+-----------------+--------------------------------------------------+</span><br></pre></td></tr></table></figure><p>The implementation of writing a single record is as follows. First, it calculates the values of each field in the header, then writes the header and data parts to the log file.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="type">const</span> <span class="type">char</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="type">char</span> buf[kHeaderSize];</span><br><span class="line">  buf[<span class="number">4</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(t);</span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="type">uint32_t</span> crc = crc32c::<span class="built_in">Extend</span>(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::<span class="built_in">Mask</span>(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">  <span class="built_in">EncodeFixed32</span>(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(ptr, length));</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = dest_-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When calculating the CRC32 here, it uses <code>type_crc_[t]</code>. This array is initialized in the Writer’s constructor using the InitTypeCrc function, which can improve calculation efficiency and avoid recalculating the CRC32 checksum each time a record is written. If the type_crc_ array is not initialized, you could also use <code>crc32c::Extend(0, ptr, length)</code> to calculate the CRC checksum. However, this would only calculate the CRC checksum for the data part, without considering the <strong>record type</strong>. By using type_crc_, the record type is used as the initial value for the crc32 calculation, so that even for the same content, if the types are different, the calculated crc32 will also be different.</p><p>We’ve mentioned record types here, and the code also records a <code>block_offset_</code>. What are these used for? This is the <strong>data segmentation logic</strong> done in AddRecord.</p><h3 id="Data-Segmentation-Records"><a href="#Data-Segmentation-Records" class="headerlink" title="Data Segmentation Records"></a>Data Segmentation Records</h3><p><strong>When writing data, if a single piece of data is too large, LevelDB will segment the data into multiple records and write them bit by bit</strong>. After segmentation, one piece of data may include multiple records, so it’s necessary to design a good <strong>record organization format</strong> to correctly rebuild the complete data when reading. LevelDB’s approach here is quite direct: it adds a record type to each record to identify whether it’s a complete record, first part, middle part, or last part. This way, when reading, the data can be assembled in the order of the record types. A piece of data might be segmented in the following ways:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first(R1), middle(R1), middle(R1), ..., last(R1)</span><br><span class="line">first(R2), last(R2)</span><br><span class="line">full(R3)</span><br></pre></td></tr></table></figure><p>Here, first, middle, last, and full represent the types of records. All records are placed in <strong>logical blocks</strong>, with the size of a logical block being kBlockSize (32768&#x3D;32KB), which is defined in <a href="https://github.com/google/leveldb/blob/main/db/log_format.h#L27">db&#x2F;log_format.h</a>. When segmenting data, it ensures that <strong>a single record does not span logical blocks</strong>. The overall logic for segmenting records is implemented in AddRecord, mainly based on the size of the data, the remaining space in the current logical block, and then determining whether segmentation is needed. For scenarios requiring segmentation, the data is segmented into records, the correct record type is set, and then EmitPhysicalRecord is called to write them one by one. The core code is as follows, with some comments and assert validation logic removed:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="type">const</span> Slice&amp; slice)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ptr = slice.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">size_t</span> left = slice.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="type">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="built_in">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(<span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="built_in">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that for data of length 0, a record will still be written here, with the record type as fulltype, and the record only containing a header without a data part. There are specific test cases to verify this situation. Also, note that if after writing some records, the remaining space in the current logical block is less than 7, not enough to write a Header, it will fill the remaining space with <code>\x00</code> and then switch to the next logical block.</p><p>The <strong>implementation of determining the current record type is quite clever</strong> here, only needing to maintain two flags: begin and end. When starting to write data, begin is true, and after writing a record, begin is updated to false. The update of end is determined by whether the remaining data length is 0. Then, based on the values of begin and end, the current record type can be determined. Note that the order of if-else here is also crucial: if it’s both begin and end, it indicates a kFullType record; then if it’s only begin, it’s kFirstType; if it’s only end, it’s kLastType; in other cases, it’s kMiddleType.</p><p>There’s a design here worth considering: <strong>why not cross logical blocks when segmenting records</strong>? In fact, if you look at the code for reading WAL logs later, you’ll find that this design allows for block-by-block reading. <strong>Records within each block are complete, which means there’s no need to handle records spanning blocks, greatly simplifying the reading logic</strong>. Additionally, if a block is damaged, it will only affect the records within that block, not the records in other blocks.</p><p>So far, we’ve introduced the process of writing data to WAL log files. Next, let’s look at how to read WAL log files.</p><h2 id="Reading-WAL-Logs"><a href="#Reading-WAL-Logs" class="headerlink" title="Reading WAL Logs"></a>Reading WAL Logs</h2><p>Compared to segmenting data into records and then writing to log files, the logic for reading logs and reconstructing data is slightly more complex. The <a href="https://github.com/google/leveldb/blob/main/db/log_reader.h#L20">db&#x2F;log_reader.h</a> defines a Reader class for reading data from log files. The main data member of Reader is <code>SequentialFile* const file_;</code>, which points to a <strong>log file that supports sequential reading</strong>. Similar to WritableFile, SequentialFile is also an abstract class interface defined in include&#x2F;leveldb&#x2F;env.h, encapsulating the sequential read operations of the file system. For specific interfaces and implementations, refer to <a href="https://selfboot.cn/en/2024/08/02/leveldb_source_env_posixfile/#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%96%87%E4%BB%B6">LevelDB Source Code Reading: Posix File Operation Interface Implementation Details</a>.</p><p>The main method of the Reader class is <code>ReadRecord</code>, used to read a complete piece of data. It can be called multiple times to sequentially read all the data. If some unexpected data occurs during the reading process, such as invalid record length or CRC check failure, the Reporter interface defined in Reader can be used to record error information. Additionally, Reader supports skipping a certain length of data in the file, used to skip over already read data when recovering data. The complete implementation is in <a href="https://github.com/google/leveldb/blob/main/db/log_reader.cc">db&#x2F;log_reader.cc</a>, let’s take a detailed look.</p><h3 id="Skipping-Initial-Data"><a href="#Skipping-Initial-Data" class="headerlink" title="Skipping Initial Data"></a>Skipping Initial Data</h3><p>Reader has a last_record_offset_ that records the offset of the latest complete data read, initialized to 0. Subsequently, each time a record of type kFullType or kLastType is read, this value is updated. At the entrance of ReadRecord, it first compares the size of last_record_offset_ and initial_offset_. Here, initial_offset_ is passed in during construction, used to specify the length of data to skip reading. If last_record_offset_ is less than initial_offset_, it needs to skip the initial_offset_ part at the beginning of the file. The implementation of skipping the beginning part is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::SkipToInitialBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> offset_in_block = initial_offset_ % kBlockSize;</span><br><span class="line">  <span class="type">uint64_t</span> block_start_location = initial_offset_ - offset_in_block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t search a block if we&#x27;d be in the trailer</span></span><br><span class="line">  <span class="keyword">if</span> (offset_in_block &gt; kBlockSize - <span class="number">6</span>) &#123;</span><br><span class="line">    block_start_location += kBlockSize;</span><br><span class="line">  &#125;</span><br><span class="line">  end_of_buffer_offset_ = block_start_location;</span><br><span class="line">  <span class="comment">// Skip to start of first block that can contain the initial record</span></span><br><span class="line">  <span class="keyword">if</span> (block_start_location &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Status skip_status = file_-&gt;<span class="built_in">Skip</span>(block_start_location);</span><br><span class="line">    <span class="keyword">if</span> (!skip_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReportDrop</span>(block_start_location, skip_status);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s a special case here: if initial_offset_ happens to be at the end of a logical block, the entire logical block needs to be skipped. Determining whether it’s at the end of a logical block is simple: take the modulus of initial_offset_ with the size of the logical block (32kb), and if the remaining part is just within the last 6 bytes of the logical block, it’s considered to be at the end of the logical block. Note that when skipping, it will only skip entire logical blocks, ensuring reading starts from the <strong>head of the logical block</strong> containing initial_offset_. This may cause the offset of the first record read to be smaller than initial_offset_, which will be handled later in ReadPhysicalRecord.</p><h3 id="Parsing-a-Complete-Piece-of-Data"><a href="#Parsing-a-Complete-Piece-of-Data" class="headerlink" title="Parsing a Complete Piece of Data"></a>Parsing a Complete Piece of Data</h3><p>ReadRecord is used to read a complete piece of data from the log file. Here, a complete piece of data may include multiple records, each of which needs to be read out and then concatenated.</p><p>First, <strong>in_fragmented_record</strong> is used to mark whether we’re currently in a <strong>fragmented record</strong>, initialized to false. Then it enters a while loop, continuously calling ReadPhysicalRecord to read out records, saving them in fragment, and then processing them according to the record type. Note that there’s a <code>resyncing_</code> here, which is set to true during initialization if there’s data to be skipped (initial_offset_&gt;0), indicating that it’s currently in a state of skipping data. In this state, as long as a record of type kFullType is read, resyncing_ will be updated to false, indicating the end of data skipping and the start of normal data reading.</p><p>When reading data, it will determine whether data needs to be concatenated based on the current record type.</p><ul><li>If it’s of type kFullType, it means this is a complete piece of data. fragment is directly set as result, and last_record_offset_ is updated.</li><li>If it’s of type kFirstType, it means this is the beginning of a new piece of data. This record is saved in scratch, and in_fragmented_record is set to true.</li><li>If it’s of type kMiddleType, it means this is a middle part of a piece of data. in_fragmented_record must be true at this time, otherwise an error is reported. In this case, scratch continues to concatenate new records.</li><li>If it’s of type kLastType, it means this is the last part of a piece of data. in_fragmented_record must be true at this time, otherwise an error is reported. The last part of fragment is concatenated to scratch, then scratch is set as result, last_record_offset_ is updated, and it returns.</li></ul><p>There are also other record types, such as kEof and kBadRecord, which are abnormal situations and need special handling. The core logic of ReadRecord is as follows, with some error handling code omitted:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::ReadRecord</span><span class="params">(Slice* record, std::string* scratch)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  record-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">bool</span> in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">  Slice fragment;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> record_type = <span class="built_in">ReadPhysicalRecord</span>(&amp;fragment);</span><br><span class="line">    <span class="keyword">if</span> (resyncing_) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (record_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> kFullType:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *record = fragment;</span><br><span class="line">        last_record_offset_ = prospective_record_offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">case</span> kFirstType:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        scratch-&gt;<span class="built_in">assign</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        in_fragmented_record = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kMiddleType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(1)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kLastType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(2)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">          *record = <span class="built_in">Slice</span>(*scratch);</span><br><span class="line">          last_record_offset_ = prospective_record_offset;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reading-a-Single-Logical-Block"><a href="#Reading-a-Single-Logical-Block" class="headerlink" title="Reading a Single Logical Block"></a>Reading a Single Logical Block</h3><p>ReadPhysicalRecord <strong>encapsulates the process of extracting records from logical blocks</strong>. The size of a logical block is kBlockSize&#x3D;32KB, which is defined in <a href="https://github.com/google/leveldb/blob/main/db/log_format.h#L27">db&#x2F;log_format.h</a>. When we read files from disk, we <strong>use logical blocks as the minimum reading unit</strong>, read them into memory cache, and then parse the records one by one. Here, the outermost layer is a while loop. It first checks the size of buffer_. If the data in buffer_ is not enough to parse out a record (length less than kHeaderSize), it reads a logical block of data from the file into buffer_.</p><ul><li>If the length read from the file is less than kBlockSize, it means it has reached the end of the file. In this case, eof_ is set to true, then it continues into the loop, clears the data in buffer_, and returns kEof.</li><li>If there’s an error reading the file, it reports the read failure using ReportDrop, clears buffer_, sets eof_ to true, and then directly returns kEof.</li><li>If it successfully reads kBlockSize of content into buffer_, it proceeds to parse the records.</li></ul><p>Of course, there might be multiple records in a logical block Block. ReadPhysicalRecord returns after parsing each record. Before returning, it updates the pointer of buffer_ to point to the start position of the next record. When re-entering ReadPhysicalRecord, if it finds there are still records in buffer_ (length greater than kHeaderSize), it won’t read from the file but directly parse from buffer_ continuing from the last position.</p><p>The specific code for parsing records is the opposite of writing records above. It first parses information such as length and crc32 from the Header, then saves the record data in result, and finally updates the data of buffer_ to point to the start position of the next record.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Reader::ReadPhysicalRecord</span><span class="params">(Slice* result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer_.<span class="built_in">size</span>() &lt; kHeaderSize) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* header = buffer_.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">4</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">5</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> type = header[<span class="number">6</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    buffer_.<span class="built_in">remove_prefix</span>(kHeaderSize + length);    <span class="comment">// Point to the start position of the next record</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *result = <span class="built_in">Slice</span>(header + kHeaderSize, length);</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>The code above omitted some exception handling logic, such as invalid record length and CRC check failure. The exception handling here mainly uses the Reporter interface to record error information and then clear buffer_. This way, even if some exceptions occur during the reading process, it will at most affect the current buffer_ parsing without affecting the reading and parsing of subsequent logical blocks.</p><p>There’s another exception: <strong>when the current record is within the skipped initial_offset_ range</strong>. This is because when we skipped earlier, we only skipped entire logical blocks, ensuring reading starts from the <strong>head of the logical block</strong> containing initial_offset_. If the offset of the current record is less than initial_offset_, it means this record needs to be skipped. In this case, it adjusts the starting part of buffer_ and returns kBadRecord.</p><h2 id="WAL-Read-and-Write-Testing"><a href="#WAL-Read-and-Write-Testing" class="headerlink" title="WAL Read and Write Testing"></a>WAL Read and Write Testing</h2><p><a href="https://github.com/google/leveldb/blob/main/db/log_test.cc">db&#x2F;log_test.cc</a> provides some utility helper classes and functions, as well as detailed test cases, to fully test the WAL log reading and writing here. For example, BigString is used to generate strings of specified length, and the LogTest class encapsulates the read and write logic of Reader and Writer, exposing convenient interfaces for testing, such as Write, ShrinkSize, Read, etc. Additionally, it doesn’t directly read files but implements a StringSource class inheriting from SequentialFile, using string to simulate file reading. It also implements a StringDest class inheriting from WritableFile, using string to simulate file writing.</p><p>Here are some test cases for normal reading and writing:</p><ul><li>Empty: Tests reading an empty file directly, returning EOF.</li><li>ReadWrite: Tests simple writing and reading, ensuring that written data can be correctly read. Here, an empty string is written and can be normally read out.</li><li>ManyBlocks: Tests writing a large number of strings of different lengths, occupying multiple logical blocks. Then reads them one by one to ensure they can be correctly read.</li><li>Fragmentation: Tests writing extremely large strings, where each piece of data needs to occupy multiple records. Then reads them one by one to ensure they can be correctly read.</li></ul><p>In addition, some test cases for abnormal situations are constructed. For example, TruncatedTrailingRecordIsIgnored is used in LevelDB’s log system to verify the handling of <strong>truncated records at the end of log files</strong>. When the last record of a log file is not completely written (for example, due to system crash or other write interruption events), this incomplete record should be ignored rather than treated as an error.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(LogTest, TruncatedTrailingRecordIsIgnored) &#123;</span><br><span class="line">  <span class="built_in">Write</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="built_in">ShrinkSize</span>(<span class="number">4</span>);  <span class="comment">// Drop all payload as well as a header byte</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;EOF&quot;</span>, <span class="built_in">Read</span>());</span><br><span class="line">  <span class="comment">// Truncated last record is ignored, not treated as an error.</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">0</span>, <span class="built_in">DroppedBytes</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;&quot;</span>, <span class="built_in">ReportMessage</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BadLength is used to verify the behavior when dealing with corrupted record length fields. The test ensures that the log system can correctly identify and ignore invalid records caused by <strong>errors in the record length field</strong>, while being able to continue reading subsequent valid records and report appropriate error messages.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(LogTest, BadLength) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> kPayloadSize = kBlockSize - kHeaderSize;</span><br><span class="line">  <span class="built_in">Write</span>(<span class="built_in">BigString</span>(<span class="string">&quot;bar&quot;</span>, kPayloadSize));</span><br><span class="line">  <span class="built_in">Write</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="comment">// Least significant size byte is stored in header[4].</span></span><br><span class="line">  <span class="built_in">IncrementByte</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;foo&quot;</span>, <span class="built_in">Read</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kBlockSize, <span class="built_in">DroppedBytes</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;OK&quot;</span>, <span class="built_in">MatchError</span>(<span class="string">&quot;bad record length&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, IncrementByte is used to increase the value at the 4th byte by 1. This position stores the length information of the record, thus causing the record length to increase. When reading, it will find that the record length is invalid and then report an error message. The logic for checking the length is in ReadPhysicalRecord, as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kHeaderSize + length &gt; buffer_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  <span class="type">size_t</span> drop_size = buffer_.<span class="built_in">size</span>();</span><br><span class="line">  buffer_.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">if</span> (!eof_) &#123;</span><br><span class="line">    <span class="built_in">ReportCorruption</span>(drop_size, <span class="string">&quot;bad record length&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kBadRecord;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> kEof;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In addition, a large number of test cases are constructed to verify the initial skip length. A function CheckInitialOffsetRecord is encapsulated here to verify whether the records with initial skip length are correctly skipped. This function will write some records, then set initial_offset_ to read records, verifying whether records of initial_offset_ length have been skipped.</p><p>Through a large number of test cases, the correctness of the WAL log read and write logic is ensured. The test cases here are also very worth learning, as they can help us better understand the read and write logic of WAL logs.</p>]]></content:encoded>
      
      
      <category domain="https://selfboot.cn/categories/Source-Code-Analysis/">Source Code Analysis</category>
      
      
      <category domain="https://selfboot.cn/tags/C/">C++</category>
      
      <category domain="https://selfboot.cn/tags/LevelDB/">LevelDB</category>
      
      
      <comments>https://selfboot.cn/en/2024/08/14/leveldb_source_wal_log/#disqus_thread</comments>
      
    </item>
    
    
    
    
    
    <item>
      <title>LevelDB Explained -  Understanding Advanced C++ Techniques</title>
      <link>https://selfboot.cn/en/2024/08/13/leveldb_source_unstand_c++/</link>
      <guid>https://selfboot.cn/en/2024/08/13/leveldb_source_unstand_c++/</guid>
      <pubDate>Tue, 13 Aug 2024 21:00:00 GMT</pubDate>
      
      <description>This article delves into the advanced C++ techniques used in LevelDB, including flexible arrays, symbol exporting for linking, and the Pimpl class design. Through specific code examples, it explains in detail how to implement variable-length data structures using flexible arrays, optimizing memory usage and reducing memory fragmentation. It also introduces different methods of symbol exporting and their importance for cross-platform compilation, as well as the application of the Pimpl design pattern in encapsulation and binary compatibility.</description>
      
      
      
      <content:encoded><![CDATA[<p>The overall code of LevelDB is quite understandable, <strong>without using many esoteric C++ techniques</strong>. However, there are some implementations that are relatively uncommon, such as flexible arrays, symbol exporting for linking, and Pimpl class design. This article will review these advanced C++ techniques to help better understand the implementation of LevelDB.</p><h2 id="Flexible-Arrays"><a href="#Flexible-Arrays" class="headerlink" title="Flexible Arrays"></a>Flexible Arrays</h2><p>In the LRUHandle structure definition in <a href="https://github.com/google/leveldb/blob/main/util/cache.cc">util&#x2F;cache.cc</a>, there’s a flexible array member <code>char key_data[1]</code>, used to implement <strong>variable-length data structures</strong> in C&#x2F;C++.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LRUHandle</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>In this handle structure, <code>key_data[1]</code> is actually just a placeholder. The space actually allocated to <code>key_data</code> is larger than 1 byte, determined by the total_size calculated during malloc. Specifically, in LevelDB’s implementation, when inserting a new cache entry, memory is dynamically allocated based on the length of the key, and then the content of the key is copied into this memory. The code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash, <span class="type">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">void</span> (*deleter)(<span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// Calculate the total memory size needed. Note that 1 is subtracted here because key_data[1] is a placeholder, already having one byte</span></span><br><span class="line">  LRUHandle* e = <span class="built_in">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  <span class="comment">// Copy key data into key_data</span></span><br><span class="line">  std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// ... omitted</span></span><br></pre></td></tr></table></figure><p>The code above allocates <strong>contiguous memory</strong> for both the LRUHandle structure and the trailing key_data array in a single malloc call. This avoids allocating memory separately for the key data, thereby <strong>reducing additional memory allocation overhead and potential memory fragmentation issues</strong>. At the same time, the entire data structure of LRUHandle is compactly stored in a contiguous block of memory, improving space utilization and potentially enhancing cache locality. If std::vector or std::string were used instead, it would require two memory allocations for each LRUHandle object: one for the LRUHandle object itself, and one for the dynamically allocated memory by std::vector or std::string to store the data. In a high-performance database implementation, such memory allocation overhead is not negligible.</p><p>Furthermore, the array length at the end of the structure here is 1. In many other code examples, <strong>the trailing array length is 0 or not written at all</strong>. What’s the difference between these two methods? In fact, both approaches are used to add variable-length data at the end of a structure. <code>char key_data[];</code> is a more explicit way of declaring a trailing array, directly indicating that the array itself doesn’t allocate any space, introduced in the C99 standard. However, this declaration is not legal in some standard C++ versions, although some compilers may support it as an extension. In C++, to avoid compatibility issues, it’s usually recommended to use <code>char key_data[1];</code>, as it typically has better support in compilers.</p><p>There are some discussions about this that you can refer to: <a href="https://stackoverflow.com/questions/14643406/whats-the-need-of-array-with-zero-elements">What’s the need of array with zero elements?</a> and <a href="https://stackoverflow.com/questions/4559558/one-element-array-in-struct">One element array in struct</a>.</p><h2 id="Symbol-Exporting-for-Linking"><a href="#Symbol-Exporting-for-Linking" class="headerlink" title="Symbol Exporting for Linking"></a>Symbol Exporting for Linking</h2><p>In many classes in include&#x2F;leveldb, such as the <a href="https://github.com/google/leveldb/blob/main/include/leveldb/db.h#L46">DB class</a> in <a href="https://github.com/google/leveldb/blob/main/include/leveldb/db.h">db.h</a>, the definition includes a macro <code>LEVELDB_EXPORT</code>, as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> DB &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The definition of this macro is in <a href="https://github.com/google/leveldb/blob/main/include/leveldb/export.h">include&#x2F;leveldb&#x2F;export.h</a>, with many compilation option branches. For ease of reading, indentation has been added below (the actual code doesn’t have it):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LEVELDB_EXPORT)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_SHARED_LIBRARY)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> defined(_WIN32)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_COMPILE_LIBRARY)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __declspec(dllexport)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __declspec(dllimport)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(LEVELDB_COMPILE_LIBRARY)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span>  <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_COMPILE_LIBRARY)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __attribute__((visibility(<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span>  <span class="comment">// defined(LEVELDB_SHARED_LIBRARY)</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(LEVELDB_EXPORT)</span></span></span><br></pre></td></tr></table></figure><p>We know that leveldb itself doesn’t provide database services like MySQL or PostgreSQL; it’s just a library that we can link to for reading and writing data. To export leveldb as a dynamic link library, it’s necessary to control the visibility and linking attributes of symbols. To support cross-platform builds, different attributes are specified based on different platform information.</p><p>On Linux systems, when compiling the library, if LEVELDB_COMPILE_LIBRARY is defined, the <code>__attribute__((visibility(&quot;default&quot;)))</code> attribute will be added. This sets the linking visibility of the symbol to default, so that other code linking to this shared library can use this class.</p><p>What’s the problem if we don’t use this macro to export symbols? In the Linux environment, <strong>all symbols are visible by default</strong>, which will export more symbols. This not only increases the size of the library but may also conflict with symbols in other libraries. Hiding some symbols that are not intended for public use can help the linker optimize the program, <strong>improving loading speed and reducing memory usage</strong>. Moreover, through export macros, we can explicitly control which interfaces are public and which are private, <strong>hiding implementation details to achieve good encapsulation</strong>.</p><p>When <code>LEVELDB_SHARED_LIBRARY</code> is not defined, the LEVELDB_EXPORT macro <strong>is defined as empty</strong>, which means that when leveldb is compiled as a static library, all symbols that might otherwise need special export&#x2F;import markers don’t need such markers. In the case of static linking, symbol exporting is not necessary for the linking process because the code of the static library will be directly included in the final binary file during compilation.</p><h2 id="Pimpl-Class-Design"><a href="#Pimpl-Class-Design" class="headerlink" title="Pimpl Class Design"></a>Pimpl Class Design</h2><p>In many classes in LevelDB, there is only one private member variable of pointer type. For example, in the TableBuild class definition in the include&#x2F;leveldb&#x2F;table_builder.h header file, there is a private member variable Rep *rep_, which is a pointer to the Rep structure:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Rep</span>;</span><br><span class="line"> Rep* rep_;</span><br></pre></td></tr></table></figure><p>Then in the <a href="https://github.com/google/leveldb/blob/main/table/table_builder.cc">table&#x2F;table_builder.cc</a> file, the Rep structure is defined:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TableBuilder</span>::Rep &#123;</span><br><span class="line">  <span class="built_in">Rep</span>(<span class="type">const</span> Options&amp; opt, WritableFile* f)</span><br><span class="line">      : <span class="built_in">options</span>(opt),</span><br><span class="line">        <span class="built_in">index_block_options</span>(opt),</span><br><span class="line">        <span class="built_in">file</span>(f),</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><strong>Why not directly define the Rep structure in the header file</strong>? In fact, this is using the <strong>Pimpl (Pointer to Implementation)</strong> design pattern, which has several advantages:</p><ul><li><strong>Binary compatibility</strong> (ABI stability). When the TableBuilder class library is updated, as long as its interface (.h file) remains unchanged, even if members are added to the Rep structure in the implementation or the implementation of the interface is changed, applications depending on this library <strong>only need to update the dynamic library file, without recompilation</strong>. If binary compatibility is not achieved, for example, if some member variables are added to a public class, and the application only updates the dynamic library without recompiling, it will cause the program to crash at runtime due to inconsistent object memory distribution. You can refer to a similar problem encountered in a previous business scenario, <a href="https://selfboot.cn/en/2024/03/15/object_memory_coredump/">Analysis of C++ Process Coredump Caused by Missing Bazel Dependencies</a>.</li><li><strong>Reduced compilation dependencies</strong>. If the definition of the Rep structure is in the header file, any modification to the Rep structure would cause files that include table_builder.h to be recompiled. By putting the definition of the Rep structure in the source file, only table_builder.cc needs to be recompiled.</li><li><strong>Separation of interface and implementation</strong>. The interface (public methods defined in the .h file) and the implementation (the Rep structure and specific implementation defined in the .cc file) are completely separate. This allows developers to freely modify implementation details, such as adding new private member variables or modifying internal logic, without changing the public interface.</li></ul><p><strong>Why do these advantages exist after using member pointers</strong>? This comes down to the memory layout of C++ objects. The layout of an object of a class in memory is contiguous and directly includes all of its non-static member variables. If the member variables are simple types (like int, double, etc.) or objects of other classes, these members will be directly embedded into the object’s memory layout. You can refer to my previous article <a href="https://selfboot.cn/en/2024/05/10/c++_object_model/">In-depth Understanding of C++ Object Memory Layout with Examples</a> for more information.</p><p>When a member variable is a pointer to another class, its layout in memory is just a pointer (Impl* pImpl), not the specific class object. The <strong>size and alignment of this pointer are fixed, regardless of what data Impl contains</strong>. Therefore, no matter how the internal implementation of the class corresponding to the pointer changes (e.g., adding or removing data members, changing the types of members, etc.), the size and layout of the external class remain unchanged and unaffected.</p><p>In “Effective C++”, Item 31 mentions using this approach to reduce compilation dependencies:</p><blockquote><p>If you can accomplish a task with object references or pointers, don’t use objects. You can define references and pointers to a type with just a type declaration; but if you define objects of a type, you need the type’s definition.</p></blockquote><p>Of course, there’s no silver bullet in software development, and these advantages come with corresponding costs. Refer to <a href="https://en.cppreference.com/w/cpp/language/pimpl">cppreference.com: PImpl</a>:</p><ul><li><strong>Lifecycle management overhead (Runtime Overhead)</strong>: Pimpl typically requires dynamically allocating memory on the heap to store the implementation object (Impl object). This dynamic allocation is <strong>slower than allocating objects on the stack</strong> (usually a faster allocation method) and involves more complex memory management. Additionally, allocating memory on the heap can cause memory leaks if not released. However, in the above example, Rep is allocated during object construction and released during destruction, so it won’t cause memory leaks.</li><li><strong>Access overhead</strong>: Each time a private member function or variable is accessed through Pimpl, it requires indirect access through a pointer.</li><li><strong>Space overhead</strong>: Each class using Pimpl will add at least one pointer’s worth of space overhead in its object to store the implementation pointer. If the implementation part needs to access public members, additional pointers may be needed or pointers may need to be passed as parameters.</li></ul><p>Overall, Pimpl is a good design pattern for basic libraries. You can also refer to <a href="https://stackoverflow.com/questions/8972588/is-the-pimpl-idiom-really-used-in-practice">Is the PIMPL idiom really used in practice?</a> for more discussion.</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p><code>constexpr</code> specifies variables or functions used to declare constant expressions. The purpose of this declaration is to inform the compiler that <strong>this value or function is known at compile time</strong>, allowing for more optimization and checks during compilation.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kCacheSize = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>Compared to const, constexpr emphasizes compile-time constants, while const variables are initialized at the time of declaration, but they <strong>don’t necessarily have to be determined at compile time</strong>, usually just indicating that they cannot be modified at runtime.</p>]]></content:encoded>
      
      
      <category domain="https://selfboot.cn/categories/Source-Code-Analysis/">Source Code Analysis</category>
      
      
      <category domain="https://selfboot.cn/tags/C/">C++</category>
      
      <category domain="https://selfboot.cn/tags/LevelDB/">LevelDB</category>
      
      
      <comments>https://selfboot.cn/en/2024/08/13/leveldb_source_unstand_c++/#disqus_thread</comments>
      
    </item>
    
    
    
    
    
    <item>
      <title>LevelDB Explained - Bloom Filter Implementation and Visualization</title>
      <link>https://selfboot.cn/en/2024/08/08/leveldb_source_bloom_filter/</link>
      <guid>https://selfboot.cn/en/2024/08/08/leveldb_source_bloom_filter/</guid>
      <pubDate>Thu, 08 Aug 2024 11:38:52 GMT</pubDate>
      
      <description>This article provides a detailed introduction to the basic concepts, mathematical principles, and parameter selection of Bloom filters. It analyzes the specific implementation in LevelDB&#39;s source code, including hash function selection, filter creation, and query processes. The article also showcases LevelDB&#39;s Bloom filter test cases, verifying its correctness and performance. Additionally, it offers a visual demonstration of Bloom filters to help readers intuitively understand their working principles.</description>
      
      
      
      <content:encoded><![CDATA[<p>In LevelDB, data is stored in SSTable files. When using Get() to query a key, it may be necessary to read multiple blocks from the SST file. To reduce disk reads, LevelDB provides a FilterPolicy strategy. If it can determine that a key is not in the current SSTable file, it can skip reading that file, thus improving query efficiency.</p><p>LevelDB supports user-defined filter policies but provides a default Bloom filter implementation. A Bloom filter is a space-efficient data structure used to determine whether an element is a member of a set. It has a certain false positive rate but no false negatives. In simple terms, <strong>if a Bloom filter determines that an element does not exist, then the element definitely does not exist; if a Bloom filter determines that an element exists, then the element may not exist</strong>.</p><span id="more"></span><p>Using a Bloom filter in LevelDB is quite simple, as shown in the following code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Options options;</span><br><span class="line">options.filter_policy = <span class="built_in">NewBloomFilterPolicy</span>(<span class="number">10</span>);</span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;/tmp/testdb&quot;</span>, &amp;db);</span><br><span class="line"><span class="comment">// ... use the database ...</span></span><br><span class="line"><span class="keyword">delete</span> db;</span><br><span class="line"><span class="keyword">delete</span> options.filter_policy;</span><br></pre></td></tr></table></figure><p>So what are the principles behind Bloom filters? And how are they implemented in LevelDB? Let’s take a look together in this article.</p><h2 id="LevelDB-Interface-Definition"><a href="#LevelDB-Interface-Definition" class="headerlink" title="LevelDB Interface Definition"></a>LevelDB Interface Definition</h2><p>Before delving into the implementation details of Bloom filters, let’s first look at how LevelDB defines the filter interface.</p><p>LevelDB <strong>defines the interface for filter policies</strong> in <a href="https://github.com/google/leveldb/blob/main/include/leveldb/filter_policy.h">filter_policy.h</a>. FilterPolicy itself is an abstract class that defines 3 pure virtual functions as interfaces. It cannot be instantiated directly and must be implemented by subclasses.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">FilterPolicy</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, <span class="type">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::string* dst)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; filter)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>All three of these interfaces are important, and the code comments explain them in detail:</p><ul><li>Name(): Returns the name of the filter policy, which is <strong>very important for version compatibility</strong>. If the implementation of the filter policy (i.e., data structure or algorithm) changes, potentially causing incompatibility with old versions, the returned name should reflect this change to prevent old filter policies from being used incorrectly.</li><li>CreateFilter(): Used to create a filter, i.e., adding all keys in keys to the filter and then saving the content in dst.</li><li>KeyMayMatch(): Used to determine if a key exists in the filter, where filter is the dst generated by CreateFilter(). If the key exists in the filter, it must return true. <strong>If it doesn’t exist, it can return either true or false, but the probability of returning false should be as high as possible</strong>.</li></ul><p>Additionally, a factory function is provided to create a Bloom filter instance. However, one drawback is that after using the returned filter policy instance, you need to remember to manually release the resources. The use of a factory function here <strong>allows library maintainers to change the object creation process without affecting existing client code</strong>. For example, if a more efficient Bloom filter implementation is developed in the future, <strong>the factory function can simply be modified to return the new implementation without needing to modify the code that calls it. This provides convenience for future expansion and maintenance</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LEVELDB_EXPORT <span class="type">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="type">int</span> bits_per_key)</span></span>;</span><br></pre></td></tr></table></figure><p>By defining the filter policy interface and using a factory function, developers can easily implement different filter policies. To implement a new filter policy, you only need to inherit the <code>FilterPolicy</code> class and implement the corresponding methods. For the caller, they only need to pass the new filter policy to the <code>Options</code> object, and the overall changes will be relatively simple.</p><h2 id="Bloom-Filter-Principles"><a href="#Bloom-Filter-Principles" class="headerlink" title="Bloom Filter Principles"></a>Bloom Filter Principles</h2><p>LevelDB implemented its own Bloom filter as the default filter policy. Before we start looking at the implementation code, let’s first understand the principles of Bloom filters.</p><p>In 1970, Burton Howard Bloom created the <a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a>, an efficient data structure, to check whether an English word is in the dictionary for a spell checker. Its core is an m-bit bit array and k hash functions. The core operations are as follows:</p><ol><li>Initialization: At the start, the Bloom filter is an array of m bits, with each bit set to 0.</li><li>Adding elements: When adding an element to the Bloom filter, first use k hash functions to hash the element, producing k array position indices, then set all these positions to 1.</li><li>Querying elements: To check if an element is in the Bloom filter, use the same k hash functions to hash the element, obtaining k indices. If all these indices correspond to bits that are 1, then <strong>the element may exist in the set</strong>; if any bit is 0, then <strong>the element definitely does not exist in the set</strong>.</li></ol><p>From the above description, we can see that the time required to add or check whether an element is in the set is a fixed constant $ O( k )$, completely independent of the number of elements already in the set. Compared to other data structures representing sets, such as hash tables, balanced binary trees, skip lists, etc., in addition to fast lookup speed, Bloom filters are also very space-efficient as they don’t need to store the elements themselves, saving considerable space.</p><p>However, Bloom filters also have drawbacks. Careful consideration of the above process reveals that <strong>the query results of Bloom filters can be false positives</strong>. Bloom filters use multiple hash functions to process each element, setting multiple resulting positions to 1, <strong>and these positions may overlap with the hash results of other elements</strong>. Suppose a key does not exist in the set, but its hash results overlap with the hash results of other elements. In this case, the Bloom filter would determine that this key exists in the set, which is known as a false positive.</p><p>The probability that a Bloom filter incorrectly determines an element exists when it actually does not is called the false positive rate. Intuitively, <strong>for a fixed number k of hash functions, the larger the array size m, the fewer hash collisions, and thus the lower the false positive rate</strong>. To design a good Bloom filter ensuring a very low false positive rate, this qualitative analysis is not enough; we need to perform mathematical derivation for quantitative analysis.</p><h3 id="Mathematical-Derivation"><a href="#Mathematical-Derivation" class="headerlink" title="Mathematical Derivation"></a>Mathematical Derivation</h3><p>Here’s a simple derivation of the Bloom filter error rate calculation. You can skip this part and directly read the <a href="#LevelDB-Implementation">LevelDB Implementation</a> section. Assume the bit array size of the Bloom filter is $( m )$, the number of hash functions is $( k )$, and $( n )$ elements have been added to the filter. We assume that the hash functions we use are very random, so <strong>we can assume that the hash functions choose positions in the array with equal probability</strong>. During the insertion of elements, the probability of a certain bit being set to 1 by a certain hash function is $( \frac{1}{m} )$, and the probability of not being set to 1 is $( 1 - \frac{1}{m} )$.</p><p>$ k $ is the number of hash functions, and the hash functions we choose are uncorrelated and independent of each other. So the probability of <strong>a bit not being set to 1 by any hash function</strong> is:</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{k}} $$</p><p>Next is a mathematical trick. The natural logarithm $ e $ has an identity:</p><p>$$ {\displaystyle \lim _{m\to \infty }\left(1-{\frac {1}{m}}\right)^{m}&#x3D;{\frac {1}{e}}} $$</p><p>For relatively large m, we can deduce:</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{k}&#x3D;\left(\left(1-{\frac {1}{m}}\right)^{m}\right)^{k&#x2F;m}\approx e^{-k&#x2F;m}} $$</p><p>We have inserted n elements, so the probability of a certain bit not being set to 1 is:</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{kn}\approx e^{-kn&#x2F;m}} $$</p><p>Therefore, the probability of a certain bit being set to 1 is:</p><p>$$ {\displaystyle 1-\left(1-{\frac {1}{m}}\right)^{kn}\approx 1-e^{-kn&#x2F;m}} $$</p><p>Assuming an element is not in the set, the probability that all k bits are set to 1 is:</p><p>$$ {\displaystyle \left(1-e^{-kn&#x2F;m}\right)^{k}} $$</p><h3 id="Parameter-Selection"><a href="#Parameter-Selection" class="headerlink" title="Parameter Selection"></a>Parameter Selection</h3><p>From the above derivation, we can see that the false positive rate is related to the number of hash functions $ k $, the size of the bit array $ m $, and the number of added elements $ n $.</p><ul><li>$ n $ is usually determined by the application scenario, representing the <strong>expected total number of elements to be inserted into the Bloom filter</strong>. It can be predicted, determined by external factors, and is not easily adjustable.</li><li>Increasing $ m $ can directly reduce the false positive rate, but this will <strong>increase the storage space requirements of the Bloom filter</strong>. In storage-constrained environments, you may not want to increase it indefinitely. Additionally, the effect of expanding $ m $ is <strong>linear</strong>, and you need to balance performance improvement with additional storage costs.</li><li>Changing $ k $ has a <strong>very significant impact on the false positive rate</strong> because it directly affects the probability of bits in the bit array being set to 1.</li></ul><p>Considering all these factors, in practical applications, $ n $ is determined by the usage scenario, while $ m $ is limited by storage costs, making adjusting $ k $ a practical and direct optimization method. Given the expected number of elements $n$ and the bit array size $m$, <strong>we need to find an appropriate k that minimizes the false positive rate</strong>.</p><p>Finding the appropriate k here is an optimization problem that can be solved mathematically. It’s quite complex, so we’ll just state the conclusion. The optimal $(k)$ is as follows:</p><p>$$ k &#x3D; \frac{m}{n} \ln 2 $$</p><h2 id="LevelDB-Implementation"><a href="#LevelDB-Implementation" class="headerlink" title="LevelDB Implementation"></a>LevelDB Implementation</h2><p>Above, we introduced the principles of Bloom filters. Now let’s see how they are specifically implemented in LevelDB. The implementation of Bloom filters in LevelDB is in <a href="https://github.com/google/leveldb/blob/main/util/bloom.cc">bloom.cc</a>, where BloomFilterPolicy inherits from FilterPolicy and implements the aforementioned interfaces.</p><h3 id="Hash-Function-Count-Selection"><a href="#Hash-Function-Count-Selection" class="headerlink" title="Hash Function Count Selection"></a>Hash Function Count Selection</h3><p>First, let’s look at the selection of the number of hash functions k. The code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="type">int</span> bits_per_key)</span> : bits_per_key_(bits_per_key) &#123;</span></span><br><span class="line">  <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">  k_ = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">  <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The bits_per_key parameter is passed in when constructing the Bloom filter, and LevelDB always passes 10. This value represents the <strong>average number of bits occupied by each key</strong>, i.e., $ \frac{m}{n} $. The 0.69 here is an approximation of $ \ln (2) $, and this coefficient comes from the optimal hash function count formula $ k &#x3D; \frac{m}{n} \ln 2 $ discussed above. Finally, some boundary protection is performed here to ensure that the value of k is between 1 and 30, avoiding k being too large and making hash calculations too time-consuming.</p><h3 id="Creating-the-Filter"><a href="#Creating-the-Filter" class="headerlink" title="Creating the Filter"></a>Creating the Filter</h3><p>Next, let’s see how the filter is created here. The <a href="https://github.com/google/leveldb/blob/main/util/bloom.cc#L28">complete code</a> is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, <span class="type">int</span> n, std::string* dst)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">  <span class="type">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">  <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">  <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">  bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">  dst-&gt;<span class="built_in">resize</span>(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">  dst-&gt;<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">  <span class="type">char</span>* array = &amp;(*dst)[init_size];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">    <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">    <span class="type">uint32_t</span> h = <span class="built_in">BloomHash</span>(keys[i]);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      array[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">      h += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First, it calculates the space needed for the bit array, based on the number of keys $ n $ and the average number of bits per key. It also considers some boundary conditions: if the resulting number of bits is too small (less than 64 bits), it sets it to 64 bits to avoid a high false positive rate. Additionally, it considers byte alignment, converting the number of bits to bytes while ensuring the total number of bits is a multiple of 8.</p><p>Next, it uses resize to increase the size of dst, <strong>allocating space for the bit array after the target string</strong>. Here, the Bloom filter <strong>is designed to be appended to existing data without overwriting or deleting existing data</strong>. The newly added space is initialized to 0 because the Bloom filter’s bit array needs to start from an all-zero state. Then k_, the number of hash functions, is added to the end of the target string dst. This value is part of the Bloom filter’s metadata and is used to determine how many hash calculations need to be performed when querying whether a key exists.</p><p>Finally, there’s the core part of the Bloom filter, calculating which bit array positions need to be set to 1. Normally, you would need to set up <strong>k hash functions, calculate k times, and then set the corresponding positions</strong>. However, LevelDB’s implementation seems different. For each key, it uses the BloomHash function to calculate the initial hash value h of the key, then sets the corresponding position. In subsequent calculations, each time it right-shifts the previous hash value by 17 bits, left-shifts by 15 bits, and then performs an OR operation to calculate delta. Then it adds delta to the previous hash value to calculate the next hash value. This way, it can obtain k hash values and then set the corresponding positions.</p><p>In the previous <a href="#Mathematical-Derivation">Mathematical Derivation</a> section, we mentioned that these <strong>k hash functions need to be random and mutually independent</strong>. Can the above method meet this requirement? The code comment mentions that it adopts the <strong>double-hashing</strong> method, referring to the analysis in <a href="https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf">[Kirsch,Mitzenmacher 2006]</a>. Although the hash values generated by double hashing are not as completely unrelated as those from completely independent hash functions, in practical applications, they provide sufficient randomness and independence to meet the requirements of Bloom filters.</p><p>The advantages here are also obvious. Double hashing can generate multiple pseudo-independent hash values from one basic hash function, without needing to implement k hashes, making the implementation very simple. Moreover, compared to multiple independent hash functions, <strong>the double hashing method reduces computational overhead because it only needs to calculate one real hash value, with the rest of the hash values obtained through simple arithmetic and bit operations</strong>.</p><h3 id="Querying-Key-Existence"><a href="#Querying-Key-Existence" class="headerlink" title="Querying Key Existence"></a>Querying Key Existence</h3><p>Finally, let’s look at how to query whether a key exists. If you understood the previous part about creating the filter, this part should be easy to understand. The <a href="https://github.com/google/leveldb/blob/main/util/bloom.cc#L56">complete code</a> is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; bloom_filter)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* array = bloom_filter.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line">  <span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> k = array[len - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line">    <span class="comment">// Consider it a match.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> h = <span class="built_in">BloomHash</span>(key);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h % bits;</span><br><span class="line">    <span class="keyword">if</span> ((array[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    h += delta;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The beginning part is just some boundary condition checks. If the filter length is less than 2, it returns false. It reads the value of k from the last byte of the filter data, which was stored when creating the filter and is used to determine how many hash calculations need to be performed. If k is greater than 30, this case is considered as possibly for future new encoding schemes, so the function directly returns true, assuming the key might exist in the set (as of 2024, no new encoding schemes have been extended here).</p><p>The next part is similar to when creating the filter. It uses the BloomHash function to calculate the hash value of the key, then performs bit rotation to generate delta, which is used to modify the hash value in the loop to simulate the effect of multiple hash functions. During this process, if any bit is 0, it indicates that <strong>the key is definitely not in the set</strong>, and the function returns false. If all relevant bits are 1, it returns true, indicating that <strong>the key might be in the set</strong>.</p><h2 id="Bloom-Filter-Testing"><a href="#Bloom-Filter-Testing" class="headerlink" title="Bloom Filter Testing"></a>Bloom Filter Testing</h2><p>The implementation of Bloom filters in LevelDB also provides complete test code, which can be found in <a href="https://github.com/google/leveldb/blob/main/util/bloom_test.cc">bloom_test.cc</a>.</p><p>First, the BloomTest class is derived from the testing::Test class, used to organize and execute test cases related to Bloom filters. Its constructor and destructor are used to create and release instances of NewBloomFilterPolicy, ensuring that each test case can run in a clean environment. The Add method is used to add keys to the Bloom filter, and Build converts the collected keys into a filter. The Matches method is used to check whether a specific key matches the filter, while the FalsePositiveRate method is used to <strong>evaluate the false positive rate of the filter</strong>.</p><p>Then there’s a series of specific test cases defined by the TEST_F macro, allowing each test case to automatically possess the methods and properties defined in the BloomTest class. The first two test cases are relatively simple:</p><ul><li>EmptyFilter: Tests an empty filter, i.e., whether the filter can correctly determine that a key does not exist when no keys have been added.</li><li>Small: Tests the case of adding a small number of keys, checking whether the filter can correctly determine if keys exist.</li></ul><p>It’s worth noting the VaryingLengths test case, which is a more complex test case used to evaluate and verify <strong>the performance and efficiency of the Bloom filter under different data scales (i.e., different numbers of keys)</strong>. By using the defined NextLength function to incrementally increase the number of keys, it tests the performance of the Bloom filter under different key set sizes. It mainly tests the following three aspects:</p><ol><li>Ensures that the size of the constructed Bloom filter is within the expected range;</li><li>Ensures that all keys added to the filter can be correctly identified as existing;</li><li>Evaluates the false positive rate (false positive rate) of the Bloom filter at different lengths, ensuring that the false positive rate does not exceed 2%. At the same time, it categorizes filters as “good” or “mediocre” based on their false positive rates, and performs statistics and comparisons on their numbers, ensuring that the number of “mediocre” filters is not too high.</li></ol><p>The complete test code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">TEST_F</span>(BloomTest, VaryingLengths) &#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="built_in">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count number of filters that significantly exceed the false positive rate</span></span><br><span class="line">  <span class="type">int</span> mediocre_filters = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> good_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> length = <span class="number">1</span>; length &lt;= <span class="number">10000</span>; length = <span class="built_in">NextLength</span>(length)) &#123;</span><br><span class="line">    <span class="built_in">Reset</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="built_in">Add</span>(<span class="built_in">Key</span>(i, buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(<span class="built_in">FilterSize</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;((length * <span class="number">10</span> / <span class="number">8</span>) + <span class="number">40</span>))</span><br><span class="line">        &lt;&lt; length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All added keys must match</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">Matches</span>(<span class="built_in">Key</span>(i, buffer)))</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Length &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;; key &quot;</span> &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check false positive rate</span></span><br><span class="line">    <span class="type">double</span> rate = <span class="built_in">FalsePositiveRate</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      std::<span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                   <span class="string">&quot;False positives: %5.2f%% @ length = %6d ; bytes = %6d\n&quot;</span>,</span><br><span class="line">                   rate * <span class="number">100.0</span>, length, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">FilterSize</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(rate, <span class="number">0.02</span>);  <span class="comment">// Must not be over 2%</span></span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0.0125</span>)</span><br><span class="line">      mediocre_filters++;  <span class="comment">// Allowed, but not too often</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      good_filters++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    std::<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Filters: %d good, %d mediocre\n&quot;</span>, good_filters,</span><br><span class="line">                 mediocre_filters);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ASSERT_LE</span>(mediocre_filters, good_filters / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here’s the result of executing the test:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_testcase.png" alt="Bloom Filter Test Results"></p><h2 id="Bloom-Filter-Visualization"><a href="#Bloom-Filter-Visualization" class="headerlink" title="Bloom Filter Visualization"></a>Bloom Filter Visualization</h2><p>Before concluding the article, let’s take a look at <a href="https://gallery.selfboot.cn/en/algorithms/bloomfilter">a visualization demonstration of the Bloom filter</a>, which displays the principles and implementation discussed above in the form of charts, deepening our understanding.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_visualization.png" alt="Bloom Filter Visualization Demo"></p><p>In this demonstration site, you can choose different numbers of hash functions and predicted key counts. It will then automatically adjust the bit array. After that, you can add elements and check if elements are in the Bloom filter. If an element is present, the corresponding array bits will be displayed with black boxes. If it’s not present, the corresponding array bits will be displayed with red boxes. This allows for an intuitive understanding of how Bloom filters work.</p><p>Also, for ease of demonstration, clicking on a bit group will show which keys would hash to this location. In reality, Bloom filters don’t store this information; it’s stored additionally here just for demonstration purposes.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Bloom filters are an efficient data structure used to determine whether an element exists in a set. Its core is a bit array and multiple hash functions, using multiple hash calculations to set bits in the bit array. Through rigorous mathematical derivation, we can conclude that the false positive rate of Bloom filters is related to the number of hash functions, the size of the bit array, and the number of added elements. In practical applications, the false positive rate can be optimized by adjusting the number of hash functions.</p><p>LevelDB implemented a Bloom filter as the default filter policy, which can be created through a factory function, maintaining extensibility. To save hash resource consumption, LevelDB generates multiple pseudo-independent hash values through the double hashing method, then sets the corresponding bits. When querying, it also uses multiple hash calculations to determine whether a key exists in the set. LevelDB provides complete test cases to verify the correctness and false positive rate of the Bloom filter.</p><p>Additionally, to intuitively understand how Bloom filters work, I’ve created a visualization demonstration of Bloom filters here, showing the principles of Bloom filters through charts.</p>]]></content:encoded>
      
      
      <category domain="https://selfboot.cn/categories/Source-Code-Analysis/">Source Code Analysis</category>
      
      
      <category domain="https://selfboot.cn/tags/C/">C++</category>
      
      <category domain="https://selfboot.cn/tags/LevelDB/">LevelDB</category>
      
      
      <comments>https://selfboot.cn/en/2024/08/08/leveldb_source_bloom_filter/#disqus_thread</comments>
      
    </item>
    
    
    
    
    
    <item>
      <title>LevelDB Explained - Preparing the Development Environment</title>
      <link>https://selfboot.cn/en/2024/08/06/leveldb_source_prepare/</link>
      <guid>https://selfboot.cn/en/2024/08/06/leveldb_source_prepare/</guid>
      <pubDate>Tue, 06 Aug 2024 20:31:43 GMT</pubDate>
      
      <description>This article introduces how to prepare the development environment for LevelDB, including source code retrieval, compilation, and VSCode configuration. Through simple read and write examples, readers can gain a preliminary understanding of LevelDB. The article also explains how to use the gtest framework to run and modify test cases for better understanding of the code logic.</description>
      
      
      
      <content:encoded><![CDATA[<p>LevelDB is an excellent LSM Tree storage component developed in C++. Although its overall codebase is not large, its design is ingenious and worth studying. During the process of reading the source code, I have compiled a <a href="https://selfboot.cn/en/tags/LevelDB/">series of articles</a> to gradually break down the implementation details of LevelDB. However, before reading the code, it’s best to prepare the entire development environment.</p><p>This article will start from the most basic step of pulling the code, recording my process of preparing the entire environment, including configuring the VSCode IDE and using the clangd plugin, as well as how to configure compilation options. Then, through a simple read and write code demo, we’ll briefly use LevelDB to gain a perceptual understanding of this library. Additionally, we’ll introduce how to run test cases. LevelDB’s test cases are well-written, and during the code reading process, we can use these cases to better understand the code.</p><span id="more"></span><h2 id="Source-Code-Compilation"><a href="#Source-Code-Compilation" class="headerlink" title="Source Code Compilation"></a>Source Code Compilation</h2><p>First is pulling the code. Here we use <code>git clone --recurse-submodules</code>, which can pull all submodules at once. Although LevelDB’s implementation doesn’t depend on third-party libraries, benchmark is used for pressure testing and googletest is used for functional testing, both of which are introduced as submodules.</p><p>If you encounter network issues when pulling the code, such as the following, you need to bypass the firewall first. You can refer to the methods in the article <a href="https://selfboot.cn/2023/12/25/how-to-use-chatgpt/">Safe, Fast, and Affordable Access to ChatGPT, Latest and Most Comprehensive Practical Tutorial!</a>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &#x27;/root/leveldb/third_party/googletest&#x27;...</span><br><span class="line">fatal: unable to access &#x27;https://github.com/google/googletest.git/&#x27;: GnuTLS recv error (-110): The TLS connection was non-properly terminated.</span><br><span class="line">fatal: clone of &#x27;https://github.com/google/googletest.git&#x27; into submodule path &#x27;/root/leveldb/third_party/googletest&#x27; failed</span><br><span class="line">Failed to clone &#x27;third_party/googletest&#x27;. Retry scheduled</span><br></pre></td></tr></table></figure><p>Next is compiling the entire source code. LevelDB uses cmake for building. To facilitate later code reading, we add <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=1</code> during compilation, which will generate a <code>compile_commands.json</code> file. This file is a configuration file for tools like clangd and can help IDEs like VSCode better understand the code. With this file, features like code jumping and auto-completion will work better. Additionally, to facilitate debugging with GDB, we add <code>-DCMAKE_BUILD_TYPE=Debug</code> to generate libraries with debugging information.</p><p>You can refer to the complete command below:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone --recurse-submodules  git@github.com:google/leveldb.git</span><br><span class="line"></span><br><span class="line">cd leveldb</span><br><span class="line">mkdir -p build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_INSTALL_PREFIX=$(pwd) .. &amp;&amp; cmake --build . --target install</span><br></pre></td></tr></table></figure><p>The <code>CMAKE_INSTALL_PREFIX</code> option is used to specify the installation directory. Here it’s specified as the current directory (build directory), so after compilation, the generated library files and header files will be placed in the build directory for convenient future use.</p><p>There are quite a few options for CMake building here. For example, <code>BUILD_SHARED_LIBS</code> is used to control whether the generated library is a static link library (.a file) or a dynamic link library (.so file). If <code>BUILD_SHARED_LIBS</code> is not explicitly set in CMakeLists.txt or through command-line arguments passed to CMake, CMake’s default behavior is usually not to enable shared library building. You can use <code>cmake -DBUILD_SHARED_LIBS=ON ..</code> on the command line to enable shared library building.</p><h2 id="IDE-Configuration"><a href="#IDE-Configuration" class="headerlink" title="IDE Configuration"></a>IDE Configuration</h2><p>I personally use vscode quite often. As a code IDE, vscode can be said to be very user-friendly. For C++ projects, although Microsoft provides an official <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C++ plugin</a> for convenient code jumping and other features, from my personal experience, it’s not very user-friendly. Here, I strongly recommend using clangd to read C++ code. You only need to <strong>install Clangd on the server, then install the clangd plugin in vscode, and use it in conjunction with the compile_commands.json compilation database file generated by Cmake earlier</strong>.</p><p>Clangd is a language server based on the LLVM project, mainly supporting code analysis for C and C++. It can <strong>provide code completion, diagnostics (i.e., errors and warnings), code jumping, and code formatting features</strong>. Compared to Microsoft’s built-in C++ plugin, clangd responds very quickly and can achieve more precise jumping and warnings with the help of clang. It also supports using <code>clang-tidy</code> to perform static analysis on project code to discover potential errors.</p><p>For example, in the code below, clang-tidy found a suspicious issue: <code>Suspicious usage of &#39;sizeof(A*)&#39;</code>, and also provided the clang-tidy check rule item <a href="https://clang.llvm.org/extra/clang-tidy/checks/bugprone/sizeof-expression.html">bugprone-sizeof-expression</a>, which is used to check whether the use of <code>sizeof</code> expressions is correct.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_clangd_tidy.png" alt="Suspicious spot found by clangd plugin using clang-tidy"></p><p>Here, new_list itself is a pointer to a pointer, so new_list[0] is actually a pointer. sizeof(new_list[0]) is getting the size of the pointer, not the size of the element pointed to by the pointer. However, this is the intended design here, which is to set the initial value of the new bucket to nullptr. In fact, this rule is intended to prevent errors like the following:</p><blockquote><p>A common mistake is to compute the size of a pointer instead of its pointee. These cases may occur because of explicit cast or implicit conversion.</p></blockquote><p>For example, code like this:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="built_in">sizeof</span>(A + <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> point;</span><br><span class="line"><span class="built_in">memset</span>(point, <span class="number">0</span>, <span class="built_in">sizeof</span>(&amp;point));</span><br></pre></td></tr></table></figure><p>Overall, the code quality of LevelDB is very high, with very few clang-tidy prompts. It’s a world apart from business code, so it’s very worth learning.</p><h2 id="LevelDB-Read-Modify-Write"><a href="#LevelDB-Read-Modify-Write" class="headerlink" title="LevelDB Read, Modify, Write"></a>LevelDB Read, Modify, Write</h2><p>LevelDB is <strong>not a database like MySQL</strong>, nor does it support SQL queries and other features. It’s just a <strong>fast key-value storage library</strong>. LevelDB doesn’t come with client and server code. If you need to provide storage functionality, you need to implement the corresponding logic yourself. Additionally, it only supports single-process access to a specified database and does not support multi-process access.</p><p>In the industry, LevelDB is generally used as an underlying dependency for storage components. For example, WeChat’s core storage <a href="https://github.com/Tencent/paxosstore">paxosstore</a> uses LevelDB to store data. Getting started with LevelDB is relatively simple. You just need to include the header file and then call the corresponding interfaces. The code below implements a simple command-line interface that uses the LevelDB library to read and write keys.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple_client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  leveldb::DB* db;</span><br><span class="line">  leveldb::Options options;</span><br><span class="line">  options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">  leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;./db&quot;</span>, &amp;db);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unable to open/create test database &#x27;./db&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string key;</span><br><span class="line">  std::string value;</span><br><span class="line">  std::string cmd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;leveldb&gt; &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; cmd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="string">&quot;set&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key &gt;&gt; value;</span><br><span class="line">      status = db-&gt;<span class="built_in">Put</span>(leveldb::<span class="built_in">WriteOptions</span>(), key, value);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error setting value: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;get&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key;</span><br><span class="line">      status = db-&gt;<span class="built_in">Get</span>(leveldb::<span class="built_in">ReadOptions</span>(), key, &amp;value);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;del&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key;</span><br><span class="line">      status = db-&gt;<span class="built_in">Delete</span>(leveldb::<span class="built_in">WriteOptions</span>(), key);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error deleting key: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;exit&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Unknown command. Supported commands are: set, get, del, exit&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here we use Cmake to build. You can refer to the following CMakeLists.txt file. Of course, the directories for include and lib libraries need to be changed according to the previously compiled directories.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(SimpleLevelDBExamples VERSION <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># Set build type to Debug to include debugging information</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"><span class="keyword">add_executable</span>(SimpleClient simple_client.cpp)</span><br><span class="line"><span class="keyword">include_directories</span>(../build/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(SimpleClient <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../build/libleveldb.a pthread)</span><br></pre></td></tr></table></figure><p>Then you can use <code>cmake --build .</code> to compile the binary file. Of course, if you’re not used to cmake, you can also use gcc directly, but you need to manually specify the paths for header files and library files. Then execute as shown in the image below, you can operate LevelDB in a command-line client similar to redis.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240806_leveldb_source_prepare_simpleclient.png" alt="Simple read and write command-line interface for LevelDB"></p><p>You can see LevelDB’s data storage files in the db folder of the current directory, as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> db</span> </span><br><span class="line">000005.ldb  000018.ldb  000020.ldb  000031.ldb  000036.log  CURRENT  LOCK  LOG  LOG.old  MANIFEST-000035</span><br></pre></td></tr></table></figure><p>We will explain LevelDB’s data storage method in detail later, and will also expand on the functions of these files. Let’s not go into details here.</p><h2 id="Running-Test-Cases"><a href="#Running-Test-Cases" class="headerlink" title="Running Test Cases"></a>Running Test Cases</h2><p>So far, we have compiled the LevelDB library and written a simple read and write command-line interface using LevelDB. Next, let’s look at LevelDB’s test cases. LevelDB’s core code all has corresponding test cases, such as <a href="https://github.com/google/leveldb/blob/main/util/cache_test.cc">cache_test.cc</a> in LRU cache, <a href="https://github.com/google/leveldb/blob/main/db/db_test.cc">db_test.cc</a> in db implementation, <a href="https://github.com/google/leveldb/blob/main/table/table_test.cc">table_test.cc</a> in table, and so on. The executable file <code>build/leveldb_tests</code> for test cases is generated along with the library using the previous compilation command.</p><h3 id="Dynamic-Library-Dependencies"><a href="#Dynamic-Library-Dependencies" class="headerlink" title="Dynamic Library Dependencies"></a>Dynamic Library Dependencies</h3><p>If you run <code>leveldb_tests</code> directly, it may prompt that the <code>libtcmalloc</code> dynamic library is missing. This is a memory allocator from Google Perftools, which LevelDB uses and needs to be installed on the system.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/leveldb_tests: error while loading shared libraries: libtcmalloc.so.4: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>The installation command is also simple. For example, on a debian system, you can use the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libgoogle-perftools-dev</span><br></pre></td></tr></table></figure><p>After installation, you can use <code>ldd</code> to check if it can be found. If it’s normal as follows, you can run the binary.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ldd ./build/leveldb_tests</span><br><span class="line">linux-vdso.so.1 (0x00007ffc0d1fc000)</span><br><span class="line">libtcmalloc.so.4 =&gt; /usr/local/lib/libtcmalloc.so.4 (0x00007f5277e91000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f5277c77000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f5277b98000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f5277b78000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5277997000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f52782ed000)</span><br></pre></td></tr></table></figure><p>Before installing the library, it prompted <code>libtcmalloc.so.4 =&gt; not found</code>, but after installing the dynamic library, it <strong>automatically linked</strong> to the correct path. How is this achieved? This is because the binary file contains references to dynamic libraries, especially <strong>the name of the library and the required symbols (functions or data)</strong>. The dynamic linker (usually <code>ld-linux.so</code> in Linux) is responsible for handling these references. It determines which libraries the binary file needs, and then loads the used libraries according to the specified paths and methods.</p><p>After we install the tcmalloc library, the dynamic library file libtcmalloc.so.4 is copied to the system’s library directory &#x2F;usr&#x2F;local&#x2F;lib. Then the installation program executes ldconfig to update ld.so.cache, which contains path information for libraries to speed up library lookup. This way, when running the binary again, the dynamic linker checks the cache, finds the newly installed library, and resolves all relevant symbol references, thus completing the linking.</p><h3 id="Modifying-and-Running"><a href="#Modifying-and-Running" class="headerlink" title="Modifying and Running"></a>Modifying and Running</h3><p>These functional test cases are all written using the gtest framework. We can view all the test cases using the <code>--gtest_list_tests</code> parameter. As shown in the image below:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_list_tests.png" alt="All current test cases for LevelDB"></p><p>If you run leveldb_tests directly, it will execute all the test cases. However, we can use the <code>--gtest_filter</code> parameter to specify running only certain test cases, for example, <code>--gtest_filter=&#39;CacheTest.*&#39;</code> only runs the test cases related to LRU cache. The result is as follows:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_cache_test.png" alt="Running only certain test cases"></p><p><strong>Test cases can help better understand the code logic.</strong> During the process of reading the code, sometimes we want to verify some logic, so we can modify the test cases a bit. For example, I deliberately broke a test case that could pass:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--- a/util/cache_test.cc</span><br><span class="line">+++ b/util/cache_test.cc</span><br><span class="line">@@ <span class="number">-69</span>,<span class="number">7</span> +<span class="number">69</span>,<span class="number">7</span> @@ <span class="built_in">TEST_F</span>(CacheTest, HitAndMiss) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Insert</span>(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">   <span class="built_in">ASSERT_EQ</span>(<span class="number">101</span>, <span class="built_in">Lookup</span>(<span class="number">100</span>));</span><br><span class="line">-  <span class="built_in">ASSERT_EQ</span>(<span class="number">-1</span>, <span class="built_in">Lookup</span>(<span class="number">200</span>));</span><br><span class="line">+  <span class="built_in">ASSERT_EQ</span>(<span class="number">101</span>, <span class="built_in">Lookup</span>(<span class="number">200</span>));</span><br><span class="line">   <span class="built_in">ASSERT_EQ</span>(<span class="number">-1</span>, <span class="built_in">Lookup</span>(<span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Insert</span>(<span class="number">200</span>, <span class="number">201</span>);</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>After modifying the test case, you need to recompile leveldb_tests. Because we configured the project’s compilation options during the previous compilation, CMake has already cached them, so the following command automatically uses the previous configuration items, such as -DCMAKE_BUILD_TYPE&#x3D;Debug, etc.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target leveldb_tests</span><br><span class="line"></span><br><span class="line">[  2%] Built target gtest</span><br><span class="line">[ 58%] Built target leveldb</span><br><span class="line">[ 61%] Built target gtest_main</span><br><span class="line">[ 64%] Built target gmock</span><br><span class="line">[ 65%] Building CXX object CMakeFiles/leveldb_tests.dir/util/cache_test.cc.o</span><br><span class="line">[ 67%] Linking CXX executable leveldb_tests</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target leveldb_tests</span></span><br></pre></td></tr></table></figure><p>Note that from the output above, you can see that only the modified file was recompiled here, generating a new object file <code>cache_test.cc.o</code>, so the compilation speed is very fast. After running it again, you’ll see that the test case doesn’t pass, as shown below:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_cache_test_fail.png" alt="Test case failing"></p><p>You can see the specific reason for the test case validation failure. During the process of reading the code, you can modify the test cases of some code at any time to verify whether your understanding is correct.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Following this article, everyone should be able to quickly prepare the development environment for LevelDB. After configuring the IDE, compiling the source code, running simple read and write examples and test cases, let’s start reading the source code together!</p>]]></content:encoded>
      
      
      <category domain="https://selfboot.cn/categories/Source-Code-Analysis/">Source Code Analysis</category>
      
      
      <category domain="https://selfboot.cn/tags/C/">C++</category>
      
      <category domain="https://selfboot.cn/tags/LevelDB/">LevelDB</category>
      
      
      <comments>https://selfboot.cn/en/2024/08/06/leveldb_source_prepare/#disqus_thread</comments>
      
    </item>
    
    
    
    
    
    <item>
      <title>LevelDB Explained - Posix File Operation Details</title>
      <link>https://selfboot.cn/en/2024/08/02/leveldb_source_env_posixfile/</link>
      <guid>https://selfboot.cn/en/2024/08/02/leveldb_source_env_posixfile/</guid>
      <pubDate>Fri, 02 Aug 2024 10:37:38 GMT</pubDate>
      
      <description>This article details LevelDB&#39;s abstracted file operations, including the implementation of sequential read/write and random file access under Posix, and how to adapt to different operating systems through abstract interfaces. It also introduces key designs such as buffer optimization, resource limit management, and flexible reading strategies to improve system performance and usability. Additionally, it covers implementation details like the application of the factory method pattern, error handling mechanisms, and cross-platform compatibility considerations.</description>
      
      
      
      <content:encoded><![CDATA[<p>LevelDB supports running on various operating systems. To adapt to different operating systems, it needs to encapsulate some system calls, such as file operations, thread operations, time operations, etc. In the exposed include files, the <a href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h">env.h</a> file defines various interfaces used by LevelDB. This includes the Env class, which encapsulates file operations, directory operations, etc., as well as some file abstract classes such as SequentialFile, WritableFile, and RandomAccessFile for sequential reading, random reading, and writing files.</p><p>Through abstract interfaces, LevelDB can run on different operating systems by implementing the corresponding Env subclass for each platform. This article takes the POSIX system environment as an example to first look at how the abstracted <strong>file operation-related interfaces</strong> are implemented.</p><span id="more"></span><h2 id="Sequential-File-Reading"><a href="#Sequential-File-Reading" class="headerlink" title="Sequential File Reading"></a>Sequential File Reading</h2><p>First, let’s look at the abstract base class SequentialFile for <strong>sequential file reading</strong>, which provides a standard interface for sequential reading and skipping operations on files, and can be used for reading WAL log files. The class defines two main virtual functions:</p><ul><li>Read(size_t n, Slice* result, char* scratch): This function is used to read up to n bytes of data from the file. result is a pointer to a Slice type, used to store the read data. scratch is a character array used as a temporary buffer, and the function may write data to this buffer.</li><li>Skip(uint64_t n): This function is used to skip n bytes of data in the file. If the file is read to the end, the skip operation will stop at the end of the file, and the function returns an OK status.</li></ul><p>Of course, the comments also indicate that this class requires <strong>the caller to perform synchronization to ensure thread safety</strong>. In the POSIX environment, the implementation of this class is in the <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L136">env_posix.cc</a> file, where the PosixSequentialFile class finally inherits from SequentialFile, preventing it from being inherited by any other class, and implements the above two virtual functions. The implementation of Read is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">size_t</span> n, Slice* result, <span class="type">char</span>* scratch)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      ::<span class="type">ssize_t</span> read_size = ::<span class="built_in">read</span>(fd_, scratch, n);</span><br><span class="line">      <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) &#123;  <span class="comment">// Read error.</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">        &#125;</span><br><span class="line">        status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      *result = <span class="built_in">Slice</span>(scratch, read_size);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Here, when the system call <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> returns a value less than 0, it will judge whether it is an EINTR error based on the value of errno, and if so, it will <strong>retry reading</strong>. This is because when performing a read() operation on a file descriptor with the O_NONBLOCK flag set, if there is not enough data available to read, read() will return immediately instead of blocking to wait for data to become available. In this case, read() will return -1 and errno will be set to EAGAIN, indicating that there is no data to read and to try again later.</p><p>The implementation of Skip is relatively simple, directly calling the system call <a href="https://man7.org/linux/man-pages/man2/lseek.2.html">lseek()</a> to skip n bytes in the file. Here, the third parameter is SEEK_CUR, indicating to <strong>skip n bytes from the current position</strong>. In the operating system, each open file has an associated file position pointer (sometimes also called file offset). This pointer indicates where the next read or write operation will take place in the file. <strong>The operating system is responsible for tracking and maintaining this file position pointer</strong>. Of course, you can also specify SEEK_SET or SEEK_END, which represent skipping n bytes from the beginning and end of the file, respectively.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Skip</span><span class="params">(<span class="type">uint64_t</span> n)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">lseek</span>(fd_, n, SEEK_CUR) == <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(<span class="number">-1</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>The file descriptor should also be closed when the object is destroyed to ensure that resources are properly released</strong>. Each time a file is opened, the operating system allocates some resources, such as kernel buffers, file locks, etc. Then it returns a file descriptor (a non-negative integer) to the user, which the user then uses to operate on the file. When we call <a href="https://man7.org/linux/man-pages/man2/close.2.html">close</a>, the operating system reduces the reference count for that file, and if the reference count becomes 0, the operating system releases the corresponding resources. Additionally, there is a limit to the number of files each process can open, and not calling close(fd) may cause the process to be unable to open new files.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">PosixSequentialFile</span>() <span class="keyword">override</span> &#123; <span class="built_in">close</span>(fd_); &#125;</span><br></pre></td></tr></table></figure><h2 id="Random-File-Reading"><a href="#Random-File-Reading" class="headerlink" title="Random File Reading"></a>Random File Reading</h2><p>RandomAccessFile is an abstract base class that defines the interface for <strong>random file reading</strong>. It declares a pure virtual function Read, forcing subclasses to implement this method. The Read method is designed to allow reading a specified number of bytes from any position in the file. Because it’s a read-only interface, it supports lock-free multi-threaded concurrent access.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">char</span>* scratch)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>In the POSIX environment, this class has two implementations, one is <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L176">PosixRandomAccessFile</a> implemented using <a href="https://man7.org/linux/man-pages/man2/pread.2.html">pread()</a>, and the other is <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L238">PosixMmapReadableFile</a> implemented using mmap().</p><h3 id="Random-Reading-with-pread"><a href="#Random-Reading-with-pread" class="headerlink" title="Random Reading with pread"></a>Random Reading with pread</h3><p>The PosixRandomAccessFile class implements the RandomAccessFile interface, mainly using the POSIX pread() system call. The constructor of this class is quite interesting, receiving filename, fd, and an externally passed fd_limiter pointer. fd_limiter is used to limit the number of file descriptors held, avoiding too many open file descriptors. The specific implementation of limiter is in the <a href="#Limiter">Limiter</a> section of this article. During construction, if fd_limiter-&gt;Acquire() returns true, it means it can always hold this file descriptor. Otherwise, the file descriptor needs to be closed in the constructor, and <strong>a temporary file descriptor will be used each time content is read from the file later</strong>.</p><p>Here, fd_limiter is created in the factory function of <a href="#Env-Encapsulation-Interface">PosixEnv</a>, and the maximum number of persistent file descriptors is obtained by the MaxOpenFiles function. It first checks if the global variable g_open_read_only_file_limit has been modified to a non-negative number, and if so, uses this value. If not set, it needs to decide based on the system’s resource limits. Here, the system call <a href="https://www.man7.org/linux/man-pages/man2/getrlimit.2.html">getrlimit</a> is used to <strong>get the maximum number of file descriptors that the current process can open</strong>. If the system doesn’t limit the number of file descriptors a process can open, it returns the maximum value of an int type, otherwise it allocates 20% of this limit to read-only file operations. If getting the resource limit fails, or if the system (like the Fuchsia operating system) doesn’t support getting resource limits, a hard-coded value of 50 is used.</p><p>Next, let’s look at the constructor of PosixRandomAccessFile:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The new instance takes ownership of |fd|. |fd_limiter| must outlive this</span></span><br><span class="line"><span class="comment">// instance, and will be used to determine if .</span></span><br><span class="line"><span class="built_in">PosixRandomAccessFile</span>(std::string filename, <span class="type">int</span> fd, Limiter* fd_limiter)</span><br><span class="line">    : <span class="built_in">has_permanent_fd_</span>(fd_limiter-&gt;<span class="built_in">Acquire</span>()),</span><br><span class="line">      <span class="built_in">fd_</span>(has_permanent_fd_ ? fd : <span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">fd_limiter_</span>(fd_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd_ == <span class="number">-1</span>);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);  <span class="comment">// The file will be opened on every read.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The constructor uses the member variable has_permanent_fd_ to record whether it always holds an open file descriptor, and if not, fd_ is -1. Correspondingly, in the destructor, if has_permanent_fd_ is true, it needs to call close() to close the file descriptor and release the resource count of fd_limiter_. Next, let’s look at the core Read method of this class, the code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = fd_;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    fd = ::<span class="built_in">open</span>(filename_.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(fd != <span class="number">-1</span>);</span><br><span class="line">  Status status;</span><br><span class="line">  <span class="type">ssize_t</span> read_size = ::<span class="built_in">pread</span>(fd, scratch, n, <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(offset));</span><br><span class="line">  *result = <span class="built_in">Slice</span>(scratch, (read_size &lt; <span class="number">0</span>) ? <span class="number">0</span> : read_size);</span><br><span class="line">  <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// An error: return a non-ok status.</span></span><br><span class="line">    status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    <span class="comment">// Close the temporary file descriptor opened earlier.</span></span><br><span class="line">    <span class="built_in">assert</span>(fd != fd_);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, it first determines whether it holds a <strong>persistent file descriptor</strong>, and if not, it needs to open the file each time it reads the file. Then it calls pread() to read the file content. pread() is similar to read(), but it can read data from a specified position in the file. The first parameter of pread() is the file descriptor, the second parameter is the buffer for reading, the third parameter is the number of bytes to read, and the fourth parameter is the offset in the file. If the read is successful, the read data is stored in result, otherwise an error status is returned. Finally, if it doesn’t hold a persistent file descriptor, it needs to close the temporary file descriptor after reading the data.</p><p>The implementation of the PosixRandomAccessFile class is relatively simple, directly using the system file API, without the need for additional memory mapping management, suitable for small files or infrequent read operations. However, if access is frequent, too many system calls may lead to performance degradation, in which case <strong>memory mapping files</strong> can be used to improve performance.</p><h3 id="Random-Reading-with-mmap"><a href="#Random-Reading-with-mmap" class="headerlink" title="Random Reading with mmap"></a>Random Reading with mmap</h3><p>The PosixMmapReadableFile class also implements the RandomAccessFile interface, but it maps the file or part of the file to the process’s address space through memory mapping (mmap), and accessing this part of memory is equivalent to accessing the file itself. <strong>Memory mapping allows the operating system to utilize page caches, which can significantly improve the performance of frequent reads, especially in large file scenarios, improving read efficiency</strong>.</p><p>Unlike PosixRandomAccessFile, here the constructor needs to pass in the mmap_base pointer, which points to the file content mapped through the mmap system call, and also needs to pass in length, which is the length of the mapped area, i.e., the size of the file. The mapping is done in the external NewRandomAccessFile method, and PosixMmapReadableFile directly uses the mapped address.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PosixMmapReadableFile</span>(std::string filename, <span class="type">char</span>* mmap_base, <span class="type">size_t</span> length,</span><br><span class="line">                      Limiter* mmap_limiter)</span><br><span class="line">    : <span class="built_in">mmap_base_</span>(mmap_base),</span><br><span class="line">      <span class="built_in">length_</span>(length),</span><br><span class="line">      <span class="built_in">mmap_limiter_</span>(mmap_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>Of course, mmap also needs to limit resources to avoid exhausting virtual memory. Here, the Limiter class is also used, which will be described in detail later. The Read method <strong>directly reads data from mmap_base_, without the need to call system calls</strong>, which is much more efficient. The overall code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (offset + n &gt; length_) &#123;</span><br><span class="line">    *result = <span class="built_in">Slice</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, EINVAL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *result = <span class="built_in">Slice</span>(mmap_base_ + offset, n);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sequential-File-Writing"><a href="#Sequential-File-Writing" class="headerlink" title="Sequential File Writing"></a>Sequential File Writing</h2><p>The previous sections were all about reading files, of course, we can’t miss the writing file interface. WritableFile is an abstract base class that defines the interface for <strong>sequential file writing</strong>. It provides a standard interface for sequential writing and synchronization operations on files, which can be used for writing WAL log files. The class defines three main virtual functions:</p><ul><li>Append(const Slice&amp; data): Appends data to the file object. For small blocks of data, it appends to the object’s memory cache, and for large blocks of data, it calls WriteUnbuffered to write to disk.</li><li>Flush(): Calls the system write to write the data currently in the memory cache to disk. Note that <strong>this does not guarantee that the data has been synchronized to the physical disk</strong>.</li><li>Sync(): Ensures that the data in the internal buffer is written to the file, and also <strong>ensures that the data is synchronized to the physical disk</strong> to guarantee data persistence. After calling Sync(), the data will not be lost even if a power failure or system crash occurs.</li></ul><p>In the POSIX environment, the implementation of this class is <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L277">PosixWritableFile</a>. The class internally uses a <strong>buffer of 65536 bytes</strong> <code>buf_</code>, and only writes data to the disk file when the buffer is full. If there are a large number of short content writes, they can be merged in memory first, thereby reducing the number of calls to the underlying file system and improving the efficiency of write operations.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">size_t</span> kWritableFileBufferSize = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf_[0, pos_ - 1] contains data to be written to fd_.</span></span><br><span class="line">  <span class="type">char</span> buf_[kWritableFileBufferSize];</span><br></pre></td></tr></table></figure><p>The strategy for merging writes is implemented in Append, and the code is quite clear. For the content to be written, if it can be completely placed in the buffer, it is directly copied to the buffer, and then returns success. Otherwise, it first fills the buffer, then writes the data in the buffer to the file. At this point, if the remaining data can be written to the buffer, it is written directly, otherwise it is flushed directly to the disk. The complete implementation is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Append</span><span class="params">(<span class="type">const</span> Slice&amp; data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> write_size = data.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* write_data = data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fit as much as possible into buffer.</span></span><br><span class="line">  <span class="type">size_t</span> copy_size = std::<span class="built_in">min</span>(write_size, kWritableFileBufferSize - pos_);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(buf_ + pos_, write_data, copy_size);</span><br><span class="line">  write_data += copy_size;</span><br><span class="line">  write_size -= copy_size;</span><br><span class="line">  pos_ += copy_size;</span><br><span class="line">  <span class="keyword">if</span> (write_size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Can&#x27;t fit in buffer, so need to do at least one write.</span></span><br><span class="line">  Status status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Small writes go to buffer, large writes are written directly.</span></span><br><span class="line">  <span class="keyword">if</span> (write_size &lt; kWritableFileBufferSize) &#123;</span><br><span class="line">    std::<span class="built_in">memcpy</span>(buf_, write_data, write_size);</span><br><span class="line">    pos_ = write_size;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WriteUnbuffered</span>(write_data, write_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The WriteUnbuffered function is called above to write data to disk, which is implemented through the system call <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>. The main code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteUnbuffered</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> write_result = ::<span class="built_in">write</span>(fd_, data, size);</span><br><span class="line">    <span class="keyword">if</span> (write_result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    data += write_result;</span><br><span class="line">    size -= write_result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In addition to the Append function, WritableFile also provides a Flush interface for writing the data in the memory buffer buf_ to the file, which is also implemented by calling WriteUnbuffered internally. However, it’s worth noting that even if Flush writes to disk successfully, it <strong>does not guarantee that the data has been written to the disk, or even that the disk has enough space to store the content</strong>. If you want to ensure that the data is successfully written to the physical disk file, you need to call the Sync() interface, implemented as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Sync</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  Status status = <span class="built_in">SyncDirIfManifest</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line">  status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SyncFd</span>(fd_, filename_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The core here is calling the SyncFd() method, which <strong>ensures that all buffered data associated with the file descriptor fd is synchronized to the physical disk</strong>. The implementation of this function considers different operating system characteristics and file system behaviors, using conditional compilation directives (#if, #else, #endif) to handle different environments. On macOS and iOS systems, it uses the <code>F_FULLFSYNC</code> option of the fcntl() function to ensure that data is synchronized to the physical disk. If HAVE_FDATASYNC is defined, it will use fdatasync() to synchronize data. In other cases, it defaults to using the fsync() function to achieve the same functionality.</p><p>Note that SyncDirIfManifest ensures that if the file is a manifest file (named starting with “MANIFEST”), related directory changes are also synchronized. The manifest file records the metadata of the database files, including version information, merge operations, database status, and other critical information. When the file system creates new files or modifies file directory entries, these changes may not be immediately written to disk. <strong>Ensuring that the data of the directory has been synchronized to disk before updating the manifest file</strong> prevents the files referenced by the manifest file from not being actually written to disk when the system crashes.</p><h2 id="Resource-Concurrent-Limitation"><a href="#Resource-Concurrent-Limitation" class="headerlink" title="Resource Concurrent Limitation"></a>Resource Concurrent Limitation</h2><p>As mentioned above, to avoid having too many open file descriptors, the Acquire method of the Limiter class is used for limitation. This class is also implemented in <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L73">env_posix.cc</a>. The comments for this class are particularly good, clearly explaining its purpose, which is mainly used to limit resource usage to avoid resource exhaustion. It is currently used to limit read-only file descriptors and mmap file usage to avoid running out of file descriptors or virtual memory, or encountering kernel performance problems in very large databases.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper class to limit resource usage to avoid exhaustion.</span></span><br><span class="line"><span class="comment">// Currently used to limit read-only file descriptors and mmap file usage</span></span><br><span class="line"><span class="comment">// so that we do not run out of file descriptors or virtual memory, or run into</span></span><br><span class="line"><span class="comment">// kernel performance problems for very large databases.</span></span><br></pre></td></tr></table></figure><p>The constructor takes a parameter max_acquires, which sets the maximum number of resources that can be acquired. The class internally maintains an atomic variable acquires_allowed_ to track the number of resources currently allowed to be acquired, with an initial value set to max_acquires. Conditional compilation is used here, NDEBUG is a commonly used preprocessor macro used to indicate whether the program is compiled in non-debug mode.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Limit maximum number of resources to |max_acquires|.</span></span><br><span class="line">  <span class="built_in">Limiter</span>(<span class="type">int</span> max_acquires)</span><br><span class="line">      :</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(NDEBUG)</span></span><br><span class="line">        <span class="built_in">max_acquires_</span>(max_acquires),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(NDEBUG)</span></span></span><br><span class="line">        <span class="built_in">acquires_allowed_</span>(max_acquires) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(max_acquires &gt;= <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>If in debug mode, max_acquires_ is used to record the maximum number of resources, and assertions are added in the Acquire and Release methods to ensure that resource acquisition and release operations are correct. In the production environment, <strong>when NDEBUG is defined, all assert calls will be ignored by the compiler and will not generate any execution code</strong>.</p><p>The core interfaces of this class are Acquire and Release. These two methods are used to acquire and release resources respectively. The code for Acquire is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> old_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (old_acquires_allowed &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pre_increment_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Silence compiler warnings about unused arguments when NDEBUG is defined.</span></span><br><span class="line">  (<span class="type">void</span>)pre_increment_acquires_allowed;</span><br><span class="line">  <span class="comment">// If the check below fails, Release() was called more times than acquire.</span></span><br><span class="line">  <span class="built_in">assert</span>(pre_increment_acquires_allowed &lt; max_acquires_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, fetch_sub(1, std::memory_order_relaxed) is used to atomically decrease the value of acquires_allowed_ and return the value before the decrease as old_acquires_allowed. If old_acquires_allowed is greater than 0, it means there were resources available before the decrease, so it returns true. If no resources are available (i.e., old_acquires_allowed is 0 or negative), it atomically adds the counter back to 1 using fetch_add(1, std::memory_order_relaxed) to restore the state, and returns false.</p><p>The Release method is used to release resources previously successfully acquired through the Acquire method. It uses fetch_add(1, std::memory_order_relaxed) to atomically increase the value of acquires_allowed_, indicating that the resource has been released, and uses an assertion to ensure that the number of Release calls does not exceed the number of successful Acquire calls, preventing resource count errors.</p><p>When operating on the atomic counter here, std::memory_order_relaxed is used, indicating that these atomic operations <strong>do not need any special ordering constraints on memory</strong>, only guaranteeing the atomicity of the operation. This is because the operations here do not depend on the results of any other memory operations, they simply increment or decrement the counter.</p><h2 id="Env-Encapsulation-Interface"><a href="#Env-Encapsulation-Interface" class="headerlink" title="Env Encapsulation Interface"></a>Env Encapsulation Interface</h2><p>In addition to the above file operation classes, there is also an important Env abstract base class, which derives PosixEnv under Posix, encapsulating many implementations.</p><h3 id="Factory-Construction-of-Objects"><a href="#Factory-Construction-of-Objects" class="headerlink" title="Factory Construction of Objects"></a>Factory Construction of Objects</h3><p>First are several factory methods used to create file read and write objects like SequentialFile, RandomAccessFile, and WritableFile objects. The NewSequentialFile factory method creates a PosixSequentialFile file object, encapsulating the call to open the file. The advantage of using the factory method here is that it can handle some errors, such as file opening failure. Additionally, the input parameter is <code>WritableFile**</code>, supporting polymorphism. If other WritableFile implementations are added in the future, they can be switched to different implementations by modifying the factory method without changing the calling code.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewSequentialFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                         SequentialFile** result)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    *result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename, errno);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *result = <span class="keyword">new</span> <span class="built_in">PosixSequentialFile</span>(filename, fd);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When opening a file here, in addition to O_RDONLY indicating read-only, there is also a kOpenBaseFlags. kOpenBaseFlags is a flag that is set based on the compilation option HAVE_O_CLOEXEC. If the system supports O_CLOEXEC, this flag will be set. O_CLOEXEC ensures that <strong>the file descriptor is automatically closed when executing exec() series functions, thus preventing file descriptor leakage to the newly executed program</strong>.</p><p>By default, when a process creates a child process, all file descriptors are inherited by the child process. Unless explicitly handled for each file descriptor, they will remain open after exec is executed. In most cases, if a process intends to execute another program (usually through exec series functions), it’s likely that it doesn’t want the new program to access certain resources of the current process, especially file descriptors. The O_CLOEXEC flag ensures that these file descriptors are automatically closed after exec, thus not leaking to the new program. Although LevelDB itself doesn’t call exec functions, this flag is still added here, which is a good defensive programming habit.</p><p>Of course, this flag may not be supported on all platforms. For cross-platform compatibility, in <a href="https://github.com/google/leveldb/blob/main/CMakeLists.txt#L54">CmakeLists.txt</a>, check_cxx_symbol_exists is used to detect whether the current environment’s fcntl.h file has O_CLOEXEC, and if so, the HAVE_O_CLOEXEC macro is defined. It’s worth mentioning that check_cxx_symbol_exists is quite useful, it can <strong>determine whether specific features are supported before compilation, so that compilation settings or source code can be adjusted appropriately based on the detection results</strong>. Several macros in LevelDB are detected in this way, such as fdatasync, F_FULLFSYNC, etc.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">check_cxx_symbol_exists(fdatasync <span class="string">&quot;unistd.h&quot;</span> HAVE_FDATASYNC)</span><br><span class="line">check_cxx_symbol_exists(F_FULLFSYNC <span class="string">&quot;fcntl.h&quot;</span> HAVE_FULLFSYNC)</span><br><span class="line">check_cxx_symbol_exists(O_CLOEXEC <span class="string">&quot;fcntl.h&quot;</span> HAVE_O_CLOEXEC)</span><br></pre></td></tr></table></figure><p>The NewWritableFile and NewAppendableFile factory functions are similar, first opening the file and then creating a PosixWritableFile object. However, different flags are used when opening the file:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_TRUNC | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_APPEND | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure><p>O_TRUNC indicates that if the file exists, its length will be truncated to 0. O_APPEND indicates that when writing data, it will always append the data to the end of the file, rather than overwriting existing data in the file.</p><p>NewRandomAccessFile is a bit more complex because it supports two modes of random reading. First, it opens the file to get the fd, then uses mmap_limiter_ to limit the number of memory-mapped open files. If it exceeds the mmap limit, it uses pread for random reading. If it doesn’t exceed the limit, it uses mmap to memory-map the file, gets the mapped address and file size, and then creates a PosixMmapReadableFile object.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewRandomAccessFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                           RandomAccessFile** result)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!mmap_limiter_.<span class="built_in">Acquire</span>()) &#123;</span><br><span class="line">    *result = <span class="keyword">new</span> <span class="built_in">PosixRandomAccessFile</span>(filename, fd, &amp;fd_limiter_);</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint64_t</span> file_size;</span><br><span class="line">  Status status = <span class="built_in">GetFileSize</span>(filename, &amp;file_size);</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="type">void</span>* mmap_base = ::<span class="built_in">mmap</span>(<span class="comment">/*addr=*/</span><span class="literal">nullptr</span>, file_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmap_base != MAP_FAILED) &#123;</span><br><span class="line">      *result = <span class="keyword">new</span> <span class="built_in">PosixMmapReadableFile</span>(filename,</span><br><span class="line">                                          <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(mmap_base),</span><br><span class="line">                                          file_size, &amp;mmap_limiter_);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  ::<span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    mmap_limiter_.<span class="built_in">Release</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, the maximum number of files limited by mmap_limiter_ is obtained by the MaxMmaps function. For 64-bit systems, due to the very large virtual memory address space (usually over 256TB in actual applications), LevelDB allows allocating 1000 memory-mapped areas, which should not have a significant impact on the overall performance of the system. For 32-bit systems, due to the limited virtual memory address space, LevelDB does not allow allocating memory-mapped areas.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Up to 1000 mmap regions for 64-bit binaries; none for 32-bit.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> kDefaultMmapLimit = (<span class="built_in">sizeof</span>(<span class="type">void</span>*) &gt;= <span class="number">8</span>) ? <span class="number">1000</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="File-Utility-Classes"><a href="#File-Utility-Classes" class="headerlink" title="File Utility Classes"></a>File Utility Classes</h3><p>In addition to the several core file classes mentioned above, Env also provides a series of file operation interfaces, including file metadata retrieval, file deletion, etc. This is a good opportunity to familiarize ourselves with <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc">various system calls in the Posix environment</a>.</p><p>FileExists: Determines <strong>whether the current process can access the file (inability to access does not mean the file does not exist)</strong>, implemented by calling the system call <a href="https://man7.org/linux/man-pages/man2/access.2.html">access()</a>;</p><p>RemoveFile: If no process is currently using the file (i.e., no open file descriptors point to this file), it will delete the file. Implemented through the system call <a href="https://man7.org/linux/man-pages/man2/unlink.2.html">unlink()</a>, unlink actually deletes the link between the filename and its corresponding inode. If this inode has no other links and no process has this file open, the actual data blocks and inode of the file will be released.</p><p>GetFileSize: Gets the size of the file. If the file does not exist or the retrieval fails, it returns 0. This is implemented through the <a href="https://man7.org/linux/man-pages/man2/stat.2.html">stat</a> system call. When calling the stat function, you need to pass the filename and a pointer to a stat structure. The system will check the path permissions corresponding to the filename, then retrieve the file’s inode. The inode is a data structure in the file system that stores the file’s metadata, including file size, permissions, creation time, last access time, etc. The file system maintains an inode table for quick lookup and access to inode information, and for most file systems (such as EXT4, NTFS, XFS, etc.), commonly used inodes are usually cached in memory, so retrieving the inode is generally very efficient.</p><p>RenameFile: Renames a file or folder. You can specify new and old filenames here, implemented through the system call <a href="https://man7.org/linux/man-pages/man2/rename.2.html">rename()</a>.</p><p>CreateDir: Creates a directory with default permissions of 755. This is implemented through the system call <a href="https://man7.org/linux/man-pages/man2/mkdir.2.html">mkdir()</a>. If pathname already exists, it returns failure.</p><p>RemoveDir: Deletes a directory, implemented through the system call <a href="https://man7.org/linux/man-pages/man2/rmdir.2.html">rmdir()</a>.</p><p>GetChildren: Slightly more complex, it uses the system call opendir to get the directory, then uses readdir to traverse the files in it, and finally remembers to use closedir to clean up resources.</p><h2 id="File-Operation-Summary"><a href="#File-Operation-Summary" class="headerlink" title="File Operation Summary"></a>File Operation Summary</h2><p>It must be said that a simple file operation encapsulation contains many implementation details. Let’s summarize them briefly:</p><ol><li>Buffer optimization: In the WritableFile implementation, a memory buffer is used, which can merge small write operations, reduce the number of system calls, and improve write efficiency.</li><li>Resource limit management: The Limiter class is used to limit the number of simultaneously open file descriptors and memory mappings (mmap). By setting reasonable upper limits, resource exhaustion is avoided, improving system stability and performance.</li><li>Flexible reading strategy: For random reading, LevelDB provides two implementations based on pread and mmap, which can dynamically choose the most appropriate method according to system resource conditions.</li><li>Factory method pattern: Using factory methods to create file objects encapsulates operations such as file opening, facilitating error handling and future expansion.</li><li>Cross-platform compatibility: Through conditional compilation and feature detection (such as checking for O_CLOEXEC), code compatibility on different platforms is ensured.</li><li>Synchronization mechanism: Flush and Sync interfaces are provided, allowing users to choose different levels of data persistence guarantees as needed.</li></ol><p>In addition to encapsulating file operations, there are other encapsulations in Env, which we’ll see in the next article.</p>]]></content:encoded>
      
      
      <category domain="https://selfboot.cn/categories/Source-Code-Analysis/">Source Code Analysis</category>
      
      
      <category domain="https://selfboot.cn/tags/C/">C++</category>
      
      <category domain="https://selfboot.cn/tags/LevelDB/">LevelDB</category>
      
      
      <comments>https://selfboot.cn/en/2024/08/02/leveldb_source_env_posixfile/#disqus_thread</comments>
      
    </item>
    
    
    
    
    
    
    
    <item>
      <title>LevelDB Explained - Preventing C++ Object Destruction</title>
      <link>https://selfboot.cn/en/2024/07/22/leveldb_source_nodestructor/</link>
      <guid>https://selfboot.cn/en/2024/07/22/leveldb_source_nodestructor/</guid>
      <pubDate>Mon, 22 Jul 2024 18:03:10 GMT</pubDate>
      
      <description>Delve into the NoDestructor template class in LevelDB&#39;s source code, revealing its implementation principles and motivations for preventing object destruction. Analyze the C++ static local variable destruction order issue, introduce NoDestructor&#39;s design details, test cases, and practical application scenarios. Suitable for C++ developers and programmers interested in low-level systems, helping you master advanced C++ programming techniques.</description>
      
      
      
      <content:encoded><![CDATA[<p>In the LevelDB source code, there’s a function for getting a Comparator that seemed a bit strange when I first saw it. It looks like it constructs a singleton, but it’s slightly more complex. The complete code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/comparator.cc</span></span><br><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, <code>NoDestructor</code> is a template class that, judging by its name, is used to <strong>prevent object destruction</strong>. Why prevent object destruction, and how is it achieved? This article will delve into these questions.</p><span id="more"></span><h2 id="The-NoDestructor-Template-Class"><a href="#The-NoDestructor-Template-Class" class="headerlink" title="The NoDestructor Template Class"></a>The NoDestructor Template Class</h2><p>Let’s first look at the <code>NoDestructor</code> template class, which is used to <strong>wrap an instance so that its destructor is never called</strong>. This template class uses several advanced features, such as template programming, perfect forwarding, static assertions, alignment requirements, and placement new. Let’s explain each of these. First, here’s the complete code implementation:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/no_destructor.h</span></span><br><span class="line"><span class="comment">// Wraps an instance whose destructor is never called.</span></span><br><span class="line"><span class="comment">// This is intended for use with function-level static variables.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InstanceType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoDestructor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ConstructorArgTypes&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">NoDestructor</span><span class="params">(ConstructorArgTypes&amp;&amp;... constructor_args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(instance_storage_) &gt;= <span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                  <span class="string">&quot;instance_storage_ is not large enough to hold the instance&quot;</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        <span class="built_in">alignof</span>(<span class="keyword">decltype</span>(instance_storage_)) &gt;= <span class="built_in">alignof</span>(InstanceType),</span><br><span class="line">        <span class="string">&quot;instance_storage_ does not meet the instance&#x27;s alignment requirement&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> (&amp;instance_storage_)</span><br><span class="line">        <span class="built_in">InstanceType</span>(std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">NoDestructor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NoDestructor</span>(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  NoDestructor&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">InstanceType* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;InstanceType*&gt;(&amp;instance_storage_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typename</span> std::aligned_storage&lt;<span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                                <span class="built_in">alignof</span>(InstanceType)&gt;::type instance_storage_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Let’s start with the constructor part. <code>typename... ConstructorArgTypes</code> indicates that this is a variadic template function, which can accept any number and type of parameters. This allows the NoDestructor class to be used with any type of InstanceType, regardless of how many parameters or what types of parameters its constructor needs. For more on variadic templates, you can also check out an article I wrote earlier: <a href="https://selfboot.cn/2024/05/07/variadic_arguments_in_c++/">The Evolution of Variadic Arguments Implementation in C++</a>.</p><p>The constructor parameter <code>ConstructorArgTypes&amp;&amp;... constructor_args</code> is a universal reference parameter pack, which, when used in conjunction with std::forward, can achieve perfect forwarding of parameters.</p><p>The constructor begins with two <strong>static assertions (static_assert) to check if instance_storage_ is large enough and meets the alignment requirements</strong>. The first static_assert ensures that the storage space allocated for InstanceType, instance_storage_, is at least as large as the InstanceType instance itself, <strong>to ensure there’s enough space to store an object of that type</strong>. The second static_assert ensures that the alignment of instance_storage_ meets the alignment requirements of InstanceType. The memory alignment requirements for objects are related to performance, which we won’t expand on here.</p><p>Then it starts constructing the object, using <strong>C++’s placement new syntax</strong>. <code>&amp;instance_storage_</code> provides an address, telling the compiler to construct the InstanceType object at this pre-allocated memory address. This avoids additional memory allocation, constructing the object directly in the reserved memory block. Next, using perfect forwarding, <code>std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...</code> ensures that all constructor parameters are passed to InstanceType’s constructor with the correct type (preserving lvalue or rvalue properties). This is best practice for parameter passing in modern C++, reducing unnecessary copy or move operations and improving efficiency.</p><p>The memory address used for placement new construction earlier is provided by the member variable instance_storage_, whose type is defined by the <a href="https://en.cppreference.com/w/cpp/types/aligned_storage">std::aligned_storage</a> template. This is a specially designed type <strong>used to provide a raw memory block that can safely store any type, while ensuring that the stored object type (InstanceType here) has appropriate size and alignment requirements</strong>. Here, the raw memory area created by std::aligned_storage is consistent with the memory area where the NoDestructor object is located, meaning that if NoDestructor is defined as a local variable within a function, both it and its instance_storage_ will be located on the stack. If NoDestructor is defined as a static or global variable, it and instance_storage_ will be in the static storage area, and objects in the static storage area have a lifetime that spans the entire program execution.</p><p>It’s worth noting that in the C++23 standard, std::aligned_storage will be deprecated. For more details, refer to <a href="https://stackoverflow.com/questions/71828288/why-is-stdaligned-storage-to-be-deprecated-in-c23-and-what-to-use-instead">Why is std::aligned_storage to be deprecated in C++23 and what to use instead?</a>.</p><p>Returning to the example at the beginning of the article, the singleton object is a static local variable initialized the first time BytewiseComparator() is called, and its lifetime is as long as the entire program’s lifetime. When the program exits, <strong>the singleton object itself will be destructed and destroyed</strong>, but NoDestructor hasn’t added any logic in its destructor to destruct the object constructed in instance_storage_, so the BytewiseComparatorImpl object in instance_storage_ will never be destructed.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LevelDB also provides a test case to verify that NoDestructor here behaves as expected.</p><h2 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test Case"></a>Test Case</h2><p>In <code>util/no_destructor_test.cc</code>, a struct <code>DoNotDestruct</code> is first defined, which calls std::abort() in its destructor. If the program runs or exits and calls the destructor of a DoNotDestruct object, the test program will terminate abnormally.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DoNotDestruct</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DoNotDestruct</span>(<span class="type">uint32_t</span> a, <span class="type">uint64_t</span> b) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">DoNotDestruct</span>() &#123; std::<span class="built_in">abort</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used to check constructor argument forwarding.</span></span><br><span class="line">  <span class="type">uint32_t</span> a;</span><br><span class="line">  <span class="type">uint64_t</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Then two test cases are defined, one defining a NoDestructor object on the stack, and the other defining a static NoDestructor object. These two test cases verify the behavior of NoDestructor objects on the stack and in the static storage area, respectively.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StackInstance) &#123;</span><br><span class="line">  <span class="function">NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StaticInstance) &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the implementation of NoDestructor is problematic and cannot ensure that the destruction of the passed-in object is not executed, the test program will terminate abnormally. Let’s run these two test cases, and the result is as follows:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png" alt="Test cases pass, destructor not called"></p><p>Here we can add a test case to verify what happens if we directly define a DoNotDestruct object, whether the test process will terminate abnormally. We can first define an object on the stack to test, placing it before the other two test cases, as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, Instance) &#123;</span><br><span class="line">  <span class="function">DoNotDestruct <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The result of running is as follows, this test case will terminate abnormally during execution, indicating that the destructor of the DoNotDestruct object was called.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png" alt="Test process terminates abnormally, indicating destructor was called"></p><p>Actually, we can modify this further by directly defining the instance object here with static, then compiling and re-running the test cases. You’ll find that all 3 test cases pass, but the test process still aborts at the end. This is because when the process exits, static objects are destructed, and at this time, the destructor of the DoNotDestruct object is called.</p><h2 id="Why-Can’t-It-Be-Destructed"><a href="#Why-Can’t-It-Be-Destructed" class="headerlink" title="Why Can’t It Be Destructed?"></a>Why Can’t It Be Destructed?</h2><p>In the above example, we saw the implementation of the NoDestructor template class, which serves to prevent the destruction of static local singleton objects. So why prevent object destruction? Simply put, <strong>the C++ standard does not specify the destruction order of static local variables in different compilation units</strong>. If there are dependencies between static variables and their destruction order is incorrect, it may lead to the program accessing already destructed objects, resulting in undefined behavior that could cause the program to crash.</p><p>Let’s take an example. Suppose there are two classes, one is a logging system and the other is some kind of service. The service needs to log information to the logging system during destruction. The code for the logger class is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span> <span class="comment">// Include assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isAlive; <span class="comment">// Flag to check if the object has been destructed</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Logger instance; <span class="comment">// Static local variable</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>() : <span class="built_in">isAlive</span>(<span class="literal">true</span>) &#123;&#125; <span class="comment">// Constructor initializes isAlive to true</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Logger destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        isAlive = <span class="literal">false</span>; <span class="comment">// Mark as destructed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(isAlive); <span class="comment">// Assert the object is not destructed</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Note the isAlive member variable of this class, which is initialized to true in the constructor and set to false in the destructor. In the log function, it first checks if isAlive is true, and if it’s false, it will trigger an assertion failure. Next is the code for the service class, which, as an example, only uses the static local variable of the logger class to record a log during destruction.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Service</span>() &#123;</span><br><span class="line">        Logger::<span class="built_in">getInstance</span>().<span class="built_in">log</span>(<span class="string">&quot;Service destroyed.&quot;</span>); <span class="comment">// Log during destruction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>In the main function, use global variables globalService and globalLogger, where globalService is a global Service instance and globalLogger is a Logger singleton.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Service globalService; <span class="comment">// Global Service instance</span></span><br><span class="line">Logger&amp; globalLogger = Logger::<span class="built_in">getInstance</span>(); <span class="comment">// Global Logger instance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Compile and run this program:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -g -fno-omit-frame-pointer -o main main.cpp</span></span><br></pre></td></tr></table></figure><p>After running, the assert assertion will <strong>most likely fail</strong>. We know that <strong>in a single compilation unit (here main.cpp), global variables are initialized in the order they appear, and then destructed in the reverse order</strong>. Here, globalLogger will be destructed first, then globalService. In globalService’s destructor, it will call Logger’s log function, but at this point globalLogger has already been destructed, isAlive has been set to false, so it will likely trigger an assertion failure. The reason we say “most likely” is because after the globalLogger object is destructed, the memory space it occupied may <strong>not yet have been reclaimed by the operating system or used for other purposes</strong>, so access to its member variable isAlive may still appear “normal”. Here’s the result of my run:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">main: logger.h:22: void Logger::log(const string&amp;): Assertion `isAlive&#x27; failed.</span><br><span class="line">[1]    1017435 abort      ./main</span><br></pre></td></tr></table></figure><p>In fact, if we don’t add the isAlive-related logic here, the output when running will most likely be as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">Log: Service destroyed.</span><br></pre></td></tr></table></figure><p>From the output, we can see that, as before, globalLogger is destructed first, followed by globalService. However, the process is unlikely to crash here. This is because after globalLogger is destructed, <strong>although its lifecycle has ended, calls to member functions may still execute “normally”</strong>. The execution of member functions here usually depends on the class’s code (located in the code segment), and as long as the content of the code segment hasn’t been rewritten and the method doesn’t depend on member variables that have been destroyed or changed, it may still run without error.</p><p>Of course, even if it doesn’t trigger a program crash here, using an already destructed object is <a href="https://selfboot.cn/en/2016/09/18/c++_undefined_behaviours/">undefined behavior</a> in C++. Undefined behavior means the program may crash, may run normally, or may produce unpredictable results. The results of such behavior may vary on different systems or at different runtimes, and we must avoid this situation in our development.</p><p>Actually, as far as LevelDB’s implementation here is concerned, BytewiseComparatorImpl is a <a href="https://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor">trivially destructible</a> object that doesn’t depend on other global variables, so its own destruction won’t be problematic. If we use it to generate a static local singleton object and then use it in other static local objects or global objects, these objects will call BytewiseComparatorImpl’s destructor when they are destructed. And according to the previous analysis, BytewiseComparatorImpl itself is a static local object, <strong>which may be destructed earlier than the objects using it when the process ends and resources are reclaimed</strong>. This would lead to repeated destruction, producing undefined behavior.</p><p>For more explanations about static variable destruction, you can also refer to the article <a href="https://ppwwyyxx.com/blog/2023/Safe-Static-Initialization-No-Destruction/">Safe Static Initialization, No Destruction</a>, where the author discusses this issue in detail.</p>]]></content:encoded>
      
      
      <category domain="https://selfboot.cn/categories/Source-Code-Analysis/">Source Code Analysis</category>
      
      
      <category domain="https://selfboot.cn/tags/C/">C++</category>
      
      <category domain="https://selfboot.cn/tags/LevelDB/">LevelDB</category>
      
      
      <comments>https://selfboot.cn/en/2024/07/22/leveldb_source_nodestructor/#disqus_thread</comments>
      
    </item>
    
    
    
    
    
    <item>
      <title>Creating Games Using Free Claude3.5 with Artifacts</title>
      <link>https://selfboot.cn/en/2024/06/22/claude35_artifacts/</link>
      <guid>https://selfboot.cn/en/2024/06/22/claude35_artifacts/</guid>
      <pubDate>Sat, 22 Jun 2024 13:47:28 GMT</pubDate>
      
      <description>This article explores Anthropic&#39;s newly released Claude 3.5 model and its Artifacts feature, showcasing its exceptional code generation and problem-solving capabilities through the rapid implementation of Gomoku and Tetris games. It also discusses some limitations of the current version, such as restrictions on workspace functionality, and looks ahead to the future direction of AI-assisted programming.</description>
      
      
      
      <content:encoded><![CDATA[<p>Anthropic has <strong>quietly</strong> released the <a href="https://www.anthropic.com/news/claude-3-5-sonnet">Claude 3.5 model</a>, which not only improves model performance but also supports Artifacts. After initial experience, I feel this is what the future of AI should look like, even more impressive than the previous GPT4-o.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_artifacts.png" alt="Coding in the Artifacts workspace"></p><p>Before Artifacts, if you wanted to use ChatGPT or other LLMs to help implement program functionality, you needed to first provide the functional requirements, then copy the AI’s code into your own environment to run. If it didn’t meet expectations, you had to ask again, modify the code, and run it again. This process needed to be repeated until satisfaction or giving up (some complex code is still not well written by AI currently).</p><span id="more"></span><p>Now with Artifacts, after providing specific functional requirements, Claude creates a <strong>workspace</strong>, where AI can view and edit code in real-time during the subsequent dialogue process. This way, Claude has transformed from an ordinary conversational generation AI into a <strong>collaborative work environment</strong>. Perhaps in the near future, we can incorporate Claude into our own projects, allowing it to participate in development like a regular team member.</p><p>The vision is certainly beautiful, but Artifacts is still a beta feature at present. How does it perform? Let’s try and see.</p><h2 id="AI-Implementation-of-Gomoku-Game"><a href="#AI-Implementation-of-Gomoku-Game" class="headerlink" title="AI Implementation of Gomoku Game"></a>AI Implementation of Gomoku Game</h2><p>First, I tried to let Claude implement a web version of the Gomoku game. My prompt was also very simple:</p><blockquote><p>I want to write a web Gomoku game, please provide the complete implementation code</p></blockquote><p>Then, I saw the Artifacts workspace, which already had a code file and was automatically generating code.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_gobang_code.png" alt="Artifacts generating Gomoku code file"></p><p>After the code was generated, it directly jumped to a preview page where I could see the Gomoku interface. I originally thought this preview page was static, but surprisingly, I could interact on this page. Clicking on positions on the board would alternately place black and white pieces.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_gobang_preview.png" alt="Artifacts generated Gomoku interface preview"></p><p>Since it could place pieces, I wondered if it had implemented the rules of Gomoku. So I played a bit and found that AI had indeed implemented the rules of Gomoku, and even had win&#x2F;loss judgment.</p><p>This <strong>completely exceeded expectations</strong>!!! With just one sentence, really just one sentence, <strong>AI implemented a fairly complete Gomoku game, with a beautiful interface, rule judgment, and win&#x2F;loss determination. It’s already completely playable</strong>.</p><p>The key is that AI also gave some suggestions for further improving the game, such as:</p><ul><li>Adding an undo function</li><li>Implementing a timer</li><li>Adding sound effects</li><li>Implementing an AI opponent</li><li>Optimizing the experience on mobile devices</li></ul><p>It feels like this is not an AI, but a flesh-and-blood, opinionated, experienced front-end engineer.</p><h3 id="Gomoku-Game-Demo"><a href="#Gomoku-Game-Demo" class="headerlink" title="Gomoku Game Demo"></a>Gomoku Game Demo</h3><p>You can experience the AI-written Gomoku game at the <a href="#Gomoku-Game-Demo">demo address</a> in the blog post.</p><div id="game-container">    <div id="board"></div>    <p id="status">Black's turn</p>    <button onclick="resetGame()">Restart</button></div><p>After showing the Gomoku effect generated by Claude3.5 to a friend, they were a bit skeptical about where AI got the code from. After all, Gomoku implementations are everywhere on the internet, and AI might have learned someone else’s code and used it. This makes sense, so we can only upgrade the difficulty to see how Claude3.5 performs.</p><h2 id="AI-Implementation-of-Tetris"><a href="#AI-Implementation-of-Tetris" class="headerlink" title="AI Implementation of Tetris"></a>AI Implementation of Tetris</h2><p>Next, let’s try a more complex game, Tetris. Also starting with a simple prompt, AI generated an initial Python version. To run it directly in the blog, I asked it to change to a web version. The first version generated, when embedded in the blog, found that the border was gone, and when using the up and down keys to switch shapes, the webpage would scroll along. So I asked Claude to solve this problem, and unexpectedly, it gave perfect code in one go.</p><p>As you can see from the image below, after re-prompting, Claude provided a second version of the file, and then the preview page was a complete Tetris game, controllable by keyboard to move and rotate blocks.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_tetris.png" alt="Artifacts generated Tetris interface preview"></p><p>Here, through <strong>continuous dialogue prompts</strong>, some functions were modified, and by the 5th version, we got a very good functional prototype. Throughout the conversation process, Claude3.5’s <strong>understanding ability was quite good</strong>, not very different from GPT4, and the final implementation effect also exceeded expectations.</p><h3 id="Tetris-Demo"><a href="#Tetris-Demo" class="headerlink" title="Tetris Demo"></a>Tetris Demo</h3><p>I’ve directly embedded the AI-generated code into the blog, and you can experience the Tetris game in the <a href="###Tetris-Demo">demo below</a>.</p><div id="tetrisContainer">    <canvas id="tetrisCanvas" width="300" height="600"></canvas>    <button id="startButton">Start Game</button>    <div id="gameOverMessage">        Game Over!<br>        Your score is: <span id="finalScore"></span><br>        <button id="restartButton">Restart</button>    </div></div><p>Judging from the continuous modification process of Tetris here, AI’s understanding ability and coding skills are quite strong, probably on par with GPT4.</p><h2 id="Everyone-Using-AI-to-Write-Programs"><a href="#Everyone-Using-AI-to-Write-Programs" class="headerlink" title="Everyone Using AI to Write Programs"></a>Everyone Using AI to Write Programs</h2><p>From the simple games written above, Anthropic’s performance is quite impressive. In fact, I also tried to use it to do some algorithm Web visualizations, and Claude3.5 provided very good examples. For instance, I asked it to implement a token bucket rate limiting algorithm, where you can set the token bucket capacity and rate, as well as the token consumption speed, and then have it draw a request monitoring curve.</p><p>After setting the parameters each time, it would dynamically generate a monitoring curve. Then you could pause at any time, reset the parameters, and continue to generate new monitoring curves. After setting a few parameters and running, I got the following result:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240622_claude35_artifacts_token_bucket.png" alt="Artifacts generated token bucket rate limiting algorithm interface preview"></p><p>For people without front-end development experience, being able to quickly implement a visualized algorithm demonstration is truly magical. With Anthropic’s help, everyone can break out of their circle, <strong>no longer limited by their own technical experience, and quickly implement some of their ideas</strong>.</p><p>Especially for people who want to learn programming, in the past, you basically had to first study books, learn skills, and then gradually apply them to projects. Now you can have a conversation with AI with questions, let AI help implement, and if you have any problems in between, you can communicate with AI at any time. <strong>This learning process is more interesting</strong>. After all, if you ask me to first learn a bunch of front-end syntax and then stumble to implement a Tetris game, I would give up very quickly. But if I can generate a complete, runnable game with just one sentence, and then discuss the implementation process and code details with AI, it would be much more interesting and give a greater sense of achievement.</p><h2 id="Anthropic’s-Shortcomings"><a href="#Anthropic’s-Shortcomings" class="headerlink" title="Anthropic’s Shortcomings"></a>Anthropic’s Shortcomings</h2><p>Of course, the current Anthropic is only a beta version and still has many shortcomings. The article title mentions using free Claude3.5, but there are quite a few limitations in the free version. First, there’s a <a href="https://support.anthropic.com/en/articles/7996848-how-large-is-claude-s-context-window">limit on conversation length</a>. If the content is a bit long, adding attachments will prompt:</p><blockquote><p>Your message will exceed the length limit for this chat. Try attaching fewer or smaller files or starting a new conversation. Or consider upgrading to Claude Pro.</p></blockquote><p>Even without attachments, too many conversation turns will prompt:</p><blockquote><p>Your message will exceed the length limit for this chat. Try shortening your message or starting a new conversation. Or consider upgrading to Claude Pro.</p></blockquote><p>Moreover, the free version <strong>has a limit on the number of messages that can be sent per hour</strong>, which is easily triggered. However, these are all minor issues that can be solved by upgrading to Pro. In my opinion, Anthropic’s <strong>biggest flaw currently is that the workspace functionality is too limited</strong>, still quite far from being truly practical.</p><p>Currently (as of 2024.06.22), the code in the workspace can only be generated by AI, <strong>it cannot be edited by yourself</strong>, nor can you upload your own code. If you want to make some simple modifications based on AI code, it’s very difficult. Additionally, in each conversation, the content generated in the workspace is all put together, <strong>you can’t generate multiple files like in a file system</strong>.</p><p>For example, if I want to use Python to implement a web backend service, using the FastAPI framework, implementing APIs with authentication functionality, and requiring convenient Docker deployment. Claude3.5 <strong>only generated one file</strong> in the workspace, and put main.py, Dockerfile, requirements.txt, and other content in it. If I want to use it, I still need to create folders locally, copy the contents into different files separately, and then initialize the environment to run.</p><p>If Anthropic’s workspace <strong>could create folders and then put the entire project’s code in it</strong>, and provide a function to download the entire project, it would be much more convenient. Going even further, Anthropic could provide a Python runtime environment, <strong>allowing users to run and debug code directly in the workspace</strong>. In this way, Anthropic could become a true collaborative work environment, not just a code generation tool.</p><p>Ideally, the future Anthropic should be able to generate and manage multiple folders or files in the workspace, allow us to manually modify parts of the code, and debug code in the workspace. Then Anthropic can discover problems during debugging and fix them. In other words, <strong>AI can understand the entire project code and participate in every process of development together with humans</strong>.</p><p>Perhaps such an Anthropic will be born soon.</p><!-- Tetris --><style>    #tetrisContainer {        position: relative;        width: 300px;        height: 600px;        margin: 20px auto;    }    #tetrisCanvas {        border: 2px solid #333;    }    #startButton {        position: absolute;        top: 50%;        left: 50%;        transform: translate(-50%, -50%);        padding: 10px 20px;        font-size: 16px;        cursor: pointer;    }    #gameOverMessage {        position: absolute;        top: 50%;        left: 50%;        transform: translate(-50%, -50%);        background-color: rgba(0, 0, 0, 0.7);        color: white;        padding: 20px;        text-align: center;        display: none;        width: 80%;        box-sizing: border-box;    }    #restartButton {        margin-top: 15px;        padding: 10px 20px;        font-size: 16px;        cursor: pointer;    }</style><script>    const canvas = document.getElementById('tetrisCanvas');    const ctx = canvas.getContext('2d');    const startButton = document.getElementById('startButton');    const restartButton = document.getElementById('restartButton');    const gameOverMessage = document.getElementById('gameOverMessage');    const finalScoreSpan = document.getElementById('finalScore');    const ROWS = 20;    const COLS = 10;    const BLOCK_SIZE = 30;    const SHAPES = [        [[1, 1, 1, 1]],        [[1, 1], [1, 1]],        [[1, 1, 1], [0, 1, 0]],        [[1, 1, 1], [1, 0, 0]],        [[1, 1, 1], [0, 0, 1]],        [[1, 1, 0], [0, 1, 1]],        [[0, 1, 1], [1, 1, 0]]    ];    const COLORS = [        '#00FFFF', '#FFFF00', '#FF00FF', '#FF0000',        '#00FF00', '#0000FF', '#FFA500'    ];    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));    let currentPiece = null;    let score = 0;    let gameActive = false;    let gameLoop;    function createPiece() {        const shapeIndex = Math.floor(Math.random() * SHAPES.length);        const colorIndex = Math.floor(Math.random() * COLORS.length);        return {            shape: SHAPES[shapeIndex],            color: COLORS[colorIndex],            x: Math.floor(COLS / 2) - Math.floor(SHAPES[shapeIndex][0].length / 2),            y: 0        };    }    function drawBlock(x, y, color) {        ctx.fillStyle = color;        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);        ctx.strokeStyle = '#000';        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);    }    function drawBoard() {        board.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    drawBlock(x, y, value);                }            });        });    }    function drawPiece() {        currentPiece.shape.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    drawBlock(currentPiece.x + x, currentPiece.y + y, currentPiece.color);                }            });        });    }    function isValidMove(piece, x, y) {        return piece.shape.every((row, dy) => {            return row.every((value, dx) => {                let newX = x + dx;                let newY = y + dy;                return (                    value === 0 ||                    (newX >= 0 && newX < COLS && newY < ROWS && (newY < 0 || board[newY][newX] === 0))                );            });        });    }    function rotatePiece() {        let rotated = currentPiece.shape[0].map((_, i) =>            currentPiece.shape.map(row => row[i]).reverse()        );        if (isValidMove({...currentPiece, shape: rotated}, currentPiece.x, currentPiece.y)) {            currentPiece.shape = rotated;        }    }    function movePiece(dx, dy) {        if (isValidMove(currentPiece, currentPiece.x + dx, currentPiece.y + dy)) {            currentPiece.x += dx;            currentPiece.y += dy;            return true;        }        return false;    }    function mergePiece() {        currentPiece.shape.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;                }            });        });    }    function clearLines() {        let linesCleared = 0;        for (let y = ROWS - 1; y >= 0; y--) {            if (board[y].every(cell => cell !== 0)) {                board.splice(y, 1);                board.unshift(Array(COLS).fill(0));                linesCleared++;            }        }        if (linesCleared > 0) {            score += linesCleared * 100;        }    }    function gameOver() {        return board[0].some(cell => cell !== 0);    }    function updateGame() {        if (!movePiece(0, 1)) {            mergePiece();            clearLines();            if (gameOver()) {                endGame();            } else {                currentPiece = createPiece();            }        }        drawGame();    }    function drawGame() {        ctx.clearRect(0, 0, canvas.width, canvas.height);        drawBoard();        if (currentPiece) {            drawPiece();        }    }    function startGame() {        board = Array(ROWS).fill().map(() => Array(COLS).fill(0));        score = 0;        currentPiece = createPiece();        gameActive = true;        startButton.style.display = 'none';        gameOverMessage.style.display = 'none';        drawGame();        gameLoop = setInterval(updateGame, 500); // 每500毫秒更新一次游戏状态    }    function endGame() {        gameActive = false;        clearInterval(gameLoop);        finalScoreSpan.textContent = score;        gameOverMessage.style.display = 'block';    }    startButton.addEventListener('click', startGame);    restartButton.addEventListener('click', startGame);    document.addEventListener('keydown', event => {        if (!gameActive) return;        event.preventDefault();        switch (event.keyCode) {            case 37: // 左箭头                movePiece(-1, 0);                break;            case 39: // 右箭头                movePiece(1, 0);                break;            case 40: // 下箭头                movePiece(0, 1);                break;            case 38: // 上箭头                rotatePiece();                break;        }        drawGame();    });    drawGame();</script><script>    const boardSize = 15;    let currentPlayer = 'black';    let gameBoard = [];    function createBoard() {        const board = document.getElementById('board');        for (let i = 0; i < boardSize; i++) {            const row = document.createElement('div');            row.className = 'row';            gameBoard[i] = [];            for (let j = 0; j < boardSize; j++) {                const cell = document.createElement('div');                cell.className = 'cell';                cell.onclick = () => placePiece(i, j);                row.appendChild(cell);                gameBoard[i][j] = '';            }            board.appendChild(row);        }    }    function placePiece(row, col) {        if (gameBoard[row][col] !== '') return;        const cell = document.getElementById('board').children[row].children[col];        const piece = document.createElement('div');        piece.className = `piece ${currentPlayer}`;        cell.appendChild(piece);        gameBoard[row][col] = currentPlayer;        if (checkWin(row, col)) {            document.getElementById('status').textContent = `${currentPlayer === 'black' ? 'Black' : 'White'} Wins！`;            disableBoard();        } else {            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';            document.getElementById('status').textContent = `${currentPlayer === 'black' ? 'Black' : 'White'}'s Turn`;        }    }    function checkWin(row, col) {        const directions = [            [1, 0], [0, 1], [1, 1], [1, -1]        ];        for (const [dx, dy] of directions) {            let count = 1;            count += countDirection(row, col, dx, dy);            count += countDirection(row, col, -dx, -dy);            if (count >= 5) return true;        }        return false;    }    function countDirection(row, col, dx, dy) {        let count = 0;        let x = row + dx;        let y = col + dy;        while (x >= 0 && x < boardSize && y >= 0 && y < boardSize && gameBoard[x][y] === currentPlayer) {            count++;            x += dx;            y += dy;        }        return count;    }    function disableBoard() {        const cells = document.getElementsByClassName('cell');        for (const cell of cells) {            cell.onclick = null;        }    }    function resetGame() {        const board = document.getElementById('board');        board.innerHTML = '';        gameBoard = [];        currentPlayer = 'black';        document.getElementById('status').textContent = 'Black\'s turn';        createBoard();    }    createBoard();</script><style>    #game-container {        text-align: center;    }    #board {        display: inline-block;        background-color: #d4a36a;        padding: 10px;        border: 2px solid #8b4513;    }    .row {        display: flex;    }    .cell {        width: 30px;        height: 30px;        border: 1px solid #000;        display: flex;        justify-content: center;        align-items: center;        cursor: pointer;    }    .piece {        width: 26px;        height: 26px;        border-radius: 50%;    }    .black {        background-color: #000;    }    .white {        background-color: #fff;    }</style>]]></content:encoded>
      
      
      <category domain="https://selfboot.cn/categories/Artificial-Intelligence/">Artificial Intelligence</category>
      
      
      <category domain="https://selfboot.cn/tags/LLM/">LLM</category>
      
      
      <comments>https://selfboot.cn/en/2024/06/22/claude35_artifacts/#disqus_thread</comments>
      
    </item>
    
    
    
    
    
    <item>
      <title>How an Async Thread Pool Exception Caused Service Chaos</title>
      <link>https://selfboot.cn/en/2024/06/13/async_pool_block_problem/</link>
      <guid>https://selfboot.cn/en/2024/06/13/async_pool_block_problem/</guid>
      <pubDate>Thu, 13 Jun 2024 20:01:55 GMT</pubDate>
      
      <description>This article provides a detailed analysis of a service restart issue caused by C++ thread pools, integer overflow, and exception handling. It explores the differences in exception handling between std::thread and std::async, revealing the potential chain reaction of unhandled exceptions in async-implemented thread pools. Through log analysis, code review, and GDB debugging, it gradually locates the root cause of the problem and provides a fix. The article also summarizes key points in multi-threaded programming, exception handling, and thread pool design, offering valuable experience and references for developers.</description>
      
      
      
      <content:encoded><![CDATA[<p>Recently, I encountered a very strange service restart issue in our business, and the troubleshooting process was quite complex. This article will review the process. The problem involves multiple aspects such as C++ thread pools, integer overflow, exception catching, and blocking, which is quite interesting.</p><p>Next, I will organize the content of this article according to the <strong>problem investigation process</strong>, starting with an introduction to the problem background, then listing the initial troubleshooting ideas and methods for locating abnormal requests. Then, through code analysis and some simple use cases to reproduce the problem, we will unveil the mystery of the service restart.</p><span id="more"></span><h2 id="Problem-Background"><a href="#Problem-Background" class="headerlink" title="Problem Background"></a>Problem Background</h2><p>We have a module A that provides RPC services externally, and the main caller B calls A’s services. Module A’s service is divided into two processes: the mesh process and the business process, both of which are multi-threaded. The mesh process functions similarly to a <a href="https://istio.io/latest/docs/reference/config/networking/sidecar/">Sidecar</a>, assigning a worker thread to handle each RPC request received from the main caller. The worker sends the request package to the business process through a Unix socket and then waits for the business process to process it before replying to the main caller. The business process is specifically used for business logic, processing the request package and sending the response package to the worker in the mesh process. The overall process is shown in the following diagram:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_bg.png" alt="Service divided into mesh process and business process"></p><p>Recently, the main caller B discovered through monitoring that there were several instances each day where it couldn’t connect to module A’s service port. Each instance didn’t last long and automatically recovered after a while.</p><p>A brief look at module A’s logs revealed that at the corresponding time points, <strong>the monitoring script failed to probe A’s service and thus restarted the service</strong>. The monitoring script here probes module A’s liveness detection RPC (which simply replies with a “hello”) at fixed intervals to check if the service is normal. If several consecutive probes fail, it considers the service to have a problem and attempts to restart it. This occasional restart of module A was due to the monitoring script being unable to get a reply from the liveness detection RPC, thus restarting the service.</p><p>So <strong>when did this problem start to occur?</strong> Extending the monitoring time for module A, we found that occasional mysterious restarts only started 7 days ago. Each server of module A experienced restarts, but the restart frequency was very low, so module A didn’t trigger any alarms.</p><p>Based on experience, probe failures are usually due to the service process crashing, such as the process exiting due to a coredump or being killed by the system due to an OOM (Out Of Memory) error. However, checking module A’s logs, we found it wasn’t either of these two situations. Module A didn’t show any coredump-related logs, and memory usage was normal during the restart periods. Could it be that there’s <strong>an infinite loop in the code causing the worker thread to be occupied and unable to release</strong>? Looking at the CPU usage during the restart periods, it was also at normal levels. Of course, if there’s a constant sleep in the infinite loop, the CPU usage wouldn’t be high, but there wasn’t anything using sleep in the business logic, so we initially ruled out an infinite loop.</p><p>This was a bit strange. Let’s continue to carefully examine the service logs for troubleshooting.</p><h2 id="Initial-Investigation"><a href="#Initial-Investigation" class="headerlink" title="Initial Investigation"></a>Initial Investigation</h2><p>We found a machine that had recently restarted and first looked at the service process logs at the restart time point. The mesh process in module A is a C++ multi-threaded service with N worker threads concurrently processing business RPC requests. The framework prints logs at intervals, recording how many of the current workers are idle and how many are busy processing requests. Under normal circumstances, in the printed logs, most threads are idle, with only a few busy.</p><p>However, before the process restart, we found that the number of worker threads in the logs was a bit abnormal, with <strong>idle threads decreasing rapidly within 1 minute until reaching 0</strong>. Assuming a total of 200 workers, the relevant logs before the restart were roughly as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">worker idle 100, busy 100;</span><br><span class="line">worker idle 40, busy 160;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>No wonder the monitoring script would fail to probe. At this moment, all of the service’s workers were occupied, with no idle workers to handle new incoming requests. All new requests would queue up waiting for a worker until timing out and failing.</p><p>So what caused the workers to be continuously occupied without being released? The service only recently started experiencing this issue, so we first thought it might be related to recent changes. We looked at the recent code changes but didn’t find any problems.</p><p>Next, there were actually two troubleshooting approaches. The first was to wait for the service process to get stuck again, then use gdb to attach to the process or use gcore to dump a coredump file. This would allow us to examine the call stack of the worker threads and see what function was causing the workers to be continuously occupied. We first ruled out gdb attach because the occurrence probability was quite low, and the monitoring script would restart the service in a very short time, making it difficult to find the right moment. Additionally, it’s not very suitable to attach to a production service for troubleshooting. As for gcore, it would require modifying the monitoring script to save the process coredump file when there’s a problem with the probe. However, considering that we needed to modify the monitoring script and that the coredump file might not necessarily reveal the problem, we didn’t adopt this approach for now.</p><p>The second approach was to find a request that could reproduce the problem and locate the issue through reproduction. After all, <strong>if a problem can be consistently reproduced, it’s as good as half solved</strong>. This is actually based on the assumption that <strong>intermittent problems are usually caused by certain special requests triggering some boundary conditions</strong>.</p><p>For our RPC module, if a special request causes a worker to be continuously occupied, then this request must be one that doesn’t receive a response. Therefore, we can <strong>print relevant logs when the module receives a request package and when it gives a response package</strong>. Then, during the time period when the service gets stuck, we can filter out those RPC requests in the logs that have requests but no responses.</p><p>After adding logs and deploying them, coincidentally, another service restart occurred. Through the logs, we finally found the suspicious request. Combined with this suspicious request, we discovered a problematic piece of code, which became the breakthrough point for solving the problem.</p><h2 id="Problematic-Code-Analysis"><a href="#Problematic-Code-Analysis" class="headerlink" title="Problematic Code Analysis"></a>Problematic Code Analysis</h2><p>Let’s first look at this problematic code. After simplification and hiding key information, it’s roughly as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gramCount = <span class="number">3</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; posVec;</span><br><span class="line"><span class="comment">// GetPosVec(posVec);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt; posVec.<span class="built_in">size</span>() - gramCount; ++i) &#123;</span><br><span class="line">posVec[i] = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As smart as you are, you must have noticed the problem with this code.</p><p>Here, i is an unsigned integer, and <code>posVec.size()</code> also returns an unsigned integer type size_t. When posVec.size() is less than gramCount, <code>posVec.size() - gramCount</code> will <strong>overflow</strong>, becoming a very large positive integer. Then in the loop, this very large positive integer will be used to traverse posVec, leading to <strong>array out of bounds</strong>. When using operator[] to access the array here, out-of-bounds access is <a href="https://selfboot.cn/en/2016/09/18/c++_undefined_behaviours/">undefined behavior</a>, which generally causes the program to crash. I wrote a simple test code and found that it indeed resulted in a segmentation fault. It’s worth adding that if <a href="https://cplusplus.com/reference/array/array/at/">at is used to access the array</a>, out-of-bounds access will throw an out_of_range exception, which will definitely crash if the exception is caught.</p><p>However, this code in module A didn’t crash, but instead caused the worker thread to be continuously occupied. Why is this? One suspicious point is that the above code is actually running in a newly opened thread pool. To add some background here, after module A receives an RPC request, it processes the business logic in a worker thread. Some business logic is quite time-consuming, so <strong>to improve processing speed, the time-consuming parts are put into an additional thread pool for concurrent execution</strong>.</p><p>The implementation of this thread pool is a bit complex, but the basic idea is <strong>a task queue + N pre-configured worker threads</strong>. The task queue is used to store tasks that need to be executed, and worker threads fetch tasks from the task queue to execute. The thread pool provides an interface <code>RunTask(concur, max_seq, task);</code> where concur is the number of threads for concurrent execution, max_seq is the total number of tasks, and task is the task function. RunTask will use concur threads to concurrently execute this task function task until all max_seq tasks are completed.</p><p>Before the task starts, RunTask defines a pipe to synchronize messages between the main thread and the task thread pool. Once all threads complete their tasks, the last exiting thread will write a character to the pipe to notify the main thread. The main thread will wait for the character in the pipe and then return.</p><p>The code with integer overflow above is placed in this additional thread pool for execution. Could the problem be caused by the thread pool? To quickly verify this hypothesis, I wrote a simple test script, putting the above code into the thread pool for execution, and the process indeed got stuck without response. The first guess was, could it be that the threads in the thread pool crashed due to array out of bounds, failed to write to the pipe, causing the main thread to block indefinitely on the pipe read operation?</p><p>Let’s verify this below.</p><h2 id="Multithreading-thread"><a href="#Multithreading-thread" class="headerlink" title="Multithreading: thread"></a>Multithreading: thread</h2><p>To verify the above hypothesis, I wrote a simple test program to simulate the workflow of the business thread pool. Here, C++11’s thread is used to start 5 new threads, and these threads sleep for a period of time to simulate task execution. When all threads have completed their tasks, the last completed thread writes a character to the pipe, and the main thread blocks on reading from the pipe. The test code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">completedThreads</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCurrentTimeAndThread</span><span class="params">(<span class="type">const</span> std::string&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_c), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot; Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>], <span class="type">int</span> totalThreads)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// Simulate some work</span></span><br><span class="line">    <span class="type">int</span> finished = ++completedThreads;</span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// The last completed thread writes to the pipe</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction, fds, totalThreads);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// Main thread blocks here waiting for pipe write</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// What happens if we comment this out?</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread finished&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After running, we found that this behaves as expected. 5 threads execute concurrently for 1s, and the main thread waits for the last thread to complete, then reads the result from the pipe and continues execution. The result is as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140358584862528 - 2024-06-12 11:40:51</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140358568072960 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358559680256 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358551287552 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358584858368 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358576465664 - 2024-06-12 11:40:52</span><br><span class="line">Main thread finished Thread ID: 140358584862528 - 2024-06-12 11:40:52</span><br></pre></td></tr></table></figure><p>Now, let’s <strong>make the last child thread directly throw an exception and see if the main thread blocks</strong>. We make the following changes based on the above code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Out of range exception&quot;</span>); <span class="comment">// Simulate at out-of-bounds array access, throw exception</span></span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// The last completed thread writes to the pipe</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>After recompiling and running, we found that the entire process crashed directly. The result is as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140342189496128 - 2024-06-12 11:46:23</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140342189491968 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342181099264 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342172706560 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342164313856 - 2024-06-12 11:46:24</span><br><span class="line">terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span><br><span class="line">  what():  Out of range exception</span><br><span class="line">[1]    2622429 abort      ./thread_test2</span><br></pre></td></tr></table></figure><p>It seems the previous guess was wrong! In a multi-threaded environment, a single thread throwing an exception caused the entire process to abort. Why is this? We have to mention <strong>C++’s exception handling mechanism</strong> here.</p><h3 id="C-Exception-Handling"><a href="#C-Exception-Handling" class="headerlink" title="C++ Exception Handling"></a>C++ Exception Handling</h3><p>In C++, when a program encounters a problem it can’t resolve on its own, it can throw an exception. Exceptions are usually objects derived from the standard exception class, such as std::runtime_error. When programming, you can put code that might throw exceptions inside a try block, followed by one or more catch blocks to catch and handle specific types of exceptions.</p><p>If an exception is not caught in the current scope, <strong>it will be propagated to higher levels of the try-catch structure in the call stack</strong> until a suitable catch block is found. If no suitable catch block is found throughout the entire call stack, <a href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate()</a> will be called, with the specific execution operation specified by std::terminate_handler, which by default calls <a href="https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a>. If no signal handler is set to catch the SIGABRT signal, the program will be abnormally terminated.</p><p>For the example multi-threaded code above, the last thread throws an exception, but there’s nowhere to catch it, so std::abort() is ultimately called to terminate the entire process. From the output above, we can see that the last line is abort.</p><p>C++ is designed this way because an uncaught exception usually means the program has entered an unknown state, and continuing to run could lead to more serious errors, such as data corruption or security vulnerabilities. Therefore, <strong>immediately terminating the program is considered a safe failure mode</strong>.</p><h3 id="Thread-Object-Lifecycle"><a href="#Thread-Object-Lifecycle" class="headerlink" title="Thread Object Lifecycle"></a>Thread Object Lifecycle</h3><p>There’s another point to mention here. In the example program above, the main thread calls thread.join() on each child thread’s thread object at the end. What happens if we comment this out and run the program? The process will still crash, and it’s also calling terminate(). Why is this?</p><p>Actually, the terminate documentation mentioned earlier states that terminate will be called in the following situation:</p><blockquote><ol start="10"><li>A joinable std::thread is destroyed or assigned to.</li></ol></blockquote><p>Continuing to look at the std::thread::joinable documentation, we find the following explanation:</p><blockquote><p>A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</p></blockquote><p>We know that child threads automatically exit after executing their related code. However, this doesn’t mean that the std::thread object associated with that thread will automatically handle all the resources and states of this thread. In C++, the ending of an operating system thread and the lifecycle management of a std::thread object are two related but relatively independent concepts:</p><ul><li><strong>Operating system thread</strong>: When a thread finishes executing code, it automatically stops, and the thread’s system resources (such as thread descriptors and stack) are usually reclaimed by the operating system.</li><li><strong>std::thread object management</strong>: Although the thread has ended, the std::thread object still needs to correctly update its state to <strong>reflect that the thread is no longer active</strong>. This is mainly achieved through the <a href="https://en.cppreference.com/w/cpp/thread/thread/join">join()</a> or detach() methods. If these methods are not called, when the std::thread object is destroyed, it will detect that it still “owns” an active thread, which will lead to calling std::terminate().</li></ul><p>In the example code above, when the main thread calls the join() method, it will block waiting for the child thread to finish executing (in this example, writing a character to the pipe has already ensured completion), and then mark the std::thread object state as “inactive”.</p><p>So, returning to the previous question, <strong>why does the main thread get stuck when a thread in the thread pool throws an exception in the business code</strong>? Upon closer inspection of the thread pool implementation code, we found that it doesn’t use thread to create threads, but uses <a href="https://en.cppreference.com/w/cpp/thread/async">std::async</a>. What is async? How does it work, and could the thread getting stuck be related to async?</p><p>Let’s continue to verify together.</p><h2 id="Multithreading-async"><a href="#Multithreading-async" class="headerlink" title="Multithreading: async"></a>Multithreading: async</h2><p>C++11 introduced std::async, which is a high-level tool for <strong>simplifying concurrent programming</strong>. It can <strong>run a function or callable object in an asynchronous execution context and return a std::future object</strong> to access the return value or exception state of that function.</p><p>Haha, after reading this introduction, are you confused and bewildered? Don’t worry, let’s set these aside and look at the code first. We’ll make some slight modifications based on the previous thread example code, using async for concurrent execution. The complete code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">completedThreads</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCurrentTimeAndThread</span><span class="params">(<span class="type">const</span> std::string&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_c), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot; Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>], <span class="type">int</span> totalThreads)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// Simulate some work</span></span><br><span class="line">    <span class="type">int</span> finished = ++completedThreads;</span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Out of range exception&quot;</span>); <span class="comment">// Simulate at out-of-bounds array access, throw exception</span></span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// The last completed thread writes to the pipe</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">        futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, threadFunction, fds, totalThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// Main thread blocks here waiting for pipe write</span></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread finished&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After running, we found that the main thread got stuck!! The running result is as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140098007660352 - 2024-06-12 21:06:00</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140097990870784 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140097974085376 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140097999263488 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140098007656192 - 2024-06-12 21:06:01</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>We have successfully reproduced the problem in the business. Before continuing with deeper analysis, let’s first look at how async is used, mainly as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">    futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, threadFunction, fds, totalThreads));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The above code uses the std::async function to start a group of asynchronous tasks, defined by threadFunction. Each task is configured to execute on a new thread when created, and uses the std::launch::async strategy to ensure they start immediately. The execution results (or states) of these tasks are encapsulated in std::future<void> objects and stored in the futures std::vector. That’s enough to understand for now, let’s continue to analyze why the main thread gets stuck.</p><h3 id="GDB-Analysis"><a href="#GDB-Analysis" class="headerlink" title="GDB Analysis"></a>GDB Analysis</h3><p>Let’s use GDB to see what happens during the process execution. After running here, we can see that 5 new threads are created to execute async tasks, then 4 threads print task output, and then all 5 threads are destroyed by the system. After that, the GDB console will get stuck. At this point, use Ctrl+C to pause program execution, and then you can use the GDB console.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_gdb.png" alt="GDB troubleshooting blocked process"></p><p>After the process gets stuck, looking at the stack, we find it’s blocked on the read in the main function of the main thread. At this point, only the main thread remains in the process, which can be confirmed using info threads. Here, 0x7ffff7a9e740 is actually the hexadecimal of Thread ID: 140737348495168 printed at the beginning of the process. From the GDB results, we can see that the last child thread throws an exception before it’s about to write, then exits directly without writing a character to the pipe, and the main thread keeps blocking on the read of the pipe.</p><p>The question arises, shouldn’t the entire process abort and terminate? In the previous <a href="#Multithreading:-thread">thread example</a>, when the thread’s thrown exception wasn’t caught, it caused the process to abort, and the main thread also ended as a result. But here, the <strong>exception thrown by the thread created by async seems to have disappeared, with no place to catch it, and it didn’t trigger the process to abort</strong>. Why is this?</p><h3 id="Async-Exception-Handling"><a href="#Async-Exception-Handling" class="headerlink" title="Async Exception Handling"></a>Async Exception Handling</h3><p>Let’s first see if the <a href="https://en.cppreference.com/w/cpp/thread/async">async</a> documentation says anything about how exceptions are handled.</p><blockquote><p>If the function f returns a value or throws an exception, it is stored in the shared state accessible through the std::future that std::async returns to the caller.</p></blockquote><p>We can see that if a thread started by std::async throws an exception, <strong>these exceptions will be caught and stored in the returned std::future object</strong>. Looking further at the future documentation, we find that <a href="https://en.cppreference.com/w/cpp/thread/future/get">future::get</a> can be used to get the execution result of the task. If the task throws an exception, calling get will re-throw the exception.</p><blockquote><p>If an exception was stored in the shared state referenced by the future (e.g. via a call to std::promise::set_exception()) then that exception will be thrown.</p></blockquote><p>At this point, we’ve found the reason why the above example program didn’t abort, which lies in async’s exception handling mechanism. <strong>In async, exceptions thrown by threads are stored in std::future objects, rather than directly causing the process to abort. After the child thread throws an exception, it doesn’t write a character to the pipe, so the main thread keeps blocking on read waiting, causing the entire process to appear stuck</strong>.</p><p>Here, we can call get before read in the example program to catch the exception and print it out for verification.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; future : futures) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        future.<span class="built_in">get</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// Main thread blocks here waiting for pipe write</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>We can see that an out_of_range exception is indeed caught here.</p><h3 id="Advantages-of-Async"><a href="#Advantages-of-Async" class="headerlink" title="Advantages of Async"></a>Advantages of Async</h3><p>Regarding async, let’s add a bit more thought. What advantages does async introduced in C++11 have compared to traditional thread?</p><p>First, std::async provides a <strong>simpler way to create and execute asynchronous tasks</strong> compared to directly using std::thread. It automatically handles thread creation and management, allowing developers to focus on business logic rather than the details of thread management. std::async can automatically manage the lifecycle of tasks, including timely starting and terminating threads. Using std::async doesn’t require explicitly calling join() or detach().</p><p>Additionally, as mentioned earlier, tasks started using std::async can throw exceptions during execution, and these exceptions are caught and stored in the returned std::future object. By calling std::future::get(), these exceptions can be caught and handled in the main thread.</p><p>Furthermore, calling std::async allows specifying the launch mode (std::launch::async or std::launch::deferred), where std::launch::async forces the task to run immediately in a new thread, while std::launch::deferred delays the execution of the task until std::future::get() or std::future::wait() is called.</p><p>Generally speaking, when tasks need to be executed in parallel and have no dependencies on each other, using std::async without concerning about thread management will be much simpler. Or if you need to get the execution results of parallel tasks at some future point, combining std::async with std::future will also be much more convenient.</p><h2 id="Production-Service-Review"><a href="#Production-Service-Review" class="headerlink" title="Production Service Review"></a>Production Service Review</h2><p>Alright, now let’s return to the discussion of the production service. Through the previous analysis, we can now determine the source of the problem, but there are still a few details related to the production service that need to be clarified. The first is that the problematic code here had been online for a long time, so why did the problem only occur recently? Going back to the example in the <a href="#Problematic-Code-Analysis">Problematic Code Analysis</a> section, if the array size is greater than or equal to gramCount, there would be no overflow and it wouldn’t cause a crash. Recently, the length of the array here changed, which is why the above problem occurred.</p><p>The second question is, each time abnormal data is encountered, it only blocks the current 1 working worker, and there shouldn’t be many abnormal request data in a short time. But when we observed the logs during the <a href="#Initial-Investigation">Initial Investigation</a>, <strong>all workers were exhausted in an extremely short time</strong>. Why is this?</p><p>As mentioned in the <a href="#Problem-Background">Problem Background</a>, both the mesh process and the business process are multi-threaded. The rapidly decreasing idle workers seen in the logs in a short time were from the mesh process. The actual business logic is handled in the business process, where all threads in the business process share a global thread pool implemented as an async singleton. The async-implemented thread pool specifies how many threads there are in total when creating the singleton object, and these threads are used by all business process worker threads. The overall structure is shown in the following diagram:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_worker.png" alt="Business thread architecture"></p><p>Whenever there is an abnormal data, it will cause 1 thread in the async thread pool to exit, while simultaneously blocking 1 thread in the business process. As time progresses, after accumulating enough abnormal data, two situations will occur:</p><ol><li><p>All threads in the async thread pool exit due to exceptions. At this point, any business threads that haven’t been blocked will be blocked on read when using the thread pool to process data, regardless of whether the data is abnormal or not, because there are no async threads to compute. This situation occurs when the number of threads in the business process is greater than the number of threads in the async thread pool.</p></li><li><p>There are still working threads in the async thread pool, but all threads in the business process are blocked on read due to previously occurring abnormal data. This situation occurs when the number of threads in the business process is less than the number of threads in the async thread pool.</p></li></ol><p>In either case, <strong>at some point, due to the last abnormal request data, all working threads in the business process will be blocked, unable to handle requests coming from mesh</strong>. From this moment on, every time mesh receives a request, one worker in the mesh process will be occupied. The accumulation of requests in a short time leads to all workers in the mesh process being occupied, and thus unable to handle new incoming requests, ultimately causing the monitoring script to detect service anomalies.</p><p>At this point, the reason for the restart has been revealed, and the fix method is also clear. The simplest method is to add a try-catch block when executing business functions in async threads. If an exception is caught, directly call abort to terminate the entire business process. This way, if there’s a bug in the code that causes an exception to be thrown, once triggered after going online, the process will immediately terminate. Problems will be discovered early, and it’s also convenient to analyze the problem from the coredump file.</p>]]></content:encoded>
      
      
      <category domain="https://selfboot.cn/categories/Programming/">Programming</category>
      
      
      <category domain="https://selfboot.cn/tags/C/">C++</category>
      
      
      <comments>https://selfboot.cn/en/2024/06/13/async_pool_block_problem/#disqus_thread</comments>
      
    </item>
    
    
    
    
    
    
  </channel>
</rss>