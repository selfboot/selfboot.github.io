<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article explores the implementation of core utility components in LevelDB, including the Arena memory allocator, Random number generator, CRC32 cyclic redundancy check, and integer encoding/decoding tools. It analyzes the design considerations, implementation details, and optimization strategies of these components, demonstrating how they efficiently support various operations in LevelDB."><title>LevelDB Explained - Arena, Random, CRC32, and More.</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB Explained - Arena, Random, CRC32, and More.</h1><div class="post-meta">2024/08/29<span> | </span><span class="category"><a href="/categories/Source-Code-Analysis/">Source Code Analysis</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2024/08/29/leveldb_source_utils/" href="/en/2024/08/29/leveldb_source_utils/#disqus_thread"></a><div class="post-content"><p>LevelDB implements several utility tools, such as the custom memory allocator Arena and the random number generation class Random. These implementations consider specific use cases, making optimizations and trade-offs that are worth studying. This article will mainly discuss the implementation of the following parts:</p>
<ul>
<li>Memory management Arena, a simple and efficient memory allocation manager suitable for LevelDB;</li>
<li>Random number generator Random, a good <strong>linear congruential pseudorandom generation</strong> algorithm that uses bitwise operations instead of modulo to optimize execution efficiency.</li>
<li>CRC32 cyclic redundancy check, used to detect errors during data transmission or storage;</li>
<li>Integer encoding and decoding, used to store numbers in byte streams or parse numbers from byte streams.</li>
</ul>
<p>In addition, there are some more complex utils components that will be discussed in separate articles, such as:</p>
<ul>
<li><a href="https://selfboot.cn/en/2024/07/22/leveldb_source_nodestructor/">LevelDB Source Code Reading: Preventing Object Destruction</a> discusses how to prevent an object from being destructed in C++ and the reasons for doing so.</li>
</ul>
<span id="more"></span>

<h2 id="Memory-Management-Arena"><a href="#Memory-Management-Arena" class="headerlink" title="Memory Management Arena"></a>Memory Management Arena</h2><p>LevelDB <strong>does not directly use</strong> the system’s default malloc to allocate memory, nor does it use third-party libraries like tcmalloc to manage memory allocation and deallocation. Instead, it implements a simple memory allocator of its own. This memory allocator can be said to be <strong>tailor-made</strong>, mainly based on the following considerations:</p>
<ol>
<li>Primarily used in memtable, there will be a large number of allocations, possibly many small memory allocations;</li>
<li>Unified recovery timing, all memory will be reclaimed together after the memtable data is written to disk;</li>
</ol>
<p>The data in the memory memtable is actually stored in a skiplist. Each time a key is inserted, a node needs to be inserted into the skiplist, and the memory used by these nodes is allocated by arena. For small keys, it will prioritize taking from the remaining memory of the current block, and only go to the allocation logic if there’s not enough. The code for <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/arena.h#L55">Allocate</a> is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>{</span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) {</span><br><span class="line">    <span class="type">char</span>* result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The logic for allocating memory through system calls is in AllocateFallback. If the required memory is greater than kBlockSize / 4, it allocates according to the actual need. Otherwise, it directly allocates memory for one block and then updates the usage. The unused memory remaining here can be used the next time memory is allocated. If it’s not enough for the next required amount, it will again go through system calls to allocate.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) {</span><br><span class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></span><br><span class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We waste the remaining space in the current block.</span></span><br><span class="line">  alloc_ptr_ = <span class="built_in">AllocateNewBlock</span>(kBlockSize);</span><br><span class="line">  alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* result = alloc_ptr_;</span><br><span class="line">  alloc_ptr_ += bytes;</span><br><span class="line">  alloc_bytes_remaining_ -= bytes;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>This method may lead to some <strong>memory waste</strong>. For example, if 496 bytes are used the first time, it will actually allocate 4096 bytes, leaving 3600 bytes. Then if more than 3600 bytes are used the next time, it will allocate new memory, wasting the remaining 3600 bytes from the last allocation. Although this wastes some memory usage, the overall code is relatively simple, and the allocation efficiency is quite high. This wasted memory will also be reclaimed when the memtable is written to disk.</p>
<p>By the way, let’s mention the final memory reclamation here. Each time <code>new []</code> is called to allocate memory, the starting address is placed in a vector, and then when the Arena class is destructed, all memory blocks are retrieved by traversing and uniformly released.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> </span>{</span><br><span class="line">  <span class="type">char</span>* result = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">  blocks_.<span class="built_in">push_back</span>(result);</span><br><span class="line">  memory_usage_.<span class="built_in">fetch_add</span>(block_bytes + <span class="built_in">sizeof</span>(<span class="type">char</span>*),</span><br><span class="line">                          std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">Arena::~<span class="built_in">Arena</span>() {</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">delete</span>[] blocks_[i];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>In addition, this class also provides an atomic counter <code>memory_usage_</code>, which keeps track of the amount of memory currently occupied by this class.</p>
<h2 id="Random-Number-Generator"><a href="#Random-Number-Generator" class="headerlink" title="Random Number Generator"></a>Random Number Generator</h2><p>LevelDB’s <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/random.h">util/random.h</a> implements a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">Pseudorandom Number Generator (PRNG)</a> class Random, used in scenarios such as <strong>generating skip list height</strong>. This random number generator is implemented based on a linear congruential generator (LCG), with the following formula for generating random numbers:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seed_ = (seed_ * A) % M</span><br></pre></td></tr></tbody></table></figure>

<p>According to congruence theory, as long as A and M are appropriately chosen, the above recursive formula will be able to generate a pseudorandom number sequence with a period of M, and there will be no repeated numbers in this sequence (except for the initial value). The modulus M value of $ 2^{31}-1 $ here is a common choice because it is a <strong>Mersenne prime</strong>, which is conducive to generating random sequences with good periodicity.</p>
<p>The constructor takes a 32-bit unsigned integer as a seed (seed_) and ensures that the seed falls within a valid range (non-zero and not equal to 2147483647L, i.e., $ 2^{31}-1 $). This is because the value of the seed directly affects the random number generation process, and these two specific values (0 and $ 2^{31}-1 $) would cause the generated sequence to lose randomness in the calculation process.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Random</span><span class="params">(<span class="type">uint32_t</span> s)</span> : seed_(s &amp; <span class="number">0x7fffffffu</span>) {</span></span><br><span class="line">  <span class="comment">// Avoid bad seeds.</span></span><br><span class="line">  <span class="keyword">if</span> (seed_ == <span class="number">0</span> || seed_ == <span class="number">2147483647L</span>) {</span><br><span class="line">    seed_ = <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The code for generating random numbers is very concise, as follows (ignoring the original comments):</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Next</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> M = <span class="number">2147483647L</span>;  <span class="comment">// 2^31-1</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> A = <span class="number">16807</span>;        <span class="comment">// bits 14, 8, 7, 5, 2, 1, 0</span></span><br><span class="line">  <span class="type">uint64_t</span> product = seed_ * A;</span><br><span class="line">  seed_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;((product &gt;&gt; <span class="number">31</span>) + (product &amp; M));</span><br><span class="line">  <span class="keyword">if</span> (seed_ &gt; M) {</span><br><span class="line">    seed_ -= M;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> seed_;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>First, <code>product = seed_ * A</code>, where the product might exceed the range of 32 bits. To <strong>prevent overflow</strong>, uint64_t is used to hold this intermediate result. As a reminder of a painful lesson, <strong>integer addition, subtraction, multiplication, and division must always consider overflow scenarios; many software vulnerabilities are caused by overflow</strong>. Then, the modulo operation product%M here <strong>uses bitwise operations and addition to replace</strong> it, to improve computational efficiency.</p>
<p>This is mainly based on the <strong>distributive property of modulo operations</strong>: $ (a + b) \mod m = ((a \mod m) + (b \mod m)) \mod m $, dividing product into <code>product &gt;&gt; 31 + product &amp; M</code>, because M = $ 2^{31}-1 $, the AND operation here takes the lower 31 bits of product.</p>
<p>In addition to basic random number generation, the Random class also provides methods like <code>Uniform()</code> for generating random numbers within a specific range, <code>OneIn()</code> for probabilistically returning true or false, and <code>Skewed()</code> for generating numbers biased towards smaller values. These are all very useful utility functions in specific scenarios.</p>
<p>The implementation of Skewed is quite interesting. It first uniformly selects a base from the range [0, max_log], then uses <code>Uniform(1 &lt;&lt; base)</code> to return a random number in the range $ [0, 2^{base} - 1]$. The probability of selecting the base here is uniform, which means that choosing a smaller base (thus generating smaller random numbers) has the same probability as choosing a larger base (thus generating larger random numbers). However, since the smaller the value of base, the smaller the range of random numbers that can be generated, this naturally leads to the <strong>function tending to generate smaller values</strong>.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Skewed: pick "base" uniformly from range [0,max_log] and then</span></span><br><span class="line"><span class="comment">// return "base" random bits.  The effect is to pick a number in the</span></span><br><span class="line"><span class="comment">// range [0,2^max_log-1] with exponential bias towards smaller numbers.</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Skewed</span><span class="params">(<span class="type">int</span> max_log)</span> </span>{ <span class="keyword">return</span> <span class="built_in">Uniform</span>(<span class="number">1</span> &lt;&lt; <span class="built_in">Uniform</span>(max_log + <span class="number">1</span>)); }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="CRC32"><a href="#CRC32" class="headerlink" title="CRC32"></a>CRC32</h2><p>CRC (<strong>Cyclic Redundancy Check</strong>) is a method of calculating a check code for data through a specific algorithm, widely used in <strong>network communication and data storage systems</strong> to detect whether errors occurred during data transmission or storage. CRC32 is a common CRC algorithm that uses a 32-bit checksum.</p>
<p>The calculation of CRC is based on <strong>polynomial division</strong>, where the processed data is viewed as a huge polynomial, <strong>divided by another predefined “generator polynomial”</strong>, and then the remainder is taken as the output CRC value. The CRC algorithm has a natural <strong>streaming calculation characteristic</strong>, allowing for the CRC of part of a message to be calculated first, and then using this result as the initial value (init_crc) for the calculation of the next part. The following <code>Extend</code> function accepts an initial CRC value (which could be the CRC result of a previous data block) and then calculates the CRC value after adding the new data block. This allows LevelDB to continuously calculate CRC as data is appended, without needing to start from the beginning each time.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the crc32c of concat(A, data[0,n-1]) where init_crc is the</span></span><br><span class="line"><span class="comment">// crc32c of some string A.  Extend() is often used to maintain the</span></span><br><span class="line"><span class="comment">// crc32c of a stream of data.</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Extend</span><span class="params">(<span class="type">uint32_t</span> init_crc, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the crc32c of data[0,n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Value</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> n)</span> </span>{ <span class="keyword">return</span> <span class="built_in">Extend</span>(<span class="number">0</span>, data, n); }</span><br></pre></td></tr></tbody></table></figure>

<p>The implementation in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/crc32c.cc">crc32c.cc</a> is quite complex, involving lookup tables (table-driven approach), data alignment, and possible hardware acceleration. The specific principles can be referred to in <a target="_blank" rel="noopener" href="http://www.ross.net/crc/download/crc_v3.txt">A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS</a>. The choice of <strong>generator polynomial</strong> is crucial to the effectiveness and error detection capability of the CRC algorithm. Generator polynomials are not arbitrarily chosen; they are typically designed through mathematical and computer simulation experiments to ensure maximum error detection capability for specific data lengths and application scenarios. The common generator polynomial <code>0x04C11DB7</code> was selected for the CRC-32 algorithm in the IEEE 802.3 standard.</p>
<p>It’s worth adding that CRC is only used to <strong>detect random errors</strong>, such as bit flips in network transmission or disk storage. It is not an error-correcting code; it can only detect errors and <strong>cannot correct errors</strong>. We can deliberately tamper with the content and ensure the same CRC result. If protection against tampering is needed, more complex cryptographic hash functions or digital signature techniques must be used.</p>
<p>Additionally, in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/crc32c.h">crc32c.h</a>, we see a Mask. The code comments explain this clearly: if the data itself contains CRC values, then directly calculating CRC on data that includes CRC might reduce the error detection capability of CRC. Therefore, LevelDB “masks” the original CRC value by swapping the high and low bits and adding a constant (kMaskDelta). This transformed CRC value can be stored in files. When verifying data integrity, the Unmask function is used to convert the masked CRC value back to the original CRC value, which is then compared with the CRC calculation result of the current data.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a masked representation of crc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Motivation: it is problematic to compute the CRC of a string that</span></span><br><span class="line"><span class="comment">// contains embedded CRCs.  Therefore we recommend that CRCs stored</span></span><br><span class="line"><span class="comment">// somewhere (e.g., in files) should be masked before being stored.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Mask</span><span class="params">(<span class="type">uint32_t</span> crc)</span> </span>{</span><br><span class="line">  <span class="comment">// Rotate right by 15 bits and add a constant.</span></span><br><span class="line">  <span class="keyword">return</span> ((crc &gt;&gt; <span class="number">15</span>) | (crc &lt;&lt; <span class="number">17</span>)) + kMaskDelta;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the crc whose masked representation is masked_crc.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Unmask</span><span class="params">(<span class="type">uint32_t</span> masked_crc)</span> </span>{</span><br><span class="line">  <span class="type">uint32_t</span> rot = masked_crc - kMaskDelta;</span><br><span class="line">  <span class="keyword">return</span> ((rot &gt;&gt; <span class="number">17</span>) | (rot &lt;&lt; <span class="number">15</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>There’s an interesting point here: after swapping the high 15 bits of the original CRC32 value and adding a constant, it might exceed the maximum value of uint32_t, <strong>causing overflow</strong>. <strong>In C++, the overflow behavior of unsigned integers is well-defined and handled as modulo operation</strong>. For example, if the current crc is 32767, after shifting and adding the constant, the result is 7021325016, which becomes 2726357720 after taking modulo $ 2^{32} $. The subtraction operation in Unmask will also overflow, which is handled as a modulo operation in C++ as well. Here, $ 2726357720-kMaskDelta = -131072 $ becomes 4294836224 after taking modulo $ 2^{32} $, and after swapping the high and low bits, we get back the original CRC 32767. So <strong>the overflow here won’t cause any bugs</strong>.</p>
<h2 id="Integer-Encoding-and-Decoding"><a href="#Integer-Encoding-and-Decoding" class="headerlink" title="Integer Encoding and Decoding"></a>Integer Encoding and Decoding</h2><p>LevelDB often needs to store numbers in byte streams or parse numbers from byte streams, such as storing length information in keys or sequence numbers in batch write tasks. In <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/coding.h">util/coding.h</a>, a series of encoding and decoding utility functions are defined to facilitate storing and parsing numbers in byte streams. First, let’s look at fixed-length encoding and decoding, which mainly includes the following functions:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed32</span><span class="params">(std::string* dst, <span class="type">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed64</span><span class="params">(std::string* dst, <span class="type">uint64_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> value)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>Taking 32-bit encoding as an example, the <code>PutFixed32</code> function encodes a 32-bit unsigned integer value into 4 bytes and then appends it to the end of the dst string. The <code>EncodeFixed32</code> function encodes value into 4 bytes and stores them in the memory pointed to by dst. PutFixed32 is based on EncodeFixed32 at the bottom layer, but it appends the result to the dst string.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> value)</span> </span>{</span><br><span class="line">  <span class="type">uint8_t</span>* <span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  buffer[<span class="number">0</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value);</span><br><span class="line">  buffer[<span class="number">1</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buffer[<span class="number">2</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  buffer[<span class="number">3</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>First, <code>reinterpret_cast&lt;uint8_t*&gt;(dst)</code> converts the <code>char*</code> type pointer to a <code>uint8_t*</code> type, allowing direct manipulation of individual bytes. Then, using shift and mask operations, each byte of value is written into the buffer array separately, with <strong>value’s low-order bytes stored at low addresses (little-endian)</strong>. Suppose we have a uint32_t value 0x12345678 (in hexadecimal), and we want to encode this value into a character array and then decode it back from the array.</p>
<ul>
<li>buffer[0] stores the lowest 8 bits of value, i.e., 0x78.</li>
<li>buffer[1] stores the second lowest 8 bits of value, i.e., 0x56.</li>
<li>buffer[2] stores the second highest 8 bits of value, i.e., 0x34.</li>
<li>buffer[3] stores the highest 8 bits of value, i.e., 0x12.</li>
</ul>
<p>After encoding, the content in dst will be: <code>78 56 34 12</code>. The decoding process is to combine these 4 bytes in the reverse order to obtain the original value.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">DecodeFixed32</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ptr)</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* <span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / ldr instruction.</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">0</span>])) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>In addition to encoding integers as fixed-length bytes, LevelDB also supports using variable-length integer (Varint) encoding to store numbers. This is because often, the values that need to be stored have a wide range but are frequently small, and using 4 bytes to store all integers would be wasteful. Varint is an efficient data compression method where smaller values occupy fewer bytes, saving space.</p>
<p>The principle of Varint is simple: it uses one or more bytes to store integers, where <strong>the highest bit (8th bit) of each byte is used to indicate whether there are more bytes</strong>. If this bit is 1, it means there are more bytes; if it’s 0, it means this is the last byte. The remaining 7 bits are used to store the actual numeric value. The following table shows the Varint encoding from one to three bytes (more bytes follow a similar pattern, not listed here):</p>
<table>
<thead>
<tr>
<th>Value Range</th>
<th>Varint Byte Expression</th>
</tr>
</thead>
<tbody><tr>
<td>1-127</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>128-16383</td>
<td>1xxxxxxx 0xxxxxxx</td>
</tr>
<tr>
<td>16384-2097151</td>
<td>1xxxxxxx 1xxxxxxx 0xxxxxxx</td>
</tr>
</tbody></table>
<p>In the specific implementation, EncodeVarint32 and EncodeVarint64 differ slightly. The 32-bit version first determines the number of bytes needed and then hard-codes the writing. The 64-bit version uses a loop to write, processing 7 bits each time until the value is less than 128.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> v)</span> </span>{</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="type">uint8_t</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) {</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  }</span><br><span class="line">  *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Of course, this is encoding, and there’s a corresponding implementation for decoding Varint from byte streams. The main implementation is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetVarint64Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">const</span> <span class="type">char</span>* limit, <span class="type">uint64_t</span>* value)</span> </span>{</span><br><span class="line">  <span class="type">uint64_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">63</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) {</span><br><span class="line">    <span class="type">uint64_t</span> byte = *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) {</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(p);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>This is the reverse process of encoding. After successfully decoding an integer, it returns a new pointer pointing to the position in the byte stream immediately following the decoded integer. The GetVarint64 function uses this implementation. After parsing a 64-bit integer from input, it also updates the state of input, <strong>making it point to the remaining unprocessed data</strong>. Updating the byte stream here is very useful for continuously processing multiple data items in a data stream, for example, when parsing a data stream composed of multiple Varint-encoded integers, input is updated after each call to GetVarint64, ready to parse the next integer.</p>
<p>There’s also a class of helper functions, such as PutLengthPrefixedSlice for encoding a string as a combination of a length prefix and string content, and GetLengthPrefixedSlice as the corresponding decoding function. These encoding and decoding functions are widely used in LevelDB for storing and parsing various data structures, such as keys and values in memtable, block data in SSTable files, etc.</p>
<p>The integer encoding and decoding here are accompanied by a large number of test cases, placed in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/coding_test.cc">util/coding_test.cc</a>. There are normal encoding and verification tests, such as Fixed32 encoding and decoding verification for 0 to 100000. In addition, there are some <strong>abnormal tests</strong>, such as the Varint32Overflow decoding case for incorrect Varint32, using GetVarint32Ptr to decode “\x81\x82\x83\x84\x85\x11”.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>The utils components in LevelDB are all designed to better adapt to LevelDB’s usage scenarios. For example, the Arena memory allocator is suitable for a large number of small memory allocations in memtable, the Random number generator is used for generating skip list heights, CRC32 is used for error detection during data transmission or storage, and encoding/decoding utility functions are used for storing and parsing numbers.</p>
<p>This article only briefly introduces the implementation of these components and doesn’t delve too much into the mathematical knowledge behind these components, such as the linear congruential algorithm of the random number generator and the polynomial division of CRC32. If you’re interested, you can continue to explore these topics in depth.</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2024/08/29/leveldb_source_utils/';
    this.page.identifier = 'en/2024/08/29/leveldb_source_utils/';
    this.page.title = 'LevelDB Explained - Arena, Random, CRC32, and More.';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (17)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (14)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2024/08/29/leveldb_source_utils/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/05/23/mcp_user_report/" title="In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?">In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?</a></li><li><a href="/en/2025/01/24/leveldb_source_writedb/" title="LevelDB Explained - Implementation and Optimization Details of Key-Value Writing">LevelDB Explained - Implementation and Optimization Details of Key-Value Writing</a></li><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li><li><a href="/en/2024/09/09/leveldb_source_skiplist/" title="LevelDB Explained - How to implement SkipList">LevelDB Explained - How to implement SkipList</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Management-Arena"><span class="toc-number">1.</span> <span class="toc-text">Memory Management Arena</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Random-Number-Generator"><span class="toc-number">2.</span> <span class="toc-text">Random Number Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CRC32"><span class="toc-number">3.</span> <span class="toc-text">CRC32</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer-Encoding-and-Decoding"><span class="toc-number">4.</span> <span class="toc-text">Integer Encoding and Decoding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">5.</span> <span class="toc-text">Conclusion</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>