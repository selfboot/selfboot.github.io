<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-WUJTOV7jES"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article details LevelDB's abstracted file operations, including the implementation of sequential read/write and random file access under Posix, and how to adapt to different operating systems through abstract interfaces. It also introduces key designs such as buffer optimization, resource limit management, and flexible reading strategies to improve system performance and usability. Additionally, it covers implementation details like the application of the factory method pattern, error handling mechanisms, and cross-platform compatibility considerations."><title>LevelDB Explained - Posix File Operation Details</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LevelDB Explained - Posix File Operation Details</h1><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB Explained - Posix File Operation Details</h1><div class="post-meta">2024/08/02<span> | </span><span class="category"><a href="/categories/Source-Code-Analysis/">Source Code Analysis</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2024/08/02/leveldb_source_env_posixfile/" href="/en/2024/08/02/leveldb_source_env_posixfile/#disqus_thread"></a><div class="post-content"><p>LevelDB supports running on various operating systems. To adapt to different operating systems, it needs to encapsulate some system calls, such as file operations, thread operations, time operations, etc. In the exposed include files, the <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h">env.h</a> file defines various interfaces used by LevelDB. This includes the Env class, which encapsulates file operations, directory operations, etc., as well as some file abstract classes such as SequentialFile, WritableFile, and RandomAccessFile for sequential reading, random reading, and writing files.</p>
<p>Through abstract interfaces, LevelDB can run on different operating systems by implementing the corresponding Env subclass for each platform. This article takes the POSIX system environment as an example to first look at how the abstracted <strong>file operation-related interfaces</strong> are implemented.</p>
<span id="more"></span>

<h2 id="Sequential-File-Reading"><a href="#Sequential-File-Reading" class="headerlink" title="Sequential File Reading"></a>Sequential File Reading</h2><p>First, let’s look at the abstract base class SequentialFile for <strong>sequential file reading</strong>, which provides a standard interface for sequential reading and skipping operations on files, and can be used for reading WAL log files. The class defines two main virtual functions:</p>
<ul>
<li>Read(size_t n, Slice* result, char* scratch): This function is used to read up to n bytes of data from the file. result is a pointer to a Slice type, used to store the read data. scratch is a character array used as a temporary buffer, and the function may write data to this buffer.</li>
<li>Skip(uint64_t n): This function is used to skip n bytes of data in the file. If the file is read to the end, the skip operation will stop at the end of the file, and the function returns an OK status.</li>
</ul>
<p>Of course, the comments also indicate that this class requires <strong>the caller to perform synchronization to ensure thread safety</strong>. In the POSIX environment, the implementation of this class is in the <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L136">env_posix.cc</a> file, where the PosixSequentialFile class finally inherits from SequentialFile, preventing it from being inherited by any other class, and implements the above two virtual functions. The implementation of Read is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">size_t</span> n, Slice* result, <span class="type">char</span>* scratch)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">      ::<span class="type">ssize_t</span> read_size = ::<span class="built_in">read</span>(fd_, scratch, n);</span><br><span class="line">      <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) {  <span class="comment">// Read error.</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) {</span><br><span class="line">          <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">        }</span><br><span class="line">        status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      *result = <span class="built_in">Slice</span>(scratch, read_size);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>Here, when the system call <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> returns a value less than 0, it will judge whether it is an EINTR error based on the value of errno, and if so, it will <strong>retry reading</strong>. This is because when performing a read() operation on a file descriptor with the O_NONBLOCK flag set, if there is not enough data available to read, read() will return immediately instead of blocking to wait for data to become available. In this case, read() will return -1 and errno will be set to EAGAIN, indicating that there is no data to read and to try again later.</p>
<p>The implementation of Skip is relatively simple, directly calling the system call <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/lseek.2.html">lseek()</a> to skip n bytes in the file. Here, the third parameter is SEEK_CUR, indicating to <strong>skip n bytes from the current position</strong>. In the operating system, each open file has an associated file position pointer (sometimes also called file offset). This pointer indicates where the next read or write operation will take place in the file. <strong>The operating system is responsible for tracking and maintaining this file position pointer</strong>. Of course, you can also specify SEEK_SET or SEEK_END, which represent skipping n bytes from the beginning and end of the file, respectively.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Skip</span><span class="params">(<span class="type">uint64_t</span> n)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">lseek</span>(fd_, n, SEEK_CUR) == <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(<span class="number">-1</span>)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>The file descriptor should also be closed when the object is destroyed to ensure that resources are properly released</strong>. Each time a file is opened, the operating system allocates some resources, such as kernel buffers, file locks, etc. Then it returns a file descriptor (a non-negative integer) to the user, which the user then uses to operate on the file. When we call <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/close.2.html">close</a>, the operating system reduces the reference count for that file, and if the reference count becomes 0, the operating system releases the corresponding resources. Additionally, there is a limit to the number of files each process can open, and not calling close(fd) may cause the process to be unable to open new files.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">PosixSequentialFile</span>() <span class="keyword">override</span> { <span class="built_in">close</span>(fd_); }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Random-File-Reading"><a href="#Random-File-Reading" class="headerlink" title="Random File Reading"></a>Random File Reading</h2><p>RandomAccessFile is an abstract base class that defines the interface for <strong>random file reading</strong>. It declares a pure virtual function Read, forcing subclasses to implement this method. The Read method is designed to allow reading a specified number of bytes from any position in the file. Because it’s a read-only interface, it supports lock-free multi-threaded concurrent access.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">char</span>* scratch)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>In the POSIX environment, this class has two implementations, one is <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L176">PosixRandomAccessFile</a> implemented using <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/pread.2.html">pread()</a>, and the other is <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L238">PosixMmapReadableFile</a> implemented using mmap().</p>
<h3 id="Random-Reading-with-pread"><a href="#Random-Reading-with-pread" class="headerlink" title="Random Reading with pread"></a>Random Reading with pread</h3><p>The PosixRandomAccessFile class implements the RandomAccessFile interface, mainly using the POSIX pread() system call. The constructor of this class is quite interesting, receiving filename, fd, and an externally passed fd_limiter pointer. fd_limiter is used to limit the number of file descriptors held, avoiding too many open file descriptors. The specific implementation of limiter is in the <a href="#Limiter">Limiter</a> section of this article. During construction, if fd_limiter-&gt;Acquire() returns true, it means it can always hold this file descriptor. Otherwise, the file descriptor needs to be closed in the constructor, and <strong>a temporary file descriptor will be used each time content is read from the file later</strong>.</p>
<p>Here, fd_limiter is created in the factory function of <a href="#Env-Encapsulation-Interface">PosixEnv</a>, and the maximum number of persistent file descriptors is obtained by the MaxOpenFiles function. It first checks if the global variable g_open_read_only_file_limit has been modified to a non-negative number, and if so, uses this value. If not set, it needs to decide based on the system’s resource limits. Here, the system call <a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man2/getrlimit.2.html">getrlimit</a> is used to <strong>get the maximum number of file descriptors that the current process can open</strong>. If the system doesn’t limit the number of file descriptors a process can open, it returns the maximum value of an int type, otherwise it allocates 20% of this limit to read-only file operations. If getting the resource limit fails, or if the system (like the Fuchsia operating system) doesn’t support getting resource limits, a hard-coded value of 50 is used.</p>
<p>Next, let’s look at the constructor of PosixRandomAccessFile:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The new instance takes ownership of |fd|. |fd_limiter| must outlive this</span></span><br><span class="line"><span class="comment">// instance, and will be used to determine if .</span></span><br><span class="line"><span class="built_in">PosixRandomAccessFile</span>(std::string filename, <span class="type">int</span> fd, Limiter* fd_limiter)</span><br><span class="line">    : <span class="built_in">has_permanent_fd_</span>(fd_limiter-&gt;<span class="built_in">Acquire</span>()),</span><br><span class="line">      <span class="built_in">fd_</span>(has_permanent_fd_ ? fd : <span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">fd_limiter_</span>(fd_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) {</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) {</span><br><span class="line">    <span class="built_in">assert</span>(fd_ == <span class="number">-1</span>);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);  <span class="comment">// The file will be opened on every read.</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The constructor uses the member variable has_permanent_fd_ to record whether it always holds an open file descriptor, and if not, fd_ is -1. Correspondingly, in the destructor, if has_permanent_fd_ is true, it needs to call close() to close the file descriptor and release the resource count of fd_limiter_. Next, let’s look at the core Read method of this class, the code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="type">int</span> fd = fd_;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) {</span><br><span class="line">    fd = ::<span class="built_in">open</span>(filename_.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">assert</span>(fd != <span class="number">-1</span>);</span><br><span class="line">  Status status;</span><br><span class="line">  <span class="type">ssize_t</span> read_size = ::<span class="built_in">pread</span>(fd, scratch, n, <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(offset));</span><br><span class="line">  *result = <span class="built_in">Slice</span>(scratch, (read_size &lt; <span class="number">0</span>) ? <span class="number">0</span> : read_size);</span><br><span class="line">  <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// An error: return a non-ok status.</span></span><br><span class="line">    status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) {</span><br><span class="line">    <span class="comment">// Close the temporary file descriptor opened earlier.</span></span><br><span class="line">    <span class="built_in">assert</span>(fd != fd_);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, it first determines whether it holds a <strong>persistent file descriptor</strong>, and if not, it needs to open the file each time it reads the file. Then it calls pread() to read the file content. pread() is similar to read(), but it can read data from a specified position in the file. The first parameter of pread() is the file descriptor, the second parameter is the buffer for reading, the third parameter is the number of bytes to read, and the fourth parameter is the offset in the file. If the read is successful, the read data is stored in result, otherwise an error status is returned. Finally, if it doesn’t hold a persistent file descriptor, it needs to close the temporary file descriptor after reading the data.</p>
<p>The implementation of the PosixRandomAccessFile class is relatively simple, directly using the system file API, without the need for additional memory mapping management, suitable for small files or infrequent read operations. However, if access is frequent, too many system calls may lead to performance degradation, in which case <strong>memory mapping files</strong> can be used to improve performance.</p>
<h3 id="Random-Reading-with-mmap"><a href="#Random-Reading-with-mmap" class="headerlink" title="Random Reading with mmap"></a>Random Reading with mmap</h3><p>The PosixMmapReadableFile class also implements the RandomAccessFile interface, but it maps the file or part of the file to the process’s address space through memory mapping (mmap), and accessing this part of memory is equivalent to accessing the file itself. <strong>Memory mapping allows the operating system to utilize page caches, which can significantly improve the performance of frequent reads, especially in large file scenarios, improving read efficiency</strong>.</p>
<p>Unlike PosixRandomAccessFile, here the constructor needs to pass in the mmap_base pointer, which points to the file content mapped through the mmap system call, and also needs to pass in length, which is the length of the mapped area, i.e., the size of the file. The mapping is done in the external NewRandomAccessFile method, and PosixMmapReadableFile directly uses the mapped address.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PosixMmapReadableFile</span>(std::string filename, <span class="type">char</span>* mmap_base, <span class="type">size_t</span> length,</span><br><span class="line">                      Limiter* mmap_limiter)</span><br><span class="line">    : <span class="built_in">mmap_base_</span>(mmap_base),</span><br><span class="line">      <span class="built_in">length_</span>(length),</span><br><span class="line">      <span class="built_in">mmap_limiter_</span>(mmap_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) {}</span><br></pre></td></tr></tbody></table></figure>

<p>Of course, mmap also needs to limit resources to avoid exhausting virtual memory. Here, the Limiter class is also used, which will be described in detail later. The Read method <strong>directly reads data from mmap_base_, without the need to call system calls</strong>, which is much more efficient. The overall code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (offset + n &gt; length_) {</span><br><span class="line">    *result = <span class="built_in">Slice</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, EINVAL);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  *result = <span class="built_in">Slice</span>(mmap_base_ + offset, n);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Sequential-File-Writing"><a href="#Sequential-File-Writing" class="headerlink" title="Sequential File Writing"></a>Sequential File Writing</h2><p>The previous sections were all about reading files, of course, we can’t miss the writing file interface. WritableFile is an abstract base class that defines the interface for <strong>sequential file writing</strong>. It provides a standard interface for sequential writing and synchronization operations on files, which can be used for writing WAL log files. The class defines three main virtual functions:</p>
<ul>
<li>Append(const Slice&amp; data): Appends data to the file object. For small blocks of data, it appends to the object’s memory cache, and for large blocks of data, it calls WriteUnbuffered to write to disk.</li>
<li>Flush(): Calls the system write to write the data currently in the memory cache to disk. Note that <strong>this does not guarantee that the data has been synchronized to the physical disk</strong>.</li>
<li>Sync(): Ensures that the data in the internal buffer is written to the file, and also <strong>ensures that the data is synchronized to the physical disk</strong> to guarantee data persistence. After calling Sync(), the data will not be lost even if a power failure or system crash occurs.</li>
</ul>
<p>In the POSIX environment, the implementation of this class is <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L277">PosixWritableFile</a>. The class internally uses a <strong>buffer of 65536 bytes</strong> <code>buf_</code>, and only writes data to the disk file when the buffer is full. If there are a large number of short content writes, they can be merged in memory first, thereby reducing the number of calls to the underlying file system and improving the efficiency of write operations.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">size_t</span> kWritableFileBufferSize = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf_[0, pos_ - 1] contains data to be written to fd_.</span></span><br><span class="line">  <span class="type">char</span> buf_[kWritableFileBufferSize];</span><br></pre></td></tr></tbody></table></figure>

<p>The strategy for merging writes is implemented in Append, and the code is quite clear. For the content to be written, if it can be completely placed in the buffer, it is directly copied to the buffer, and then returns success. Otherwise, it first fills the buffer, then writes the data in the buffer to the file. At this point, if the remaining data can be written to the buffer, it is written directly, otherwise it is flushed directly to the disk. The complete implementation is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Append</span><span class="params">(<span class="type">const</span> Slice&amp; data)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="type">size_t</span> write_size = data.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* write_data = data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fit as much as possible into buffer.</span></span><br><span class="line">  <span class="type">size_t</span> copy_size = std::<span class="built_in">min</span>(write_size, kWritableFileBufferSize - pos_);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(buf_ + pos_, write_data, copy_size);</span><br><span class="line">  write_data += copy_size;</span><br><span class="line">  write_size -= copy_size;</span><br><span class="line">  pos_ += copy_size;</span><br><span class="line">  <span class="keyword">if</span> (write_size == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Can't fit in buffer, so need to do at least one write.</span></span><br><span class="line">  Status status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) {</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Small writes go to buffer, large writes are written directly.</span></span><br><span class="line">  <span class="keyword">if</span> (write_size &lt; kWritableFileBufferSize) {</span><br><span class="line">    std::<span class="built_in">memcpy</span>(buf_, write_data, write_size);</span><br><span class="line">    pos_ = write_size;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WriteUnbuffered</span>(write_data, write_size);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The WriteUnbuffered function is called above to write data to disk, which is implemented through the system call <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>. The main code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteUnbuffered</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> size)</span> </span>{</span><br><span class="line">  <span class="keyword">while</span> (size &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="type">ssize_t</span> write_result = ::<span class="built_in">write</span>(fd_, data, size);</span><br><span class="line">    <span class="keyword">if</span> (write_result &lt; <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) {</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    }</span><br><span class="line">    data += write_result;</span><br><span class="line">    size -= write_result;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>In addition to the Append function, WritableFile also provides a Flush interface for writing the data in the memory buffer buf_ to the file, which is also implemented by calling WriteUnbuffered internally. However, it’s worth noting that even if Flush writes to disk successfully, it <strong>does not guarantee that the data has been written to the disk, or even that the disk has enough space to store the content</strong>. If you want to ensure that the data is successfully written to the physical disk file, you need to call the Sync() interface, implemented as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Sync</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  Status status = <span class="built_in">SyncDirIfManifest</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) {</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  }</span><br><span class="line">  status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) {</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SyncFd</span>(fd_, filename_);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The core here is calling the SyncFd() method, which <strong>ensures that all buffered data associated with the file descriptor fd is synchronized to the physical disk</strong>. The implementation of this function considers different operating system characteristics and file system behaviors, using conditional compilation directives (#if, #else, #endif) to handle different environments. On macOS and iOS systems, it uses the <code>F_FULLFSYNC</code> option of the fcntl() function to ensure that data is synchronized to the physical disk. If HAVE_FDATASYNC is defined, it will use fdatasync() to synchronize data. In other cases, it defaults to using the fsync() function to achieve the same functionality.</p>
<p>Note that SyncDirIfManifest ensures that if the file is a manifest file (named starting with “MANIFEST”), related directory changes are also synchronized. The manifest file records the metadata of the database files, including version information, merge operations, database status, and other critical information. When the file system creates new files or modifies file directory entries, these changes may not be immediately written to disk. <strong>Ensuring that the data of the directory has been synchronized to disk before updating the manifest file</strong> prevents the files referenced by the manifest file from not being actually written to disk when the system crashes.</p>
<h2 id="Resource-Concurrent-Limitation"><a href="#Resource-Concurrent-Limitation" class="headerlink" title="Resource Concurrent Limitation"></a>Resource Concurrent Limitation</h2><p>As mentioned above, to avoid having too many open file descriptors, the Acquire method of the Limiter class is used for limitation. This class is also implemented in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L73">env_posix.cc</a>. The comments for this class are particularly good, clearly explaining its purpose, which is mainly used to limit resource usage to avoid resource exhaustion. It is currently used to limit read-only file descriptors and mmap file usage to avoid running out of file descriptors or virtual memory, or encountering kernel performance problems in very large databases.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper class to limit resource usage to avoid exhaustion.</span></span><br><span class="line"><span class="comment">// Currently used to limit read-only file descriptors and mmap file usage</span></span><br><span class="line"><span class="comment">// so that we do not run out of file descriptors or virtual memory, or run into</span></span><br><span class="line"><span class="comment">// kernel performance problems for very large databases.</span></span><br></pre></td></tr></tbody></table></figure>

<p>The constructor takes a parameter max_acquires, which sets the maximum number of resources that can be acquired. The class internally maintains an atomic variable acquires_allowed_ to track the number of resources currently allowed to be acquired, with an initial value set to max_acquires. Conditional compilation is used here, NDEBUG is a commonly used preprocessor macro used to indicate whether the program is compiled in non-debug mode.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Limit maximum number of resources to |max_acquires|.</span></span><br><span class="line">  <span class="built_in">Limiter</span>(<span class="type">int</span> max_acquires)</span><br><span class="line">      :</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(NDEBUG)</span></span><br><span class="line">        <span class="built_in">max_acquires_</span>(max_acquires),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(NDEBUG)</span></span></span><br><span class="line">        <span class="built_in">acquires_allowed_</span>(max_acquires) {</span><br><span class="line">    <span class="built_in">assert</span>(max_acquires &gt;= <span class="number">0</span>);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>If in debug mode, max_acquires_ is used to record the maximum number of resources, and assertions are added in the Acquire and Release methods to ensure that resource acquisition and release operations are correct. In the production environment, <strong>when NDEBUG is defined, all assert calls will be ignored by the compiler and will not generate any execution code</strong>.</p>
<p>The core interfaces of this class are Acquire and Release. These two methods are used to acquire and release resources respectively. The code for Acquire is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Acquire</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> old_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (old_acquires_allowed &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pre_increment_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Silence compiler warnings about unused arguments when NDEBUG is defined.</span></span><br><span class="line">  (<span class="type">void</span>)pre_increment_acquires_allowed;</span><br><span class="line">  <span class="comment">// If the check below fails, Release() was called more times than acquire.</span></span><br><span class="line">  <span class="built_in">assert</span>(pre_increment_acquires_allowed &lt; max_acquires_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, fetch_sub(1, std::memory_order_relaxed) is used to atomically decrease the value of acquires_allowed_ and return the value before the decrease as old_acquires_allowed. If old_acquires_allowed is greater than 0, it means there were resources available before the decrease, so it returns true. If no resources are available (i.e., old_acquires_allowed is 0 or negative), it atomically adds the counter back to 1 using fetch_add(1, std::memory_order_relaxed) to restore the state, and returns false.</p>
<p>The Release method is used to release resources previously successfully acquired through the Acquire method. It uses fetch_add(1, std::memory_order_relaxed) to atomically increase the value of acquires_allowed_, indicating that the resource has been released, and uses an assertion to ensure that the number of Release calls does not exceed the number of successful Acquire calls, preventing resource count errors.</p>
<p>When operating on the atomic counter here, std::memory_order_relaxed is used, indicating that these atomic operations <strong>do not need any special ordering constraints on memory</strong>, only guaranteeing the atomicity of the operation. This is because the operations here do not depend on the results of any other memory operations, they simply increment or decrement the counter.</p>
<h2 id="Env-Encapsulation-Interface"><a href="#Env-Encapsulation-Interface" class="headerlink" title="Env Encapsulation Interface"></a>Env Encapsulation Interface</h2><p>In addition to the above file operation classes, there is also an important Env abstract base class, which derives PosixEnv under Posix, encapsulating many implementations.</p>
<h3 id="Factory-Construction-of-Objects"><a href="#Factory-Construction-of-Objects" class="headerlink" title="Factory Construction of Objects"></a>Factory Construction of Objects</h3><p>First are several factory methods used to create file read and write objects like SequentialFile, RandomAccessFile, and WritableFile objects. The NewSequentialFile factory method creates a PosixSequentialFile file object, encapsulating the call to open the file. The advantage of using the factory method here is that it can handle some errors, such as file opening failure. Additionally, the input parameter is <code>WritableFile**</code>, supporting polymorphism. If other WritableFile implementations are added in the future, they can be switched to different implementations by modifying the factory method without changing the calling code.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewSequentialFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                         SequentialFile** result)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">    *result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename, errno);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  *result = <span class="keyword">new</span> <span class="built_in">PosixSequentialFile</span>(filename, fd);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>When opening a file here, in addition to O_RDONLY indicating read-only, there is also a kOpenBaseFlags. kOpenBaseFlags is a flag that is set based on the compilation option HAVE_O_CLOEXEC. If the system supports O_CLOEXEC, this flag will be set. O_CLOEXEC ensures that <strong>the file descriptor is automatically closed when executing exec() series functions, thus preventing file descriptor leakage to the newly executed program</strong>.</p>
<p>By default, when a process creates a child process, all file descriptors are inherited by the child process. Unless explicitly handled for each file descriptor, they will remain open after exec is executed. In most cases, if a process intends to execute another program (usually through exec series functions), it’s likely that it doesn’t want the new program to access certain resources of the current process, especially file descriptors. The O_CLOEXEC flag ensures that these file descriptors are automatically closed after exec, thus not leaking to the new program. Although LevelDB itself doesn’t call exec functions, this flag is still added here, which is a good defensive programming habit.</p>
<p>Of course, this flag may not be supported on all platforms. For cross-platform compatibility, in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/CMakeLists.txt#L54">CmakeLists.txt</a>, check_cxx_symbol_exists is used to detect whether the current environment’s fcntl.h file has O_CLOEXEC, and if so, the HAVE_O_CLOEXEC macro is defined. It’s worth mentioning that check_cxx_symbol_exists is quite useful, it can <strong>determine whether specific features are supported before compilation, so that compilation settings or source code can be adjusted appropriately based on the detection results</strong>. Several macros in LevelDB are detected in this way, such as fdatasync, F_FULLFSYNC, etc.</p>
<figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">check_cxx_symbol_exists(fdatasync <span class="string">"unistd.h"</span> HAVE_FDATASYNC)</span><br><span class="line">check_cxx_symbol_exists(F_FULLFSYNC <span class="string">"fcntl.h"</span> HAVE_FULLFSYNC)</span><br><span class="line">check_cxx_symbol_exists(O_CLOEXEC <span class="string">"fcntl.h"</span> HAVE_O_CLOEXEC)</span><br></pre></td></tr></tbody></table></figure>

<p>The NewWritableFile and NewAppendableFile factory functions are similar, first opening the file and then creating a PosixWritableFile object. However, different flags are used when opening the file:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_TRUNC | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_APPEND | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>O_TRUNC indicates that if the file exists, its length will be truncated to 0. O_APPEND indicates that when writing data, it will always append the data to the end of the file, rather than overwriting existing data in the file.</p>
<p>NewRandomAccessFile is a bit more complex because it supports two modes of random reading. First, it opens the file to get the fd, then uses mmap_limiter_ to limit the number of memory-mapped open files. If it exceeds the mmap limit, it uses pread for random reading. If it doesn’t exceed the limit, it uses mmap to memory-map the file, gets the mapped address and file size, and then creates a PosixMmapReadableFile object.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewRandomAccessFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                           RandomAccessFile** result)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!mmap_limiter_.<span class="built_in">Acquire</span>()) {</span><br><span class="line">    *result = <span class="keyword">new</span> <span class="built_in">PosixRandomAccessFile</span>(filename, fd, &amp;fd_limiter_);</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="type">uint64_t</span> file_size;</span><br><span class="line">  Status status = <span class="built_in">GetFileSize</span>(filename, &amp;file_size);</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) {</span><br><span class="line">    <span class="type">void</span>* mmap_base = ::<span class="built_in">mmap</span>(<span class="comment">/*addr=*/</span><span class="literal">nullptr</span>, file_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmap_base != MAP_FAILED) {</span><br><span class="line">      *result = <span class="keyword">new</span> <span class="built_in">PosixMmapReadableFile</span>(filename,</span><br><span class="line">                                          <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(mmap_base),</span><br><span class="line">                                          file_size, &amp;mmap_limiter_);</span><br><span class="line">    } </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  }</span><br><span class="line">  ::<span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) {</span><br><span class="line">    mmap_limiter_.<span class="built_in">Release</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, the maximum number of files limited by mmap_limiter_ is obtained by the MaxMmaps function. For 64-bit systems, due to the very large virtual memory address space (usually over 256TB in actual applications), LevelDB allows allocating 1000 memory-mapped areas, which should not have a significant impact on the overall performance of the system. For 32-bit systems, due to the limited virtual memory address space, LevelDB does not allow allocating memory-mapped areas.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Up to 1000 mmap regions for 64-bit binaries; none for 32-bit.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> kDefaultMmapLimit = (<span class="built_in">sizeof</span>(<span class="type">void</span>*) &gt;= <span class="number">8</span>) ? <span class="number">1000</span> : <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="File-Utility-Classes"><a href="#File-Utility-Classes" class="headerlink" title="File Utility Classes"></a>File Utility Classes</h3><p>In addition to the several core file classes mentioned above, Env also provides a series of file operation interfaces, including file metadata retrieval, file deletion, etc. This is a good opportunity to familiarize ourselves with <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc">various system calls in the Posix environment</a>.</p>
<p>FileExists: Determines <strong>whether the current process can access the file (inability to access does not mean the file does not exist)</strong>, implemented by calling the system call <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/access.2.html">access()</a>;</p>
<p>RemoveFile: If no process is currently using the file (i.e., no open file descriptors point to this file), it will delete the file. Implemented through the system call <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/unlink.2.html">unlink()</a>, unlink actually deletes the link between the filename and its corresponding inode. If this inode has no other links and no process has this file open, the actual data blocks and inode of the file will be released.</p>
<p>GetFileSize: Gets the size of the file. If the file does not exist or the retrieval fails, it returns 0. This is implemented through the <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/stat.2.html">stat</a> system call. When calling the stat function, you need to pass the filename and a pointer to a stat structure. The system will check the path permissions corresponding to the filename, then retrieve the file’s inode. The inode is a data structure in the file system that stores the file’s metadata, including file size, permissions, creation time, last access time, etc. The file system maintains an inode table for quick lookup and access to inode information, and for most file systems (such as EXT4, NTFS, XFS, etc.), commonly used inodes are usually cached in memory, so retrieving the inode is generally very efficient.</p>
<p>RenameFile: Renames a file or folder. You can specify new and old filenames here, implemented through the system call <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/rename.2.html">rename()</a>.</p>
<p>CreateDir: Creates a directory with default permissions of 755. This is implemented through the system call <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/mkdir.2.html">mkdir()</a>. If pathname already exists, it returns failure.</p>
<p>RemoveDir: Deletes a directory, implemented through the system call <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/rmdir.2.html">rmdir()</a>.</p>
<p>GetChildren: Slightly more complex, it uses the system call opendir to get the directory, then uses readdir to traverse the files in it, and finally remembers to use closedir to clean up resources.</p>
<h2 id="File-Operation-Summary"><a href="#File-Operation-Summary" class="headerlink" title="File Operation Summary"></a>File Operation Summary</h2><p>It must be said that a simple file operation encapsulation contains many implementation details. Let’s summarize them briefly:</p>
<ol>
<li>Buffer optimization: In the WritableFile implementation, a memory buffer is used, which can merge small write operations, reduce the number of system calls, and improve write efficiency.</li>
<li>Resource limit management: The Limiter class is used to limit the number of simultaneously open file descriptors and memory mappings (mmap). By setting reasonable upper limits, resource exhaustion is avoided, improving system stability and performance.</li>
<li>Flexible reading strategy: For random reading, LevelDB provides two implementations based on pread and mmap, which can dynamically choose the most appropriate method according to system resource conditions.</li>
<li>Factory method pattern: Using factory methods to create file objects encapsulates operations such as file opening, facilitating error handling and future expansion.</li>
<li>Cross-platform compatibility: Through conditional compilation and feature detection (such as checking for O_CLOEXEC), code compatibility on different platforms is ensured.</li>
<li>Synchronization mechanism: Flush and Sync interfaces are provided, allowing users to choose different levels of data persistence guarantees as needed.</li>
</ol>
<p>In addition to encapsulating file operations, there are other encapsulations in Env, which we’ll see in the next article.</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2024/08/02/leveldb_source_env_posixfile/';
    this.page.identifier = 'en/2024/08/02/leveldb_source_env_posixfile/';
    this.page.title = 'LevelDB Explained - Posix File Operation Details';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (2)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (1)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (6)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2024/08/02/leveldb_source_env_posixfile/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2024/08/14/leveldb_source_wal_log/" title="LevelDB Explained - How To Read and Write WAL Logs">LevelDB Explained - How To Read and Write WAL Logs</a></li><li><a href="/en/2024/08/13/leveldb_source_unstand_c++/" title="LevelDB Explained -  Understanding Advanced C++ Techniques">LevelDB Explained -  Understanding Advanced C++ Techniques</a></li><li><a href="/en/2024/08/08/leveldb_source_bloom_filter/" title="LevelDB Explained - Bloom Filter Implementation and Visualization">LevelDB Explained - Bloom Filter Implementation and Visualization</a></li><li><a href="/en/2024/08/06/leveldb_source_prepare/" title="LevelDB Explained - Preparing the Development Environment">LevelDB Explained - Preparing the Development Environment</a></li><li><a href="/en/2024/08/02/leveldb_source_env_posixfile/" title="LevelDB Explained - Posix File Operation Details">LevelDB Explained - Posix File Operation Details</a></li><li><a href="/en/2024/07/22/leveldb_source_nodestructor/" title="LevelDB Explained - Preventing C++ Object Destruction">LevelDB Explained - Preventing C++ Object Destruction</a></li><li><a href="/en/2024/06/22/claude35_artifacts/" title="Creating Games Using Free Claude3.5 with Artifacts">Creating Games Using Free Claude3.5 with Artifacts</a></li><li><a href="/en/2024/06/13/async_pool_block_problem/" title="How an Async Thread Pool Exception Caused Service Chaos">How an Async Thread Pool Exception Caused Service Chaos</a></li><li><a href="/en/2024/05/19/stream_sse_chunk/" title="Understand Web Stream Output Implementation with Examples">Understand Web Stream Output Implementation with Examples</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 9 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"> Contents</i></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sequential-File-Reading"><span class="toc-number">1.</span> <span class="toc-text">Sequential File Reading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Random-File-Reading"><span class="toc-number">2.</span> <span class="toc-text">Random File Reading</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Random-Reading-with-pread"><span class="toc-number">2.1.</span> <span class="toc-text">Random Reading with pread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Random-Reading-with-mmap"><span class="toc-number">2.2.</span> <span class="toc-text">Random Reading with mmap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sequential-File-Writing"><span class="toc-number">3.</span> <span class="toc-text">Sequential File Writing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource-Concurrent-Limitation"><span class="toc-number">4.</span> <span class="toc-text">Resource Concurrent Limitation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Env-Encapsulation-Interface"><span class="toc-number">5.</span> <span class="toc-text">Env Encapsulation Interface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Factory-Construction-of-Objects"><span class="toc-number">5.1.</span> <span class="toc-text">Factory Construction of Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-Utility-Classes"><span class="toc-number">5.2.</span> <span class="toc-text">File Utility Classes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File-Operation-Summary"><span class="toc-number">6.</span> <span class="toc-text">File Operation Summary</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>