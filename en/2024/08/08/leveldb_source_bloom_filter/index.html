<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-WUJTOV7jES"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article provides a detailed introduction to the basic concepts, mathematical principles, and parameter selection of Bloom filters. It analyzes the specific implementation in LevelDB's source code, including hash function selection, filter creation, and query processes. The article also showcases LevelDB's Bloom filter test cases, verifying its correctness and performance. Additionally, it offers a visual demonstration of Bloom filters to help readers intuitively understand their working principles."><title>LevelDB Explained - Bloom Filter Implementation and Visualization</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB Explained - Bloom Filter Implementation and Visualization</h1><div class="post-meta">2024/08/08<span> | </span><span class="category"><a href="/categories/Source-Code-Analysis/">Source Code Analysis</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2024/08/08/leveldb_source_bloom_filter/" href="/en/2024/08/08/leveldb_source_bloom_filter/#disqus_thread"></a><div class="post-content"><p>In LevelDB, data is stored in SSTable files. When using Get() to query a key, it may be necessary to read multiple blocks from the SST file. To reduce disk reads, LevelDB provides a FilterPolicy strategy. If it can determine that a key is not in the current SSTable file, it can skip reading that file, thus improving query efficiency.</p>
<p>LevelDB supports user-defined filter policies but provides a default Bloom filter implementation. A Bloom filter is a space-efficient data structure used to determine whether an element is a member of a set. It has a certain false positive rate but no false negatives. In simple terms, <strong>if a Bloom filter determines that an element does not exist, then the element definitely does not exist; if a Bloom filter determines that an element exists, then the element may not exist</strong>.</p>
<span id="more"></span>

<p>Using a Bloom filter in LevelDB is quite simple, as shown in the following code:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Options options;</span><br><span class="line">options.filter_policy = <span class="built_in">NewBloomFilterPolicy</span>(<span class="number">10</span>);</span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">"/tmp/testdb"</span>, &amp;db);</span><br><span class="line"><span class="comment">// ... use the database ...</span></span><br><span class="line"><span class="keyword">delete</span> db;</span><br><span class="line"><span class="keyword">delete</span> options.filter_policy;</span><br></pre></td></tr></tbody></table></figure>

<p>So what are the principles behind Bloom filters? And how are they implemented in LevelDB? Let’s take a look together in this article.</p>
<h2 id="LevelDB-Interface-Definition"><a href="#LevelDB-Interface-Definition" class="headerlink" title="LevelDB Interface Definition"></a>LevelDB Interface Definition</h2><p>Before delving into the implementation details of Bloom filters, let’s first look at how LevelDB defines the filter interface.</p>
<p>LevelDB <strong>defines the interface for filter policies</strong> in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/include/leveldb/filter_policy.h">filter_policy.h</a>. FilterPolicy itself is an abstract class that defines 3 pure virtual functions as interfaces. It cannot be instantiated directly and must be implemented by subclasses.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> FilterPolicy {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">FilterPolicy</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, <span class="type">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::string* dst)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; filter)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>All three of these interfaces are important, and the code comments explain them in detail:</p>
<ul>
<li>Name(): Returns the name of the filter policy, which is <strong>very important for version compatibility</strong>. If the implementation of the filter policy (i.e., data structure or algorithm) changes, potentially causing incompatibility with old versions, the returned name should reflect this change to prevent old filter policies from being used incorrectly.</li>
<li>CreateFilter(): Used to create a filter, i.e., adding all keys in keys to the filter and then saving the content in dst.</li>
<li>KeyMayMatch(): Used to determine if a key exists in the filter, where filter is the dst generated by CreateFilter(). If the key exists in the filter, it must return true. <strong>If it doesn’t exist, it can return either true or false, but the probability of returning false should be as high as possible</strong>.</li>
</ul>
<p>Additionally, a factory function is provided to create a Bloom filter instance. However, one drawback is that after using the returned filter policy instance, you need to remember to manually release the resources. The use of a factory function here <strong>allows library maintainers to change the object creation process without affecting existing client code</strong>. For example, if a more efficient Bloom filter implementation is developed in the future, <strong>the factory function can simply be modified to return the new implementation without needing to modify the code that calls it. This provides convenience for future expansion and maintenance</strong>.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LEVELDB_EXPORT <span class="type">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="type">int</span> bits_per_key)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>By defining the filter policy interface and using a factory function, developers can easily implement different filter policies. To implement a new filter policy, you only need to inherit the <code>FilterPolicy</code> class and implement the corresponding methods. For the caller, they only need to pass the new filter policy to the <code>Options</code> object, and the overall changes will be relatively simple.</p>
<h2 id="Bloom-Filter-Principles"><a href="#Bloom-Filter-Principles" class="headerlink" title="Bloom Filter Principles"></a>Bloom Filter Principles</h2><p>LevelDB implemented its own Bloom filter as the default filter policy. Before we start looking at the implementation code, let’s first understand the principles of Bloom filters.</p>
<p>In 1970, Burton Howard Bloom created the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a>, an efficient data structure, to check whether an English word is in the dictionary for a spell checker. Its core is an m-bit bit array and k hash functions. The core operations are as follows:</p>
<ol>
<li>Initialization: At the start, the Bloom filter is an array of m bits, with each bit set to 0.</li>
<li>Adding elements: When adding an element to the Bloom filter, first use k hash functions to hash the element, producing k array position indices, then set all these positions to 1.</li>
<li>Querying elements: To check if an element is in the Bloom filter, use the same k hash functions to hash the element, obtaining k indices. If all these indices correspond to bits that are 1, then <strong>the element may exist in the set</strong>; if any bit is 0, then <strong>the element definitely does not exist in the set</strong>.</li>
</ol>
<p>From the above description, we can see that the time required to add or check whether an element is in the set is a fixed constant $ O( k )$, completely independent of the number of elements already in the set. Compared to other data structures representing sets, such as hash tables, balanced binary trees, skip lists, etc., in addition to fast lookup speed, Bloom filters are also very space-efficient as they don’t need to store the elements themselves, saving considerable space.</p>
<p>However, Bloom filters also have drawbacks. Careful consideration of the above process reveals that <strong>the query results of Bloom filters can be false positives</strong>. Bloom filters use multiple hash functions to process each element, setting multiple resulting positions to 1, <strong>and these positions may overlap with the hash results of other elements</strong>. Suppose a key does not exist in the set, but its hash results overlap with the hash results of other elements. In this case, the Bloom filter would determine that this key exists in the set, which is known as a false positive.</p>
<p>The probability that a Bloom filter incorrectly determines an element exists when it actually does not is called the false positive rate. Intuitively, <strong>for a fixed number k of hash functions, the larger the array size m, the fewer hash collisions, and thus the lower the false positive rate</strong>. To design a good Bloom filter ensuring a very low false positive rate, this qualitative analysis is not enough; we need to perform mathematical derivation for quantitative analysis.</p>
<h3 id="Mathematical-Derivation"><a href="#Mathematical-Derivation" class="headerlink" title="Mathematical Derivation"></a>Mathematical Derivation</h3><p>Here’s a simple derivation of the Bloom filter error rate calculation. You can skip this part and directly read the <a href="#LevelDB-Implementation">LevelDB Implementation</a> section. Assume the bit array size of the Bloom filter is $( m )$, the number of hash functions is $( k )$, and $( n )$ elements have been added to the filter. We assume that the hash functions we use are very random, so <strong>we can assume that the hash functions choose positions in the array with equal probability</strong>. During the insertion of elements, the probability of a certain bit being set to 1 by a certain hash function is $( \frac{1}{m} )$, and the probability of not being set to 1 is $( 1 - \frac{1}{m} )$.</p>
<p>$ k $ is the number of hash functions, and the hash functions we choose are uncorrelated and independent of each other. So the probability of <strong>a bit not being set to 1 by any hash function</strong> is:</p>
<p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{k}} $$</p>
<p>Next is a mathematical trick. The natural logarithm $ e $ has an identity:</p>
<p>$$ {\displaystyle \lim _{m\to \infty }\left(1-{\frac {1}{m}}\right)^{m}={\frac {1}{e}}} $$</p>
<p>For relatively large m, we can deduce:</p>
<p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{k}=\left(\left(1-{\frac {1}{m}}\right)^{m}\right)^{k/m}\approx e^{-k/m}} $$</p>
<p>We have inserted n elements, so the probability of a certain bit not being set to 1 is:</p>
<p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{kn}\approx e^{-kn/m}} $$</p>
<p>Therefore, the probability of a certain bit being set to 1 is:</p>
<p>$$ {\displaystyle 1-\left(1-{\frac {1}{m}}\right)^{kn}\approx 1-e^{-kn/m}} $$</p>
<p>Assuming an element is not in the set, the probability that all k bits are set to 1 is:</p>
<p>$$ {\displaystyle \left(1-e^{-kn/m}\right)^{k}} $$</p>
<h3 id="Parameter-Selection"><a href="#Parameter-Selection" class="headerlink" title="Parameter Selection"></a>Parameter Selection</h3><p>From the above derivation, we can see that the false positive rate is related to the number of hash functions $ k $, the size of the bit array $ m $, and the number of added elements $ n $.</p>
<ul>
<li>$ n $ is usually determined by the application scenario, representing the <strong>expected total number of elements to be inserted into the Bloom filter</strong>. It can be predicted, determined by external factors, and is not easily adjustable.</li>
<li>Increasing $ m $ can directly reduce the false positive rate, but this will <strong>increase the storage space requirements of the Bloom filter</strong>. In storage-constrained environments, you may not want to increase it indefinitely. Additionally, the effect of expanding $ m $ is <strong>linear</strong>, and you need to balance performance improvement with additional storage costs.</li>
<li>Changing $ k $ has a <strong>very significant impact on the false positive rate</strong> because it directly affects the probability of bits in the bit array being set to 1.</li>
</ul>
<p>Considering all these factors, in practical applications, $ n $ is determined by the usage scenario, while $ m $ is limited by storage costs, making adjusting $ k $ a practical and direct optimization method. Given the expected number of elements $n$ and the bit array size $m$, <strong>we need to find an appropriate k that minimizes the false positive rate</strong>.</p>
<p>Finding the appropriate k here is an optimization problem that can be solved mathematically. It’s quite complex, so we’ll just state the conclusion. The optimal $(k)$ is as follows:</p>
<p>$$ k = \frac{m}{n} \ln 2 $$</p>
<h2 id="LevelDB-Implementation"><a href="#LevelDB-Implementation" class="headerlink" title="LevelDB Implementation"></a>LevelDB Implementation</h2><p>Above, we introduced the principles of Bloom filters. Now let’s see how they are specifically implemented in LevelDB. The implementation of Bloom filters in LevelDB is in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/bloom.cc">bloom.cc</a>, where BloomFilterPolicy inherits from FilterPolicy and implements the aforementioned interfaces.</p>
<h3 id="Hash-Function-Count-Selection"><a href="#Hash-Function-Count-Selection" class="headerlink" title="Hash Function Count Selection"></a>Hash Function Count Selection</h3><p>First, let’s look at the selection of the number of hash functions k. The code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="type">int</span> bits_per_key)</span> : bits_per_key_(bits_per_key) {</span></span><br><span class="line">  <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">  k_ = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">  <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The bits_per_key parameter is passed in when constructing the Bloom filter, and LevelDB always passes 10. This value represents the <strong>average number of bits occupied by each key</strong>, i.e., $ \frac{m}{n} $. The 0.69 here is an approximation of $ \ln (2) $, and this coefficient comes from the optimal hash function count formula $ k = \frac{m}{n} \ln 2 $ discussed above. Finally, some boundary protection is performed here to ensure that the value of k is between 1 and 30, avoiding k being too large and making hash calculations too time-consuming.</p>
<h3 id="Creating-the-Filter"><a href="#Creating-the-Filter" class="headerlink" title="Creating the Filter"></a>Creating the Filter</h3><p>Next, let’s see how the filter is created here. The <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/bloom.cc#L28">complete code</a> is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, <span class="type">int</span> n, std::string* dst)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">  <span class="type">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">  <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">  <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">  bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">  dst-&gt;<span class="built_in">resize</span>(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">  dst-&gt;<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">  <span class="type">char</span>* array = &amp;(*dst)[init_size];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">    <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">    <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">    <span class="type">uint32_t</span> h = <span class="built_in">BloomHash</span>(keys[i]);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) {</span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      array[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">      h += delta;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>First, it calculates the space needed for the bit array, based on the number of keys $ n $ and the average number of bits per key. It also considers some boundary conditions: if the resulting number of bits is too small (less than 64 bits), it sets it to 64 bits to avoid a high false positive rate. Additionally, it considers byte alignment, converting the number of bits to bytes while ensuring the total number of bits is a multiple of 8.</p>
<p>Next, it uses resize to increase the size of dst, <strong>allocating space for the bit array after the target string</strong>. Here, the Bloom filter <strong>is designed to be appended to existing data without overwriting or deleting existing data</strong>. The newly added space is initialized to 0 because the Bloom filter’s bit array needs to start from an all-zero state. Then k_, the number of hash functions, is added to the end of the target string dst. This value is part of the Bloom filter’s metadata and is used to determine how many hash calculations need to be performed when querying whether a key exists.</p>
<p>Finally, there’s the core part of the Bloom filter, calculating which bit array positions need to be set to 1. Normally, you would need to set up <strong>k hash functions, calculate k times, and then set the corresponding positions</strong>. However, LevelDB’s implementation seems different. For each key, it uses the BloomHash function to calculate the initial hash value h of the key, then sets the corresponding position. In subsequent calculations, each time it right-shifts the previous hash value by 17 bits, left-shifts by 15 bits, and then performs an OR operation to calculate delta. Then it adds delta to the previous hash value to calculate the next hash value. This way, it can obtain k hash values and then set the corresponding positions.</p>
<p>In the previous <a href="#Mathematical-Derivation">Mathematical Derivation</a> section, we mentioned that these <strong>k hash functions need to be random and mutually independent</strong>. Can the above method meet this requirement? The code comment mentions that it adopts the <strong>double-hashing</strong> method, referring to the analysis in <a target="_blank" rel="noopener" href="https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf">[Kirsch,Mitzenmacher 2006]</a>. Although the hash values generated by double hashing are not as completely unrelated as those from completely independent hash functions, in practical applications, they provide sufficient randomness and independence to meet the requirements of Bloom filters.</p>
<p>The advantages here are also obvious. Double hashing can generate multiple pseudo-independent hash values from one basic hash function, without needing to implement k hashes, making the implementation very simple. Moreover, compared to multiple independent hash functions, <strong>the double hashing method reduces computational overhead because it only needs to calculate one real hash value, with the rest of the hash values obtained through simple arithmetic and bit operations</strong>.</p>
<h3 id="Querying-Key-Existence"><a href="#Querying-Key-Existence" class="headerlink" title="Querying Key Existence"></a>Querying Key Existence</h3><p>Finally, let’s look at how to query whether a key exists. If you understood the previous part about creating the filter, this part should be easy to understand. The <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/bloom.cc#L56">complete code</a> is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; bloom_filter)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* array = bloom_filter.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line">  <span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> k = array[len - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (k &gt; <span class="number">30</span>) {</span><br><span class="line">    <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line">    <span class="comment">// Consider it a match.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> h = <span class="built_in">BloomHash</span>(key);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) {</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h % bits;</span><br><span class="line">    <span class="keyword">if</span> ((array[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    h += delta;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The beginning part is just some boundary condition checks. If the filter length is less than 2, it returns false. It reads the value of k from the last byte of the filter data, which was stored when creating the filter and is used to determine how many hash calculations need to be performed. If k is greater than 30, this case is considered as possibly for future new encoding schemes, so the function directly returns true, assuming the key might exist in the set (as of 2024, no new encoding schemes have been extended here).</p>
<p>The next part is similar to when creating the filter. It uses the BloomHash function to calculate the hash value of the key, then performs bit rotation to generate delta, which is used to modify the hash value in the loop to simulate the effect of multiple hash functions. During this process, if any bit is 0, it indicates that <strong>the key is definitely not in the set</strong>, and the function returns false. If all relevant bits are 1, it returns true, indicating that <strong>the key might be in the set</strong>.</p>
<h2 id="Bloom-Filter-Testing"><a href="#Bloom-Filter-Testing" class="headerlink" title="Bloom Filter Testing"></a>Bloom Filter Testing</h2><p>The implementation of Bloom filters in LevelDB also provides complete test code, which can be found in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/bloom_test.cc">bloom_test.cc</a>.</p>
<p>First, the BloomTest class is derived from the testing::Test class, used to organize and execute test cases related to Bloom filters. Its constructor and destructor are used to create and release instances of NewBloomFilterPolicy, ensuring that each test case can run in a clean environment. The Add method is used to add keys to the Bloom filter, and Build converts the collected keys into a filter. The Matches method is used to check whether a specific key matches the filter, while the FalsePositiveRate method is used to <strong>evaluate the false positive rate of the filter</strong>.</p>
<p>Then there’s a series of specific test cases defined by the TEST_F macro, allowing each test case to automatically possess the methods and properties defined in the BloomTest class. The first two test cases are relatively simple:</p>
<ul>
<li>EmptyFilter: Tests an empty filter, i.e., whether the filter can correctly determine that a key does not exist when no keys have been added.</li>
<li>Small: Tests the case of adding a small number of keys, checking whether the filter can correctly determine if keys exist.</li>
</ul>
<p>It’s worth noting the VaryingLengths test case, which is a more complex test case used to evaluate and verify <strong>the performance and efficiency of the Bloom filter under different data scales (i.e., different numbers of keys)</strong>. By using the defined NextLength function to incrementally increase the number of keys, it tests the performance of the Bloom filter under different key set sizes. It mainly tests the following three aspects:</p>
<ol>
<li>Ensures that the size of the constructed Bloom filter is within the expected range;</li>
<li>Ensures that all keys added to the filter can be correctly identified as existing;</li>
<li>Evaluates the false positive rate (false positive rate) of the Bloom filter at different lengths, ensuring that the false positive rate does not exceed 2%. At the same time, it categorizes filters as “good” or “mediocre” based on their false positive rates, and performs statistics and comparisons on their numbers, ensuring that the number of “mediocre” filters is not too high.</li>
</ol>
<p>The complete test code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">TEST_F</span>(BloomTest, VaryingLengths) {</span><br><span class="line">  <span class="type">char</span> buffer[<span class="built_in">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count number of filters that significantly exceed the false positive rate</span></span><br><span class="line">  <span class="type">int</span> mediocre_filters = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> good_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> length = <span class="number">1</span>; length &lt;= <span class="number">10000</span>; length = <span class="built_in">NextLength</span>(length)) {</span><br><span class="line">    <span class="built_in">Reset</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">      <span class="built_in">Add</span>(<span class="built_in">Key</span>(i, buffer));</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(<span class="built_in">FilterSize</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;((length * <span class="number">10</span> / <span class="number">8</span>) + <span class="number">40</span>))</span><br><span class="line">        &lt;&lt; length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All added keys must match</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">      <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">Matches</span>(<span class="built_in">Key</span>(i, buffer)))</span><br><span class="line">          &lt;&lt; <span class="string">"Length "</span> &lt;&lt; length &lt;&lt; <span class="string">"; key "</span> &lt;&lt; i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check false positive rate</span></span><br><span class="line">    <span class="type">double</span> rate = <span class="built_in">FalsePositiveRate</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) {</span><br><span class="line">      std::<span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                   <span class="string">"False positives: %5.2f%% @ length = %6d ; bytes = %6d\n"</span>,</span><br><span class="line">                   rate * <span class="number">100.0</span>, length, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">FilterSize</span>()));</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(rate, <span class="number">0.02</span>);  <span class="comment">// Must not be over 2%</span></span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0.0125</span>)</span><br><span class="line">      mediocre_filters++;  <span class="comment">// Allowed, but not too often</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      good_filters++;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) {</span><br><span class="line">    std::<span class="built_in">fprintf</span>(stderr, <span class="string">"Filters: %d good, %d mediocre\n"</span>, good_filters,</span><br><span class="line">                 mediocre_filters);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">ASSERT_LE</span>(mediocre_filters, good_filters / <span class="number">5</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here’s the result of executing the test:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_testcase.png/webp" alt="Bloom Filter Test Results" srcset="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_testcase.png/webp 1854w, https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_testcase.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_testcase.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_testcase.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1854" height="1864"></p>
<h2 id="Bloom-Filter-Visualization"><a href="#Bloom-Filter-Visualization" class="headerlink" title="Bloom Filter Visualization"></a>Bloom Filter Visualization</h2><p>Before concluding the article, let’s take a look at <a target="_blank" rel="noopener" href="https://gallery.selfboot.cn/en/algorithms/bloomfilter">a visualization demonstration of the Bloom filter</a>, which displays the principles and implementation discussed above in the form of charts, deepening our understanding.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_visualization.png/webp" alt="Bloom Filter Visualization Demo" srcset="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_visualization.png/webp 3106w, https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_visualization.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_visualization.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_visualization.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3106" height="1498"></p>
<p>In this demonstration site, you can choose different numbers of hash functions and predicted key counts. It will then automatically adjust the bit array. After that, you can add elements and check if elements are in the Bloom filter. If an element is present, the corresponding array bits will be displayed with black boxes. If it’s not present, the corresponding array bits will be displayed with red boxes. This allows for an intuitive understanding of how Bloom filters work.</p>
<p>Also, for ease of demonstration, clicking on a bit group will show which keys would hash to this location. In reality, Bloom filters don’t store this information; it’s stored additionally here just for demonstration purposes.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Bloom filters are an efficient data structure used to determine whether an element exists in a set. Its core is a bit array and multiple hash functions, using multiple hash calculations to set bits in the bit array. Through rigorous mathematical derivation, we can conclude that the false positive rate of Bloom filters is related to the number of hash functions, the size of the bit array, and the number of added elements. In practical applications, the false positive rate can be optimized by adjusting the number of hash functions.</p>
<p>LevelDB implemented a Bloom filter as the default filter policy, which can be created through a factory function, maintaining extensibility. To save hash resource consumption, LevelDB generates multiple pseudo-independent hash values through the double hashing method, then sets the corresponding bits. When querying, it also uses multiple hash calculations to determine whether a key exists in the set. LevelDB provides complete test cases to verify the correctness and false positive rate of the Bloom filter.</p>
<p>Additionally, to intuitively understand how Bloom filters work, I’ve created a visualization demonstration of Bloom filters here, showing the principles of Bloom filters through charts.</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2024/08/08/leveldb_source_bloom_filter/';
    this.page.identifier = 'en/2024/08/08/leveldb_source_bloom_filter/';
    this.page.title = 'LevelDB Explained - Bloom Filter Implementation and Visualization';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (18)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (13)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (13)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2024/08/08/leveldb_source_bloom_filter/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li><li><a href="/en/2024/09/09/leveldb_source_skiplist/" title="LevelDB Explained - How to implement SkipList">LevelDB Explained - How to implement SkipList</a></li><li><a href="/en/2024/09/05/claude35_prompt/" title="Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...">Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...</a></li><li><a href="/en/2024/08/29/leveldb_source_utils/" title="LevelDB Explained - Arena, Random, CRC32, and More.">LevelDB Explained - Arena, Random, CRC32, and More.</a></li><li><a href="/en/2024/08/14/leveldb_source_wal_log/" title="LevelDB Explained - How To Read and Write WAL Logs">LevelDB Explained - How To Read and Write WAL Logs</a></li><li><a href="/en/2024/08/13/leveldb_source_unstand_c++/" title="LevelDB Explained -  Understanding Advanced C++ Techniques">LevelDB Explained -  Understanding Advanced C++ Techniques</a></li><li><a href="/en/2024/08/08/leveldb_source_bloom_filter/" title="LevelDB Explained - Bloom Filter Implementation and Visualization">LevelDB Explained - Bloom Filter Implementation and Visualization</a></li><li><a href="/en/2024/08/06/leveldb_source_prepare/" title="LevelDB Explained - Preparing the Development Environment">LevelDB Explained - Preparing the Development Environment</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#LevelDB-Interface-Definition"><span class="toc-number">1.</span> <span class="toc-text">LevelDB Interface Definition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bloom-Filter-Principles"><span class="toc-number">2.</span> <span class="toc-text">Bloom Filter Principles</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mathematical-Derivation"><span class="toc-number">2.1.</span> <span class="toc-text">Mathematical Derivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parameter-Selection"><span class="toc-number">2.2.</span> <span class="toc-text">Parameter Selection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LevelDB-Implementation"><span class="toc-number">3.</span> <span class="toc-text">LevelDB Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-Function-Count-Selection"><span class="toc-number">3.1.</span> <span class="toc-text">Hash Function Count Selection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-the-Filter"><span class="toc-number">3.2.</span> <span class="toc-text">Creating the Filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Querying-Key-Existence"><span class="toc-number">3.3.</span> <span class="toc-text">Querying Key Existence</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bloom-Filter-Testing"><span class="toc-number">4.</span> <span class="toc-text">Bloom Filter Testing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bloom-Filter-Visualization"><span class="toc-number">5.</span> <span class="toc-text">Bloom Filter Visualization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">6.</span> <span class="toc-text">Summary</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>