<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Using LevelDB's hash table implementation as an example, this article analyzes how to design a high-performance hash table. Through double pointers, it implements linked list insertion, deletion, and lookup operations, optimizes list insertion using head insertion method, and analyzes the implementation of list expansion. Finally, it provides a detailed introduction to double pointers in C++ through an example."><title>LevelDB Explained - How to Design a High-Performance HashTable</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB Explained - How to Design a High-Performance HashTable</h1><div class="post-meta">2024/12/25<span> | </span><span class="category"><a href="/categories/Source-Code-Analysis/">Source Code Analysis</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2024/12/25/leveldb_source_hashtable/" href="/en/2024/12/25/leveldb_source_hashtable/#disqus_thread"></a><div class="post-content"><p>Hash tables are a classic data structure that anyone who has written code should be familiar with. Every programming language has its own hash table implementation that’s ready to use out of the box. As a result, while many people have used hash tables, probably not many have implemented one themselves.</p>
<p>Designing a high-performance hash table actually requires considering quite a few details, such as how to handle hash collisions and how to handle hash table expansion. Some mature hash table implementations, like the one in the C++ standard library, have a large <a target="_blank" rel="noopener" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/tr1/hashtable.h">codebase</a> and can be difficult to understand.</p>
<p>Fortunately, when implementing LRU Cache, LevelDB also implemented a <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/cache.cc#L70">simple and efficient hash table</a>. The overall code is very concise - small but complete, making it very worth studying. Using LevelDB’s hash table implementation as an example, this article analyzes how to design a high-performance hash table.</p>
<span id="more"></span>

<h2 id="Why-LevelDB-Implements-Its-Own-Hash-Table"><a href="#Why-LevelDB-Implements-Its-Own-Hash-Table" class="headerlink" title="Why LevelDB Implements Its Own Hash Table"></a>Why LevelDB Implements Its Own Hash Table</h2><p>The C++ standard library already has a hash table implementation, so why did LevelDB implement its own? Here’s what the official documentation says:</p>
<blockquote>
<p>We provide our own simple hash table since it removes a whole bunch<br>of porting hacks and is also faster than some of the built-in hash<br>table implementations in some of the compiler/runtime combinations<br>we have tested.  E.g., readrandom speeds up by ~5% over the g++<br>4.4.3’s builtin hashtable.</p>
</blockquote>
<p>To summarize, other implementations can be cumbersome, while implementing their own version eliminates third-party dependencies and ensures both code simplicity and performance.</p>
<h2 id="LevelDB-Hash-Table-Implementation-Principles"><a href="#LevelDB-Hash-Table-Implementation-Principles" class="headerlink" title="LevelDB Hash Table Implementation Principles"></a>LevelDB Hash Table Implementation Principles</h2><p>The hash table implementation here is similar to the one in the C++ standard library, using an array to store hash buckets. <strong>The average time complexity for insertion, lookup, and deletion operations is O(1) - first locate the specific hash bucket based on the key’s hash value, then perform the corresponding operation on the collision chain</strong>. Additionally, if the hash table’s load factor becomes too high during insertion, expansion occurs.</p>
<p>One thing to note is that since LevelDB’s hash table is used to implement LRU Cache, the element type here is <code>LRUHandle</code>. Besides having key and value fields, it also has a next_hash pointer that uses chaining to handle hash collisions. Additionally, it stores the hash value, which is typically generated by the caller and saved. This allows the hash value to be used directly in subsequent lookup, insertion, and deletion operations to locate the specific hash bucket. The other fields of LRUHandle are mainly used in LRU Cache and won’t be discussed here.</p>
<h3 id="FindPointer-Implementation"><a href="#FindPointer-Implementation" class="headerlink" title="FindPointer Implementation"></a>FindPointer Implementation</h3><p>Let’s first look at the operation to find a specified key. LevelDB encapsulates a basic <code>FindPointer()</code> method that returns a double pointer to the key. Here’s the <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/cache.cc#L115">specific implementation</a>:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a pointer to slot that points to a cache entry that</span></span><br><span class="line"><span class="comment">// matches key/hash.  If there is no such cache entry, return a</span></span><br><span class="line"><span class="comment">// pointer to the trailing slot in the corresponding linked list.</span></span><br><span class="line"><span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash)</span> </span>{</span><br><span class="line">  LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">  <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;<span class="built_in">key</span>())) {</span><br><span class="line">    ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, it first locates the specific hash bucket based on the key’s hash value. If the bucket is empty, it directly returns the address pointing to the bucket’s nullptr head pointer. If the bucket is not empty, <strong>it uses the classic chaining method to handle hash collisions</strong>. It traverses the collision chain on the hash bucket, and if it finds the corresponding key, it returns a double pointer pointing to that node. If it traverses the entire list without finding it, it returns the address of the tail pointer.</p>
<p>The clever part here is that <strong>it returns a double pointer, allowing the method to be reused in lookup, insertion, and deletion operations</strong>. During lookup, directly dereferencing the returned pointer yields the target node. During insertion, this pointer can both check for existing nodes with the same key and directly insert new nodes at the correct position. During deletion, nodes can be removed directly by modifying the value this pointer points to, without needing to record the predecessor node.</p>
<h3 id="Remove-Operation"><a href="#Remove-Operation" class="headerlink" title="Remove Operation"></a>Remove Operation</h3><p>The Remove operation for deleting a key is <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/cache.cc#L95">implemented</a> as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash)</span> </span>{</span><br><span class="line">  LRUHandle** ptr = <span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">  LRUHandle* result = *ptr;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) {</span><br><span class="line">    *ptr = result-&gt;next_hash;</span><br><span class="line">    --elems_;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Simple, right? To delete a specified node in a linked list, it first uses FindPointer to find the address of the pointer pointing to the list node, then <strong>assigns the address of the next node (result-&gt;next_hash) to the original pointer position</strong>, completing the deletion operation. This method returns the pointer to the deleted node, allowing the caller to handle subsequent processing (such as memory deallocation). This implementation approach <strong>doesn’t need to record the predecessor node, is simple and efficient, and can correctly handle the deletion of head nodes</strong>.</p>
<p>This deletion method can elegantly handle all of the following cases:</p>
<table>
<thead>
<tr>
<th>Case</th>
<th>Description</th>
<th>Initial State</th>
<th>State After Deletion</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Delete first node A</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; [C] –&gt; nullptr</td>
<td>list_[i] –&gt; [B] –&gt; [C] –&gt; nullptr</td>
</tr>
<tr>
<td>2</td>
<td>Delete middle node B</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; [C] –&gt; nullptr</td>
<td>list_[i] –&gt; [A] –&gt; [C] –&gt; nullptr</td>
</tr>
<tr>
<td>3</td>
<td>Delete last node C</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; [C] –&gt; nullptr</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td>
</tr>
<tr>
<td>4</td>
<td>Delete only node A</td>
<td>list_[i] –&gt; [A] –&gt; nullptr</td>
<td>list_[i] –&gt; nullptr</td>
</tr>
<tr>
<td>5</td>
<td>Key to delete doesn’t exist</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td>
</tr>
<tr>
<td>6</td>
<td>Hash bucket is empty</td>
<td>list_[i] –&gt; nullptr</td>
<td>list_[i] –&gt; nullptr</td>
</tr>
</tbody></table>
<h3 id="Insert-Operation"><a href="#Insert-Operation" class="headerlink" title="Insert Operation"></a>Insert Operation</h3><p>The <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/cache.cc#L79">Insert method</a> for inserting nodes is similar to deletion, first finding the insertion position and then performing the insertion:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>{</span><br><span class="line">  LRUHandle** ptr = <span class="built_in">FindPointer</span>(h-&gt;<span class="built_in">key</span>(), h-&gt;hash);</span><br><span class="line">  LRUHandle* old = *ptr;</span><br><span class="line">  h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">  *ptr = h;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Line 4 here uses double pointers to handle all of the following cases at once (we’ll discuss double pointers in detail later):</p>
<table>
<thead>
<tr>
<th>Case</th>
<th>Description</th>
<th>Initial State</th>
<th>State After Insertion</th>
<th>Return Value</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Insert into empty bucket</td>
<td>list_[i] –&gt; nullptr</td>
<td>list_[i] –&gt; [H] –&gt; nullptr</td>
<td>nullptr</td>
</tr>
<tr>
<td>2</td>
<td>Key exists (first node)</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td>
<td>list_[i] –&gt; [H] –&gt; [B] –&gt; nullptr</td>
<td>A</td>
</tr>
<tr>
<td>3</td>
<td>Key exists (middle node)</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; [C] –&gt; nullptr</td>
<td>list_[i] –&gt; [A] –&gt; [H] –&gt; [C] –&gt; nullptr</td>
<td>B</td>
</tr>
<tr>
<td>4</td>
<td>Key exists (last node)</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td>
<td>list_[i] –&gt; [A] –&gt; [H] –&gt; nullptr</td>
<td>B</td>
</tr>
<tr>
<td>5</td>
<td>Insert new key (non-empty bucket)</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td>
<td>list_[i] –&gt; [A] –&gt; [B] –&gt; [H] –&gt; nullptr</td>
<td>nullptr</td>
</tr>
</tbody></table>
<p>After insertion, it checks old to determine if this is a new node. If it is, it updates the hash table’s element count and checks if dynamic expansion is needed, which we’ll look at next.</p>
<h2 id="Dynamic-Expansion-with-High-Load-Factor"><a href="#Dynamic-Expansion-with-High-Load-Factor" class="headerlink" title="Dynamic Expansion with High Load Factor"></a>Dynamic Expansion with High Load Factor</h2><p>For a hash table with a fixed number of buckets, <strong>as more elements are inserted, the probability of hash collisions increases</strong>. In extreme cases, each key might have a long collision chain, causing hash table lookup and deletion performance to degrade. To <strong>measure the severity of hash collisions</strong>, we can define the <strong>load factor = number of hash table elements / number of hash buckets</strong>. Once this value exceeds a threshold, expansion is needed.</p>
<p>Earlier in the Insert method, when inserting elements, it tracks the current hash table element count. Once the load factor exceeds the threshold of 1, it calls <code>Resize()</code> to expand:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (old == <span class="literal">nullptr</span>) {</span><br><span class="line">    ++elems_;</span><br><span class="line">    <span class="keyword">if</span> (elems_ &gt; length_) {</span><br><span class="line">    <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">    <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">    <span class="built_in">Resize</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>The first problem to solve in expansion is deciding the new hash bucket count</strong>. Here’s LevelDB’s implementation:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (new_length &lt; elems_) {</span><br><span class="line">      new_length *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The standard library’s vector also chooses to expand by powers of 2. <strong>If the expansion factor is too large, it might waste too much space; if too small, it might cause frequent expansions</strong>. In practice, 2 is generally chosen as the expansion factor.</p>
<p>After deciding the new bucket size, it first creates the larger capacity hash buckets, then <strong>traverses all old hash buckets, and for each bucket, traverses the collision chain for each key, inserting each key into the new list</strong>. Here’s the core implementation:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">    <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="built_in">sizeof</span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) {</span><br><span class="line">      LRUHandle* h = list_[i];</span><br><span class="line">      <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) {</span><br><span class="line">        LRUHandle* next = h-&gt;next_hash;</span><br><span class="line">        <span class="comment">// Head insertion into new hash table</span></span><br><span class="line">        h = next;</span><br><span class="line">        count++;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">assert</span>(elems_ == count);</span><br><span class="line">    <span class="keyword">delete</span>[] list_;</span><br><span class="line">    list_ = new_list;</span><br><span class="line">    length_ = new_length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>During Resize, each time a key is successfully added to the new hash table, it updates the hash table’s element count. Later, it uses an assert statement to check if the element count is correct after expansion. After all keys are inserted into the new hash table, it can reclaim the old hash table’s memory, then replace list_ with the new hash table and update the hash table capacity.</p>
<p>We skipped the critical insertion logic earlier - <strong>in the while loop, it traverses each key in the old hash table’s collision chain, then uses head insertion to insert into the new hash table</strong>. Let’s look at the head insertion implementation in detail.</p>
<h2 id="Optimizing-List-Insertion-with-Head-Insertion"><a href="#Optimizing-List-Insertion-with-Head-Insertion" class="headerlink" title="Optimizing List Insertion with Head Insertion"></a>Optimizing List Insertion with Head Insertion</h2><p>Here’s the core code for head insertion that was omitted from Resize earlier:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) {</span><br><span class="line">      LRUHandle* h = list_[i];</span><br><span class="line">      <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        <span class="type">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line">        LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">        h-&gt;next_hash = *ptr;</span><br><span class="line">        *ptr = h;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>The core idea of head insertion is: <strong>insert new nodes at the head of the list</strong>. Suppose the original list is:</p>
<figure class="highlight brainfuck"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">list_</span><span class="title">[</span><span class="comment">i</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">A</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">B</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">C</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="comment">nullptr</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>The rehashing process will handle nodes A, B, C in sequence, inserting them into the new hash table</strong>. If nodes A and B are still in the same bucket in the new hash table, the list state after rehashing will be:</p>
<figure class="highlight brainfuck"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">new_list</span><span class="title">[</span><span class="comment">hash_a</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">B</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">A</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="comment">nullptr</span></span><br><span class="line"><span class="comment">new_list</span><span class="title">[</span><span class="comment">hash_c</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">C</span><span class="title">]</span> <span class="literal">--</span>&gt;<span class="comment">nullptr</span></span><br></pre></td></tr></tbody></table></figure>

<p>Here A and B are still in the same bucket in the new list, but their order is reversed. Compared to traditional insertion that traverses to the list tail, <strong>head insertion is simpler, only needing to insert at the head without traversing to the tail, so the operation time complexity is O(1)</strong>. Additionally, using head insertion doesn’t require maintaining a tail pointer, making it <strong>more space efficient</strong>. Furthermore, <strong>head insertion has cache locality benefits - recently inserted nodes are at the head of the list, improving lookup efficiency for certain access patterns</strong>.</p>
<h2 id="Understanding-Double-Pointers-in-C"><a href="#Understanding-Double-Pointers-in-C" class="headerlink" title="Understanding Double Pointers in C++"></a>Understanding Double Pointers in C++</h2><p>The linked list operation code is very concise, without various complex conditional checks, thanks to the good use of double pointers. So how should we understand double pointers in C++? <strong>In C++, objects have values and corresponding memory addresses, pointers store object memory addresses, and double pointers store pointer addresses</strong>.</p>
<p>Let’s look at a clearer example. Suppose a bucket has a collision chain <code>bucket-&gt;A-&gt;B-&gt;nullptr</code>, which can be represented by this C++ code:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle *node_a;    <span class="comment">// Address: 0x100, Data: {value: "A", next_hash: 0x200}</span></span><br><span class="line">LRUHandle *node_b;    <span class="comment">// Address: 0x200, Data: {value: "B", next_hash: nullptr}</span></span><br><span class="line">node_a-&gt;next_hash = node_b;</span><br><span class="line">LRUHandle* bucket = node_a;   <span class="comment">// Address: 0x300, Data: 0x100</span></span><br></pre></td></tr></tbody></table></figure>

<p>Of course, the specific memory address values here are just for understanding - the actual runtime memory addresses will be different. Now there’s a new node node_h with address 0x500. To insert this node into the above list using head insertion, the core code is just 3 lines:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">h-&gt;next_hash = *ptr;    </span><br><span class="line">*ptr = h;</span><br></pre></td></tr></tbody></table></figure>

<p>Let’s look at the changes from each line. After the first line executes, the overall memory layout is:</p>
<table>
<thead>
<tr>
<th>Variable Name</th>
<th>Memory Address</th>
<th>Stored Value</th>
</tr>
</thead>
<tbody><tr>
<td>ptr</td>
<td>0x400</td>
<td>0x300</td>
</tr>
<tr>
<td>bucket</td>
<td>0x300</td>
<td>0x100</td>
</tr>
<tr>
<td>node_a</td>
<td>0x100</td>
<td>{value: “A”, next_hash: 0x200}</td>
</tr>
<tr>
<td>node_b</td>
<td>0x200</td>
<td>{value: “B”, next_hash: nullptr}</td>
</tr>
</tbody></table>
<p>Then executing <code>h-&gt;next_hash = *ptr</code> points node_h’s next_hash to *ptr, where *ptr gets A’s address. The overall memory layout becomes:</p>
<table>
<thead>
<tr>
<th>Variable Name</th>
<th>Memory Address</th>
<th>Stored Value</th>
</tr>
</thead>
<tbody><tr>
<td>ptr</td>
<td>0x400</td>
<td>0x300</td>
</tr>
<tr>
<td>bucket</td>
<td>0x300</td>
<td>0x100 (*ptr)</td>
</tr>
<tr>
<td>node_h</td>
<td>0x500</td>
<td>{value: “H”, next_hash: <strong>0x100</strong>}</td>
</tr>
<tr>
<td>node_a</td>
<td><strong>0x100</strong></td>
<td>{value: “A”, next_hash: <strong>0x200</strong>}</td>
</tr>
<tr>
<td>node_b</td>
<td><strong>0x200</strong></td>
<td>{value: “B”, next_hash: nullptr}</td>
</tr>
</tbody></table>
<p>At this point we’ve built the <strong>H-&gt;A-&gt;B-&gt;nullptr</strong> chain. But bucket still points to A, so we need to execute <code>*ptr = h</code> to make bucket point to node_h’s address. After this step, the overall memory layout becomes:</p>
<table>
<thead>
<tr>
<th>Variable Name</th>
<th>Memory Address</th>
<th>Stored Value</th>
</tr>
</thead>
<tbody><tr>
<td>ptr</td>
<td>0x400</td>
<td>0x300</td>
</tr>
<tr>
<td>bucket</td>
<td>0x300</td>
<td><strong>0x500</strong></td>
</tr>
<tr>
<td>node_h</td>
<td><strong>0x500</strong></td>
<td>{value: “H”, next_hash: <strong>0x100</strong>}</td>
</tr>
<tr>
<td>node_a</td>
<td><strong>0x100</strong></td>
<td>{value: “A”, next_hash: <strong>0x200</strong>}</td>
</tr>
<tr>
<td>node_b</td>
<td><strong>0x200</strong></td>
<td>{value: “B”, next_hash: nullptr}</td>
</tr>
</tbody></table>
<p>With this, we’ve completed building <code>p-&gt;bucket-&gt;H-&gt;A-&gt;B-&gt;nullptr</code>.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>We’ve analyzed LevelDB’s hash table implementation in detail. Here are the key points for designing a high-performance hash table:</p>
<ol>
<li><p><strong>Clever Use of Double Pointers</strong> - By returning a pointer to the node pointer, the FindPointer method can be reused in lookup, insertion, and deletion operations, greatly simplifying linked list operation code.</p>
</li>
<li><p><strong>Efficient Collision Handling</strong> - Uses chaining to handle hash collisions and optimizes list insertion with head insertion, avoiding the overhead of traversing to the list tail.</p>
</li>
<li><p><strong>Dynamic Expansion Mechanism</strong> - Monitors the load factor and expands by a factor of 2 at appropriate times, balancing space utilization and performance.</p>
</li>
<li><p><strong>Concise and Elegant Implementation</strong> - The entire implementation has minimal code but includes all core hash table functionality, making it an excellent learning example.</p>
</li>
</ol>
<p>While this implementation is primarily used for LevelDB’s LRU Cache, many of its design principles are valuable references for implementing other high-performance data structures. In particular, the use of double pointers demonstrates the power of pointers in C++.</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2024/12/25/leveldb_source_hashtable/';
    this.page.identifier = 'en/2024/12/25/leveldb_source_hashtable/';
    this.page.title = 'LevelDB Explained - How to Design a High-Performance HashTable';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (17)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (13)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2024/12/25/leveldb_source_hashtable/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/01/24/leveldb_source_writedb/" title="LevelDB Explained - Implementation and Optimization Details of Key-Value Writing">LevelDB Explained - Implementation and Optimization Details of Key-Value Writing</a></li><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li><li><a href="/en/2024/09/09/leveldb_source_skiplist/" title="LevelDB Explained - How to implement SkipList">LevelDB Explained - How to implement SkipList</a></li><li><a href="/en/2024/09/05/claude35_prompt/" title="Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...">Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-LevelDB-Implements-Its-Own-Hash-Table"><span class="toc-number">1.</span> <span class="toc-text">Why LevelDB Implements Its Own Hash Table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LevelDB-Hash-Table-Implementation-Principles"><span class="toc-number">2.</span> <span class="toc-text">LevelDB Hash Table Implementation Principles</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FindPointer-Implementation"><span class="toc-number">2.1.</span> <span class="toc-text">FindPointer Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remove-Operation"><span class="toc-number">2.2.</span> <span class="toc-text">Remove Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-Operation"><span class="toc-number">2.3.</span> <span class="toc-text">Insert Operation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Expansion-with-High-Load-Factor"><span class="toc-number">3.</span> <span class="toc-text">Dynamic Expansion with High Load Factor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Optimizing-List-Insertion-with-Head-Insertion"><span class="toc-number">4.</span> <span class="toc-text">Optimizing List Insertion with Head Insertion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Understanding-Double-Pointers-in-C"><span class="toc-number">5.</span> <span class="toc-text">Understanding Double Pointers in C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">6.</span> <span class="toc-text">Summary</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>