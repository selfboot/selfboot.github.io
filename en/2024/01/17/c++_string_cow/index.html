<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article reproduces the issue of string copies being modified and affecting the original string through example code, analyzing the root cause. It then comprehensively explains the principles of Copy-On-Write and its drawbacks, such as potential memory errors and unsuitability for multi-threading. Finally, it introduces how the C++11 standard modifies constraints and the SSO optimization in higher versions of string implementations."><title>Unexpected C++ String Modification Caused by COW (Copy-On-Write)</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Unexpected C++ String Modification Caused by COW (Copy-On-Write)</h1><div class="post-meta">2024/01/17<span> | </span><span class="category"><a href="/categories/Programming/">Programming</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2024/01/17/c++_string_cow/" href="/en/2024/01/17/c++_string_cow/#disqus_thread"></a><div class="post-content"><p>Recently, a colleague encountered a strange problem where in C++, after copying a string and modifying the copy’s content, the original value was also changed. For those not very familiar with C++, this seems a bit “spooky”. In this article, we’ll discuss this issue in depth, starting from a simple reproduction of the problem, to the underlying principles, and the changes in the C++ standard.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240115_c++_string_cow_cover.png/webp" alt="C++ string modification of copy affects original content" srcset="https://slefboot-1251736664.file.myqcloud.com/20240115_c++_string_cow_cover.png/webp 1938w, https://slefboot-1251736664.file.myqcloud.com/20240115_c++_string_cow_cover.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240115_c++_string_cow_cover.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240115_c++_string_cow_cover.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1938" height="1212"></p>
<span id="more"></span>

<h2 id="Problem-Reproduction"><a href="#Problem-Reproduction" class="headerlink" title="Problem Reproduction"></a>Problem Reproduction</h2><p>Here’s a code snippet that can consistently reproduce the issue. We define a string ‘original’, make a copy of it, and then call a function to modify the content of the copy string. The function in the business code is more complex, but for reproduction, we use a simple function that only modifies the first character of the copy. We print the contents and memory addresses of both strings before and after modifying the copy. Before looking further, you can try to guess the output of the following code.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModifyStringInplace</span><span class="params">(string &amp;str)</span> </span>{</span><br><span class="line">    <span class="type">size_t</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">char</span> *s = <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(str.<span class="built_in">c_str</span>());</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">'X'</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    string original = <span class="string">"Hello, World!"</span>;</span><br><span class="line">    string copy = original;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display memory addresses of both strings</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Original: "</span> &lt;&lt; original &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(original.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Copy    : "</span> &lt;&lt;  copy &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(copy.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modify the copy</span></span><br><span class="line">    <span class="built_in">ModifyStringInplace</span>(copy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display memory addresses of both strings again</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"After Modification:"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Original: "</span> &lt;&lt; original &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(original.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Copy    : "</span> &lt;&lt;  copy &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(copy.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>In the business production environment, compiling the above code with G++ 4.9.3 and running it produces the following result:</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Original: Hello, World!, address: 0x186c028</span><br><span class="line">Copy    : Hello, World!, address: 0x186c028</span><br><span class="line">After Modification:</span><br><span class="line">Original: Xello, World!, address: 0x186c028</span><br><span class="line">Copy    : Xello, World!, address: 0x186c028</span><br></pre></td></tr></tbody></table></figure>

<p>We can see that after modifying the copy, <strong>the content of the original string also changed</strong>. Another strange thing is that the <strong>memory addresses of the original string and the copy are always the same</strong>. What’s going on here? To answer this question, we need to first understand the implementation mechanism of C++ strings.</p>
<h2 id="String-Copy-On-Write"><a href="#String-Copy-On-Write" class="headerlink" title="String Copy-On-Write"></a>String Copy-On-Write</h2><p>In lower versions of GCC/G++ (below version 5), the implementation of the string class adopts a <strong>Copy-On-Write (COW)</strong> mechanism. When a string object is copied, it <strong>doesn’t immediately copy the entire string data, but instead shares the same data with the original string</strong>. Only when a part of the string is modified (i.e., “written”) is a real copy of the data created. The advantage of COW is that it can significantly reduce unnecessary data copying, especially in scenarios where string objects are <strong>frequently copied but rarely modified</strong>.</p>
<p>The general implementation of COW:</p>
<ul>
<li><strong>Reference Counting</strong>: A string object typically contains a pointer to the string data and a reference count. This reference count indicates how many string objects share the same data.</li>
<li><strong>Sharing on Copy</strong>: When a string object is copied, it simply copies the pointer to the data and the reference count, not the data itself. The copied string object shares the same data with the original object, and the reference count increases.</li>
<li><strong>Copying on Write</strong>: If any string object tries to modify the shared data, it first checks the reference count. If the reference count is greater than 1, it means the data is shared by multiple objects. In this case, the modification operation first creates a new copy of the data (i.e., “copy”), and then modifies this new copy. The reference count is then updated to reflect the change in sharing status.</li>
</ul>
<p>COW implementation requires careful management of memory allocation and deallocation, as well as increasing and decreasing reference counts, to ensure data correctness and avoid memory leaks. Now, returning to the reproduction code above, we changed the copied string, but from the output results, it appears that <strong>the write copy in COW was not triggered, as the addresses are still the same before and after</strong>. Why is this? Let’s look at the implementation of ModifyStringInplace. The c_str() method of string returns a pointer to a <strong>constant character array</strong>, which by design is read-only and <strong>should not be used to modify the content of the string</strong>.</p>
<p>However, in the above implementation, <code>const_cast</code> was used to remove the const (constant) attribute of the object, and then the data in memory was modified. <strong>Direct modification of underlying data through a pointer</strong> will not be recognized by the string’s internal mechanism (including COW) because it bypasses the state check of the string’s externally exposed interface. If we slightly modify the above code to use <code>[]</code> to modify the content of the string, <code>str[0] = 'X'</code>, it would trigger the write copy of COW, thus preventing the content of the original string from being modified. The output would be as follows:</p>
<figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">Original:</span> Hello, World<span class="operator">!</span>, <span class="params">address:</span> <span class="number">0</span>x607028</span><br><span class="line"><span class="params">Copy    :</span> Hello, World<span class="operator">!</span>, <span class="params">address:</span> <span class="number">0</span>x607028</span><br><span class="line">After <span class="params">Modification:</span></span><br><span class="line"><span class="params">Original:</span> Hello, World<span class="operator">!</span>, <span class="params">address:</span> <span class="number">0</span>x607028</span><br><span class="line"><span class="params">Copy    :</span> Xello, World<span class="operator">!</span>, <span class="params">address:</span> <span class="number">0</span>x607058</span><br></pre></td></tr></tbody></table></figure>

<p>In fact, even just reading a character from the string using <code>[]</code> will trigger copy-on-write. For example, in the following code:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    string original = <span class="string">"Hello, World!"</span>;</span><br><span class="line">    string copy = original;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display memory addresses of both strings</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Original: "</span> &lt;&lt; original &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(original.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Copy    : "</span> &lt;&lt;  copy &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(copy.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    copy[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// Display memory addresses of both strings again</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"After :"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Original: "</span> &lt;&lt; original &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(original.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Copy    : "</span> &lt;&lt;  copy &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(copy.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>When compiled and run on a lower version of G++, we can see that after reading a character from the string using operator[], the address of the copy’s content also changes (from <code>0x21f2028</code> to <code>0x21f2058</code>), as shown below:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Original: Hello, World!, address: 0x21f2028</span><br><span class="line">Copy    : Hello, World!, address: 0x21f2028</span><br><span class="line">After Modification:</span><br><span class="line">Original: Hello, World!, address: 0x21f2028</span><br><span class="line">Copy    : Hello, World!, address: 0x21f2058</span><br></pre></td></tr></tbody></table></figure>

<p>This is because operator[] returns a reference to the character, through which <strong>the content of the string can be modified</strong>. This interface has the semantics of “modifying” the string, so it triggers copy-on-write. Although the code above didn’t actually modify anything, the COW mechanism itself finds it difficult to perceive that no modification occurred here. Using iterators <code>begin()/end()</code> would have the same issue.</p>
<h2 id="Drawbacks-of-Copy-On-Write"><a href="#Drawbacks-of-Copy-On-Write" class="headerlink" title="Drawbacks of Copy-On-Write"></a>Drawbacks of Copy-On-Write</h2><p>The advantage of implementing string with COW is that it can reduce unnecessary data copying, but it also has some drawbacks. Let’s look at a simple example, referring to an answer under <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12199710/legality-of-cow-stdstring-implementation-in-c11">Legality of COW std::string implementation in C++11</a>.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">"str"</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = s.<span class="built_in">data</span>();</span><br><span class="line">    {</span><br><span class="line">        std::string copy = s;</span><br><span class="line">        std::cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; std::endl; <span class="comment">// cow: now s new allocation</span></span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; <span class="string">'\n'</span>;  <span class="comment">// p is dangling</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Under the COW mechanism, when copy is created as a copy of s, s and copy actually share the same underlying data. At this point, p points to the address of this shared data. Then, operator[] causes s to trigger a memory reallocation, and now only copy has a reference to the memory portion corresponding to p. When copy’s lifecycle ends and it is destroyed, p becomes a <strong>dangling pointer</strong>. Accessing the memory pointed to by a dangling pointer afterwards is <a href="https://selfboot.cn/en/2016/09/18/c++_undefined_behaviours/">undefined behavior</a>, which may cause the program to crash or produce unpredictable output. If the COW mechanism were not used, this problem wouldn’t occur.</p>
<p>However, even in C++11 and later standards where std::string in the standard library no longer uses the COW mechanism, <strong>retaining pointers to internal string data is still an unsafe practice</strong>, because any operation that modifies the string <strong>may cause reallocation of the internal buffer, making previous pointers or references invalid</strong>.</p>
<h3 id="Multi-threading-Issues"><a href="#Multi-threading-Issues" class="headerlink" title="Multi-threading Issues"></a>Multi-threading Issues</h3><p>Besides bringing the potential bugs mentioned above, COW has another significant flaw: it’s <strong>not suitable for multi-threaded environments</strong>. You can read the article <a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2534.html">Concurrency Modifications to Basic String</a> for details. The problem brought by COW is:</p>
<blockquote>
<p>The current definition of basic_string allows only <strong>very limited concurrent access to strings</strong>. Such limited concurrency will inhibit performance in multi-threaded applications.</p>
</blockquote>
<p>Here’s a simple example. For the original string, several copies are made first, and then run in different threads. In a COW implementation, it must be ensured that operations on independent copy strings in each thread are thread-safe, which requires that <strong>the reference count of shared memory in the string must be an atomic operation</strong>. Atomic operations themselves have overhead, and in a multi-threaded environment, atomic operations on the same address by multiple CPUs have even greater overhead. If COW were not used in the implementation, this overhead <strong>could be avoided</strong>.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringOperations modifies the string here</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string thread1 = <span class="string">"Hello, World! This is a test string."</span>; <span class="comment">// Shared string</span></span><br><span class="line">    <span class="function">std::string <span class="title">thread2</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">thread3</span><span class="params">(thread1)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(StringOperations, std::<span class="built_in">ref</span>(thread1));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(StringOperations, std::<span class="built_in">ref</span>(thread2));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(StringOperations, std::<span class="built_in">ref</span>(thread3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) {</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Of course, if different threads share the same string object, then regardless of whether copy-on-write is used or not, thread synchronization is necessary here to ensure thread safety. We won’t discuss this further here.</p>
<h2 id="C-11-Standard-Improvements"><a href="#C-11-Standard-Improvements" class="headerlink" title="C++11 Standard Improvements"></a>C++11 Standard Improvements</h2><p>Given the drawbacks of copy-on-write mentioned above, the GCC compiler, starting from version 5.1, no longer uses COW to implement string. You can refer to <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html">Dual ABI</a>:</p>
<blockquote>
<p>In the GCC 5.1 release libstdc++ introduced a new library ABI that includes new implementations of string and std::list. These changes were necessary to conform to the 2011 C++ standard which <strong>forbids Copy-On-Write strings</strong> and requires lists to keep track of their size.</p>
</blockquote>
<p>This is mainly because the C++11 standard made changes. In <a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf">21.4.1 basic_string general requirements</a>, there is such a description:</p>
<blockquote>
<p>References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated by the following uses of that basic_string object:</p>
<ul>
<li>as an argument to any standard library function taking a reference to non-const basic_string as an argument.</li>
<li>Calling non-const member functions, except operator[], at, front, back, begin, rbegin, end, and rend.</li>
</ul>
</blockquote>
<p>If the string is implemented with COW, as in the previous example, <strong>just calling non-const operator[] would also trigger copy-on-write, leading to invalidation of references to the original string</strong>.</p>
<h2 id="String-Optimization-in-Higher-Versions"><a href="#String-Optimization-in-Higher-Versions" class="headerlink" title="String Optimization in Higher Versions"></a>String Optimization in Higher Versions</h2><p>Higher versions of GCC, especially those following the C++11 standard and later versions, have made significant modifications to the implementation of std::string, mainly to improve performance and ensure thread safety. Higher versions of GCC abandoned COW and optimized for small strings (SSO). When a string is short enough to be stored directly in the internal buffer of the std::string object, it will use this internal buffer (on the stack) instead of allocating separate heap memory. This can reduce the overhead of memory allocation and improve performance when accessing small strings.</p>
<p>We can verify this with the following code:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    string a = <span class="string">"short"</span>;</span><br><span class="line">    string b = <span class="string">"this is a long string here, hahahhh"</span>;</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(a.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;b &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(b.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Compiling and running with a higher version, you can see output similar to the following:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7ffcb9ff22d0:0x7ffcb9ff22e0</span><br><span class="line">0x7ffcb9ff22b0:0x421eb0</span><br></pre></td></tr></tbody></table></figure>

<p>For shorter strings, the address is very close to the address of the variable itself, indicating it’s on the stack. For longer strings, the address is very different from the variable’s own address, indicating it’s allocated on the heap. For longer strings, higher versions of GCC have implemented more effective dynamic memory allocation and management strategies, including avoiding unnecessary memory reallocation and adopting incremental or doubling capacity strategies when growing strings, to reduce the number of memory allocations and improve memory utilization.</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2024/01/17/c++_string_cow/';
    this.page.identifier = 'en/2024/01/17/c++_string_cow/';
    this.page.title = 'Unexpected C++ String Modification Caused by COW (Copy-On-Write)';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (19)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (14)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2024/01/17/c++_string_cow/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/06/11/leveldb_source_memtable/" title="LevelDB Explained - The Implementation Details of MemTable">LevelDB Explained - The Implementation Details of MemTable</a></li><li><a href="/en/2025/06/10/leveldb_mvcc_intro/" title="LevelDB Explained - Understanding Multi-Version Concurrency Control (MVCC)">LevelDB Explained - Understanding Multi-Version Concurrency Control (MVCC)</a></li><li><a href="/en/2025/05/23/mcp_user_report/" title="In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?">In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?</a></li><li><a href="/en/2025/01/24/leveldb_source_writedb/" title="LevelDB Explained - Implementation and Optimization Details of Key-Value Writing">LevelDB Explained - Implementation and Optimization Details of Key-Value Writing</a></li><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li><li><a href="/en/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB Explained - How to Analyze the Time Complexity of SkipLists?">LevelDB Explained - How to Analyze the Time Complexity of SkipLists?</a></li><li><a href="/en/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Problem-Reproduction"><span class="toc-number">1.</span> <span class="toc-text">Problem Reproduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Copy-On-Write"><span class="toc-number">2.</span> <span class="toc-text">String Copy-On-Write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Drawbacks-of-Copy-On-Write"><span class="toc-number">3.</span> <span class="toc-text">Drawbacks of Copy-On-Write</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Multi-threading-Issues"><span class="toc-number">3.1.</span> <span class="toc-text">Multi-threading Issues</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-Standard-Improvements"><span class="toc-number">4.</span> <span class="toc-text">C++11 Standard Improvements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Optimization-in-Higher-Versions"><span class="toc-number">5.</span> <span class="toc-text">String Optimization in Higher Versions</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>