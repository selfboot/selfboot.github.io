<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Skip lists are probabilistic data structures that can replace balanced trees, offering fast insertion, deletion, and search operations. LevelDB's skip list implementation is concise, stable in performance, and suitable for storing data in memory MemTables. This article starts by discussing the drawbacks of current binary search trees and balanced trees, introducing skip lists as a data structure. Then, based on the original paper, it explains the implementation principles of skip lists, followed by a detailed analysis of LevelDB's implementation code, including iterator implementation and extreme performance optimization for concurrent reading. Finally, it provides a visualization page that intuitively shows the skip list construction process."><title>LevelDB Explained - How to implement SkipList</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB Explained - How to implement SkipList</h1><div class="post-meta">2024/09/09<span> | </span><span class="category"><a href="/categories/Source-Code-Analysis/">Source Code Analysis</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="en/2024/09/09/leveldb_source_skiplist/" href="/en/2024/09/09/leveldb_source_skiplist/#disqus_thread"></a><div class="post-content"><p>In LevelDB, the data in the memory MemTable is stored in a SkipList to support fast insertion. Skip lists are probabilistic data structures proposed by William Pugh in his paper <a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf">Skip Lists: A Probabilistic Alternative to Balanced Trees</a>. They are somewhat similar to <strong>ordered linked lists</strong> but can have multiple levels, trading space for time, allowing for fast query, insertion, and deletion operations with an average time complexity of $ O(\log n) $. Compared to some balanced trees, <strong>the code implementation is relatively simple and performance is stable</strong>, making it widely applicable.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240321_leveldb_source_skiplist.png/webp" alt="Inspirational approach to skip list implementation" srcset="https://slefboot-1251736664.file.myqcloud.com/20240321_leveldb_source_skiplist.png/webp 1396w, https://slefboot-1251736664.file.myqcloud.com/20240321_leveldb_source_skiplist.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240321_leveldb_source_skiplist.png/webp800 800w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1396" height="736"></p>
<p>So, what are the principles behind skip lists? How are they implemented in LevelDB? What are the highlights and optimizations in LevelDB’s skip list implementation? How does it support single-threaded writing and concurrent reading of skip lists? This article will delve into these aspects from the principles and implementation of skip lists. Finally, it provides <strong>a visualization page that intuitively shows the construction and overall structure of skip lists</strong>.</p>
<span id="more"></span>

<h2 id="Principles-of-Skip-Lists"><a href="#Principles-of-Skip-Lists" class="headerlink" title="Principles of Skip Lists"></a>Principles of Skip Lists</h2><p>Skip lists are primarily used to store ordered data structures. Before delving into the principles of skip lists, let’s first look at how people stored ordered data before skip lists.</p>
<h3 id="Storing-Ordered-Data"><a href="#Storing-Ordered-Data" class="headerlink" title="Storing Ordered Data"></a>Storing Ordered Data</h3><p>To store ordered abstract data types, the simplest method is to use ordered binary trees, such as binary search trees (BST). In a binary search tree, each node contains a key value that is comparable, allowing ordered operations. <strong>Any node’s left subtree contains only nodes with key values less than that node’s key value, while its right subtree contains only nodes with key values greater than that node’s key value</strong>.</p>
<p>Based on the structural definition of binary search trees, we can easily think of methods for insertion and search operations. For example, when searching, start from the root node of the tree and move down level by level. If the target key value is less than the current node’s key value, search the left subtree; if the target key value is greater than the current node’s key value, search the right subtree; if they are equal, the target node is found. Insertion is similar, finding the target and inserting at the appropriate position. The deletion operation is slightly more complex, requiring adjustment of the tree structure based on the current node’s subtree situation after finding the target node. We won’t expand on this here, but if you’re interested, you can learn more details in the binary search tree visualization blog.</p>
<p>The average time complexity of binary search trees is $ O(\log n) $, but if the elements in the binary search tree are <strong>inserted in order</strong>, the tree may degenerate into a linked list, causing the time complexity of operations to degrade from $ O(\log n) $ to $ O(n) $. For example, the following figure shows the structure of a binary search tree after inserting 10 elements in order:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240828_leveldb_source_skiplist_sequential.png/webp" alt="Binary search tree degenerating into a linked list" srcset="https://slefboot-1251736664.file.myqcloud.com/20240828_leveldb_source_skiplist_sequential.png/webp 2990w, https://slefboot-1251736664.file.myqcloud.com/20240828_leveldb_source_skiplist_sequential.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240828_leveldb_source_skiplist_sequential.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240828_leveldb_source_skiplist_sequential.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2990" height="1472"></p>
<p>By the way, you can better understand binary search trees <a target="_blank" rel="noopener" href="https://gallery.selfboot.cn/en/algorithms/binarysearchtree/">in this visualization page</a>. To solve the performance degradation problem, people have proposed many balanced trees, such as AVL trees and red-black trees. <strong>The implementation of these balanced trees is relatively complex, adding some complicated operations to maintain the balance of the tree.</strong></p>
<h3 id="The-Idea-of-Skip-Lists"><a href="#The-Idea-of-Skip-Lists" class="headerlink" title="The Idea of Skip Lists"></a>The Idea of Skip Lists</h3><p>The balanced trees mentioned above all <strong>force the tree structure to satisfy certain balance conditions</strong>, thus requiring complex structural adjustments. The author of skip lists, however, took a different approach, introducing <strong>probabilistic balance</strong> rather than mandatory structural balance. Through a <strong>simple randomization process</strong>, skip lists achieve average search time, insertion time, and deletion time similar to balanced trees with lower complexity.</p>
<p>William Pugh didn’t mention in his paper how he came up with the idea of skip lists, only mentioning in the Related Work section that Sprugnoli proposed a <strong>randomized balanced search tree</strong> in 1981. Perhaps it was this <strong>randomized idea</strong> that inspired Pugh, eventually leading him to propose skip lists. In fact, the randomized idea is quite important. For example, Google’s <a target="_blank" rel="noopener" href="https://gallery.selfboot.cn/en/algorithms/jumphash">Jumphash consistent hashing algorithm</a> also uses probability to calculate which hash bucket should be used, which has several advantages compared to the <a target="_blank" rel="noopener" href="https://gallery.selfboot.cn/en/algorithms/hashring">hashring</a> method.</p>
<p>Before getting into the principles of skip lists, let’s review <strong>searching in ordered linked lists</strong>. If we want to search an ordered linked list, we can only scan from the beginning, resulting in a complexity of $ O(n) $. However, this doesn’t take advantage of the <strong>ordered</strong> nature. If it were an ordered array, we could reduce the complexity to $ O(\log n) $ through binary search. The difference between ordered linked lists and ordered arrays is that we can’t quickly access middle elements through indices, only through <strong>pointer traversal</strong>.</p>
<p>So, is there a way to <strong>skip some nodes</strong> during the search, thereby reducing search time? A fairly intuitive method is to <strong>create more pointers, trading space for time</strong>. Referring back to the figure at the beginning of the article, $ a $ is the original ordered linked list, $ b $ adds some pointer indexes, allowing jumps of 2 nodes at a time, and $ c $ further adds pointer indexes, allowing jumps of 4 nodes at a time.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240828_leveldb_source_skiplist_multilevel.png/webp" alt="Trading space for time, adding node pointers to speed up search" srcset="https://slefboot-1251736664.file.myqcloud.com/20240828_leveldb_source_skiplist_multilevel.png/webp 2408w, https://slefboot-1251736664.file.myqcloud.com/20240828_leveldb_source_skiplist_multilevel.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240828_leveldb_source_skiplist_multilevel.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240828_leveldb_source_skiplist_multilevel.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2408" height="592"></p>
<p>If the number of nodes at each level of pointers in the constructed linked list is <strong>1/2 of the next level</strong>, then at the highest level, it only takes 1 jump to skip half of the nodes. In such a structure, searching is similar to an ordered array, where we can quickly locate the target node through <strong>binary search</strong>. Since the overall height of the linked list index is $ O(\log n) $, the time complexity of searching is also $ O(\log n) $.</p>
<p><strong>It looks perfect, as long as we don’t consider insertion and deletion operations</strong>. If we need to insert or delete a new node, we need to <strong>disrupt and reconstruct the entire index layer</strong>, which is disastrous.</p>
<p>To solve this problem, the author of skip lists, Pugh, introduced the idea of <strong>randomization</strong>, using <strong>random decisions on node height</strong> to avoid the complex index layer reconstruction brought by insertion and deletion operations. At the same time, he mathematically proved that the implementation of skip lists would guarantee an average time complexity of $ O(\log n) $.</p>
<p>The core idea of skip lists is actually similar to the multi-level index mentioned above, <strong>using multi-level indexes to accelerate searching</strong>. Each level is an ordered linked list, with the bottom level containing all elements. The nodes at each level are a subset of the nodes at the previous level, becoming sparser as we go up. The difference is that in skip lists, the height of levels is <strong>randomly decided</strong>, unlike the above where each level is 1/2 of the next level. Therefore, the cost of insertion and deletion operations is <strong>controllable</strong>, unlike the multi-level index which requires reconstructing the entire index layer.</p>
<p>Of course, there are still many details in the implementation of skip lists. Next, we’ll delve into this through the skip list implementation in LevelDB.</p>
<h2 id="Implementation-in-LevelDB"><a href="#Implementation-in-LevelDB" class="headerlink" title="Implementation in LevelDB"></a>Implementation in LevelDB</h2><p>The skip list implementation in LevelDB is in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/skiplist.h">db/skiplist.h</a>, mainly the SkipList class. Let’s first look at the design of this class.</p>
<h3 id="SkipList-Class"><a href="#SkipList-Class" class="headerlink" title="SkipList Class"></a>SkipList Class</h3><p>The SkipList class is defined as a <strong>template class</strong>. By using the template <code>template &lt;typename Key, class Comparator&gt;</code>, the SkipList class can be used for keys of any data type (Key), and the comparison logic for keys can be customized through an external comparator (Comparator). This SkipList only has a <code>.h</code> file, without a <code>.cc</code> file, because the implementation of template classes is usually in the header file.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkipList</span> {</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a new SkipList object that will use "cmp" for comparing keys,</span></span><br><span class="line">  <span class="comment">// and will allocate memory using "*arena".  Objects allocated in the arena</span></span><br><span class="line">  <span class="comment">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SkipList</span><span class="params">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SkipList</span>(<span class="type">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SkipList&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>The constructor of the SkipList class is used to create a new skip list object, where cmp is the comparator used to compare keys, and arena is the Arena object used to allocate memory. The SkipList class disables the copy constructor and assignment operator through delete, avoiding accidentally copying the entire skip list (<strong>which is unnecessary and costly</strong>).</p>
<p>The SkipList class exposes two core operation interfaces, Insert and Contains. Insert is used to insert new nodes, and Contains is used to check if a node exists. There is no operation provided here to delete nodes, because the data in MemTable in LevelDB is <strong>only appended</strong>, and data in the skip list will not be deleted. When deleting a key in the DB, it only adds a deletion type record in the MemTable.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert key into the list.</span></span><br><span class="line"><span class="comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Contains</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>To implement the skip list functionality, the SkipList class internally defines a Node class to represent nodes in the skip list. It is defined as an internal class because this can <strong>improve the encapsulation and maintainability of the skip list</strong>.</p>
<ul>
<li>Encapsulation: The Node class is a core part of the SkipList implementation, but users of SkipList usually don’t need to interact directly with node objects. Defining the Node class as a private internal class can hide implementation details;</li>
<li>Maintainability: If the implementation of the skip list needs to be modified or extended, related changes will be confined to the internal of the SkipList class, without affecting external code using these structures, which helps with code maintenance and debugging.</li>
</ul>
<p>The SkipList class also has some private members and methods to assist in implementing the Insert and Contains operations of the skip list. For example:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KeyIsAfterNode</span><span class="params">(<span class="type">const</span> Key&amp; key, Node* n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Node* <span class="title">FindGreaterOrEqual</span><span class="params">(<span class="type">const</span> Key&amp; key, Node** prev)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Node* <span class="title">FindLessThan</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">Node* <span class="title">FindLast</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>In addition, to facilitate the caller to traverse the skip list, a public Iterator class is provided. It encapsulates common iterator operations such as Next, Prev, Seek, SeekToFirst, SeekToLast, etc.</p>
<p>Next, we’ll first look at the design of the Node class, then analyze how SkipList implements insertion and search operations. Finally, we’ll look at the implementation of the Iterator class provided externally.</p>
<h3 id="Node-Class"><a href="#Node-Class" class="headerlink" title="Node Class"></a>Node Class</h3><p>The Node class represents a single node in the skip list, including the node’s key value and multiple levels of successor node pointers. With this class, the SkipList class can construct the entire skip list. First, let’s give the code and comments for the Node class, you can take a moment to digest it.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SkipList</span>&lt;Key, Comparator&gt;::Node {</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(<span class="type">const</span> Key&amp; k)</span> : key(k) {</span>}</span><br><span class="line"></span><br><span class="line">  Key <span class="type">const</span> key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Accessors/mutators for links.  Wrapped in methods so we can</span></span><br><span class="line">  <span class="comment">// add the appropriate barriers as necessary.</span></span><br><span class="line">  <span class="function">Node* <span class="title">Next</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use an 'acquire load' so that we observe a fully initialized</span></span><br><span class="line">    <span class="comment">// version of the returned Node.</span></span><br><span class="line">    <span class="keyword">return</span> next_[n].<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetNext</span><span class="params">(<span class="type">int</span> n, Node* x)</span> </span>{</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use a 'release store' so that anybody who reads through this</span></span><br><span class="line">    <span class="comment">// pointer observes a fully initialized version of the inserted node.</span></span><br><span class="line">    next_[n].<span class="built_in">store</span>(x, std::memory_order_release);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No-barrier variants that can be safely used in a few locations.</span></span><br><span class="line">  <span class="function">Node* <span class="title">NoBarrier_Next</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> next_[n].<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NoBarrier_SetNext</span><span class="params">(<span class="type">int</span> n, Node* x)</span> </span>{</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    next_[n].<span class="built_in">store</span>(x, std::memory_order_relaxed);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// Array of length equal to the node height.  next_[0] is lowest level link.</span></span><br><span class="line">  std::atomic&lt;Node*&gt; next_[<span class="number">1</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>First is the member variable key, whose type is the template Key, and the key is immutable (const). The other member variable next_ is at the end, using <code>std::atomic&lt;Node*&gt; next_[1]</code> to support <strong>dynamically expanding the size of the array</strong>. This is <a href="https://selfboot.cn/en/2024/08/13/leveldb_source_unstand_c++/#Flexible-Arrays">flexible array in C++</a>, the next_ array is used to store all the successor nodes of the current node, <code>next_[0]</code> stores the next node pointer at the bottom level, <code>next_[1]</code> stores the one level up, and so on.</p>
<p>When creating a new Node object, <strong>additional memory will be dynamically allocated to store more next pointers based on the height of the node</strong>. SkipList encapsulates a NewNode method, the code is given in advance here so that you can better understand the creation of flexible array objects here.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::<span class="built_in">NewNode</span>(</span><br><span class="line">    <span class="type">const</span> Key&amp; key, <span class="type">int</span> height) {</span><br><span class="line">  <span class="type">char</span>* <span class="type">const</span> node_memory = arena_-&gt;<span class="built_in">AllocateAligned</span>(</span><br><span class="line">      <span class="built_in">sizeof</span>(Node) + <span class="built_in">sizeof</span>(std::atomic&lt;Node*&gt;) * (height - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">new</span> (node_memory) <span class="built_in">Node</span>(key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The code here is less common, worth expanding on. First, calculate the memory size needed for Node, <strong>the size of Node itself plus the size of height minus 1 next pointers</strong>, then call Arena’s AllocateAligned method to allocate memory. Arena is LevelDB’s own memory allocation class, for detailed explanation, you can refer to <a href="https://selfboot.cn/en/2024/08/29/leveldb_source_utils/#Memory-Management-Arena">LevelDB Explained - Arena, Random, CRC32, and More.</a>. Finally, use <strong>placement new to construct Node object</strong>, this is mainly to construct Node object on the memory allocated by Arena, rather than constructing on the heap.</p>
<p>In addition, the Node class provides 4 methods, Next, SetNext, NoBarrier_Next and NoBarrier_SetNext, used to read and set the pointer to the next node. Here, the functionality is simply reading and setting the values of the next_ array, but it uses C++’s atomic types and some synchronization semantics, which will be discussed in the <a href="#Concurrent-Reading-Issues">Concurrent Reading</a> section later in this article.</p>
<p>That’s it for the Node class, next let’s look at how SkipList implements insertion and search operations.</p>
<h3 id="Search-Node"><a href="#Search-Node" class="headerlink" title="Search Node"></a>Search Node</h3><p>The most basic operation in a skip list is to find the node greater than or equal to a given key, which is the private method FindGreaterOrEqual in SkipList. The public Contains method, which checks if a certain key exists, is implemented through this. During node insertion, this method is also used to find the position to insert. Before looking at the specific implementation code in LevelDB, we can first understand the search process through a figure from the paper.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240829_leveldb_source_skiplist_searchpath.png/webp" alt="Skip list node search process" srcset="https://slefboot-1251736664.file.myqcloud.com/20240829_leveldb_source_skiplist_searchpath.png/webp 1260w, https://slefboot-1251736664.file.myqcloud.com/20240829_leveldb_source_skiplist_searchpath.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240829_leveldb_source_skiplist_searchpath.png/webp800 800w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1260" height="280"></p>
<p>The search process starts from the <strong>highest current level of the skip list and proceeds to the right and down</strong>. To simplify some boundary checks in the implementation, a dummy node is usually added as the head node, not storing any specific value. When searching, first initialize the current node as the head node head_, then <strong>start searching from the highest level to the right. If the key of the node to the right on the same level is less than the target key, continue searching to the right; if it’s greater than or equal to the target key, search down to the next level. Repeat this search process until finding the node greater than or equal to the target key at the bottom level</strong>.</p>
<p>Now let’s look at the specific implementation code of FindGreaterOrEqual. The code is concise and the logic is clear.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the earliest node that comes at or after key.</span></span><br><span class="line"><span class="comment">// Return nullptr if there is no such node.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If prev is non-null, fills prev[level] with pointer to previous</span></span><br><span class="line"><span class="comment">// node at "level" for every level in [0..max_height_-1].</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::<span class="built_in">FindGreaterOrEqual</span>(<span class="type">const</span> Key&amp; key,</span><br><span class="line">                                              Node** prev) <span class="type">const</span> {</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="type">int</span> level = <span class="built_in">GetMaxHeight</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    Node* next = x-&gt;<span class="built_in">Next</span>(level);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeyIsAfterNode</span>(key, next)) {</span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev[level] = x;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>It’s worth mentioning the prev pointer array here, which is <strong>used to record the predecessor nodes at each level</strong>. This array is to support insertion operations. When inserting a node, we need to know the predecessor nodes of the new node at each level, so that we can correctly insert the new node. The prev array here is passed in as a parameter. If the caller doesn’t need to record the search path, they can pass in nullptr.</p>
<p>With this method, it’s easy to implement the Contains and Insert methods. The Contains method only needs to call FindGreaterOrEqual and then check if the returned node equals the target key. Here, we don’t need predecessor nodes, so we can pass nullptr for prev.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="type">bool</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">Contains</span>(<span class="type">const</span> Key&amp; key) <span class="type">const</span> {</span><br><span class="line">  Node* x = <span class="built_in">FindGreaterOrEqual</span>(key, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">nullptr</span> &amp;&amp; <span class="built_in">Equal</span>(key, x-&gt;key)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Insert-Node"><a href="#Insert-Node" class="headerlink" title="Insert Node"></a>Insert Node</h3><p>Inserting a node is relatively more complex. Before looking at the code, let’s look at the figure given in the paper. The upper part is the logic of finding the position to insert, and the lower part is the skip list after inserting the node. Here we can see that a new node has been added, and the pointers pointing to the new node and the pointers from the new node to the subsequent nodes have been updated.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240829_leveldb_source_skiplist_insert.png/webp" alt="Skip list node insertion process" srcset="https://slefboot-1251736664.file.myqcloud.com/20240829_leveldb_source_skiplist_insert.png/webp 1402w, https://slefboot-1251736664.file.myqcloud.com/20240829_leveldb_source_skiplist_insert.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240829_leveldb_source_skiplist_insert.png/webp800 800w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1402" height="614"></p>
<p>So what is the height of the newly inserted node? How are the pointers of the preceding and following nodes updated after insertion at the corresponding position? Let’s look at the implementation code in LevelDB.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="type">void</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> Key&amp; key) {</span><br><span class="line">  Node* prev[kMaxHeight];           <span class="comment">// 1</span></span><br><span class="line">  Node* x = <span class="built_in">FindGreaterOrEqual</span>(key, prev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  <span class="built_in">assert</span>(x == <span class="literal">nullptr</span> || !<span class="built_in">Equal</span>(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> height = <span class="built_in">RandomHeight</span>();      <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> (height &gt; <span class="built_in">GetMaxHeight</span>()) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetMaxHeight</span>(); i &lt; height; i++) {</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    }</span><br><span class="line">    max_height_.<span class="built_in">store</span>(height, std::memory_order_relaxed);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  x = <span class="built_in">NewNode</span>(key, height);         <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; i++) {</span><br><span class="line">    x-&gt;<span class="built_in">NoBarrier_SetNext</span>(i, prev[i]-&gt;<span class="built_in">NoBarrier_Next</span>(i));</span><br><span class="line">    prev[i]-&gt;<span class="built_in">SetNext</span>(i, x);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>The code above omits some comments and is divided into 3 functional blocks. Here’s an explanation for each part:</p>
<ol>
<li>First, define an array prev of type <code>Node*</code> with a length of <code>kMaxHeight=12</code>, which is the maximum supported level height of the skip list. This array <strong>stores the predecessor nodes of the new node to be inserted at each level</strong>. When inserting a new node in the skip list, we can <strong>find the position to insert the new node at each level through this prev array</strong>.</li>
<li>Use a random algorithm to <strong>decide the level height of the new node</strong>. Here, LevelDB starts with an initial height of 1, then decides whether to increase a level with a <strong>1/4</strong> probability. If the height of the new node exceeds the current maximum height of the skip list, we need to update the maximum height and set the prev for the exceeding parts to the head node, because the new levels start from the head node.</li>
<li>Create a new node with a height of height and insert it into the linked list. The specific method is also simple: iterate through each level of the new node, <strong>use the NoBarrier_SetNext method to set the next node of the new node, then update the next node of the prev node to the new node, achieving the insertion of the new node</strong>. NoBarrier_SetNext indicates that in this context, no additional <strong>memory barriers are needed to ensure the visibility of memory operations</strong>. The insertion of the new node is not much different from the insertion operation of a general linked list. There’s <a target="_blank" rel="noopener" href="https://gallery.selfboot.cn/en/algorithms/linkedlist/">a good visualization here</a> that can deepen your understanding of linked list insertion.</li>
</ol>
<p>Now let’s look at some of the details. First, let’s look at the RandomHeight method, which is used to generate the height of new nodes. The core code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="type">int</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">RandomHeight</span>() {</span><br><span class="line">  <span class="comment">// Increase height with probability 1 in kBranching</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line">  <span class="type">int</span> height = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (height &lt; kMaxHeight &amp;&amp; rnd_.<span class="built_in">OneIn</span>(kBranching)) {</span><br><span class="line">    height++;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> height;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, rnd_ is a <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/random.h">Random</a> object, which is LevelDB’s own <strong>linear congruential random number generator class</strong>. For a detailed explanation, you can refer to <a href="https://selfboot.cn/en/2024/08/29/leveldb_source_utils/#Random-Number-Generator">LevelDB Explained - Arena, Random, CRC32, and More.</a>. In the RandomHeight method, each loop has a 1/4 probability of increasing a level, until the height reaches the maximum supported height <code>kMaxHeight=12</code> or doesn’t meet the 1/4 probability. The total height of 12 and the probability value of 1/4 are empirical values, which are also mentioned in the paper. We’ll discuss the choice of these two values in the performance analysis section later.</p>
<p>The insertion into the linked list actually needs to consider concurrent reading issues, but we won’t expand on that here. We’ll discuss it specifically later. Next, let’s look at the design of the Iterator class in SkipList.</p>
<h3 id="Iterator-Design"><a href="#Iterator-Design" class="headerlink" title="Iterator Design"></a>Iterator Design</h3><p>The Iterator class is mainly used for traversing nodes in the skip list. The design and usage of iterators here are quite interesting. LevelDB defines an abstract base class leveldb::Iterator in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/include/leveldb/iterator.h">include/leveldb/iterator.h</a>, which contains general iterator interfaces that can be used for different data structures.</p>
<p>On the other hand, SkipList&lt;Key, Comparator&gt;::Iterator is an internal class of SkipList, defined in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/skiplist.h#L61">db/skiplist.h</a>, which can only be used for the SkipList data structure. The Iterator of the skip list does not inherit from the leveldb::Iterator abstract base class, but is <strong>used in combination</strong> as a member of the MemTableIterator object. Specifically, it’s used in <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/memtable.cc#L46">db/memtable.cc</a>, where the MemTableIterator class is defined, inheriting from Iterator, and then rewriting its methods using the Iterator of the skip list.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemTableIterator</span> : <span class="keyword">public</span> Iterator {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>{ iter_.<span class="built_in">SeekToLast</span>(); }</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>{ iter_.<span class="built_in">Next</span>(); }</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>{ iter_.<span class="built_in">Prev</span>(); }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{ <span class="keyword">return</span> Status::<span class="built_in">OK</span>(); }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  MemTable::Table::Iterator iter_;</span><br><span class="line">  std::string tmp_;  <span class="comment">// For passing to EncodeKey</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>Here, MemTableIterator acts as an adapter, adapting the functionality of SkipList::Iterator to a form that conforms to LevelDB’s external Iterator interface, ensuring the consistency of interfaces between various parts of LevelDB. If there’s a need to replace the skip list implementation or iterator behavior in memtable in the future, MemTableIterator can be modified locally without affecting other code using the Iterator interface.</p>
<p>So how is the SkipList::Iterator class specifically defined? As follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Iterator</span> {</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">    <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="type">const</span> SkipList* list)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> SkipList* list_;</span><br><span class="line">    Node* node_;</span><br><span class="line">    <span class="comment">// Intentionally copyable</span></span><br><span class="line">  };</span><br></pre></td></tr></tbody></table></figure>

<p>By passing in a SkipList pointer object, you can traverse the skip list. The class defines a Node* node_ member variable to record the currently traversed node. Most methods are not difficult to implement, just needing to encapsulate the methods in the skip list introduced earlier. There are two special methods that require adding new methods to the skip list:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">Prev</span>() {</span><br><span class="line">  <span class="comment">// Instead of using explicit "prev" links, we just search for the</span></span><br><span class="line">  <span class="comment">// last node that falls before key.</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindLessThan</span>(node_-&gt;key);</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) {</span><br><span class="line">    node_ = <span class="literal">nullptr</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::<span class="built_in">SeekToLast</span>() {</span><br><span class="line">  node_ = list_-&gt;<span class="built_in">FindLast</span>();</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) {</span><br><span class="line">    node_ = <span class="literal">nullptr</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>These call the skip list’s <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/skiplist.h#L281">FindLessThan</a> and <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/skiplist.h#L302">FindLast</a> methods respectively to implement the Prev and SeekToLast methods. FindLessThan searches for the largest node less than the given key, while FindLast searches for the last node in the skip list (i.e., the largest node). These two methods are very similar to each other and also very similar to the FindGreaterOrEqual method. The following figure lists the differences between these two methods.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240902_leveldb_source_skiplist_find_diff.png/webp" alt="Differences between FindLessThan and FindLast methods in skip list" srcset="https://slefboot-1251736664.file.myqcloud.com/20240902_leveldb_source_skiplist_find_diff.png/webp 2418w, https://slefboot-1251736664.file.myqcloud.com/20240902_leveldb_source_skiplist_find_diff.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240902_leveldb_source_skiplist_find_diff.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240902_leveldb_source_skiplist_find_diff.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2418" height="732"></p>
<p>The basic idea is to start from the head node of the skip list and search right and down level by level. At each level, check if the next node of the current node exists. If the next node doesn’t exist, switch to the next level and continue searching. If it exists, we need to judge whether to search right based on the situation. Finally, they all reach the bottom level (level 0) and return a certain node.</p>
<p>At this point, the core functionality implementation of the skip list has been fully clarified. However, there’s still one question that needs to be answered: are the operations of this skip list thread-safe in a multi-threaded situation? When analyzing the implementation of the skip list above, we intentionally ignored multi-threading issues. Let’s look at this in detail next.</p>
<h2 id="Concurrent-Read"><a href="#Concurrent-Read" class="headerlink" title="Concurrent Read"></a>Concurrent Read</h2><p>We know that although LevelDB only supports single-process use, it supports multi-threading. More accurately, when inserting into memtable, <strong>LevelDB uses locks to ensure that only one thread can execute the Insert operation of the skip list at the same time</strong>. However, it allows multiple threads to concurrently read data from the SkipList, which involves <strong>multi-threaded concurrent reading issues</strong>. How does LevelDB support <strong>single write and multiple reads</strong> here?</p>
<p>During the Insert operation, there are two pieces of data being modified: one is the current maximum height max_height_ of the entire linked list, and the other is the node pointer update caused by inserting a new node. Although the writing process is single-threaded, <strong>the updates to the maximum height and next pointers are not atomic</strong>, and concurrent reading threads may read old height values or unupdated next pointers. Let’s see how LevelDB solves this problem.</p>
<p>When inserting a new node, first read the current maximum height of the linked list. If the new node is higher, the maximum height needs to be updated. The current maximum height of the linked list is recorded using the atomic type std::atomic<int>, using std::memory_order_relaxed semantics to ensure that <strong>read and write operations on max_height_ are atomic, but no memory barrier is added</strong>. The relevant code is as follows:</int></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetMaxHeight</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> max_height_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> <span class="title class_">Comparator</span>&gt;</span><br><span class="line"><span class="type">void</span> SkipList&lt;Key, Comparator&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> Key&amp; key) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (height &gt; <span class="built_in">GetMaxHeight</span>()) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetMaxHeight</span>(); i &lt; height; i++) {</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    }</span><br><span class="line">    max_height_.<span class="built_in">store</span>(height, std::memory_order_relaxed);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ... subsequent setting of node pointers (instruction reordering may occur here)</span></span><br></pre></td></tr></tbody></table></figure>

<p>For reading threads, <strong>if they read a new height value and updated node pointers, there’s no problem, as the reading threads correctly perceive the new node</strong>. But if the writing thread hasn’t finished updating the node pointers, and the reading thread reads the new height value, it will start searching from the new height. At this time, head_-&gt;next[max_height_] points to nullptr, so it will continue searching downwards, which won’t affect the search process. In fact, in this situation, if the writing thread has updated the pointers at lower levels, the reading thread may also perceive the existence of the new node.</p>
<p>Also, could it happen that the writing thread updates the new node pointers, but the reading thread reads the old height? We know that <strong>compilers and processors may reorder instructions, as long as this reordering doesn’t violate the execution logic of a single thread</strong>. In the above write operation, max_height_ might be written after the node pointers are updated. At this time, if a reading thread reads the old height value, it hasn’t perceived the newly added higher levels, but the search operation can still be completed within the existing levels. <strong>In fact, for the reading thread, it perceives that a new node with a lower level has been added</strong>.</p>
<h3 id="Memory-Barriers"><a href="#Memory-Barriers" class="headerlink" title="Memory Barriers"></a>Memory Barriers</h3><p>Actually, we’ve overlooked an important point in the previous analysis, which is the <strong>concurrent reading problem when updating level pointers</strong>. Earlier, we assumed that when updating the new node’s level pointers, the writing thread updates level by level from bottom to top, and <strong>reading threads might read partial lower level pointers, but won’t read incomplete level pointers</strong>. To efficiently implement this, LevelDB uses memory barriers, which starts from the design of the Node class.</p>
<p>In the <a href="#Node-Class-Design">Node class</a> implementation above, the next_ array uses the atomic type, which is the <strong>atomic operation type</strong> introduced in C++11. The Node class also provides two sets of methods to access and update pointers in the next_ array. The Next and SetNext methods are <strong>with memory barriers</strong>, and the main functions of memory barriers are:</p>
<ol>
<li><strong>Prevent reordering</strong>: Ensure that all write operations before the memory barrier are completed before operations after the memory barrier.</li>
<li><strong>Visibility guarantee</strong>: Ensure that all write operations before the memory barrier are visible to other threads.</li>
</ol>
<p>Specifically here, the SetNext method uses the atomic store operation and specifies the memory order memory_order_release, which provides the following guarantee: <strong>all write operations before this store will be completed before this store, and all read operations after this store will start after this store</strong>. The Next method used by reading threads uses memory_order_acquire to read the pointer, ensuring that <strong>read or write operations occurring after the read operation are not reordered before the load operation</strong>.</p>
<p>The NoBarrier_Next and NoBarrier_SetNext methods are <strong>without memory barriers</strong>. These two methods use memory_order_relaxed, and the compiler won’t insert any synchronization or barriers between this operation and other memory operations, so it doesn’t provide any memory order guarantee, which <strong>will have higher performance</strong>.</p>
<p>That’s enough background for now. It’s a bit complicated, but don’t worry, let’s look at it in conjunction with the code:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">NewNode</span>(key, height);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; i++) {</span><br><span class="line">  <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">  <span class="comment">// we publish a pointer to "x" in prev[i].</span></span><br><span class="line">  x-&gt;<span class="built_in">NoBarrier_SetNext</span>(i, prev[i]-&gt;<span class="built_in">NoBarrier_Next</span>(i)); <span class="comment">// successor pointer</span></span><br><span class="line">  prev[i]-&gt;<span class="built_in">SetNext</span>(i, x); <span class="comment">// predecessor pointer</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>This code updates the new node’s level pointers from bottom to top. For the i-th level, as long as the writing thread completes SetNext(i, x), modifying the pointer pointing to the new node x at this level, <strong>other reading threads can see the fully initialized i-th level</strong>. Here we need to understand the meaning of full initialization. We can assume there are no memory barriers here, what situation would occur?</p>
<ul>
<li><strong>Inconsistent multi-level pointers</strong>: Pointers at different levels might be updated in an inconsistent order, and reading threads might see that high-level pointers have been updated, but low-level pointers haven’t been updated yet.</li>
<li><strong>Memory visibility issues</strong>: In multi-core systems, write operations on one core may not be immediately visible to other cores, causing other threads to possibly not see the newly inserted node for a long time.</li>
<li><strong>Node pointer disorder</strong>: Here, the pointer pointing to the new node is updated first, but the successor pointer of the new node hasn’t been updated. This causes reading threads to read the new node but find no successor pointer, thinking they’ve reached the end.</li>
</ul>
<p>With memory barriers, it <strong>ensures that from bottom to top, each level is in a fully initialized state</strong>. LevelDB has also <strong>optimized to the extreme</strong> here, reducing unnecessary memory barriers. When inserting node x at level i, both the successor and predecessor pointers of x need to be updated. For the successor pointer, using the NoBarrier_SetNext method is sufficient because a memory barrier will be added when setting the predecessor pointer later. The comment in the code also mentions this point.</p>
<h2 id="Online-Visualization"><a href="#Online-Visualization" class="headerlink" title="Online Visualization"></a>Online Visualization</h2><p>To intuitively see the process of building a skip list, I used Claude3.5 to create a <a target="_blank" rel="noopener" href="https://gallery.selfboot.cn/en/algorithms/skiplist">skip list visualization page</a>. You can specify the maximum level height of the skip list, adjust the probability of increasing level height, then randomly initialize the skip list, or insert, delete, and search for nodes, observing the changes in the skip list structure.</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240815_leveldb_source_skiplist_visualization.png/webp" alt="Online visualization of skip lists" srcset="https://slefboot-1251736664.file.myqcloud.com/20240815_leveldb_source_skiplist_visualization.png/webp 3050w, https://slefboot-1251736664.file.myqcloud.com/20240815_leveldb_source_skiplist_visualization.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240815_leveldb_source_skiplist_visualization.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240815_leveldb_source_skiplist_visualization.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3050" height="1216"></p>
<p>With a maximum of 12 levels and an increasing probability of 1/4, you can see that the average level height of the skip list is quite low. You can also adjust the probability to 1/2 here to see the changes in the skip list.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Skip lists are probabilistic data structures that can be used to replace balanced trees, implementing fast insertion, deletion, and search operations. The skip list implementation in LevelDB has concise code, stable performance, and is suitable for storing data in memory MemTables. This article has deeply discussed the principles and implementation of skip lists, and finally provided a visualization page where you can intuitively see the construction process of skip lists.</p>
<p>One of the great advantages of LevelDB is that it provides detailed tests. So how is the skip list tested here? Additionally, by introducing randomization, skip lists perform similarly to balanced trees. How can we analyze the performance of skip lists? See you in the next article~</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/en/2024/09/09/leveldb_source_skiplist/';
    this.page.identifier = 'en/2024/09/09/leveldb_source_skiplist/';
    this.page.title = 'LevelDB Explained - How to implement SkipList';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (19)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (21)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (14)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = en/2024/09/09/leveldb_source_skiplist/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/en/2025/06/27/leveldb_source_table_build/" title="LevelDB Explained - A Step by Step Guide to SSTable Build">LevelDB Explained - A Step by Step Guide to SSTable Build</a></li><li><a href="/en/2025/06/13/leveldb_source_LRU_cache/" title="LevelDB Explained - The Implementation Details of a High-Performance LRU Cache">LevelDB Explained - The Implementation Details of a High-Performance LRU Cache</a></li><li><a href="/en/2025/06/11/leveldb_source_memtable/" title="LevelDB Explained - The Implementation Details of MemTable">LevelDB Explained - The Implementation Details of MemTable</a></li><li><a href="/en/2025/06/10/leveldb_mvcc_intro/" title="LevelDB Explained - Understanding Multi-Version Concurrency Control (MVCC)">LevelDB Explained - Understanding Multi-Version Concurrency Control (MVCC)</a></li><li><a href="/en/2025/05/23/mcp_user_report/" title="In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?">In-depth Experience with 3 MCP Servers via Cursor: Impressive but Not Yet Practical?</a></li><li><a href="/en/2025/01/24/leveldb_source_writedb/" title="LevelDB Explained - Implementation and Optimization Details of Key-Value Writing">LevelDB Explained - Implementation and Optimization Details of Key-Value Writing</a></li><li><a href="/en/2025/01/13/leveldb_source_write_batch/" title="LevelDB Explained - Elegant Merging of Write and Delete Operations">LevelDB Explained - Elegant Merging of Write and Delete Operations</a></li><li><a href="/en/2025/01/10/c++_crash_cases/" title="5 Real-world Cases of C++ Process Crashes from Production">5 Real-world Cases of C++ Process Crashes from Production</a></li><li><a href="/en/2025/01/02/leveldb_source_thread_anno/" title="LevelDB Explained - Static Thread Safety Analysis with Clang">LevelDB Explained - Static Thread Safety Analysis with Clang</a></li><li><a href="/en/2024/12/25/leveldb_source_hashtable/" title="LevelDB Explained - How to Design a High-Performance HashTable">LevelDB Explained - How to Design a High-Performance HashTable</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Principles-of-Skip-Lists"><span class="toc-number">1.</span> <span class="toc-text">Principles of Skip Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Storing-Ordered-Data"><span class="toc-number">1.1.</span> <span class="toc-text">Storing Ordered Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Idea-of-Skip-Lists"><span class="toc-number">1.2.</span> <span class="toc-text">The Idea of Skip Lists</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementation-in-LevelDB"><span class="toc-number">2.</span> <span class="toc-text">Implementation in LevelDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SkipList-Class"><span class="toc-number">2.1.</span> <span class="toc-text">SkipList Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-Class"><span class="toc-number">2.2.</span> <span class="toc-text">Node Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Search-Node"><span class="toc-number">2.3.</span> <span class="toc-text">Search Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-Node"><span class="toc-number">2.4.</span> <span class="toc-text">Insert Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator-Design"><span class="toc-number">2.5.</span> <span class="toc-text">Iterator Design</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Concurrent-Read"><span class="toc-number">3.</span> <span class="toc-text">Concurrent Read</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Barriers"><span class="toc-number">3.1.</span> <span class="toc-text">Memory Barriers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Online-Visualization"><span class="toc-number">4.</span> <span class="toc-text">Online Visualization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">5.</span> <span class="toc-text">Summary</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p><p>Friend Link:<a rel="dofollow" target="_blank" href="https://puzzles-game.com/">Puzzle Games</a></p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>