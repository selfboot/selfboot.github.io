<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本文先复现业务中 coredump 问题、然后通过 GDB 排查C++ 对象内存布局，揭示了 Bazel 依赖管理不完整导致不同版本 protobuf 文件混用引发的内存错误，同时也介绍了链接符号决议，bazel 依赖管理等内容。"><title>Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}
</script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7746897490519544" crossorigin="anonymous"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"><i class="fa fa-scale-balanced"></i><span> 法律普及</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析</h1><div class="post-meta">2024/03/15<span> | </span><span class="category"><a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/03/15/object_memory_coredump/" href="/2024/03/15/object_memory_coredump/#disqus_thread"></a><div class="post-content"><p>最近在项目中遇到了一个奇怪的 coredump 问题，排查过程并不顺利。经过不断分析，找到了一个复现的步骤，经过合理猜测和谨慎验证，最终才定位到原因。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231123_object_memory_coredump_cover.png/webp" alt="C++ coredump bazel依赖缺失" srcset="https://slefboot-1251736664.file.myqcloud.com/20231123_object_memory_coredump_cover.png/webp 1848w, https://slefboot-1251736664.file.myqcloud.com/20231123_object_memory_coredump_cover.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231123_object_memory_coredump_cover.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231123_object_memory_coredump_cover.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1848" height="1202"></p>
<p>复盘下来，发现这类 coredump 问题确实比较罕见，排查起来也不是很容易。只有项目代码<strong>编译依赖管理不是很合理的时候</strong>，才可能出现。另外，在复盘过程中，对这里的 coredump 以及 <strong>C++ 对象内存分布</strong>也有了更多理解。于是整理一篇文章，如有错误，欢迎指正。</p>
<span id="more"></span>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>先说下后台服务的基本架构，最外面是 cgi 层处理 nginx 转发的 http 请求，然后具体业务在中间的逻辑层处理。逻辑层是微服务框架，不同服务之间通过 RPC 调用，用的类似 <a target="_blank" rel="noopener" href="https://grpc.io/">grpc</a>。</p>
<p>某次变更，在服务 A 的 <code>service.proto</code> 文件中，对某个 rpc 请求参数增加了一个字段(比如下面的 age)：</p>
<figure class="highlight proto"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> {</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>{}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> {</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> age = <span class="number">2</span>;   <span class="comment">// 增加了参数</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span> {</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后增加了这个字段的相关逻辑，随后编译上线了该模块。我们知道在微服务架构中，经常<strong>有多个服务共用同一个 proto 对象</strong>。如果要修改 proto 的话，一般都是<strong>增加字段</strong>，这样对调用方和被调用方都是兼容的。这里服务 A 上线后，用新的 proto，其他用到这个 proto 的服务在重新编译前都会用老的版本，这样不会有问题。其实严格来说这样也是可能有问题的，之前踩过坑，主要是 Merge 的兼容问题，可以参考我之前的文章 <a href="https://selfboot.cn/2023/09/09/protobuf_field_merge/">Protobuf 序列化消息引起的存储失败问题分析</a>。</p>
<p>正常来说，如果其他服务想更新 proto，只需要重新编译就能用到新的 proto，肯定不会有问题。不过这次就出问题了，<strong>服务 A 的 proto 增加字段上线后，其他通过 client 调用 A 的服务，只要重新编译上线，就会 coredump</strong>。</p>
<h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><p>这里看了现网的 core 文件，没有发现特别有用的信息(通过 core 文件定位问题的功力还是不太够)。就想着先看看能不能稳定复现一下，毕竟对于 core 的问题，如果能稳定复现，问题基本就解决一大半了。好在通过一番尝试，找到了一个可以稳定复现的步骤。</p>
<h3 id="老版本-proto"><a href="#老版本-proto" class="headerlink" title="老版本 proto"></a>老版本 proto</h3><p>创建一个最初版本的 proto 文件，这里就叫 data.proto，并用 protoc 编译为 <code>data.pb.h</code> 和 <code>data.pb.cc</code>，其中 proto 文件内容如下：</p>
<figure class="highlight proto"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Data</span> {</span><br><span class="line">    <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译命令也很简单，<code>protoc --cpp_out=. data.proto</code> 即可。此外，还有一个 libdata.cpp 文件，定义了一个 processData 函数，使用了上面的 proto 对象。这个cpp文件被编译进了一个公共库 <code>libdata.so</code>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libdata.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"data.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> example::Data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(Data &amp;req)</span> </span>{</span><br><span class="line">    Data data;</span><br><span class="line">    data.<span class="built_in">set_message</span>(<span class="string">"Hello from lib"</span>);</span><br><span class="line">    std::cout&lt;&lt; <span class="string">"In lib, data size: "</span> &lt;&lt; <span class="built_in">sizeof</span>(data)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">"In lib, data  msg: "</span> &lt;&lt; data.<span class="built_in">message</span>()&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; <span class="string">"In lib, req size: "</span> &lt;&lt; <span class="built_in">sizeof</span>(req)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">"In lib, req  msg: "</span> &lt;&lt; req.<span class="built_in">message</span>()&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编译为动态库的命令如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC -shared libdata.cpp data.pb.cc -o libdata.so -lprotobuf -g</span><br></pre></td></tr></tbody></table></figure>

<p>这样我们就有了 <code>libdata.so</code> 动态库文件了。</p>
<h3 id="更新-proto"><a href="#更新-proto" class="headerlink" title="更新 proto"></a>更新 proto</h3><p>接下来我们修改下 data.proto 文件，增加一个 <strong>repeated 字段</strong>，如下：</p>
<figure class="highlight proto"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Data</span> {</span><br><span class="line">    <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">int32</span> users = <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>然后重新用 protoc 编译 proto 文件</strong>。接着写我们的主程序，就叫 <code>main.cpp</code>，只是简单调用前面 <code>libdata.so</code> 库中的函数，内容如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"data.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> example::Data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">processData</span><span class="params">(Data&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Data req;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"main: "</span> &lt;&lt; <span class="built_in">sizeof</span>(req) &lt;&lt; std::endl;</span><br><span class="line">    req.<span class="built_in">set_message</span>(<span class="string">"test"</span>);</span><br><span class="line">    <span class="built_in">processData</span>(req);  <span class="comment">// 调用库函数</span></span><br><span class="line">    std::cout &lt;&lt; req.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"main: "</span> &lt;&lt; <span class="built_in">sizeof</span>(req) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后编译链接我们的主程序，命令如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -o main -L. -lprotobuf -Wl,-rpath,. -ldata -g</span><br></pre></td></tr></tbody></table></figure>

<p>这里需要注意的是，我们的 <code>libdata.so</code> 库文件在当前目录，所以需要用 <code>-Wl,-rpath,.</code> 指定下动态库的搜索路径。然后运行程序，就会必现 coredump，如下图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240131_object_memory_coredump_reproduced.png/webp" alt="成功复现 coredump" srcset="https://slefboot-1251736664.file.myqcloud.com/20240131_object_memory_coredump_reproduced.png/webp 2032w, https://slefboot-1251736664.file.myqcloud.com/20240131_object_memory_coredump_reproduced.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240131_object_memory_coredump_reproduced.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240131_object_memory_coredump_reproduced.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2032" height="596"></p>
<h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><p>大多时候，能稳定复现 coredump，基本就很容易找到 coredump 的原因了。用 <code>-g</code> 编译带上调试信息，然后就可以用 gdb 跟踪排查。因为在 <code>set_message</code> 这里会 core 掉，所以我们在这里打个断点，先查看下 req 对象的内存布局，然后执行到 core，查看堆栈即可。整体的结果如下图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_gdb_message.png/webp" alt="gdb 查看 coredump 内存布局" srcset="https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_gdb_message.png/webp 2130w, https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_gdb_message.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_gdb_message.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_gdb_message.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2130" height="1582"></p>
<p>先用 GDB 打印 req 的内容，<strong>比较奇怪的是这里只有 message 字段，并没有看到 users 字段</strong>。然后执行到 <code>req.set_message("test");</code> 这里，从 coredump 的堆栈来看，set_message 这里调用 this 和 value 地址都没问题。但是底层 <code>ArenaStringPtr::Set</code> 的时候，this 的地址是 <code>0x7fffffffe3a8</code>，这个感觉应该是 message 字段的地址。从前面输出来看，应该是 <code>0x7fffffffe390</code> 才对(这里不太确定，后面会验证这点)。</p>
<figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">....</span><br><span class="line">#<span class="number">2</span>  <span class="number">0</span>x000055<span class="number">55555564e6</span> in googl<span class="number">e::</span>protobu<span class="number">f::</span>internal<span class="number">::</span>ArenaStringPtr<span class="number">::</span>Set (this=<span class="number">0</span>x7fffffffe3a8,</span><br><span class="line">    default_value=<span class="number">0</span>x<span class="number">555555559100</span> &lt;googl<span class="number">e::</span>protobu<span class="number">f::</span>internal<span class="number">::</span>fixed_address_empty_string[abi:cxx11]&gt;,</span><br><span class="line">    value="test", arena=<span class="number">0</span>x0) at /usr/include/google/protobuf/arenastring.h:<span class="number">81</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0</span>x00005<span class="number">55555556948</span> in exampl<span class="number">e::</span>Dat<span class="number">a::</span>set_message (this=<span class="number">0</span>x7fffffffe380, value=<span class="number">0</span>x55<span class="number">55555570f0</span> "test")</span><br><span class="line">    at data.pb.h:<span class="number">288</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0</span>x00005<span class="number">55555556312</span> in main () at main.cpp:<span class="number">12</span></span><br></pre></td></tr></tbody></table></figure>

<p>coredump 的直接原因就是 message 字段的内存地址错误。那么什么原因导致内存地址错了呢？这里就要回顾下我们的编译、运行过程了。我们知道在 C++ 中，<strong>对象的内存布局是由其类的定义决定的</strong>，这通常在头文件（.h）中给出。当编译一个 C++ 程序时，编译器根据类的定义（包括成员变量的类型、数量、顺序等）来确定每个对象的大小和内存布局。具体到我们这里 Protobuf 生成的 C++ 类，类的定义通常包含在 .pb.h 文件中，而 <code>.pb.cc</code> 文件则包含这些类的方法的实现，包含字段访问器（如 set_message 和 message）和其他成员函数的实现。这些实现负责<strong>实际的数据操作，如分配内存、修改字段值、生成对象的字符串表示</strong>等。</p>
<h3 id="对象内存分布"><a href="#对象内存分布" class="headerlink" title="对象内存分布"></a>对象内存分布</h3><p>我们上面的编译过程，主程序 <code>main.cpp</code> 使用了新版本的 <code>data.pb.h</code>，因此 main 中的 Data 对象<strong>按照新的内存布局</strong>进行编译。这里对象的内存布局包括成员变量的排列、对象的总大小以及可能的填充（为了满足对齐要求），所以 <strong>main 中的 Data 对象是包含了 users 字段的</strong>。怎么验证这一点呢？很简单，我们可以在 main 中打印下 Data 对象的大小，如下先<strong>注释掉会导致 coredump 的 set_message 以及读取 message 的代码</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"data.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> example::Data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">processData</span><span class="params">(Data&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Data req;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"main: "</span> &lt;&lt; <span class="built_in">sizeof</span>(req) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// req.set_message("test");</span></span><br><span class="line">    <span class="built_in">processData</span>(req);  <span class="comment">// 调用库函数</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; req.message() &lt;&lt; std::endl;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"main: "</span> &lt;&lt; <span class="built_in">sizeof</span>(req) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后重新编译链接，运行程序，输出如下：</p>
<figure class="highlight vbnet"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main:</span> <span class="number">56</span></span><br><span class="line"><span class="keyword">In</span> <span class="keyword">lib</span>, data size: <span class="number">32</span></span><br><span class="line"><span class="keyword">In</span> <span class="keyword">lib</span>, data  msg: Hello <span class="keyword">from</span> <span class="keyword">lib</span></span><br><span class="line"><span class="keyword">In</span> <span class="keyword">lib</span>, req size: <span class="number">32</span></span><br><span class="line"><span class="keyword">In</span> <span class="keyword">lib</span>, req  msg:</span><br><span class="line"><span class="symbol">main:</span> <span class="number">56</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到 <strong>main 中 data 的大小是 56，而 lib 中的 data 大小是 32</strong>。通过这个验证，我们可以确定 main 中的 Data 对象是包含了 users 字段的，所以会比 lib 中的 Data 对象大。</p>
<p>既然包含了 users 字段，为什么前面<strong>gdb 打印 main.cpp 中的 req 对象的时候，又不包含 users 字段呢？<strong>我们知道，GDB 之所以能输出对象成员、局部变量等信息，是用到了二进制文件中的</strong>符号表信息</strong>，gcc 编译的时候带上<code>-g</code>就会有这些调试信息。对于 pb 对象来说，这些调试信息是在 <code>.pb.cc</code> 文件中，包含了如何序列化和反序列化字段、如何进行内存管理（包括对于动态分配的字段如字符串和重复字段的处理）等逻辑。</p>
<p>我们再仔细回顾下前面 main 的编译链接命令，其实我们链接到的是动态库 libdata.so 中的老的 data.pb.cc 实现，这个版本的实现中并没有 users 字段。所以 gdb 打印的时候，无法显示出来。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -o main -L. -lprotobuf -Wl,-rpath,. -ldata -g</span><br></pre></td></tr></tbody></table></figure>

<p>其实这里还有个问题需要解释下，为什么前面注释掉 set_message 以及读取 message 的代码，程序就没有 core 了呢？这是因为 main 程序不再尝试修改或访问 req 对象的内容，尽管 req 对象的内存布局与 libdata.so 中的不匹配，但由于没有实际操作这些不一致的内存区域，所以并不会触发非法内存访问。</p>
<h3 id="链接新版本-pb"><a href="#链接新版本-pb" class="headerlink" title="链接新版本 pb"></a>链接新版本 pb</h3><p>前面我们链接 main 的时候，用的是动态库里面的老的 <code>data.pb.cc</code>，如果改成链接新的 <code>data.pb.cc</code>，程序还会 core 吗？我们稍微改下前面的编译链接命令，注意 main.cpp 中仍然注释 set_message 部分：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp data.pb.cc  -o main -L. -lprotobuf -Wl,-rpath,. -ldata -g</span><br></pre></td></tr></tbody></table></figure>

<p>新的链接命令只用把 <code>data.pb.cc</code> 放在 <code>-ldata</code> 前面，就会链接到新的pb实现。这里链接符号决议的过程，可以参考我之前的文章<a href="https://selfboot.cn/2023/09/19/c++_symbol_resolution/">深入理解 C++ 链接符号决议：从符号重定义说起</a>。</p>
<p>编译好后运行程序，发现果然又 core 了，不过这次 core 的位置在 <code>libdata.cpp</code> 中的 <code>processData</code> 函数中，具体在 <code>data.set_message("Hello from lib");</code> 这里，如下图所示：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240314_object_memory_coredump_core_inlib.png/webp" alt="改变链接顺序后继续 coredump" srcset="https://slefboot-1251736664.file.myqcloud.com/20240314_object_memory_coredump_core_inlib.png/webp 2130w, https://slefboot-1251736664.file.myqcloud.com/20240314_object_memory_coredump_core_inlib.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240314_object_memory_coredump_core_inlib.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240314_object_memory_coredump_core_inlib.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2130" height="1036"></p>
<p>这是因为我们的 <code>libdata.so</code> 中的 Data 对象定义是用的老的 <code>data.pb.h</code>，而链接到的实现又是新的<code>data.pb.cc</code>，导致对象不一致，所以内存会错乱导致 core。</p>
<p>这里 <strong>core 的位置也挺有意思的</strong>，如果 main.cpp 不注释 set_message 部分，如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Data req;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"main: "</span> &lt;&lt; <span class="built_in">sizeof</span>(req) &lt;&lt; std::endl;</span><br><span class="line">    req.<span class="built_in">set_message</span>(<span class="string">"test"</span>);    <span class="comment">// 不注释这里</span></span><br><span class="line">    <span class="built_in">processData</span>(req);  <span class="comment">// 调用库函数</span></span><br><span class="line">    std::cout &lt;&lt; req.<span class="built_in">message</span>() &lt;&lt; std::endl; <span class="comment">// 不注释这里</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"main: "</span> &lt;&lt; <span class="built_in">sizeof</span>(req) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>程序并没有 core 在动态库 processData 中，反而是 core 在 main 中的 <code>req.message()</code> 了。大概是因为 processData 中访问对象<strong>凑巧</strong>没有错乱，直到 main 中访问 <code>req.message()</code> 的时候才触发内存错误。那么如果把 <code>req.message()</code> 这行也注释呢，如下代码还会 core 吗？</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Data req;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"main: "</span> &lt;&lt; <span class="built_in">sizeof</span>(req) &lt;&lt; std::endl;</span><br><span class="line">    req.<span class="built_in">set_message</span>(<span class="string">"test"</span>);    <span class="comment">// 不注释这里</span></span><br><span class="line">    <span class="built_in">processData</span>(req);  <span class="comment">// 调用库函数</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; req.message() &lt;&lt; std::endl; // 注释这里！！！</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"main: "</span> &lt;&lt; <span class="built_in">sizeof</span>(req) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行后发现程序运行到了 return，打印了所有内容，但最后还是 core 掉。输出如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ main.cpp data.pb.cc  -o main -L. -lprotobuf -Wl,-rpath,. -ldata -g</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">main: 56</span><br><span class="line">In lib, data size: 32</span><br><span class="line">In lib, data  msg: Hello from lib</span><br><span class="line">In lib, req size: 32</span><br><span class="line">In lib, req  msg: test</span><br><span class="line">main: 56</span><br><span class="line">[1]    1302869 segmentation fault  ./main</span><br></pre></td></tr></tbody></table></figure>

<p>具体 core 的位置在 main 中 req 对象的析构过程，通过 GDB 可以发现，在 processData 处理之前，打印 req 也能看到 user 字段。但是 processData 后，req 的<strong>内存地址直接变成了一个非法地址</strong>，所以后续析构出错。整体 GDB 过程如下图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_core_destroy.png/webp" alt="core 在了析构函数" srcset="https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_core_destroy.png/webp 2116w, https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_core_destroy.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_core_destroy.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_core_destroy.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2116" height="1626"></p>
<p>这里再补充说下，其实在 processData 中处理 req 的时候，因为 Data 对象的定义和实现有两个版本，导致 req 的内存地址错乱，只是<strong>凑巧</strong>这个函数里面的操作没有因为内存问题 core 掉，直到 main 中析构，才最终触发 core。</p>
<h2 id="正常情况下内存分析"><a href="#正常情况下内存分析" class="headerlink" title="正常情况下内存分析"></a>正常情况下内存分析</h2><p>上面程序 core 的根源在于，<strong>在一个可执行文件中，用到了不同版本的 data.pb.h 和 data.pb.cc，从而导致内存读、写异常</strong>。接下来我们看看正常情况下，整个过程中 pb 对象的内存分布是怎样的。同时验证下前面遗留的一个猜测：底层 <code>ArenaStringPtr::Set</code> 的时候，this 的地址是 <code>0x7fffffffe3a8</code>，这个是 message 字段的地址。</p>
<p>首先用新版本 data.pb.cc 重新生成动态库，然后重新编译 main 程序，运行结果如下，一切正常。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br><span class="line">main: 56</span><br><span class="line">In lib, data size: 56</span><br><span class="line">In lib, data  msg: Hello from lib</span><br><span class="line">In lib, req size: 56</span><br><span class="line">In lib, req  msg: test</span><br><span class="line">main: 56</span><br></pre></td></tr></tbody></table></figure>

<p>接着用 GDB 来分析下，可以打印 req 对象，里面有 users 和 message 字段，拿到 message 的地址，可以看到和后面的 <code>ArenaStringPtr::Set</code> 中 this 的地址是一样的。并且在经过 processData 处理后，这里 req 对象的内存地址并没有变化，说明这里的内存操作是正常的。整体 GDB 过程如下图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_gdb_normal.png/webp" alt="正常情况下的 GDB 内存查看" srcset="https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_gdb_normal.png/webp 2130w, https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_gdb_normal.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_gdb_normal.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240315_object_memory_coredump_gdb_normal.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2130" height="1716"></p>
<h2 id="bazel-依赖缺失"><a href="#bazel-依赖缺失" class="headerlink" title="bazel 依赖缺失"></a>bazel 依赖缺失</h2><p>让我们回到文章开始介绍的业务背景中去，业务中c++项目依赖比较多，用 bazel 来做依赖管理。有问题的 build 文件大致如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">proto_library(</span><br><span class="line">    name = "data_proto",</span><br><span class="line">    srcs = ["data.proto"],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_proto_library(</span><br><span class="line">    name = "data_cc_proto",</span><br><span class="line">    deps = [":data_proto"],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_library(</span><br><span class="line">    name = "libdata",</span><br><span class="line">    srcs = ["libdata.cpp"],</span><br><span class="line">    includes = ["."],         # 万恶之源</span><br><span class="line"></span><br><span class="line">    # deps = [":data_cc_proto"], # 漏掉了这个关键的依赖</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">    name = "main",</span><br><span class="line">    srcs = ["main.cpp"],</span><br><span class="line">    deps = [":libdata", ":data_cc_proto"],</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<p>这里 libdata 的依赖其实是不完整的，正常是要依赖到 data_cc_proto 才对，但是这里并没有。在某次更新 data.proto 后，重新编译 main，<strong>bazel 分析依赖关系，发现声明的依赖里没有用到 data.proto(实际有依赖到)，所以不会重新编译 libdata</strong>。导致 libdata 里面的 Data 对象定义还是老版本的，而 main 中的 Data 对象会用新版本，这样就会导致前面的内存错乱，最终 coredump。</p>
<p>其实上面 libdata 要能编译过，得找到 <code>data.pb.h</code> 头文件才行。这里使用了 <code>includes = ["."]</code> 这种写法，允许一个规则及其所有传递依赖包含工作区内任意位置的头文件。这种写法有很多问题，比如会使得库的封装性和可维护性降低，构建速度变慢。<strong>最新版本的 bazel 其实已经禁止了这种写法</strong>，老版本的 bazel 也是不推荐的。</p>
<p>我们项目中，因为要兼容比较老版本的 protobuf(2.6 左右的版本，也是很古老了)，<strong>用的 bazel 版本比较老</strong>，大概是 2017 年的版本。在 BUILD 文件中，也大量使用 <code>include=['.']</code>，导致头文件的依赖路径很乱，所以 lib 库虽然依赖关系不全，但是仍然可以编译过，为后续的 coredump 埋下伏笔。如果升级到新版本 bazel，依赖的管理更加严格，这种依赖缺失的 BUILD 写法就会更容易发现了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后简单总结下吧。问题的开始是简单给 proto 增加了一个字段，没想到竟然导致了 coredump。虽然知道和增加字段这个变更有关系，但是分析到具体的原因还是花了不少时间。</p>
<p>中间尝试过很多排查方向：</p>
<ol>
<li>protobuf 库有 bug？搜了一圈，没发现类似问题，并且用了这么久都很稳定，所以先排除这个可能。</li>
<li>分析 coredump 文件，没有发现有用的信息。一方面是因为对 protobuf 的实现并不是很了解，所以 core 在 pb 后就无从下手。另外 GDB 分析 core 的功底也不是很深。</li>
<li>不断地<strong>剥离无关的逻辑</strong>，争取能找到一个可以复现的小 demo。这里是同事最终找到了一个复现的步骤，成为突破口。在同事稳定复现后，就比较容易猜到、并验证这里和用了不同版本的 proto 有关。</li>
</ol>
<p>然后想着写一篇文章来记录下这个不常见的坑，在准备文章开始的复盘代码时，又遇到了个问题。之前同事复现的时候，其实带了很多项目中的代码逻辑，bazel 的依赖关系也比较复杂。而在文章中，我想用<strong>最简单的代码</strong>复现并说明问题。最开始模拟改动 proto 的时候，只是增加一个 string 字段，结果发现并不会导致 coredump。虽然这里 Data 对象的内存布局不一样，但是<strong>凑巧</strong>读写内存都正常，没触发内存非法访问。后来想到增加这里的“扰动”，尝试换了 repeated，才能稳定复现 coredump。</p>
<p>复盘代码足够简单的一个好处就是，用 GDB 调试起来也比较方便，不会有太多无关的信息。通过对比 core 和正常代码中，对象内存地址的变化，再一次验证确实是因为用了不同版本的 pb 对象导致的 core。不过本文还是缺少一些深度，<strong>没有去深入分析不同版本的 pb 为什么会导致地址错乱</strong>，这部分估计得深入 protobuf 的实现了。</p>
<p>最后一个问题，后续怎么在项目中避免这类问题呢？首先避免用 <code>include ['.']</code> 带来混乱的头文件查找路径，然后<strong>规范依赖管理</strong>，所有用到 protobuf 的库，都要加上对 pb 的依赖。当然，如果能升级 bazel 最好，不过这就需要花费更多人力了。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析</p><p>本文链接为：https://selfboot.cn/2024/03/15/object_memory_coredump/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/Debug/"><i class="fa fa-tag"></i>Debug</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2024/03/15/object_memory_coredump/';
    this.page.identifier = '2024/03/15/object_memory_coredump/';
    this.page.title = 'Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (19)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (31)</li><li><a href="/categories/法律普及/">法律普及</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/法律/" style="font-size: 15.00px;">法律</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2024/03/15/object_memory_coredump/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li><li><a href="/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB 源码阅读：如何分析跳表的时间复杂度？">LevelDB 源码阅读：如何分析跳表的时间复杂度？</a></li><li><a href="/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB 源码阅读：如何正确测试跳表的并行读写？">LevelDB 源码阅读：如何正确测试跳表的并行读写？</a></li><li><a href="/2024/09/13/gpto1_hands_on/" title="实际例子上手体验 OpenAI o1-preview，比预期差一点？">实际例子上手体验 OpenAI o1-preview，比预期差一点？</a></li><li><a href="/2024/09/09/leveldb_source_skiplist/" title="LevelDB 源码阅读：跳表的原理、实现以及可视化">LevelDB 源码阅读：跳表的原理、实现以及可视化</a></li><li><a href="/2024/09/05/claude35_prompt/" title="Claude3.5 系统提示词解密：不道歉、脸盲、幻觉...">Claude3.5 系统提示词解密：不道歉、脸盲、幻觉...</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.</span> <span class="toc-text">复现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E7%89%88%E6%9C%AC-proto"><span class="toc-number">2.1.</span> <span class="toc-text">老版本 proto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0-proto"><span class="toc-number">2.2.</span> <span class="toc-text">更新 proto</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">深入分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">3.1.</span> <span class="toc-text">对象内存分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%96%B0%E7%89%88%E6%9C%AC-pb"><span class="toc-number">3.2.</span> <span class="toc-text">链接新版本 pb</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">正常情况下内存分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bazel-%E4%BE%9D%E8%B5%96%E7%BC%BA%E5%A4%B1"><span class="toc-number">5.</span> <span class="toc-text">bazel 依赖缺失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>