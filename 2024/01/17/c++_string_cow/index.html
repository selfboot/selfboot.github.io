<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本文通过示例代码复现字符串副本被修改后原字符串也跟着改变的问题，针对性地分析了问题根源。然后全面地讲解了写时复制的原理及存在的缺陷，如引起潜在内存错误、不适合多线程等。最后介绍C++11标准是如何修改约束和高版本字符串的SSO优化。"><title>C++ string 意外修改之深入理解 COW 写时复制</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C++ string 意外修改之深入理解 COW 写时复制</h1><div class="post-meta">2024/01/17<span> | </span><span class="category"><a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/01/17/c++_string_cow/" href="/2024/01/17/c++_string_cow/#disqus_thread"></a><div class="post-content"><p>最近工作中有小伙伴遇到了一个奇怪的问题，C++中复制一个 string 后，更改复制后的内容，结果原值也被改了。对于不是很熟悉 C++ 的小伙伴来说，这就有点“见鬼”了。本文接下来从问题的简单复现，到背后的原理，以及 C++ 标准的变更，来一起深入讨论这个问题。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240115_c++_string_cow_cover.png/webp" alt="C++字符串修改副本影响到原来内容" srcset="https://slefboot-1251736664.file.myqcloud.com/20240115_c++_string_cow_cover.png/webp 1938w, https://slefboot-1251736664.file.myqcloud.com/20240115_c++_string_cow_cover.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240115_c++_string_cow_cover.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240115_c++_string_cow_cover.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1938" height="1212"></p>
<span id="more"></span>

<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>这里直接给出可以稳定复现的代码，定义一个字符串 original，然后复制一份，接着调用一个函数来修改副本字符串的内容。业务中的函数比较复杂，这里复现用了一个简单的函数，只是修改 copy 的第一个字符。在修改副本 copy 前后，打印两个字符串的内容和内存地址。往下看之前，你可以先猜猜下面代码的输出。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModifyStringInplace</span><span class="params">(string &amp;str)</span> </span>{</span><br><span class="line">    <span class="type">size_t</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">char</span> *s = <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(str.<span class="built_in">c_str</span>());</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">'X'</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    string original = <span class="string">"Hello, World!"</span>;</span><br><span class="line">    string copy = original;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示两个字符串的内存地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Original: "</span> &lt;&lt; original &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(original.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Copy    : "</span> &lt;&lt;  copy &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(copy.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改副本</span></span><br><span class="line">    <span class="built_in">ModifyStringInplace</span>(copy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次显示两个字符串的内存地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"After Modification:"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Original: "</span> &lt;&lt; original &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(original.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Copy    : "</span> &lt;&lt;  copy &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(copy.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在业务生产环境上，用 G++ 4.9.3 编译上面的代码，运行结果如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Original: Hello, World!, address: 0x186c028</span><br><span class="line">Copy    : Hello, World!, address: 0x186c028</span><br><span class="line">After Modification:</span><br><span class="line">Original: Xello, World!, address: 0x186c028</span><br><span class="line">Copy    : Xello, World!, address: 0x186c028</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到在修改副本后，<strong>原始字符串的内容也发生了变化</strong>。还有一点奇怪的是，原始字符串和副本的<strong>内存地址始终是一样的</strong>。这究竟是怎么回事呢？要解决这个疑问，我们需要先了解下 C++ string 的实现机制。</p>
<h2 id="字符串写时复制"><a href="#字符串写时复制" class="headerlink" title="字符串写时复制"></a>字符串写时复制</h2><p>在低版本的 GCC/G++(5 版本以下) 中，string 类的实现采用了<strong>写时复制</strong>（Copy-On-Write，简称 COW）机制。当一个字符串对象被复制时，它<strong>并不立即复制整个字符串数据，而是与原始字符串共享相同的数据</strong>。只有在字符串的一部分被修改时（即“写入”时），才会创建数据的真实副本。COW 的优点在于它可以大幅度减少不必要的数据复制，特别是在字符串对象<strong>频繁被复制但很少被修改</strong>的场景下。</p>
<p>COW 的一般实现方式：</p>
<ul>
<li><strong>引用计数</strong>：string 对象内部通常包含一个指向字符串数据的指针和一个引用计数。这个引用计数表示有多少个 string 对象共享相同的数据。</li>
<li><strong>复制时共享</strong>：当一个 string 对象被复制时，它会简单地复制指向数据的指针和引用计数，而不是数据本身。复制后的字符串对象和原始对象共享相同的数据，并且引用计数增加。</li>
<li><strong>写入时复制</strong>：如果任何一个 string 对象试图修改共享的数据，它会首先检查引用计数。如果引用计数大于 1，表示数据被多个对象共享。在这种情况下，修改操作会先创建数据的一个新副本（即“复制”），然后对这个新副本进行修改。引用计数随后更新以反映共享情况的变化。</li>
</ul>
<p>COW 实现需要仔细管理内存分配和释放，以及引用计数的增加和减少，确保数据的正确性和避免内存泄漏。现在回到上面的复现代码，我们更改了复制后的字符串，但是从输出结果来看，并<strong>没有触发 COW 中的写复制，因为前后地址还是一样的</strong>。这是为什么呢？先来看 ModifyStringInplace 的实现，string 的 c_str() 方法返回一个<strong>指向常量字符数组</strong>的指针，设计上这里是只读的，<strong>不应该通过这个指针来修改字符串的内容</strong>。</p>
<p>但是上面的实现中，用 <code>const_cast</code> 移除了对象的 const（常量）属性，然后对内存上的数据进行了修改。通过指针<strong>直接修改底层数据的操作</strong>不会被 string 的内部机制（包括 COW）所识别到，因为它跳过了string 对外暴露接口的状态检查。如果把上面代码稍微改动下，用<code>[]</code>来修改字符串的内容，<code>str[0] = 'X'</code>，那么就会触发 COW 的写复制，从而导致原始字符串的内容不会被修改。输出如下：</p>
<figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">Original:</span> Hello, World<span class="operator">!</span>, <span class="params">address:</span> <span class="number">0</span>x607028</span><br><span class="line"><span class="params">Copy    :</span> Hello, World<span class="operator">!</span>, <span class="params">address:</span> <span class="number">0</span>x607028</span><br><span class="line">After <span class="params">Modification:</span></span><br><span class="line"><span class="params">Original:</span> Hello, World<span class="operator">!</span>, <span class="params">address:</span> <span class="number">0</span>x607028</span><br><span class="line"><span class="params">Copy    :</span> Xello, World<span class="operator">!</span>, <span class="params">address:</span> <span class="number">0</span>x607058</span><br></pre></td></tr></tbody></table></figure>

<p>其实用 <code>[]</code> 只读取字符串中某位的内容，也会触发写时复制。比如下面的代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    string original = <span class="string">"Hello, World!"</span>;</span><br><span class="line">    string copy = original;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示两个字符串的内存地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Original: "</span> &lt;&lt; original &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(original.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Copy    : "</span> &lt;&lt;  copy &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(copy.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    copy[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 再次显示两个字符串的内存地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"After :"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Original: "</span> &lt;&lt; original &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(original.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Copy    : "</span> &lt;&lt;  copy &lt;&lt; <span class="string">", address: "</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(copy.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在低版本 G++ 上编译运行，可以看到用 operator[] 读取字符串后，复制内容的地址也发生了变化(从 <code>0x21f2028</code> 到 <code>0x21f2058</code>)，如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Original: Hello, World!, address: 0x21f2028</span><br><span class="line">Copy    : Hello, World!, address: 0x21f2028</span><br><span class="line">After Modification:</span><br><span class="line">Original: Hello, World!, address: 0x21f2028</span><br><span class="line">Copy    : Hello, World!, address: 0x21f2058</span><br></pre></td></tr></tbody></table></figure>

<p>这是因为 operator[] 返回的是对字符的引用，<strong>可以通过这个引用来修改字符串的内容</strong>，这个接口有”修改”字符串的语义，所以会触发写时复制。虽然上面代码实际并没有修改，但是 COW 机制本身很难感知到这里没修改，这里改成用迭代器 <code>begin()/end()</code> 也会有同样的问题。</p>
<h2 id="写时复制的缺点"><a href="#写时复制的缺点" class="headerlink" title="写时复制的缺点"></a>写时复制的缺点</h2><p>用 COW 实现 string 的好处是可以减少不必要的数据复制，但是它也有一些缺点。先看一个简单示例，参考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12199710/legality-of-cow-stdstring-implementation-in-c11">Legality of COW std::string implementation in C++11</a> 下的一个回答。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">"str"</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = s.<span class="built_in">data</span>();</span><br><span class="line">    {</span><br><span class="line">        std::string copy = s;</span><br><span class="line">        std::cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; std::endl; <span class="comment">// cow: now s new allocation</span></span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; <span class="string">'\n'</span>;  <span class="comment">// p is dangling</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在 COW 机制下，当创建 copy 作为 s 的副本时，s 和 copy 实际上共享相同的底层数据，此时，p 指向的是这个共享数据的地址。然后 operator[] 导致 s 会触发重新分配内存，这时 p 对应内存部分的引用只有 copy 了。当 copy 的生命周期结束并被销毁，p 就成为<strong>悬空指针（dangling pointer）</strong>。后面访问悬空指针所指向的内存，这是<a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">未定义行为（undefined behavior）</a>，可能导致程序崩溃或者输出不可预测的结果。如果不使用 COW 机制，这里就不会有这个问题。</p>
<p>不过，就算是 C++11 及以后的标准中，标准库中的 std::string 不再使用 COW 机制了，<strong>保留指向字符串内部数据的指针仍然是一种不安全的做法</strong>，因为任何修改字符串的操作都<strong>可能导致重新分配内部缓冲区，从而使得之前的指针或引用变得无效</strong>。</p>
<h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><p>COW 写时复制除了带来上面这些潜在 bug 外，还有一个比较重要的缺陷，就是<strong>不适合多线程环境</strong>，详细可以阅读 <a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2534.html">Concurrency Modifications to Basic String</a> 这篇文章，COW 写时复制带来的问题就是：</p>
<blockquote>
<p>The current definition of basic_string allows only <strong>very limited concurrent access to strings</strong>. Such limited concurrency will inhibit performance in multi-threaded applications.</p>
</blockquote>
<p>举个简单的例子，如下对于原始字符串，这里先复制了几个副本，然后分别在不同的线程中运行。在 COW 的实现中，必须保证这里各个线程操作独立副本字符串是线程安全的，也就要求COW 的实现中，<strong>字符串中共享内存的引用计数必须是原子操作</strong>。原子操作本身需要开销，而且在多线程环境下，多个 CPU 对同一个地址的原子操作开销更大。如果不用 COW 实现，本来是<strong>可以避免这部分开销</strong>的。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringOperations 这里修改字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string thread1 = <span class="string">"Hello, World! This is a test string."</span>; <span class="comment">// 共享字符串</span></span><br><span class="line">    <span class="function">std::string <span class="title">thread2</span><span class="params">(thread1)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">thread3</span><span class="params">(thread1)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(StringOperations, std::<span class="built_in">ref</span>(thread1));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(StringOperations, std::<span class="built_in">ref</span>(thread2));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(StringOperations, std::<span class="built_in">ref</span>(thread3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) {</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当然如果是不同线程之间共享同一个 string 对象，那么不管是不是写时复制，这里都要进行线程同步，才能保证线程安全，这里不做讨论了。</p>
<h2 id="C-11-标准改进"><a href="#C-11-标准改进" class="headerlink" title="C++11 标准改进"></a>C++11 标准改进</h2><p>鉴于上面提到的写时复制的缺点，GCC 编译器，从 5.1 开始不再用 COW 实现 string，可以参考 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html">Dual ABI</a>：</p>
<blockquote>
<p>In the GCC 5.1 release libstdc++ introduced a new library ABI that includes new implementations of string and std::list. These changes were necessary to conform to the 2011 C++ standard which <strong>forbids Copy-On-Write strings</strong> and requires lists to keep track of their size.</p>
</blockquote>
<p>这里主要是因为 C++11 标准做了更改，<a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf">21.4.1 basic_string general requirements</a> 中有这样的描述：</p>
<blockquote>
<p>References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated by the following uses of that basic_string object:</p>
<ul>
<li>as an argument to any standard library function taking a reference to non-const basic_string as an argument.</li>
<li>Calling non-const member functions, except operator[], at, front, back, begin, rbegin, end, and rend.</li>
</ul>
</blockquote>
<p>如果是 COW 实现的字符串，如前面的例子，<strong>只是调用 non-const operator[] 也会导致写时复制，从而导致原始字符串的引用失效</strong>。</p>
<h2 id="高版本字符串优化"><a href="#高版本字符串优化" class="headerlink" title="高版本字符串优化"></a>高版本字符串优化</h2><p>高版本的 GCC，特别是遵循 C++11 标准和之后版本的实现，对 std::string 的实现进行了显著的修改，主要是为了提高性能和保证线程安全。高版本的 GCC 放弃了 COW，同时对小字符串做了优化（SSO）。当字符串足够短以至于可以直接存储在 std::string 对象的内部缓冲区中时，它就会使用这个内部缓冲区(在栈中)，而不是分配单独的堆内存。这可以减少内存分配的开销，并提高访问小字符串时的性能。</p>
<p>可以用下面代码来验证下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    string a = <span class="string">"short"</span>;</span><br><span class="line">    string b = <span class="string">"this is a long string here, hahahhh"</span>;</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(a.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;b &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(b.<span class="built_in">c_str</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>用高版本编译运行，可以看到输出类似下面结果：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7ffcb9ff22d0:0x7ffcb9ff22e0</span><br><span class="line">0x7ffcb9ff22b0:0x421eb0</span><br></pre></td></tr></tbody></table></figure>

<p>对于比较短的字符串，地址和变量本身地址十分接近，说明就在栈上。而对于比较长的字符串，地址和变量本身地址相差很大，说明是在堆上分配的。对于较长的字符串，高版本的 GCC 实现了更有效的动态内存分配和管理策略，包括避免不必要的内存重新分配，以及在增长字符串时采用增量或倍增的容量策略，以减少内存分配次数和提高内存利用率。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：C++ string 意外修改之深入理解 COW 写时复制</p><p>本文链接为：https://selfboot.cn/2024/01/17/c++_string_cow/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2024/01/17/c++_string_cow/';
    this.page.identifier = '2024/01/17/c++_string_cow/';
    this.page.title = 'C++ string 意外修改之深入理解 COW 写时复制';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (22)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (32)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2024/01/17/c++_string_cow/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/06/13/leveldb_source_LRU_cache/" title="LevelDB 源码阅读：LRU Cache 高性能缓存实现细节">LevelDB 源码阅读：LRU Cache 高性能缓存实现细节</a></li><li><a href="/2025/06/11/leveldb_source_memtable/" title="LevelDB 源码阅读：MemTable 内存表的实现细节">LevelDB 源码阅读：MemTable 内存表的实现细节</a></li><li><a href="/2025/06/10/leveldb_mvcc_intro/" title="LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)">LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)</a></li><li><a href="/2025/05/23/mcp_user_report/" title="使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?">使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?</a></li><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li><li><a href="/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB 源码阅读：如何分析跳表的时间复杂度？">LevelDB 源码阅读：如何分析跳表的时间复杂度？</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%A4%8D%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">问题复现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">字符串写时复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">写时复制的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">多线程问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-%E6%A0%87%E5%87%86%E6%94%B9%E8%BF%9B"><span class="toc-number">4.</span> <span class="toc-text">C++11 标准改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%89%88%E6%9C%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">高版本字符串优化</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p><p>友情链接：<a rel="dofollow" target="_blank" href="https://puzzles-game.com/">益智游戏</a></p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>