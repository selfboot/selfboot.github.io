<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本文详细分析了一个由 C++ 线程池、整数溢出和异常处理引发的服务重启问题。探讨了 std::thread 和 std::async 在异常处理上的差异，揭示了 async 实现的线程池中未处理异常可能导致的连锁反应。通过日志分析、代码审查和 GDB 调试，逐步定位问题根源，并提供了修复方案。文章还总结了多线程编程、异常处理和线程池设计的关键点，为开发者提供了宝贵的经验和参考。"><title>溢出、异常、线程池、阻塞，奇怪的服务重启问题定位</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">溢出、异常、线程池、阻塞，奇怪的服务重启问题定位</h1><div class="post-meta">2024/06/13<span> | </span><span class="category"><a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/06/13/async_pool_block_problem/" href="/2024/06/13/async_pool_block_problem/#disqus_thread"></a><div class="post-content"><p>最近在业务中遇见一个很奇怪的服务重启问题，定位过程比较有曲折，本文来复盘下。这个问题涉及到 C++ 线程池、整数溢出、异常捕获、阻塞等多个方面，还是挺有意思的。</p>
<p>接下来我会按照<strong>问题排查的过程</strong>来组织本文内容，会先介绍问题背景，接着列出初步的排查思路，定位异常请求的方法。然后，通过代码分析，以及复现问题的一些简单用例，来揭开服务重启的神秘面纱。</p>
<span id="more"></span>

<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>我们有个模块 A 对外提供 RPC 服务，主调方 B 会调用 A 的服务。模块 A 的服务分为 2 个进程，mesh 进程和业务进程，这两个进程都是多线程的。mesh 进程类似 <a target="_blank" rel="noopener" href="https://istio.io/latest/docs/reference/config/networking/sidecar/">Sidecar</a> 的作用，每当接收到主调方发来的 1 个 rpc 请求，就分配一个 worker 线程负责该请求。worker 会通过 unix socket 把请求包发给业务进程，然后等业务进程处理完后回复主调方。业务进程则专门用来做业务逻辑，拿到请求包处理完成后，把响应包给 mesh 进程里的 worker。整体如下图所示：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_bg.png/webp" alt="服务分mesh进程和业务进程" srcset="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_bg.png/webp 1820w, https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_bg.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_bg.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_bg.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1820" height="1062"></p>
<p>最近，主调方 B 通过监控发现每天会有几次连不上模块 A 的服务端口，每次持续时间也不长，过一会就自动恢复了。</p>
<p>简单看了下模块 A 的日志，发现在对应时间点，<strong>监控脚本拨测 A 服务失败，于是重启服务</strong>。这里的监控脚本每隔固定时间，会拨测模块 A 的 存活探测 rpc(就是简单回复一个 hello)，来检测服务是否正常。如果连续的几次拨测都失败，则认为服务有问题，就尝试重启服务。这次模块 A 的偶现重启，就是脚控脚本发现一直没法拿到存活探测 rpc 的回复，于是重启服务。</p>
<p>那么**什么时候开始出现这个问题呢？**把模块 A 的监控时间拉长，发现 7 天前才开始有偶现的诡异重启。模块 A 的每台服务器都有重启，重启频次很低，所以模块 A 也没有告警出来。</p>
<p>按照经验，拨测失败一般是服务进程挂了，比如进程 coredump 退出或者内存泄露导致 OOM 被系统杀了。但是查了下模块 A 的日志，发现并不是上面两种情况。模块 A 没看到 coredump 相关的日志，内存使用在重启时间段都是正常的。那会不会是代码中有<strong>死循环导致 worker 线程被占着一直没法释放呢</strong>？看了下重启时间段的 CPU 使用率，也是正常水平。当然如果死循环中一直 sleep，那么 CPU 使用率也不高，不过业务中并没有什么地方用到 sleep，所以这里初步排查不是死循环。</p>
<p>这就有点奇怪了，接着仔细看服务日志来排查吧。</p>
<h2 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h2><p>找了一台最近有重启的机器，先看看重启时间点服务进程的日志。模块 A 里 mesh 进程是一个 C++ 多线程服务，一共有 N 个 worker 线程并发处理业务的 RPC 请求。框架每隔一段时间，会打印日志，记录当前 worker 中有多少是空闲(idle)的，多少正在处理请求(busy)。正常情况下，打印出来的日志中，大部分线程是 idle 的，只有少部分是 busy。</p>
<p>但是在进程重启前，发现日志中的 worker 线程数有点异常，<strong>1 分钟内 idle 线程越来越少，直到为 0</strong>。假设总 worker 数为 200，重启前的相关日志大概如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">worker idle 100, busy 100;</span><br><span class="line">worker idle 40, busy 160;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>怪不得监控脚本会拨测失败，此刻服务的所有 worker 都被占用，没有空闲 worker 处理新来的请求，所有新来的请求都会排队等待 worker 直到超时失败。</p>
<p>那么是什么原因导致 worker 一直被占用没有释放出来呢？服务是最近才出现这个问题的，所以首先想到可能和最近的变更有关。把最近的代码变更看了下，没发现什么问题。</p>
<p>接下来其实有两个排查思路，第一个是等服务进程再次卡住的时候，通过 gdb attach 进程，或者 gcore 转储 coredump 文件，这样就可以查看 worker 线程的调用栈，看看是什么函数导致 worker 一直被占用。首先排除掉 gdb attach，第一是出现概率比较低，监控脚本会很短时间内重启服务，不太好找到时机，并且现网服务也不太适合 attach 上去排查问题。gcore 的话，需要改动下监控脚本，在拨测有问题的时候，保存下进程 coredump 文件。不过当时考虑到需要改监控脚本，并且通过 coredump 文件不一定能发现问题，所以暂时没采用。</p>
<p>第二个思路就是找到可以复现的请求，通过复现问题来定位，毕竟<strong>如果一个问题能稳定复现，相当于已经解决了一大半</strong>。这里其实基于这样一个假设，<strong>一般偶发的问题，都是由某类特殊的请求触发了一些边界条件导致</strong>。</p>
<p>对于我们的 RPC 模块来说，如果有一个特殊的请求导致 worker 一直被占用，那么这个请求一定是没有回包的。因此，我们可以在模块<strong>接收到请求包以及给出响应包的时候，分别打印出相关日志</strong>。然后在服务卡住的时间段，就可以过滤出日志中那些只有请求没有响应的 RPC 请求。</p>
<p>加了日志上线后，刚好又一次出现了服务重启，通过日志，终于找到了可疑请求。结合这个可疑请求，发现了一段有问题的代码，正是这段有问题的代码，成为解决问题的突破口。</p>
<h2 id="问题代码分析"><a href="#问题代码分析" class="headerlink" title="问题代码分析"></a>问题代码分析</h2><p>我们先来看下这段有问题的代码，简化后并隐去关键信息，大致如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> gramCount = <span class="number">3</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; posVec;</span><br><span class="line">	<span class="comment">// GetPosVec(posVec);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt; posVec.<span class="built_in">size</span>() - gramCount; ++i) {</span><br><span class="line">		posVec[i] = i * <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>聪明如你，一定发现这段代码的问题了吧。</p>
<p>这里 i 是无符号整数，<code>posVec.size()</code> 返回的也是无符号整数类型 size_t。当 posVec.size() 小于 gramCount 时，<code>posVec.size() - gramCount</code> 会<strong>溢出</strong>，变成一个很大的正整数。接着在循环中，会用这个很大的正整数来遍历 posVec，就会导致<strong>数组越界</strong>。这里用 operator[] 访问数组的时候，当下标越界就是<a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">未定义行为</a>，一般会导致程序 crash 掉。写了一个简单测试代码，发现确实 segmentation fault 了。这里补充说下，如果是用 <a target="_blank" rel="noopener" href="https://cplusplus.com/reference/array/array/at/">at 访问数组</a>的话，下标越界会抛出 out_of_range 异常，如果被捕获异常，肯定会 crash。</p>
<p>但是模块 A 中这里的代码却没有 crash，而是导致 worker 线程一直被占用，这又是为什么呢？一个可疑的地方就是，上面的代码其实是在一个新开的线程池中跑的。再补充说下这里的背景，模块 A 收到 RPC 请求后，会在一个 worker 线程中处理业务逻辑。有部分业务逻辑比较耗时，<strong>为了提高处理速度，会把耗时的部分放到一个额外的线程池来并发执行</strong>。</p>
<p>这里线程池的实现稍微有点复杂，大致思路就是<strong>一个任务队列 + 配置好的 N 个 worker 线程</strong>。任务队列用来存放需要执行的任务，worker 线程从任务队列中取任务执行。线程池对外提供了一个接口 <code>RunTask(concur, max_seq, task);</code> 其中 concur 是并发执行的线程数，max_seq 是任务总数，task 是任务函数。RunTask 会用 concur 个线程并发执行这个任务函数 task，直到 max_seq 个任务全部完成。</p>
<p>在任务开始前，RunTask 里面定义了一个管道，用来在主线程和任务线程池之间同步消息。一旦所有线程完成任务，最后一个退出的线程会向管道写入一个字符以通知主线程。主线程会等待管道中的字符，然后返回。</p>
<p>上面有整数溢出的代码，就是放在这个额外的线程池执行的，难道是线程池导致的问题？为了快速验证猜想，写了个简单的测试脚本，把上面代码放到线程池执行，进程果真卡住没反应了。首先猜想，会不会是线程池中的线程因为数组越界导致 crash 掉，没有写 pipe，导致主线程一直阻塞在 pipe 的读操作上呢？</p>
<p>下面来验证下。</p>
<h2 id="多线程：thread"><a href="#多线程：thread" class="headerlink" title="多线程：thread"></a>多线程：thread</h2><p>为了验证上面的猜想，写了一个简单的测试程序，模拟业务中线程池的工作流程。这里用 C++11 的 thread 来开启 5 个新线程，并且让这些线程 sleep 一段时间模拟执行任务。当所有线程都执行完任务后，最后一个完成的线程向管道写入一个字符，主线程阻塞在管道读取上。测试代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">completedThreads</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCurrentTimeAndThread</span><span class="params">(<span class="type">const</span> std::string&amp; prefix)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_c), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">    std::cout &lt;&lt; prefix &lt;&lt; <span class="string">" Thread ID: "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" - "</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>], <span class="type">int</span> totalThreads)</span> </span>{</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="type">int</span> finished = ++completedThreads;</span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) {</span><br><span class="line">        <span class="type">char</span> c = <span class="string">'o'</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 最后一个完成的线程写入管道</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">"Completed"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">"Main thread started"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) {</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction, fds, totalThreads);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Main thread is now waiting for read..."</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 主线程阻塞在这里等待管道写入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里注释掉会发生什么呢？</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) {</span><br><span class="line">        <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) {</span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">"Main thread finished"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行后发现这里是符合预期的，5 个线程并发执行 1s，主线程等最后一个线程执行完，就会从管道中读到结果继续往下执行。结果如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140358584862528 - 2024-06-12 11:40:51</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140358568072960 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358559680256 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358551287552 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358584858368 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358576465664 - 2024-06-12 11:40:52</span><br><span class="line">Main thread finished Thread ID: 140358584862528 - 2024-06-12 11:40:52</span><br></pre></td></tr></tbody></table></figure>

<p>现在让<strong>最后一个子线程直接抛出异常，来看看主线程是否阻塞</strong>。在上面代码基础上改动如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) {</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"Out of range exception"</span>); <span class="comment">// 模拟 at 越界访问数组，抛出异常</span></span><br><span class="line">        <span class="type">char</span> c = <span class="string">'o'</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 最后一个完成的线程写入管道</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>重新编译运行发现整个进程直接 crash 掉了，结果如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140342189496128 - 2024-06-12 11:46:23</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140342189491968 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342181099264 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342172706560 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342164313856 - 2024-06-12 11:46:24</span><br><span class="line">terminate called after throwing an instance of 'std::out_of_range'</span><br><span class="line">  what():  Out of range exception</span><br><span class="line">[1]    2622429 abort      ./thread_test2</span><br></pre></td></tr></tbody></table></figure>

<p>看来前面的猜想失败了！在多线程下，单个线程抛出异常导致整个进程 abort 掉了。为什么会这样？这里不得不提一下<strong>C++ 的异常处理机制了</strong>？</p>
<h3 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++ 异常处理"></a>C++ 异常处理</h3><p>在 C++ 中，当程序遇到一个无法自行解决的问题时，它可以抛出（throw）一个异常。异常通常是一个从标准异常类派生的对象，如 std::runtime_error。编程时，可以把可能抛异常的代码放到 try 块里面，然后在后面跟一个或多个 catch 块，用来捕获和处理特定类型的异常。</p>
<p>如果在当前作用域内没有捕获异常，<strong>异常将被传递到调用栈中较高层的 try-catch 结构中</strong>，直到找到合适的 catch 块。如果整个调用栈都没有找到合适的 catch 块，会调用 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate()</a>，具体执行操作由 std::terminate_handler 指定，默认下是调用 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a>。如果没有设置信号处理程序捕获 SIGABRT 信号，那么程序就会被异常终止。</p>
<p>对于上面的示例多线程代码来说，最后一个线程抛出异常，但是没有地方捕获，所以最终调用 std::abort() 终止整个进程。从上面的输出也可以看到，最后一行是 abort。</p>
<p>其实 C++ 之所以这样设计，是因为一个未捕获的异常通常意味着程序已经进入一个未知的状态，继续运行可能会导致更严重的错误，如数据损坏或安全漏洞。因此，<strong>立即终止程序被认为是一种安全的失败模式</strong>。</p>
<h3 id="thread-对象生命周期"><a href="#thread-对象生命周期" class="headerlink" title="thread 对象生命周期"></a>thread 对象生命周期</h3><p>这里再提一个地方，上面示例程序，主线程最后会对每个子线程的 thread 对象调用 thread.join()，如果把这里注释掉，运行程序会发生什么呢？进程还是会 crash 掉，并且也是调用的 terminate()。这又是为什么呢？</p>
<p>其实前面 terminate 的文档里有提到，下面这种情况也会调用 terminate：</p>
<blockquote>
<ol start="10">
<li>A joinable std::thread is destroyed or assigned to.</li>
</ol>
</blockquote>
<p>接着继续查看 std::thread::joinable 的文档，发现如下解释：</p>
<blockquote>
<p>A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</p>
</blockquote>
<p>我们知道，子线程在执行完相关代码后会自动退出。但是，这并不意味着与该线程相关联的 std::thread 对象会自动处理这个线程的所有资源和状态。在 C++ 中，操作系统线程的结束和 std::thread 对象的生命周期管理是两个相关但又相对独立的概念：</p>
<ul>
<li><strong>操作系统的线程</strong>：当线程执行完代码后会自动停止，此时线程的系统资源（如线程描述符和堆栈）通常会被操作系统回收。</li>
<li><strong>std::thread 对象的管理</strong>：虽然线程已经结束，但是 std::thread 对象依然需要正确地更新其状态来<strong>反映线程已经不再活跃</strong>。这一点主要是通过 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/thread/join">join()</a> 或 detach() 方法来实现的。如果没有调用这些方法，std::thread 对象在被销毁时将检测到它仍然“拥有”一个活跃的线程，这将导致调用 std::terminate()。</li>
</ul>
<p>前面示例代码中主线程调用 join() 方法，会阻塞等待子线程执行完(其实就这里的例子来说，管道写入字符已经确保执行完了的)，然后标记 std::thread 对象状态为“非活跃”。</p>
<p>那么回到前面的问题，为啥<strong>业务代码中线程池中的线程抛出异常，主线程会卡住呢</strong>？接着仔细看了下线程池的实现代码，发现这里并不是用 thread 来创建线程，而是用的 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/async">std::async</a>。async 是什么？它是怎么工作的，这里线程卡死会和 async 有关吗？</p>
<p>接着一起来验证吧。</p>
<h2 id="多线程：async"><a href="#多线程：async" class="headerlink" title="多线程：async"></a>多线程：async</h2><p>C++11 引入了 std::async，这是一个用于<strong>简化并发编程</strong>的高级工具，它可以在<strong>异步的执行上下文中运行一个函数或可调用对象，并返回一个 std::future 对象</strong>来访问该函数的返回值或异常状态。</p>
<p>哈哈，看完这里的介绍，是不是一头雾水、不知所云？没事，先抛开这些，直接看代码先。我们在前面 thread 示例代码的基础上，稍加改动，用 async 来并发执行，完整代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">completedThreads</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCurrentTimeAndThread</span><span class="params">(<span class="type">const</span> std::string&amp; prefix)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_c), <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line">    std::cout &lt;&lt; prefix &lt;&lt; <span class="string">" Thread ID: "</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">" - "</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>], <span class="type">int</span> totalThreads)</span> </span>{</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="type">int</span> finished = ++completedThreads;</span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) {</span><br><span class="line">	<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"Out of range exception"</span>); <span class="comment">// 模拟 at 越界访问数组，抛出异常</span></span><br><span class="line">        <span class="type">char</span> c = <span class="string">'o'</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 最后一个完成的线程写入管道</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">"Completed"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">"Main thread started"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) {</span><br><span class="line">        futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, threadFunction, fds, totalThreads));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Main thread is now waiting for read..."</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 主线程阻塞在这里等待管道写入</span></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">"Main thread finished"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行后发现，主线程卡住了！！运行结果如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140098007660352 - 2024-06-12 21:06:00</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140097990870784 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140097974085376 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140097999263488 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140098007656192 - 2024-06-12 21:06:01</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>成功复现了业务中的问题。在继续深入分析前，先来看看 async 的用法，主要如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) {</span><br><span class="line">    futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, threadFunction, fds, totalThreads));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码用 std::async 函数来启动一组异步任务，这些任务由 threadFunction 定义。每个任务在创建时都被配置为在新线程上执行，并且使用 std::launch::async 策略来确保它们会立即启动。这些任务的执行结果（或状态）被封装在 std::future<void> 对象中，并存储在 futures 这个 std::vector 中。先了解这么多就够了，接下来我们继续分析为什么主线程会卡住。</void></p>
<h3 id="GDB-分析"><a href="#GDB-分析" class="headerlink" title="GDB 分析"></a>GDB 分析</h3><p>我们用 GDB 来看看进程运行过程发生了啥。这里 run 之后，可以看到新创建了 5 个线程来执行 async 任务，接着有 4 个线程都打印了任务输出，然后 5 个线程又全部被系统销毁。之后 GDB 控制台会卡住，这时候用 Ctrl+C 来暂停程序执行，然后就可以用 GDB 控制台了。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_gdb.png/webp" alt="GDB 排查阻塞进程" srcset="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_gdb.png/webp 2258w, https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_gdb.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_gdb.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_gdb.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2258" height="1454"></p>
<p>进程卡住后看堆栈，发现阻塞在主线程 main 函数的 read 上。这时候进程只剩下主线程，可以用 info threads 确认，这里 0x7ffff7a9e740 其实就是进程开始打印出的 Thread ID: 140737348495168 的十六进制。从 GDB 的结果来看，最后一个子线程在要 write 前抛出异常，然后直接退出，没有往管道写入字符，主线程一直阻塞在管道的 read 中。</p>
<p>问题来了，整个进程不是应该 abort 终止吗？在前面 <a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9Athread">thread 的示例</a> 中，线程抛出的异常没被捕获导致进程 abort 掉，主线程也随之结束。而这里 async 创建的<strong>线程抛出的异常似乎不见了，没看到有捕获的地方，也没有触发进程 abort</strong>，这是为什么呢？</p>
<h3 id="async-异常处理"><a href="#async-异常处理" class="headerlink" title="async 异常处理"></a>async 异常处理</h3><p>先来看看 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/async">async</a> 的文档里有没有说是怎么处理异常的吧。</p>
<blockquote>
<p>If the function f returns a value or throws an exception, it is stored in the shared state accessible through the std::future that std::async returns to the caller.</p>
</blockquote>
<p>可以看到，使用 std::async 启动的线程如果抛出了异常，这些<strong>异常会被捕获并存储在返回的 std::future 对象中</strong>。再查看 future 的文档，发现可以用 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/future/get">future::get</a> 来拿到任务的执行结果，如果任务抛出异常，调用 get 的时候会重新抛出异常。</p>
<blockquote>
<p>If an exception was stored in the shared state referenced by the future (e.g. via a call to std::promise::set_exception()) then that exception will be thrown.</p>
</blockquote>
<p>至此上面示例程序没有 abort 的原因找到了，就在于 async 的异常处理机制。<strong>在 async 中，线程抛出的异常会被存储在 std::future 对象中，而不会直接导致进程 abort。子线程抛出异常后没有往管道写入字符，主线程就一直阻塞在 read 上等待，导致整个进程看起来就跟卡住一样</strong>。</p>
<p>这里我们可以在示例程序 read 前调用 get 来捕获异常，然后打印出来验证下。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; future : futures) {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        future.<span class="built_in">get</span>();</span><br><span class="line">    } <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) {</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"Caught exception: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf;</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Main thread is now waiting for read..."</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 主线程阻塞在这里等待管道写入</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到这里确实捕获到了一个 out_of_range 异常。</p>
<h3 id="async-的优势"><a href="#async-的优势" class="headerlink" title="async 的优势"></a>async 的优势</h3><p>关于 async 再补充一点思考，C++11 引入的 async 和传统的 thread 比有什么优点呢？</p>
<p>首先 std::async 提供了一种比直接使用 std::thread <strong>更简单的方法来创建并执行异步任务</strong>。它自动处理线程的创建和管理，使得开发者可以专注于业务逻辑而非线程管理的细节。std::async 可以自动管理任务的生命周期，包括适时地启动和终止线程。使用 std::async 不需要显式地调用 join() 或 detach()。</p>
<p>另外，如前面所述，使用 std::async 启动的任务可以在执行中抛出异常，这些异常会被捕获并存储在返回的 std::future 对象中。通过调用 std::future::get()，可以在主线程中捕获和处理这些异常。</p>
<p>此外，调用 std::async 可以指定启动模式（std::launch::async 或 std::launch::deferred），其中 std::launch::async 强制立即在新线程中运行任务，而 std::launch::deferred 则延迟任务的执行直到调用 std::future::get() 或 std::future::wait()。</p>
<p>一般来说，当需要并行执行且彼此之间没有依赖关系的任务时，用 std::async 不需要关注线程的管理，会简单很多。或者需要在将来的某个时间点获取并行任务的执行结果，可以将 std::async 与 std::future 结合起来用，也会方便很多。</p>
<h2 id="现网服务复盘"><a href="#现网服务复盘" class="headerlink" title="现网服务复盘"></a>现网服务复盘</h2><p>好了，现在回到现网服务的讨论，通过前面分析已经能确定问题所在了，不过还有几个和现网服务相关的细节这里也需要搞清楚。第一个就是这里出问题的代码早就上线了，为什么最近才出问题？回到<a href="##%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">问题代码分析</a>这里的示例，如果数组大小大于等于 gramCount，就不会溢出，也不会导致 crash。最近这里数组的长度有了变化，所以才出现上面的问题。</p>
<p>第二个疑问就是，每次遇到异常的数据，只会卡住当前的 1 个工作 worker，短时间也不会有很多异常请求数据。但是前面<a href="#%E5%88%9D%E6%AD%A5%E6%8E%92%E6%9F%A5">初步排查</a>的时候观察日志，在<strong>极短时间内，所有 worker 都耗尽</strong>。这又是为什么呢？</p>
<p>前面<a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF">问题背景</a>有提到过，mesh 进程和业务进程都是多线程，日志中看到短时间极速减少的 idle worker，是 mesh 进程的。实际业务逻辑在业务进程处理，业务进程中的所有线程共用一个 async 单例实现的全局线程池。async 实现的线程池在创建单例对象的时候会指定一共有多少个线程，这些线程供所有业务进程 worker 线程使用。整体如下图所示：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_worker.png/webp" alt="业务线程架构" srcset="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_worker.png/webp 2136w, https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_worker.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_worker.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_worker.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2136" height="1060"></p>
<p>每当有一个异常数据，就会导致 async 线程池中的 1 个线程退出，同时阻塞业务进程中的 1 个线程。随着时间推移，积累足够多异常数据后，会出现下面 2 种情况：</p>
<ol>
<li>async 线程池中的线程因为异常全部退出，这时候还没有阻塞的业务线程只要使用线程池处理数据，不管数据是否异常，都会阻塞在 read 上，因为根本没有 async 线程来计算。这种情况发生在业务进程的线程数大于 async 线程池中的线程数时。</li>
<li>async 线程池中还有可以工作的线程，不过业务进程中所有线程都因为曾经出现的异常数据导致阻塞在 read 上。这种情况发生在业务进程的线程数小于 async 线程池中的线程数时。</li>
</ol>
<p>不管是哪种情况，<strong>都会在某一刻，因为最后的一个异常请求数据，导致业务进程所有工作线程阻塞，无法处理 mesh 来的请求</strong>。从这一刻起，每当 mesh 接收到一个请求，mesh 进程的一个 worker 就会被占用，短时间内的请求积压，导致 mesh 进程所有 worker 被占用，也就无法处理新来的请求，最终导致监控脚本检测到服务异常。</p>
<p>至此，整个重启的原因水落石出，修复方法也跃然纸上了。最简单的方法就是在 async 线程中执行业务函数时，加上 try-catch 块，如果捕获到异常，直接调用 abort 来中止整个业务进程。这样如果代码中有导致抛出异常的 bug，上线后一旦触发进程就会立马终止，出问题早发现，也方便从 coredump 文件中分析问题。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：溢出、异常、线程池、阻塞，奇怪的服务重启问题定位</p><p>本文链接为：https://selfboot.cn/2024/06/13/async_pool_block_problem/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2024/06/13/async_pool_block_problem/';
    this.page.identifier = '2024/06/13/async_pool_block_problem/';
    this.page.title = '溢出、异常、线程池、阻塞，奇怪的服务重启问题定位';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (19)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (32)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2024/06/13/async_pool_block_problem/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/05/23/mcp_user_report/" title="使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?">使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?</a></li><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li><li><a href="/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB 源码阅读：如何分析跳表的时间复杂度？">LevelDB 源码阅读：如何分析跳表的时间复杂度？</a></li><li><a href="/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB 源码阅读：如何正确测试跳表的并行读写？">LevelDB 源码阅读：如何正确测试跳表的并行读写？</a></li><li><a href="/2024/09/13/gpto1_hands_on/" title="实际例子上手体验 OpenAI o1-preview，比预期差一点？">实际例子上手体验 OpenAI o1-preview，比预期差一点？</a></li><li><a href="/2024/09/09/leveldb_source_skiplist/" title="LevelDB 源码阅读：跳表的原理、实现以及可视化">LevelDB 源码阅读：跳表的原理、实现以及可视化</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">问题背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E6%8E%92%E6%9F%A5"><span class="toc-number">2.</span> <span class="toc-text">初步排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">问题代码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9Athread"><span class="toc-number">4.</span> <span class="toc-text">多线程：thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">C++ 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.2.</span> <span class="toc-text">thread 对象生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9Aasync"><span class="toc-number">5.</span> <span class="toc-text">多线程：async</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB-%E5%88%86%E6%9E%90"><span class="toc-number">5.1.</span> <span class="toc-text">GDB 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">async 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">5.3.</span> <span class="toc-text">async 的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%A4%8D%E7%9B%98"><span class="toc-number">6.</span> <span class="toc-text">现网服务复盘</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>