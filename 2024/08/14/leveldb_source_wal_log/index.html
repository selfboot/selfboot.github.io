<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="探讨 LevelDB 的WAL（Write-Ahead Logging）日志读写接口。详细分析 WAL日志的写入过程，包括数据切分、记录格式和存储方式，同时阐述了日志读取的复杂逻辑，如何处理跨块记录和异常情况。还展示了相关的测试用例，验证WAL日志在各种场景下的正确性。"><title>LevelDB 源码阅读：读写 WAL 日志保证持久性</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB 源码阅读：读写 WAL 日志保证持久性</h1><div class="post-meta">2024/08/14<span> | </span><span class="category"><a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/08/14/leveldb_source_wal_log/" href="/2024/08/14/leveldb_source_wal_log/#disqus_thread"></a><div class="post-content"><p>LevelDB 使用 WAL（Write-Ahead Logging）日志来确保数据的持久性。当写入操作发生时，LevelDB 首先将数据写入到日志文件中，然后再应用到内存中的数据结构（如 MemTable）。系统或数据库崩溃后重新启动时，LevelDB 会检查 WAL 日志文件中的记录。通过读取并重放这些日志记录，LevelDB 可以重建那些在崩溃发生时还未被完全写入磁盘的数据状态。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_leveldb_source_wal_log_cover.svg" alt="LevelDB WAL 日志写入流程"></p>
<p>整个 WAL 日志相关的操作流程如下：</p>
<ol>
<li>LevelDB首先将数据写入WAL日志。确保即使在系统崩溃的情况下，数据也不会丢失。</li>
<li>数据被写入内存中的MemTable，这个是内存操作，很快。</li>
<li>LevelDB向客户端确认写入完成。</li>
<li>随着时间推移，当MemTable满了之后，它会被刷新到磁盘上的SSTable文件中。</li>
<li>一旦MemTable被成功刷新到SSTable，相应的WAL日志就可以被清除了。</li>
</ol>
<p>接下来详细看看这里的实现。</p>
<span id="more"></span>

<h2 id="写-WAL-日志"><a href="#写-WAL-日志" class="headerlink" title="写 WAL 日志"></a>写 WAL 日志</h2><p>先来看看 LevelDB 是如何写 WAL 日志的。在 LevelDB 中，<a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/log_writer.h">db/log_writer.h</a> 中定义了个 Writer 类，用于写入 WAL 日志文件。Writer 类的主要方法是 <code>AddRecord</code>，用于将一个记录追加到日志文件中。主要的数据成员是 <code>WritableFile* dest_;</code>，指向支持追加写的日志文件。这里 WritableFile 是 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h#L277">include/leveldb/env.h</a> 中定义的抽象类接口，用于封装顺序写文件的操作，具体接口和实现可以参考 <a href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/#%E9%A1%BA%E5%BA%8F%E5%86%99%E6%96%87%E4%BB%B6">LevelDB 源码阅读：Posix 文件操作接口实现细节</a>。</p>
<p>WAL 日志写入的主要实现在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/log_writer.cc">db/log_writer.cc</a> 文件中，整体流程比较清晰。AddRecord 方法处理不同大小的数据，确保它们按照正确的格式和类型进行切分，然后调用 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/log_writer.cc#L82">EmitPhysicalRecord</a> 设置头部，存储单条记录。</p>
<h3 id="单条记录存储格式"><a href="#单条记录存储格式" class="headerlink" title="单条记录存储格式"></a>单条记录存储格式</h3><p>单条记录存储格式比较清晰，EmitPhysicalRecord 中有完整的实现。每条记录由 2 部分组成：<strong>7 字节固定长度</strong>的 Header以及长度不定的 Data 部分。Header 部分包括 1 字节的记录类型、2 字节的记录长度和 4 字节的校验码。其中：</p>
<ul>
<li>Record Type：记录类型，标识是完整记录、第一部分、中间部分还是最后部分。</li>
<li>Length：单条记录长度，指的是数据部分的长度，不包括头部的长度。单条记录长度最长为 kBlockSize - kHeaderSize，用 2 个字节表达足够了。</li>
<li>CRC32：循环冗余校验码，用于检查数据在存储或传输过程中是否发生了更改。</li>
</ul>
<p>如下图；</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+--------------------------------------------------+</span><br><span class="line">|     Header      |                     Data/Payload                  |</span><br><span class="line">+-----------------+--------------------------------------------------+</span><br><span class="line">| Record Type (1B)| Actual data written by the application...         |</span><br><span class="line">| Length (2B)     |                                                  |</span><br><span class="line">| CRC (4B)        |                                                  |</span><br><span class="line">+-----------------+--------------------------------------------------+</span><br></pre></td></tr></tbody></table></figure>

<p>写单条记录的实现如下，首先计算头部各个字段的值，然后将头部和数据部分写入到日志文件中。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="type">const</span> <span class="type">char</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">size_t</span> length)</span> </span>{</span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="type">char</span> buf[kHeaderSize];</span><br><span class="line">  buf[<span class="number">4</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(t);</span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="type">uint32_t</span> crc = crc32c::<span class="built_in">Extend</span>(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::<span class="built_in">Mask</span>(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">  <span class="built_in">EncodeFixed32</span>(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) {</span><br><span class="line">    s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(ptr, length));</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) {</span><br><span class="line">      s = dest_-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里计算 CRC32 的时候，用了<code>type_crc_[t]</code>，这个数组是在 Writer 的构造函数中用 InitTypeCrc 函数来进行初始化，这样可以提高计算效率，避免在每次写入记录时都重新计算 CRC32 校验码。如果没有初始化 type_crc_ 数组，其实也可以使用 <code>crc32c::Extend(0, ptr, length)</code> 来计算 CRC 校验码。不过这样的话，只计算了数据部分的 CRC 校验码，而没有考虑<strong>记录类型</strong>。用 type_crc_ 的话，把记录类型作为 crc32 计算的初始值，这样同样的内容，如果类型不同，计算出的 crc32 也不同。</p>
<p>这里提到了记录类型，代码中还记录了一个 <code>block_offset_</code>，这些又是做什么用的呢？这就是 AddRecord 中做的<strong>数据切分逻辑</strong>了。</p>
<h3 id="数据切分记录"><a href="#数据切分记录" class="headerlink" title="数据切分记录"></a>数据切分记录</h3><p><strong>在写数据的时候，如果单条数据太大，LevelDB 会将数据进行切分，分为多条记录，然后来一点点写入</strong>。经过切分后，一条数据可能就会包含多条记录，因此需要设计好<strong>记录组织格式</strong>，以便在读取时能够正确地重建完整的数据。这里 LevelDB 的做法比较直接，每条记录增加一个记录类型，用于标识是完整记录、第一部分、中间部分还是最后部分。这样在读取时，只要按照记录类型的顺序组装数据即可。这样一条数据可能分下面几种切分情况：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first(R1), middle(R1), middle(R1), ..., last(R1)</span><br><span class="line">first(R2), last(R2)</span><br><span class="line">full(R3)</span><br></pre></td></tr></tbody></table></figure>

<p>这里的 first、middle、last 和 full 分别表示记录的类型。所有的记录都放在<strong>逻辑块</strong>中，逻辑块的大小是 kBlockSize（32768=32KB），这个值在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/log_format.h#L27">db/log_format.h</a> 中定义。在切分数据的时候会保证，<strong>单条记录不跨越逻辑块</strong>。整体切分记录的逻辑在 AddRecord 中实现，主要是根据数据的大小，当前逻辑块剩余空间，然后判断是否需要切分。对于需要切分的场景，将数据切分记录，设置好正确的记录类型，然后调用 EmitPhysicalRecord 逐条写入。核心代码如下，去掉了部分注释和 assert 校验逻辑。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="type">const</span> Slice&amp; slice)</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ptr = slice.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">size_t</span> left = slice.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="type">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> {</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) {</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="built_in">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">""</span>);</span><br><span class="line">        dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));</span><br><span class="line">      }</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) {</span><br><span class="line">      type = kFullType;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (begin) {</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (end) {</span><br><span class="line">      type = kLastType;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  } <span class="keyword">while</span> (s.<span class="built_in">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意对于长度为 0 的数据，这里也会写入一条记录，记录类型为 fulltype，记录只含有头部，没有数据部分，有测试用例专门来验证这种情况。另外注意如果写入一些记录后，当前逻辑块剩余空间小于 7，不足以写入 Header，则会用 <code>\x00</code> 填充剩余空间，然后切换到下一个逻辑块。</p>
<p>这里<strong>判断当前记录类型的实现比较聪明</strong>，只需要维护两个标志 begin 和 end。刚开始写入数据的时候，begin 为 true，写入一条记录后，就更新 begin 为 false。end 的更新则是根据剩余数据长度是否为 0 来判断。然后根据 begin 和 end 的值，就可以确定当前记录的类型了。注意这里 if else 的顺序也很关键，即是 begin 又是 end 的说明是 kFullType 的记录；接着如果只是 begin，就是 kFirstType；如果只是 end，就是 kLastType，其他情况就是 kMiddleType。</p>
<p>这里有个设计值得思考下，<strong>切分记录的时候，为什么不跨逻辑块</strong>？其实如果看后面读取 WAL 日志部分代码，就会发现这样设计后可以按块进行读取。<strong>每个块内的记录都是完整的，这意味着不需要处理跨块的记录，大大简化了读取逻辑</strong>。另外，如果某个块损坏，只会影响该块内的记录，不会影响其他块的记录。</p>
<p>至此，将数据写入 WAL 日志文件的流程就介绍完了。下面我们来看看如何读取 WAL 日志文件。</p>
<h2 id="读-WAL-日志"><a href="#读-WAL-日志" class="headerlink" title="读 WAL 日志"></a>读 WAL 日志</h2><p>相比把数据切分记录然后写日志文件，读取日志并重构数据的逻辑稍微复杂一些。<a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/log_reader.h#L20">db/log_reader.h</a> 中定义了 Reader 类，用于从日志文件中读取数据。Reader 中主要的数据成员是 <code>SequentialFile* const file_;</code>，指向<strong>支持顺序读取的日志文件</strong>。和 WritableFile 类似，SequentialFile 也是在 include/leveldb/env.h 中定义的抽象类接口，封装了文件系统的顺序读取操作，具体接口和实现可以参考 <a href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%96%87%E4%BB%B6">LevelDB 源码阅读：Posix 文件操作接口实现细节</a>。</p>
<p>Reader 类的主要方法是 <code>ReadRecord</code>，用于读取一条完整的数据，可以多次调用，顺序读取出所有的数据。读取过程如果发生一些意外数据，比如记录长度不合法、CRC 校验失败等，可以用 Reader 中定义的 Reporter 接口来记录错误信息。此外，Reader 还支持跳过文件中一定长度的数据，用于恢复数据时跳过已经读取过的数据。完整的实现在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/log_reader.cc">db/log_reader.cc</a> 中，下面详细看看。</p>
<h3 id="跳过开头数据"><a href="#跳过开头数据" class="headerlink" title="跳过开头数据"></a>跳过开头数据</h3><p>Reader 中有一个 last_record_offset_ 记录当前读取到的最新一条完整数据的偏移量，初始化为 0。后续每次读取到 kFullType 或者 kLastType 类型的记录时，会更新这个值。在 ReadRecord 入口处，先判断 last_record_offset_ 和 initial_offset_ 的大小，这里 initial_offset_ 在构造时传入，用于指定跳过读取的数据长度。如果 last_record_offset_ 小于 initial_offset_，则需要跳过文件中开始的 initial_offset_ 部分。这里跳过开头部分的实现如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::SkipToInitialBlock</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> offset_in_block = initial_offset_ % kBlockSize;</span><br><span class="line">  <span class="type">uint64_t</span> block_start_location = initial_offset_ - offset_in_block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don't search a block if we'd be in the trailer</span></span><br><span class="line">  <span class="keyword">if</span> (offset_in_block &gt; kBlockSize - <span class="number">6</span>) {</span><br><span class="line">    block_start_location += kBlockSize;</span><br><span class="line">  }</span><br><span class="line">  end_of_buffer_offset_ = block_start_location;</span><br><span class="line">  <span class="comment">// Skip to start of first block that can contain the initial record</span></span><br><span class="line">  <span class="keyword">if</span> (block_start_location &gt; <span class="number">0</span>) {</span><br><span class="line">    Status skip_status = file_-&gt;<span class="built_in">Skip</span>(block_start_location);</span><br><span class="line">    <span class="keyword">if</span> (!skip_status.<span class="built_in">ok</span>()) {</span><br><span class="line">      <span class="built_in">ReportDrop</span>(block_start_location, skip_status);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里有个特殊的情况，如果 initial_offset_ 恰好位于一个逻辑块的末尾，这时候需要跳过这整个逻辑块。判断是否处于逻辑块的末尾比较简单，直接拿 initial_offset_ 取模逻辑块的大小(32kb)，如果剩余部分刚好在逻辑块的最后 6 个字节内，则说明处于逻辑块的尾部。注意这里跳的时候，只会跳过整个逻辑块，只保证了从 initial_offset_ 所在的<strong>逻辑块头部</strong>开始读取。可能导致读取到的第一条记录的偏移量小于 initial_offset_，这种情况在后面的 ReadPhysicalRecord 中会处理。</p>
<h3 id="解析一条完整数据"><a href="#解析一条完整数据" class="headerlink" title="解析一条完整数据"></a>解析一条完整数据</h3><p>ReadRecord 用于从日志文件中读取一条完整的数据，这里的完整数据可能包括多条记录，要把每一条都读出来然后拼接。</p>
<p>首先用 <strong>in_fragmented_record</strong> 来标记目前是否处于一个<strong>拆分的记录</strong>中，初始化为 false。然后进入一个 while 循环，不断调用 ReadPhysicalRecord 读取出记录，保存在 fragment 中，然后根据记录类型进行处理。注意这里有一个 <code>resyncing_</code>，在初始化的时候，如果有需要跳过的数据(initial_offset_&gt;0)，则会设置为 true，表示当前处于跳过数据的状态。在这种状态下，只要读取到 kFullType 类型的记录，就会更新 resyncing_ 为 false，表示跳过数据结束，开始正常读取数据。</p>
<p>读取数据部分，会根据当前记录的类型来判断是否需要拼接数据。</p>
<ul>
<li>如果是 kFullType 类型，说明这是一条完整的数据，直接将 fragment 设置为 result，更新 last_record_offset_；</li>
<li>如果是 kFirstType 类型，说明这是一条新的数据，将这条记录保存在 scratch 中，设置 in_fragmented_record 为 true；</li>
<li>如果是 kMiddleType 类型，说明这是一个数据的中间部分，in_fragmented_record 此时必须为 true，否则就报告错误。这时候 scratch 继续拼接新的记录。</li>
<li>如果是 kLastType 类型，说明这是一个数据的最后部分，in_fragmented_record 此时必须为 true，否则就报告错误。将最后部分的 fragment 拼接在 scratch 中，然后将 scratch 设置为 result，更新 last_record_offset_ 后返回。</li>
</ul>
<p>接着其实还有其他记录类型，比如 kEof 和 kBadRecord，这些都是异常情况，需要特殊处理。ReadRecord 核心逻辑如下，忽略掉部分错误处理的代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::ReadRecord</span><span class="params">(Slice* record, std::string* scratch)</span> </span>{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  record-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">bool</span> in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">  Slice fragment;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> record_type = <span class="built_in">ReadPhysicalRecord</span>(&amp;fragment);</span><br><span class="line">    <span class="keyword">if</span> (resyncing_) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (record_type) {</span><br><span class="line">      <span class="keyword">case</span> kFullType:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *record = fragment;</span><br><span class="line">        last_record_offset_ = prospective_record_offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">case</span> kFirstType:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        scratch-&gt;<span class="built_in">assign</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        in_fragmented_record = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kMiddleType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) {</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">"missing start of fragmented record(1)"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kLastType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) {</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">"missing start of fragmented record(2)"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">          *record = <span class="built_in">Slice</span>(*scratch);</span><br><span class="line">          last_record_offset_ = prospective_record_offset;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h3 id="读取单个逻辑块"><a href="#读取单个逻辑块" class="headerlink" title="读取单个逻辑块"></a>读取单个逻辑块</h3><p>ReadPhysicalRecord <strong>封装了从逻辑块提取记录的过程</strong>。一个逻辑块的大小是 kBlockSize=32KB，这个值在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/log_format.h#L27">db/log_format.h</a> 中定义。我们从磁盘读取文件的时候，<strong>以逻辑块为最小读取单元</strong>，读出来后缓存在内存中，然后逐条解析记录。这里最外层是一个 while 循环，首先判断 buffer_ 的大小，如果 buffer_ 中的数据不足以解析出一条记录(长度小于 kHeaderSize)，则从文件中读取一个逻辑块的数据到 buffer_ 中。</p>
<ul>
<li>如果从文件读取出来的长度小于 kBlockSize，说明读到了文件末尾，则设置 eof_ 为 true，然后继续进来循环，清空 buffer_ 中的数据，然后返回 kEof。</li>
<li>如果读文件出错，用 ReportDrop 报告读失败，清理 buffer_，设置 eof_ 为 true，然后直接返回 kEof。 </li>
<li>如果成功读取到 kBlockSize 的内容到 buffer_ ，则接着开始解析记录。</li>
</ul>
<p>当然，一个逻辑块 Block 中可能有多条记录，每次解析一条后 ReadPhysicalRecord 就会返回。这里返回前会更新 buffer_ 的指针，指向下一条记录的开始位置。下次重新进入 ReadPhysicalRecord 后，判断 buffer_ 中还有记录(长度大于 kHeaderSize)，则不会从文件读取，直接接着上次的位置从 buffer_ 中解析。</p>
<p>具体解析记录的代码和上面写记录的相反，先从 Header 中解析长度，crc32 等信息，然后把记录数据保存在 result 中，接着更新 buffer_ 的数据，指向下一条记录的开始位置。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Reader::ReadPhysicalRecord</span><span class="params">(Slice* result)</span> </span>{</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="keyword">if</span> (buffer_.<span class="built_in">size</span>() &lt; kHeaderSize) {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* header = buffer_.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">4</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">5</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> type = header[<span class="number">6</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    buffer_.<span class="built_in">remove_prefix</span>(kHeaderSize + length);    <span class="comment">// 指向下一条记录的开始位置</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *result = <span class="built_in">Slice</span>(header + kHeaderSize, length);</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码注释了一些异常处理部分逻辑，比如记录长度不合法，CRC 校验失败。这里的异常处理主要是通过 Reporter 接口来记录错误信息，然后清空 buffer_。这样即使在读取过程中发生了一些异常，最多只影响当前 buffer_ 解析，不会影响后续逻辑块的读取和解析。</p>
<p>还有一种异常是<strong>当前记录位于跳过的 initial_offset_ 范围内</strong>，这是因为前面我们跳过的时候，只跳过整个逻辑块，保证从 initial_offset_ <strong>所在的逻辑块头部</strong>开始读。如果当前记录的偏移量小于 initial_offset_，则说明这条记录是需要跳过的，调整 buffer_ 的开始部分，然后返回 kBadRecord。</p>
<h2 id="WAL-读写测试"><a href="#WAL-读写测试" class="headerlink" title="WAL 读写测试"></a>WAL 读写测试</h2><p><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/log_test.cc">db/log_test.cc</a> 中提供了一些工具辅助类和函数，以及详细的测试用例，来完整测试这里的 WAL 日志读写。比如用 BigString 生成指定长度的字符串，LogTest 类封装了 Reader 和 Writer 的读写逻辑，暴露了方便测试的接口，比如 Write、ShrinkSize、Read 等。此外这里没有直接读取文件，而是自己实现了 StringSource 类，继承自 SequentialFile，用 string 模拟读文件。实现了 StringDest 类，继承自 WritableFile，也是用 string 模拟写文件。</p>
<p>下面是一些正常读写的测试 case：</p>
<ul>
<li>Empty：测试直接读空文件，返回 EOF。</li>
<li>ReadWrite：测试简单的写入和读取，确保写入的数据能够正确读取。这里写入了一个空字符串，也是能正常读出来。</li>
<li>ManyBlocks：测试写入大量不同长度字符串，占用多个逻辑块。然后逐条读取，确保能够正确读取。</li>
<li>Fragmentation：测试写入超大的字符串，每条数据需要占用多条记录。然后逐条读取，确保能够正确读取。</li>
</ul>
<p>此外还构造了一些异常情况的测试 case，比如 TruncatedTrailingRecordIsIgnored 在 LevelDB 的日志系统中用于验证对<strong>日志文件末尾被截断的记录</strong>的处理。当日志文件的最后一个记录未能完整写入（例如，由于系统崩溃或者其他写入中断事件）时，这个不完整的记录会被忽略而不是被视为一个错误。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(LogTest, TruncatedTrailingRecordIsIgnored) {</span><br><span class="line">  <span class="built_in">Write</span>(<span class="string">"foo"</span>);</span><br><span class="line">  <span class="built_in">ShrinkSize</span>(<span class="number">4</span>);  <span class="comment">// Drop all payload as well as a header byte</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">"EOF"</span>, <span class="built_in">Read</span>());</span><br><span class="line">  <span class="comment">// Truncated last record is ignored, not treated as an error.</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">0</span>, <span class="built_in">DroppedBytes</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">""</span>, <span class="built_in">ReportMessage</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>BadLength 用来验证在处理记录长度字段被破坏（corrupted）的情况下的行为。测试确保日志系统能正确识别并且忽略由于<strong>记录长度字段错误导致的不合法记录</strong>，同时能够继续读取之后的有效记录，并且报告适当的错误信息。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(LogTest, BadLength) {</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> kPayloadSize = kBlockSize - kHeaderSize;</span><br><span class="line">  <span class="built_in">Write</span>(<span class="built_in">BigString</span>(<span class="string">"bar"</span>, kPayloadSize));</span><br><span class="line">  <span class="built_in">Write</span>(<span class="string">"foo"</span>);</span><br><span class="line">  <span class="comment">// Least significant size byte is stored in header[4].</span></span><br><span class="line">  <span class="built_in">IncrementByte</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">"foo"</span>, <span class="built_in">Read</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kBlockSize, <span class="built_in">DroppedBytes</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">"OK"</span>, <span class="built_in">MatchError</span>(<span class="string">"bad record length"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里用 IncrementByte 把第 4 个字节地方的值加 1，该位置存储的是记录的长度信息，因此导致记录长度增加。在读取的时候，会发现记录长度不合法，然后报告错误信息。校验长度部分逻辑在 ReadPhysicalRecord 中，如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kHeaderSize + length &gt; buffer_.<span class="built_in">size</span>()) {</span><br><span class="line">  <span class="type">size_t</span> drop_size = buffer_.<span class="built_in">size</span>();</span><br><span class="line">  buffer_.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">if</span> (!eof_) {</span><br><span class="line">    <span class="built_in">ReportCorruption</span>(drop_size, <span class="string">"bad record length"</span>);</span><br><span class="line">    <span class="keyword">return</span> kBadRecord;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> kEof;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此外，还构造了大量的测试 case，用来验证初始跳过长度。这里封装了一个函数 CheckInitialOffsetRecord，来验证初始跳过长度的记录是否被正确跳过。这个函数会写入一些记录，然后设置 initial_offset_ 来读取记录，验证是否跳过了 initial_offset_ 长度的记录。</p>
<p>通过大量的测试用例，保证了 WAL 日志的读写逻辑的正确性。这里的测试用例也是非常值得学习的，可以帮助我们更好地理解 WAL 日志的读写逻辑。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：LevelDB 源码阅读：读写 WAL 日志保证持久性</p><p>本文链接为：https://selfboot.cn/2024/08/14/leveldb_source_wal_log/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2024/08/14/leveldb_source_wal_log/';
    this.page.identifier = '2024/08/14/leveldb_source_wal_log/';
    this.page.title = 'LevelDB 源码阅读：读写 WAL 日志保证持久性';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (23)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (32)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2024/08/14/leveldb_source_wal_log/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/06/27/leveldb_source_table_build/" title="LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程">LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程</a></li><li><a href="/2025/06/13/leveldb_source_LRU_cache/" title="LevelDB 源码阅读：LRU Cache 高性能缓存实现细节">LevelDB 源码阅读：LRU Cache 高性能缓存实现细节</a></li><li><a href="/2025/06/11/leveldb_source_memtable/" title="LevelDB 源码阅读：MemTable 内存表的实现细节">LevelDB 源码阅读：MemTable 内存表的实现细节</a></li><li><a href="/2025/06/10/leveldb_mvcc_intro/" title="LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)">LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)</a></li><li><a href="/2025/05/23/mcp_user_report/" title="使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?">使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?</a></li><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99-WAL-%E6%97%A5%E5%BF%97"><span class="toc-number">1.</span> <span class="toc-text">写 WAL 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">单条记录存储格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%87%E5%88%86%E8%AE%B0%E5%BD%95"><span class="toc-number">1.2.</span> <span class="toc-text">数据切分记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB-WAL-%E6%97%A5%E5%BF%97"><span class="toc-number">2.</span> <span class="toc-text">读 WAL 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BF%87%E5%BC%80%E5%A4%B4%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.</span> <span class="toc-text">跳过开头数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E4%B8%80%E6%9D%A1%E5%AE%8C%E6%95%B4%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.</span> <span class="toc-text">解析一条完整数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%8D%95%E4%B8%AA%E9%80%BB%E8%BE%91%E5%9D%97"><span class="toc-number">2.3.</span> <span class="toc-text">读取单个逻辑块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WAL-%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">WAL 读写测试</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p><p>友情链接：<a rel="dofollow" target="_blank" href="https://puzzles-game.com/">益智游戏</a></p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>