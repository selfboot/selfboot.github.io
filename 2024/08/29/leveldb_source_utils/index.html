<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本文探讨了 LevelDB 中的核心工具组件实现，包括Arena内存分配器、Random随机数生成器、CRC32循环冗余校验和整数编解码工具。分析了这些组件的设计考量、实现细节和优化策略，展示了它们如何高效地支持LevelDB的各种操作。"><title>LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}
</script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7746897490519544" crossorigin="anonymous"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"><i class="fa fa-scale-balanced"></i><span> 法律普及</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码</h1><div class="post-meta">2024/08/29<span> | </span><span class="category"><a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/08/29/leveldb_source_utils/" href="/2024/08/29/leveldb_source_utils/#disqus_thread"></a><div class="post-content"><p>LevelDB 中实现了不少 utils 工具，比如定制的内存分配器 Arena，随机数生成类 Random，实现中都会考虑到具体的使用场景，做了优化以及取舍，值得好好学习。本篇文章主要聊聊下面部分的实现：</p>
<ul>
<li>内存管理 Arena，一个简单高效，适合 LevelDB 的内存分配管理器；</li>
<li>随机数 Random，一个不错的<strong>线性同余伪随机生成</strong>算法，用位运算替代取模优化了执行效率。</li>
<li>CRC32 循环冗余校验，用于检测数据传输或存储过程中是否发生错误；</li>
<li>整数编、解码，用于将数字存储在字节流或者从字节流中解析数字。</li>
</ul>
<p>此外，还有些 utils 组件比较复杂些，会放在单独的文章里聊，比如：</p>
<ul>
<li><a href="https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/">LevelDB 源码阅读：禁止对象被析构</a> 讲在 C++中如何禁止某个对象被析构，以为这样做的原因。</li>
</ul>
<span id="more"></span>

<h2 id="内存管理-Arena-类"><a href="#内存管理-Arena-类" class="headerlink" title="内存管理 Arena 类"></a>内存管理 Arena 类</h2><p>LevelDB <strong>没有直接使用</strong>系统默认的 malloc 来分配内存，也没有使用 tcmalloc 等第三方库来管理内存的分配和释放，而是自己实现了一个简单的内存分配器。这里的内存分配器可以说是<strong>量身订制</strong>，主要基于下面考虑：</p>
<ol>
<li>主要在 memtable 中使用，会有大量的分配，可能有很多小内存分配；</li>
<li>统一回收时机，在 memtable 数据落磁盘后，会一并回收；</li>
</ol>
<p>内存 memtable 的数据其实存储在 skiplist 中的。每次插入 key，就需要往 skiplist 中插入节点，这里节点使用的内存就是用 arena 来分配的。如果是小 key，这里会优先从当前 block 剩余内存中拿，不够的话才会走到分配逻辑。<a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/arena.h#L55">Allocate</a> 的代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>{</span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) {</span><br><span class="line">    <span class="type">char</span>* result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过系统调用分配内存的逻辑在 AllocateFallback 中，如果需要的内存大于 kBlockSize / 4，则按照实际需要分配。否则的话，就直接分配一个 block 的内存，然后更新使用情况。这里没有用完的内存余量，可以在下次分配内存的时候使用。如果不够下次需要的量，则重新走系统调用来分配。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) {</span><br><span class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></span><br><span class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We waste the remaining space in the current block.</span></span><br><span class="line">  alloc_ptr_ = <span class="built_in">AllocateNewBlock</span>(kBlockSize);</span><br><span class="line">  alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* result = alloc_ptr_;</span><br><span class="line">  alloc_ptr_ += bytes;</span><br><span class="line">  alloc_bytes_remaining_ -= bytes;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种方法可能会导致一些<strong>内存浪费</strong>，比如第一次使用 496 byte，实际会分配 4096 byte，剩余 3600 byte。然后下一次使用超过 3600 byte 的话，就会重新申请新的内存，上次分配剩余的 3600 byte 就会被浪费掉。虽然浪费了一定的内存使用率，不过整体代码比较简单，分配效率也比较高。这部分被浪费掉的内存，在 memtable 落磁盘后也会被重新回收掉。</p>
<p>顺便再提一下这里最后的内存回收，每次调用 <code>new []</code> 分配内存后，会把首地址放到 vector 中，然后在 Arena 类析构的时候，遍历拿出所有的内存块，统一进行释放。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> </span>{</span><br><span class="line">  <span class="type">char</span>* result = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">  blocks_.<span class="built_in">push_back</span>(result);</span><br><span class="line">  memory_usage_.<span class="built_in">fetch_add</span>(block_bytes + <span class="built_in">sizeof</span>(<span class="type">char</span>*),</span><br><span class="line">                          std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">Arena::~<span class="built_in">Arena</span>() {</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">delete</span>[] blocks_[i];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此外这个类还提供了一个原子计数器 <code>memory_usage_</code>，统计这个类目前占用的内存大小。</p>
<h2 id="随机数-Random-类"><a href="#随机数-Random-类" class="headerlink" title="随机数 Random 类"></a>随机数 Random 类</h2><p>LevelDB 的 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/random.h">util/random.h</a> 中实现了一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">伪随机数生成器(PRNG)</a>类 Random，用在<strong>跳表生成层高</strong>等场景。这个随机数生成器是基于线性同余生成器（LCG）实现，随机数的生成公式如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seed_ = (seed_ * A) % M</span><br></pre></td></tr></tbody></table></figure>

<p>根据同余理论，只要 A 和 M 被适当选取，那么上述递推公式将能生成一个周期为 M 的伪随机数序列，且这个序列中不会有重复的数(除了最初的值)。这里模数 M 的值 $ 2^{31}-1 $ 是一个常见的选择，因为它是一个<strong>梅森素数（Mersenne prime）</strong>，有利于生成具有良好周期性的随机序列。</p>
<p>构造函数接收一个 32 位无符号整数作为种子（seed_），并确保种子落在有效范围内（非 0 且不等于 2147483647L，即 $ 2^{31}-1 $）。这是因为种子的值直接影响随机数生成过程，而这两个特定的值（0 和 $ 2^{31}-1 $）在计算过程中会导致生成的序列失去随机性。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Random</span><span class="params">(<span class="type">uint32_t</span> s)</span> : seed_(s &amp; <span class="number">0x7fffffff</span>u) {</span></span><br><span class="line">  <span class="comment">// Avoid bad seeds.</span></span><br><span class="line">  <span class="keyword">if</span> (seed_ == <span class="number">0</span> || seed_ == <span class="number">2147483647L</span>) {</span><br><span class="line">    seed_ = <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>生成随机数的代码很精简，如下（忽略原有注释）：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Next</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> M = <span class="number">2147483647L</span>;  <span class="comment">// 2^31-1</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> A = <span class="number">16807</span>;        <span class="comment">// bits 14, 8, 7, 5, 2, 1, 0</span></span><br><span class="line">  <span class="type">uint64_t</span> product = seed_ * A;</span><br><span class="line">  seed_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;((product &gt;&gt; <span class="number">31</span>) + (product &amp; M));</span><br><span class="line">  <span class="keyword">if</span> (seed_ &gt; M) {</span><br><span class="line">    seed_ -= M;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> seed_;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先是 <code>product = seed_ * A</code>，这里乘积 product 可能会超出 32 位的范围，为了<strong>防止溢出</strong>使用 uint64_t 来保持这个中间结果。顺便提醒下血泪的教训，<strong>整数的加减乘除一定要考虑溢出场景，很多软件都有因为溢出导致的漏洞</strong>。然后这里 product%M 模运算<strong>用了位操作和加法来代替</strong>，以提高计算效率。</p>
<p>这里主要是基于<strong>模运算的分配律</strong>：$ (a + b) \mod m = ((a \mod m) + (b \mod m)) \mod m $，将 product 分为 <code>product &gt;&gt; 31 + product &amp; M</code>，因为 M = $ 2^{31}-1 $，这里的与运算取 product 的低31位。</p>
<p>除了基本的随机数生成，Random 类还提供了生成特定范围内随机数的 <code>Uniform()</code> 方法，以及概率性返回真或假的 <code>OneIn()</code> 方法和生成偏向小数的 <code>Skewed()</code> 方法，这些都是在特定场景下非常有用的工具函数。</p>
<p>Skewed 的实现比较有意思，首先从 [0, max_log] 范围内均匀选择一个基数 base，接着用 <code>Uniform(1 &lt;&lt; base)</code> 返回 $ [0, 2^{base} - 1]$ 范围内的一个随机数。这里基数 base 的选择概率是均匀的，这意味着选择一个较小的 base（从而生成较小的随机数）与选择一个较大的 base（从而生成较大的随机数）的概率是相同的。然而，由于 base 的值越小，能生成的随机数的范围就越小，这自然导致了<strong>函数倾向于生成较小的数值</strong>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Skewed: pick "base" uniformly from range [0,max_log] and then</span></span><br><span class="line"><span class="comment">// return "base" random bits.  The effect is to pick a number in the</span></span><br><span class="line"><span class="comment">// range [0,2^max_log-1] with exponential bias towards smaller numbers.</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Skewed</span><span class="params">(<span class="type">int</span> max_log)</span> </span>{ <span class="keyword">return</span> <span class="built_in">Uniform</span>(<span class="number">1</span> &lt;&lt; <span class="built_in">Uniform</span>(max_log + <span class="number">1</span>)); }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="CRC32-循环冗余校验"><a href="#CRC32-循环冗余校验" class="headerlink" title="CRC32 循环冗余校验"></a>CRC32 循环冗余校验</h2><p>CRC（<strong>Cyclic Redundancy Check，循环冗余检查</strong>）是一种通过特定算法来计算数据的校验码的方法，广泛用于<strong>网络通讯和数据存储系统</strong>中以检测数据在传输或存储过程中是否发生错误。CRC32是一种常见的CRC算法，使用了一个32位的校验和。</p>
<p>CRC 的计算基于<strong>多项式除法</strong>，处理的数据被视为一个巨大的多项式，通过<strong>这个多项式除以另一个预定义的“生成多项式”</strong>，然后取余数作为输出的CRC值。CRC算法具有天然的<strong>流式计算特性</strong>，可以先计算消息的一部分的CRC，然后将这个结果作为下一部分计算的初始值（init_crc）。下面的 <code>Extend</code> 函数接受一个初始的 CRC 值（可能是之前数据块的CRC结果），然后计算加上新的数据块后的CRC值。这使得 LevelDB 能够在不断追加数据时连续计算CRC，而不需要每次都从头开始。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the crc32c of concat(A, data[0,n-1]) where init_crc is the</span></span><br><span class="line"><span class="comment">// crc32c of some string A.  Extend() is often used to maintain the</span></span><br><span class="line"><span class="comment">// crc32c of a stream of data.</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Extend</span><span class="params">(<span class="type">uint32_t</span> init_crc, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the crc32c of data[0,n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Value</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> n)</span> </span>{ <span class="keyword">return</span> <span class="built_in">Extend</span>(<span class="number">0</span>, data, n); }</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/crc32c.cc">crc32c.cc</a> 中的实现比较比较复杂，涉及到查找表（table-driven approach）、数据对齐、和可能的硬件加速，具体的原理可以参考 <a target="_blank" rel="noopener" href="http://www.ross.net/crc/download/crc_v3.txt">A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS</a>。其中<strong>生成多项式</strong>的选择对CRC算法的有效性和错误检测能力至关重要。生成多项式并不是随意选取的，它们通常通过数学和计算机模拟实验被设计出来，以确保最大化特定数据长度和特定应用场景下的错误检测能力，常见的生成多项式<code>0x04C11DB7</code> 就是在IEEE 802.3标准中为 CRC-32 算法选定的。</p>
<p>这里补充说下，CRC 只是用来<strong>检测随机错误</strong>，比如网络传输或者磁盘存储中某些比特位发生了翻转。它不是纠错校验码，只能检测到错误，并<strong>不能纠正错误</strong>。我们可以故意对内容进行篡改然后保证 CRC 结果一样，如果要防篡改，要用到更为复杂的加密哈希函数或者数字签名技术。</p>
<p>另外在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/crc32c.h">crc32c.h</a> 中还看到有一个 Mask，这里代码注释也写的很清楚了，如果数据本身包含CRC值，然后直接在包含CRC的数据上再次计算CRC，可能会降低CRC的错误检测能力。因此，LevelDB 对CRC值进行高低位交换后加上一个常数（kMaskDelta），来“掩码”原始的CRC值。这种变换后的CRC值可以存储在文件中，当要验证数据完整性时，使用 Unmask 函数将掩码后的CRC值转换回原始的CRC值，再与当前数据的CRC计算结果进行比较。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a masked representation of crc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Motivation: it is problematic to compute the CRC of a string that</span></span><br><span class="line"><span class="comment">// contains embedded CRCs.  Therefore we recommend that CRCs stored</span></span><br><span class="line"><span class="comment">// somewhere (e.g., in files) should be masked before being stored.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Mask</span><span class="params">(<span class="type">uint32_t</span> crc)</span> </span>{</span><br><span class="line">  <span class="comment">// Rotate right by 15 bits and add a constant.</span></span><br><span class="line">  <span class="keyword">return</span> ((crc &gt;&gt; <span class="number">15</span>) | (crc &lt;&lt; <span class="number">17</span>)) + kMaskDelta;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the crc whose masked representation is masked_crc.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Unmask</span><span class="params">(<span class="type">uint32_t</span> masked_crc)</span> </span>{</span><br><span class="line">  <span class="type">uint32_t</span> rot = masked_crc - kMaskDelta;</span><br><span class="line">  <span class="keyword">return</span> ((rot &gt;&gt; <span class="number">17</span>) | (rot &lt;&lt; <span class="number">15</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里其实有个有意思的地方，原始 CRC32 值交换高 15 位后，加上常量后可能会大于 uint32_t 的最大值，<strong>导致溢出</strong>。<strong>在 C++ 中，无符号整型的溢出行为是定义良好的，按照取模运算处理</strong>。比如当前 crc 是 32767，这里移动后加上常量，结果是7021325016，按照 $ 2^{32} $ 取模后结果是 2726357720。而在 Unmask 中的减法操作，同样会溢出，C++中这里也是按照取模运算处理的。这里 $ 2726357720-kMaskDelta = -131072 $ 按照 $ 2^{32} $ 后结果是 4294836224，再交换高低位就拿到了原始 CRC 32767 了，所以<strong>这里的溢出不会导致 bug 的哦</strong>。</p>
<h2 id="整数编、解码"><a href="#整数编、解码" class="headerlink" title="整数编、解码"></a>整数编、解码</h2><p>LevelDB 中经常需要将数字存储在字节流或者从字节流中解析数字，比如 key 中存储长度信息，在批量写的任务中存储序列号等。在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/coding.h">util/coding.h</a> 中定义了一系列编码和解码的工具函数，方便在字节流中存储和解析数字。首先来看固定长度的编、解码，主要有下面几个函数：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed32</span><span class="params">(std::string* dst, <span class="type">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed64</span><span class="params">(std::string* dst, <span class="type">uint64_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> value)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>以 32 位的编码为例，<code>PutFixed32</code> 函数将一个 32 位的无符号整数 value 编码为 4 个字节，然后追加到 dst 字符串的末尾。<code>EncodeFixed32</code> 函数则将 value 编码为 4 个字节，存储到 dst 指向的内存中。PutFixed32 底层以 EncodeFixed32 为基础，只是将结果追加到了 dst 字符串中。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> value)</span> </span>{</span><br><span class="line">  <span class="type">uint8_t</span>* <span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  buffer[<span class="number">0</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value);</span><br><span class="line">  buffer[<span class="number">1</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buffer[<span class="number">2</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  buffer[<span class="number">3</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先通过 <code>reinterpret_cast&lt;uint8_t*&gt;(dst)</code> 将 <code>char*</code> 类型的指针转换为 <code>uint8_t*</code> 类型，使得后续可以直接操作单个字节。然后使用位移和掩码操作将 value 的每一个字节分别写入到 buffer 数组中，<strong>value 的低位字节存储在低地址中（小端序）</strong>。假设我们有一个 uint32_t 的数值 0x12345678（十六进制表示），我们想将这个值编码到一个字符数组中，然后再从数组中解码出来。</p>
<ul>
<li>buffer[0] 存储 value 的最低8位，即 0x78。</li>
<li>buffer[1] 存储 value 的次低8位，即 0x56。</li>
<li>buffer[2] 存储 value 的次高8位，即 0x34。</li>
<li>buffer[3] 存储 value 的最高8位，即 0x12。</li>
</ul>
<p>编码完之后，dst 中的内容将是：<code>78 56 34 12</code>。解码的过程就是将这 4 个字节按照相反的顺序组合起来，得到原始的 value 值。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">DecodeFixed32</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ptr)</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* <span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / ldr instruction.</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">0</span>])) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>除了将整数编码为固定长度的字节，LevelDB 还支持使用变长整数（Varint）编码来存储数字。因为很多时候，需要存的是范围很广但常常偏小的值，这时候都用 4 个字节来存储整数有点浪费。Varint 是一种高效的数据压缩方法，小的数值占用的字节少，可以节省空间。</p>
<p>Varint 原理很简单，使用一个或多个字节来存储整数的方法，其中<strong>每个字节的最高位（第8位）用来表示是否还有更多的字节</strong>。如果这一位是1，表示后面还有字节；如果是0，表示这是最后一个字节。剩下的7位用来存储实际的数字值。下图展示了从一个到三个字节的 varint 编码（更多字节类似，这里不列出）：</p>
<table>
<thead>
<tr>
<th>数值范围</th>
<th>Varint 字节表达式</th>
</tr>
</thead>
<tbody><tr>
<td>1-127</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>128-16383</td>
<td>1xxxxxxx 0xxxxxxx</td>
</tr>
<tr>
<td>16384-2097151</td>
<td>1xxxxxxx 1xxxxxxx 0xxxxxxx</td>
</tr>
</tbody></table>
<p>具体实现中，EncodeVarint32 和 EncodeVarint64 略有不同，32 位的直接先判断需要的字节数，然后硬编码写入。64 位的则是循环写入，每次处理 7 位，直到数值小于 128。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> v)</span> </span>{</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="type">uint8_t</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) {</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  }</span><br><span class="line">  *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当然，这里是编码，对应有从字节流中解码出 Varint 的实现。主要实现如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetVarint64Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">const</span> <span class="type">char</span>* limit, <span class="type">uint64_t</span>* value)</span> </span>{</span><br><span class="line">  <span class="type">uint64_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">63</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) {</span><br><span class="line">    <span class="type">uint64_t</span> byte = *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) {</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(p);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里是编码的逆过程，成功解码一个整数后，它会返回一个新的指针，指向字节流中紧跟着解码整数之后的位置。GetVarint64 函数用这个实现，从 input 中解析出一个 64 位整数后，还更新了 input 的状态，<strong>使其指向剩余未处理的数据</strong>。这里更新字节流，对于连续处理数据流中的多个数据项非常有用，例如在解析由多个 varint 编码的整数组成的数据流时，每次调用 GetVarint64 后，input 都会更新，准备好解析下一个整数。</p>
<p>这里还一类辅助函数，比如 PutLengthPrefixedSlice 用于将一个字符串编码为一个长度前缀和字符串内容的组合，而 GetLengthPrefixedSlice 则是对应的解码函数。这些编码和解码函数在 LevelDB 中被广泛应用，用于存储和解析各种数据结构，比如 memtable 中的 key 和 value，SSTable 文件的 block 数据等。</p>
<p>这里整数的编、解码配有大量的测试用例，放在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/coding_test.cc">util/coding_test.cc</a> 中。里面有正常的编码和校对测试，比如 0 到 100000 的 Fixed32 的编、解码校验。此外还有一些<strong>异常测试</strong>，比如错误的 Varint32 的解码用例 Varint32Overflow，用 GetVarint32Ptr 来解码 “\x81\x82\x83\x84\x85\x11”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LevelDB 中的 utils 组件都是为了更好的适应 LevelDB 的使用场景，比如 Arena 内存分配器适合 memtable 的大量小内存分配，Random 随机数生成器用于跳表的层高生成，CRC32 用于数据传输或存储过程中的错误检测，编解码工具函数用于存储和解析数字。</p>
<p>本文只是简单介绍这些组件的实现，并没有过多涉及这些组件背后的数学知识，比如随机数生成器的线性同余算法、CRC32 的多项式除法等。有兴趣的话，大家可以继续深入研究。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码</p><p>本文链接为：https://selfboot.cn/2024/08/29/leveldb_source_utils/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2024/08/29/leveldb_source_utils/';
    this.page.identifier = '2024/08/29/leveldb_source_utils/';
    this.page.title = 'LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (19)</li><li><a href="/categories/法律普及/">法律普及</a> (8)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (31)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/法律/" style="font-size: 15.00px;">法律</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/刑事/" style="font-size: 15.00px;">刑事</a> <a href="/tags/婚姻家庭/" style="font-size: 15.00px;">婚姻家庭</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2024/08/29/leveldb_source_utils/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li><li><a href="/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB 源码阅读：如何分析跳表的时间复杂度？">LevelDB 源码阅读：如何分析跳表的时间复杂度？</a></li><li><a href="/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB 源码阅读：如何正确测试跳表的并行读写？">LevelDB 源码阅读：如何正确测试跳表的并行读写？</a></li><li><a href="/2024/09/13/gpto1_hands_on/" title="实际例子上手体验 OpenAI o1-preview，比预期差一点？">实际例子上手体验 OpenAI o1-preview，比预期差一点？</a></li><li><a href="/2024/09/09/leveldb_source_skiplist/" title="LevelDB 源码阅读：跳表的原理、实现以及可视化">LevelDB 源码阅读：跳表的原理、实现以及可视化</a></li><li><a href="/2024/09/05/claude35_prompt/" title="Claude3.5 系统提示词解密：不道歉、脸盲、幻觉...">Claude3.5 系统提示词解密：不道歉、脸盲、幻觉...</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Arena-%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">内存管理 Arena 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0-Random-%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">随机数 Random 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CRC32-%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">CRC32 循环冗余校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%BC%96%E3%80%81%E8%A7%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">整数编、解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>