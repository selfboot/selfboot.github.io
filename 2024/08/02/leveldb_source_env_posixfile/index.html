<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="文章详细介绍了 LevelDB 抽象的文件操作，包括顺序读写、随机读取文件在 Posix 下的实现，以及如何通过抽象接口适配不同操作系统。还介绍了缓冲区优化、资源限制管理、灵活读取策略等关键设计，来提升系统的性能和可用性。此外还有工厂方法模式的应用、错误处理机制和跨平台兼容性考虑等实现细节。"><title>LevelDB 源码阅读：Posix 文件操作接口实现细节</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}
</script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7746897490519544" crossorigin="anonymous"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"><i class="fa fa-scale-balanced"></i><span> 法律普及</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB 源码阅读：Posix 文件操作接口实现细节</h1><div class="post-meta">2024/08/02<span> | </span><span class="category"><a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/08/02/leveldb_source_env_posixfile/" href="/2024/08/02/leveldb_source_env_posixfile/#disqus_thread"></a><div class="post-content"><p>LevelDB 支持在各种操作系统上运行，为了适配不同的操作系统，需要封装一些系统调用，比如文件操作、线程操作、时间操作等。在对外暴露的 include 文件中，<a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h">env.h</a> 文件定义了 LevelDB 用到的各种接口。包括 Env 类，封装文件操作，目录操作等，还有一些文件抽象类，比如 SequentialFile、WritableFile、RandomAccessFile 3 个类，用于顺序读取，随机读取和写入文件。</p>
<p>通过抽象接口，只需要为每个平台实现相应的 Env 子类，LevelDB 就可以在不同的操作系统上运行。这篇文章以 POSIX 系统环境为例，先来看看抽象出来的和<strong>文件操作相关的接口</strong>是怎么实现的。</p>
<span id="more"></span>

<h2 id="顺序读文件"><a href="#顺序读文件" class="headerlink" title="顺序读文件"></a>顺序读文件</h2><p>首先看看<strong>顺序读文件</strong>的抽象基类 SequentialFile，它为文件的顺序读取和跳过操作提供了一个标准的接口，可以用于 WAL 日志文件的读取。类中定义了2个主要的虚函数：</p>
<ul>
<li>Read(size_t n, Slice* result, char* scratch)：这个函数用于从文件中读取多达 n 字节的数据。result 是一个指向 Slice 类型的指针，用来存储读取的数据。scratch 是一个字符数组，用作临时缓冲区，函数可能会向这个缓冲区写入数据。</li>
<li>Skip(uint64_t n)：这个函数用于跳过文件中的 n 字节数据。如果文件读取到末尾，跳过操作将停止在文件末尾，函数返回 OK 状态。</li>
</ul>
<p>当然，注释里也说明了这个类需要<strong>调用者进行同步，以确保线程安全</strong>。在 POSIX 环境下，这个类的实现是在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L136">env_posix.cc</a> 文件中，PosixSequentialFile 类 final 继承自 SequentialFile，阻止被其他任何类继承，同时实现了上述两个虚函数。其中 Read 的实现如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">size_t</span> n, Slice* result, <span class="type">char</span>* scratch)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">      ::<span class="type">ssize_t</span> read_size = ::<span class="built_in">read</span>(fd_, scratch, n);</span><br><span class="line">      <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) {  <span class="comment">// Read error.</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) {</span><br><span class="line">          <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">        }</span><br><span class="line">        status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      *result = <span class="built_in">Slice</span>(scratch, read_size);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>这里当系统调用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> 返回值小于 0 时，会根据 errno 的值判断是否是 EINTR 错误，如果是则<strong>重试读取</strong>。这是因为，当对一个设置了 O_NONBLOCK 标志的文件描述符进行 read() 操作时，如果没有足够的数据可供读取，read() 会立即返回而不是阻塞等待数据变得可用。这种情况下，read() 将返回 -1 并且 errno 被设置为 EAGAIN，表明没有数据可读，可以稍后再试。</p>
<p>Skip 的实现则比较简单，直接调用系统调用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/lseek.2.html">lseek()</a> 来跳过文件中的 n 个字节。这里第三个参数是 SEEK_CUR，表示<strong>从当前位置开始跳过 n 个字节</strong>。操作系统中，每个打开的文件都有一个与之关联的文件位置指针（有时也称为文件偏移量）。这个指针指示了下一次读取或写入操作将在文件中的哪个位置进行。<strong>操作系统负责跟踪和维护这个文件位置指针</strong>。当然也可以指定 SEEK_SET 或 SEEK_END，分别表示从文件开始和文件末尾开始跳过 n 个字节。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Skip</span><span class="params">(<span class="type">uint64_t</span> n)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">lseek</span>(fd_, n, SEEK_CUR) == <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(<span class="number">-1</span>)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>在对象销毁时也要关闭文件描述符，确保资源被正确释放</strong>。每次打开文件，操作系统会分配一些资源，比如内核缓冲区、文件锁等。然后返回给用户一个文件描述符(非负整数)，之后用户通过这个文件描述符来操作文件。当我们调用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/close.2.html">close</a> 时，操作系统会减少对该文件的引用计数，如果引用计数为 0，操作系统会释放相应资源。此外每个进程能打开的文件数量有限制，不调用 close(fd) 可能导致进程无法打开新的文件。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">PosixSequentialFile</span>() <span class="keyword">override</span> { <span class="built_in">close</span>(fd_); }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="随机读文件"><a href="#随机读文件" class="headerlink" title="随机读文件"></a>随机读文件</h2><p>RandomAccessFile 是一个抽象基类，定义<strong>随机读取文件</strong>的接口。它声明了一个纯虚函数 Read，强制子类实现这个方法。Read 方法的设计允许从文件的任意位置读取指定数量的字节。因为是一个只读接口，所以支持无锁多线程并发访问。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">char</span>* scratch)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>在 POSIX 环境下，这个类有 2 种实现，一个是用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/pread.2.html">pread()</a> 实现的 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L176">PosixRandomAccessFile</a>，另一个是用 mmap() 实现的 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L238">PosixMmapReadableFile</a>。</p>
<h3 id="pread-随机读"><a href="#pread-随机读" class="headerlink" title="pread 随机读"></a>pread 随机读</h3><p>PosixRandomAccessFile 类实现了 RandomAccessFile 接口，主要用的是 POSIX 的 pread() 系统调用。该类的构造函数比较有意思，接收 filename，fd 和外部传入的 fd_limiter 指针。fd_limiter 用于限制持有的文件描述符的数量，避免打开的文件描述符过多，limiter 的具体实现在本文 <a href="#Limiter">Limiter</a> 部分。构造的时候，如果 fd_limiter-&gt;Acquire() 返回 true，说明可以一直持有这个文件描述符。否则的话，需要在构造函数中关闭文件描述符，<strong>在后面每次从文件读内容的时候再使用临时文件描述符</strong>。</p>
<p>这里 fd_limiter 在 <a href="#Env-%E5%B0%81%E8%A3%85%E6%8E%A5%E5%8F%A3">PosixEnv</a>的工厂函数里面创建，持久文件描述符的最大个数由 MaxOpenFiles 函数获得。首先检查全局变量 g_open_read_only_file_limit 是否被修改为非负数，如果是则使用这个值。如果没设置，则需要根据系统的资源限制来决定。这里通过系统调用 <a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man2/getrlimit.2.html">getrlimit</a> 来<strong>获取当前进程可以打开的最大文件描述符数</strong>。如果系统不限制进程可以打开的文件描述符数量，那么返回一个 int 类型的最大值，否则将这个限制数的20%分配给只读文件的操作。如果拿资源限制失败，或者系统(比如 Fuchsia 操作系统)不支持获取资源限制，则使用一个硬编码的数值 50。</p>
<p>接下来看看 PosixRandomAccessFile 的构造函数：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The new instance takes ownership of |fd|. |fd_limiter| must outlive this</span></span><br><span class="line"><span class="comment">// instance, and will be used to determine if .</span></span><br><span class="line"><span class="built_in">PosixRandomAccessFile</span>(std::string filename, <span class="type">int</span> fd, Limiter* fd_limiter)</span><br><span class="line">    : <span class="built_in">has_permanent_fd_</span>(fd_limiter-&gt;<span class="built_in">Acquire</span>()),</span><br><span class="line">      <span class="built_in">fd_</span>(has_permanent_fd_ ? fd : <span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">fd_limiter_</span>(fd_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) {</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) {</span><br><span class="line">    <span class="built_in">assert</span>(fd_ == <span class="number">-1</span>);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);  <span class="comment">// The file will be opened on every read.</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>构造函数中还用成员变量 has_permanent_fd_ 来记录是否一直持有打开的文件描述符，如果没有则 fd_ 为 -1。对应的，在析构函数中，如果 has_permanent_fd_ 为 true，就需要调用 close() 关闭文件描述符，并释放 fd_limiter_ 的资源计数。接下来看该类的核心 Read 方法，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="type">int</span> fd = fd_;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) {</span><br><span class="line">    fd = ::<span class="built_in">open</span>(filename_.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">assert</span>(fd != <span class="number">-1</span>);</span><br><span class="line">  Status status;</span><br><span class="line">  <span class="type">ssize_t</span> read_size = ::<span class="built_in">pread</span>(fd, scratch, n, <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(offset));</span><br><span class="line">  *result = <span class="built_in">Slice</span>(scratch, (read_size &lt; <span class="number">0</span>) ? <span class="number">0</span> : read_size);</span><br><span class="line">  <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// An error: return a non-ok status.</span></span><br><span class="line">    status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) {</span><br><span class="line">    <span class="comment">// Close the temporary file descriptor opened earlier.</span></span><br><span class="line">    <span class="built_in">assert</span>(fd != fd_);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里首先判断是否持有<strong>持久文件描述符</strong>，如果没有则需要在每次读取文件时打开文件。然后调用 pread() 读取文件内容，pread() 与 read() 类似，但是它可以从文件的指定位置读取数据。pread() 的第一个参数是文件描述符，第二个参数是读取的缓冲区，第三个参数是读取的字节数，第四个参数是文件中的偏移量。如果读取成功，将读取的数据存入 result 中，否则返回错误状态。最后如果没有持有持久文件描述符，需要在读取完数据后关闭临时文件描述符。</p>
<p>PosixRandomAccessFile 类实现相对简单，直接使用系统文件API，无需额外的内存映射管理，适用于小文件或者不频繁的读取操作。但是如果访问比较频繁，过多的系统调用可能导致性能下降，这时候就可以使用<strong>mmap 内存映射文件</strong>来提高性能。</p>
<h3 id="mmap-随机读"><a href="#mmap-随机读" class="headerlink" title="mmap 随机读"></a>mmap 随机读</h3><p>PosixMmapReadableFile 类同样实现了 RandomAccessFile 接口，不过通过内存映射（mmap）将文件或文件的一部分映射到进程的地址空间，访问这部分内存就相当于访问文件本身。<strong>内存映射允许操作系统利用页缓存，可以显著提高频读取的性能，尤其是在大文件场景下，可以提高读取效率</strong>。</p>
<p>和 PosixRandomAccessFile 有些不同，这里在构造的时候需要传入 mmap_base 指针，指向通过 mmap 系统调用映射的文件内容，同时还需要传入 length 即映射区域的长度，即文件的大小。这里的映射在外面 NewRandomAccessFile 方法中做，PosixMmapReadableFile 直接使用映射好的地址。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PosixMmapReadableFile</span>(std::string filename, <span class="type">char</span>* mmap_base, <span class="type">size_t</span> length,</span><br><span class="line">                      Limiter* mmap_limiter)</span><br><span class="line">    : <span class="built_in">mmap_base_</span>(mmap_base),</span><br><span class="line">      <span class="built_in">length_</span>(length),</span><br><span class="line">      <span class="built_in">mmap_limiter_</span>(mmap_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) {}</span><br></pre></td></tr></tbody></table></figure>

<p>当然，这里 mmap 也需要限制资源，避免耗尽虚拟内存，这里同样用的是 Limiter 类，后面会详细介绍。Read 方法<strong>直接从 mmap_base_ 中读取数据，不需要再调用系统调用</strong>，效率高很多，整体代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (offset + n &gt; length_) {</span><br><span class="line">    *result = <span class="built_in">Slice</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, EINVAL);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  *result = <span class="built_in">Slice</span>(mmap_base_ + offset, n);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="顺序写文件"><a href="#顺序写文件" class="headerlink" title="顺序写文件"></a>顺序写文件</h2><p>前面都是读文件，当然也少不了写文件接口了。WritableFile 是一个抽象基类，定义<strong>顺序写入文件</strong>的接口。它为文件的顺序写入和同步操作提供了一个标准的接口，可以用于 WAL 日志文件的写入。类中定义了3个主要的虚函数：</p>
<ul>
<li>Append(const Slice&amp; data)：向文件对象中追加数据，对于小块数据追加在对象的内存缓存中，对于大块数据则调用 WriteUnbuffered 写磁盘。</li>
<li>Flush()：将目前内存缓存中的数据调用系统 write 写磁盘，注意这里<strong>不保证数据已被同步到物理磁盘</strong>。</li>
<li>Sync()：确保内部缓冲区的数据被写入文件，还<strong>确保数据被同步到物理磁盘</strong>，以保证数据的持久性。调用 Sync() 之后，即使发生电源故障或系统崩溃，数据也不会丢失了。</li>
</ul>
<p>在 POSIX 环境下，这个类的实现是 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L277">PosixWritableFile</a>。类内部使用了一个<strong>大小为 65536 字节的缓冲区</strong> <code>buf_</code>，只有缓冲区满才会将数据写入磁盘文件。如果有大量的短内容写入，就可以先在内存中合并，从而减少对底层文件系统的调用次数，提高写操作的效率。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">size_t</span> kWritableFileBufferSize = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf_[0, pos_ - 1] contains data to be written to fd_.</span></span><br><span class="line">  <span class="type">char</span> buf_[kWritableFileBufferSize];</span><br></pre></td></tr></tbody></table></figure>

<p>这里合并写入的策略在 Append 中实现，代码比较清晰。对于写入的内容，如果能够完全放入缓冲区，则直接拷贝到缓冲区中，然后就返回成功。否则先填满缓冲区，然后将缓存区中的数据写入文件，此时如果剩余的数据能够写入缓冲区则直接写，不然就直接刷到磁盘中。完整实现如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Append</span><span class="params">(<span class="type">const</span> Slice&amp; data)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="type">size_t</span> write_size = data.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* write_data = data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fit as much as possible into buffer.</span></span><br><span class="line">  <span class="type">size_t</span> copy_size = std::<span class="built_in">min</span>(write_size, kWritableFileBufferSize - pos_);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(buf_ + pos_, write_data, copy_size);</span><br><span class="line">  write_data += copy_size;</span><br><span class="line">  write_size -= copy_size;</span><br><span class="line">  pos_ += copy_size;</span><br><span class="line">  <span class="keyword">if</span> (write_size == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Can't fit in buffer, so need to do at least one write.</span></span><br><span class="line">  Status status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) {</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Small writes go to buffer, large writes are written directly.</span></span><br><span class="line">  <span class="keyword">if</span> (write_size &lt; kWritableFileBufferSize) {</span><br><span class="line">    std::<span class="built_in">memcpy</span>(buf_, write_data, write_size);</span><br><span class="line">    pos_ = write_size;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WriteUnbuffered</span>(write_data, write_size);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面将数据写入磁盘调用的是 WriteUnbuffered 函数，该函数通过系统调用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> 实现，主要代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteUnbuffered</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> size)</span> </span>{</span><br><span class="line">  <span class="keyword">while</span> (size &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="type">ssize_t</span> write_result = ::<span class="built_in">write</span>(fd_, data, size);</span><br><span class="line">    <span class="keyword">if</span> (write_result &lt; <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) {</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    }</span><br><span class="line">    data += write_result;</span><br><span class="line">    size -= write_result;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>除了 Append 函数，WritableFile 还提供了 Flush 接口，用于将内存缓冲区 buf_ 的数据写入文件，它内部也是通过调用 WriteUnbuffered 来实现。不过值得注意的是，这里 Flush 写磁盘成功，并<strong>不保证数据已经写入磁盘，甚至不能保证磁盘有足够的空间来存储内容</strong>。如果要保证数据写物理磁盘文件成功，需要调用 Sync() 接口，实现如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Sync</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  Status status = <span class="built_in">SyncDirIfManifest</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) {</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  }</span><br><span class="line">  status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) {</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SyncFd</span>(fd_, filename_);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里核心是调用 SyncFd() 方法，<strong>确保文件描述符 fd 关联的所有缓冲数据都被同步到物理磁盘</strong>。该函数的实现考虑了不同的操作系统特性和文件系统行为，使用了条件编译指令（#if、#else、#endif）来处理不同的环境。在 macOS 和 iOS 系统上，使用了 fcntl() 函数的 <code>F_FULLFSYNC</code> 选项来确保数据被同步到物理磁盘。如果定义了 HAVE_FDATASYNC，将使用 fdatasync() 来同步数据。其他情况下，默认使用 fsync() 函数来实现同样的功能。</p>
<p>注意这里 SyncDirIfManifest 确保如果文件是 manifest 文件(以 “MANIFEST” 开始命名的文件)，相关的目录更改也得到同步。mainfest 文件记录数据库文件的元数据，包括版本信息、合并操作、数据库状态等关键信息。文件系统在创建新文件或修改文件目录项时，这些变更可能并不立即写入磁盘。<strong>在更新 manifest 文件前确保所在目录的数据已被同步到磁盘</strong>，防止系统崩溃时，manifest 文件引用的文件尚未真正写入磁盘。</p>
<h2 id="资源并发限制"><a href="#资源并发限制" class="headerlink" title="资源并发限制"></a>资源并发限制</h2><p>上面提到为了避免打开的文件描述符过多，使用 Limiter 类的 Acquire 来进行限制，该类的也在实现在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L73">env_posix.cc</a>中。这个类的注释也写的特别棒，把它的作用讲的很明白，主要用来限制资源使用，避免资源耗尽。目前用于限制只读文件描述符和 mmap 文件使用，以避免耗尽文件描述符或虚拟内存，或者在非常大的数据库中遇到内核性能问题。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper class to limit resource usage to avoid exhaustion.</span></span><br><span class="line"><span class="comment">// Currently used to limit read-only file descriptors and mmap file usage</span></span><br><span class="line"><span class="comment">// so that we do not run out of file descriptors or virtual memory, or run into</span></span><br><span class="line"><span class="comment">// kernel performance problems for very large databases.</span></span><br></pre></td></tr></tbody></table></figure>

<p>构造函数接受一个参数 max_acquires，这个参数设定了可以获取的最大资源数量。类内部维护了一个原子变量 acquires_allowed_ 来跟踪当前允许被获取的资源数量，初始值设置为 max_acquires。这里用到了条件编译，NDEBUG 是一个常用的预处理宏，用来指明程序是否在非调试模式下编译。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Limit maximum number of resources to |max_acquires|.</span></span><br><span class="line">  <span class="built_in">Limiter</span>(<span class="type">int</span> max_acquires)</span><br><span class="line">      :</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(NDEBUG)</span></span><br><span class="line">        <span class="built_in">max_acquires_</span>(max_acquires),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(NDEBUG)</span></span></span><br><span class="line">        <span class="built_in">acquires_allowed_</span>(max_acquires) {</span><br><span class="line">    <span class="built_in">assert</span>(max_acquires &gt;= <span class="number">0</span>);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>如果在调试模式下，就用 max_acquires_ 来记录最大资源数量，同时在 Acquire 和 Release 方法中加入了断言，确保资源的获取和释放操作正确。在生产环境中，当 <strong>NDEBUG 被定义时，所有的 assert 调用将被编译器忽略，不会产生任何执行代码</strong>。</p>
<p>该类的核心接口是 Acquire 和 Release，这两个方法分别用来获取和释放资源，Acquire 的代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Acquire</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">int</span> old_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (old_acquires_allowed &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pre_increment_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Silence compiler warnings about unused arguments when NDEBUG is defined.</span></span><br><span class="line">  (<span class="type">void</span>)pre_increment_acquires_allowed;</span><br><span class="line">  <span class="comment">// If the check below fails, Release() was called more times than acquire.</span></span><br><span class="line">  <span class="built_in">assert</span>(pre_increment_acquires_allowed &lt; max_acquires_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里使用 fetch_sub(1, std::memory_order_relaxed) 原子地减少 acquires_allowed_ 的值，并返回减少前的值 old_acquires_allowed。如果 old_acquires_allowed 大于0，说明在减少之前还有资源可以被获取，因此返回 true。如果没有资源可用（即 old_acquires_allowed 为0或负），则通过 fetch_add(1, std::memory_order_relaxed) 原子地将计数器加回1，恢复状态，并返回 false。</p>
<p>Release 方法用来释放之前通过 Acquire 方法成功获取的资源。它使用 fetch_add(1, std::memory_order_relaxed) 原子地增加 acquires_allowed_ 的值，表示资源被释放，同时用断言保证 Release 的调用次数不会超过 Acquire 的成功次数，防止资源计数错误。</p>
<p>这里在操作原子计数的时候，使用的是 std::memory_order_relaxed，表明这些原子操作<strong>不需要对内存进行任何特别的排序约束</strong>，只保证操作的原子性。这是因为这里的操作并不依赖于任何其他的内存操作结果，只是简单地递增或递减计数器。</p>
<h2 id="Env-封装接口"><a href="#Env-封装接口" class="headerlink" title="Env 封装接口"></a>Env 封装接口</h2><p>除了上面的几个文件操作类来，还有一个重要的 Env 抽象基类，在 Posix 下派生了 PosixEnv，封装了不少实现。</p>
<h3 id="工厂构造对象"><a href="#工厂构造对象" class="headerlink" title="工厂构造对象"></a>工厂构造对象</h3><p>首先是几个工厂方法，用于创建前面提到的文件读写对象 SequentialFile、RandomAccessFile 和 WritableFile 对象。NewSequentialFile 工厂方法来创建一个 PosixSequentialFile 文件对象，这里封装了打开文件的调用。这里用工厂方法的好处是，可以在工厂方法中处理一些错误，比如文件打开失败。此外这里入参是 <code>WritableFile**</code> ，支持了多态，如果后续加入其他的 WritableFile 实现，可以在不修改调用代码的情况下，通过修改工厂方法来切换到不同的实现。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewSequentialFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                         SequentialFile** result)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">    *result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename, errno);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  *result = <span class="keyword">new</span> <span class="built_in">PosixSequentialFile</span>(filename, fd);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里打开文件时候，传入 flag 除了 O_RDONLY 表示只读外，还有一个 kOpenBaseFlags。kOpenBaseFlags 是一个根据编译选项 HAVE_O_CLOEXEC 来决定是否设置的 flag，如果系统支持 O_CLOEXEC，就会设置这个 flag。O_CLOEXEC 确保在执行 exec() 系列函数时<strong>自动关闭文件描述符，从而防止文件描述符泄露到执行的新程序</strong>中。</p>
<p>默认情况下，当一个进程创建子进程时，所有的文件描述符都会被子进程继承。除非显式地对每个文件描述符进行处理，否则它们在 exec 执行后仍然会保持打开状态。大多数情况下，如果一个进程打算执行另一个程序（通常通过 exec 系列函数），很有可能不希望新程序访问当前进程的某些资源，特别是文件描述符。O_CLOEXEC 标志确保这些文件描述符在 exec 后自动关闭，从而不会泄露给新程序。虽然 LevelDB 本身不会调用 exec 函数，但是这里还是加上了这个 flag，这是一个良好的防御编程习惯。</p>
<p>当然这个 flag 不一定是所有平台支持，为了跨平台，在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/CMakeLists.txt#L54">CmakeLists.txt</a> 中，用check_cxx_symbol_exists 来检测当前环境的 fcntl.h 文件是否有 O_CLOEXEC，有的话则定义 HAVE_O_CLOEXEC 宏。这里特别提下，check_cxx_symbol_exists 还挺有用的，可以<strong>在编译之前确定特定的特性是否被支持，以便根据检测结果适当调整编译设置或源代码</strong>。LevelDB 中有多个宏就是这样检测的，比如 fdatasync、F_FULLFSYNC 等。</p>
<figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">check_cxx_symbol_exists(fdatasync <span class="string">"unistd.h"</span> HAVE_FDATASYNC)</span><br><span class="line">check_cxx_symbol_exists(F_FULLFSYNC <span class="string">"fcntl.h"</span> HAVE_FULLFSYNC)</span><br><span class="line">check_cxx_symbol_exists(O_CLOEXEC <span class="string">"fcntl.h"</span> HAVE_O_CLOEXEC)</span><br></pre></td></tr></tbody></table></figure>

<p>NewWritableFile 和 NewAppendableFile 工厂函数都是类似的，先打开文件，然后创建 PosixWritableFile 对象。不过这里 open 文件的时候，用的不同 flag:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_TRUNC | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_APPEND | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>O_TRUNC 表示如果文件存在，就将文件长度截断为 0。O_APPEND 表示在写入数据时，总是将数据追加到文件末尾，而不是覆盖文件中已有的数据。</p>
<p>NewRandomAccessFile 稍微复杂了一些，因为要支持两种随机读的模式。首先打开文件拿到 fd，然后根据 mmap_limiter_ 来限制内存映射打开文件数量，如果超过 mmap 限制，就用 pread 来随机读。没超过限制的话，就用 mmap 来内存映射文件，拿到映射的地址和文件大小，然后创建 PosixMmapReadableFile 对象。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewRandomAccessFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                           RandomAccessFile** result)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!mmap_limiter_.<span class="built_in">Acquire</span>()) {</span><br><span class="line">    *result = <span class="keyword">new</span> <span class="built_in">PosixRandomAccessFile</span>(filename, fd, &amp;fd_limiter_);</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="type">uint64_t</span> file_size;</span><br><span class="line">  Status status = <span class="built_in">GetFileSize</span>(filename, &amp;file_size);</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) {</span><br><span class="line">    <span class="type">void</span>* mmap_base = ::<span class="built_in">mmap</span>(<span class="comment">/*addr=*/</span><span class="literal">nullptr</span>, file_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmap_base != MAP_FAILED) {</span><br><span class="line">      *result = <span class="keyword">new</span> <span class="built_in">PosixMmapReadableFile</span>(filename,</span><br><span class="line">                                          <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(mmap_base),</span><br><span class="line">                                          file_size, &amp;mmap_limiter_);</span><br><span class="line">    } </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  }</span><br><span class="line">  ::<span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) {</span><br><span class="line">    mmap_limiter_.<span class="built_in">Release</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里 mmap_limiter_ 限制的最大文件数量由 MaxMmaps 函数获得。对于64位系统，由于有非常大的虚拟内存地址空间（实际应用中通常超过 256TB），因此 LevelDB 允许分配 1000 个内存映射区，应该不会对系统的整体性能产生显著影响。而对于32位系统，由于虚拟内存地址空间有限，LevelDB 不允许分配内存映射区。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Up to 1000 mmap regions for 64-bit binaries; none for 32-bit.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> kDefaultMmapLimit = (<span class="built_in">sizeof</span>(<span class="type">void</span>*) &gt;= <span class="number">8</span>) ? <span class="number">1000</span> : <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="文件工具类"><a href="#文件工具类" class="headerlink" title="文件工具类"></a>文件工具类</h3><p>除了上面几个核心的文件类，Env 还提供了一系列文件操作的接口，包括文件元信息获取、文件删除等，刚好可以借此来熟悉下 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/env_posix.cc">Posix 环境下的各种系统调用</a>。</p>
<p>FileExists: 判断 <strong>当前进程是否可以访问该文件(不能访问不代表文件不存在)</strong> ，通过调用系统调用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/access.2.html">access()</a> 实现；</p>
<p>RemoveFile: 如果没有任何进程正在使用该文件(即没有任何打开的文件描述符指向这个文件)，则会删除该文件。通过系统调用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/unlink.2.html">unlink()</a> 实现，unlink 实际上删除的是文件名和其对应 inode 之间的链接。如果这个 inode 没有其他链接，并且没有任何进程打开这个文件，文件实际的数据块和 inode 才会被释放。</p>
<p>GetFileSize: 获取文件的大小，如果文件不存在或者获取失败，返回 0。这里通过 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/stat.2.html">stat</a> 系统调用实现。调用 stat 函数时，需要传递文件名和一个 stat 结构体的指针。系统会检查文件名对应的路径权限，然后获取文件的 inode。inode 是文件系统中的一个数据结构，保存了文件的元数据，包括文件大小、权限、创建时间、最后访问时间等。在文件系统会保持一个 inode 表，用于快速查找和访问 inode 信息，对于大部分文件系统（如 EXT4, NTFS, XFS 等）来说，通常会在内存中缓存常用的 inode，因此获取 inode 一般会十分高效。</p>
<p>RenameFile: 重命名文件或者文件夹，这里可以指定新旧文件名，通过系统调用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/rename.2.html">rename()</a> 实现。</p>
<p>CreateDir: 创建一个目录，默认权限是 755。这里通过系统调用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/mkdir.2.html">mkdir()</a> 实现，如果 pathname 已经存在，这里返回失败。</p>
<p>RemoveDir: 删除一个目录，这里通过系统调用 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/rmdir.2.html">rmdir()</a> 实现。</p>
<p>GetChildren: 稍微复杂一点，通过系统调用 opendir 获得目录，然后用 readdir 遍历其中的文件，最后还要记得 closedir 来清理资源。 </p>
<h2 id="文件操作总结"><a href="#文件操作总结" class="headerlink" title="文件操作总结"></a>文件操作总结</h2><p>不得不说，一个简单的文件操作封装，包含了不少实现细节，这里简单总结下吧：</p>
<ol>
<li>缓冲区优化: 在 WritableFile 实现中使用了内存缓冲区，可以合并小型写入操作，减少系统调用次数，提高写入效率。</li>
<li>资源限制管理: 使用 Limiter 类来限制同时打开的文件描述符数量和内存映射(mmap)数量，通过设置合理的限制上限，避免资源耗尽，提高系统稳定性和性能。</li>
<li>灵活的读取策略: 对于随机读取，LevelDB 提供了基于 pread 和 mmap 两种实现，可以根据系统资源情况动态选择最合适的方式。</li>
<li>工厂方法模式: 使用工厂方法创建文件对象，封装了文件打开等操作，方便错误处理和未来的扩展。</li>
<li>跨平台兼容性: 通过条件编译和特性检测(如 O_CLOEXEC 的检查)，保证了代码在不同平台上的兼容性。</li>
<li>同步机制: 提供了 Flush 和 Sync 接口，允许用户根据需要选择不同级别的数据持久化保证。</li>
</ol>
<p>除了封装文件操作，Env 里面还有其他封装，下篇见吧。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：LevelDB 源码阅读：Posix 文件操作接口实现细节</p><p>本文链接为：https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/';
    this.page.identifier = '2024/08/02/leveldb_source_env_posixfile/';
    this.page.title = 'LevelDB 源码阅读：Posix 文件操作接口实现细节';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (19)</li><li><a href="/categories/法律普及/">法律普及</a> (8)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (31)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/法律/" style="font-size: 15.00px;">法律</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/刑事/" style="font-size: 15.00px;">刑事</a> <a href="/tags/婚姻家庭/" style="font-size: 15.00px;">婚姻家庭</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2024/08/02/leveldb_source_env_posixfile/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li><li><a href="/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB 源码阅读：如何分析跳表的时间复杂度？">LevelDB 源码阅读：如何分析跳表的时间复杂度？</a></li><li><a href="/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB 源码阅读：如何正确测试跳表的并行读写？">LevelDB 源码阅读：如何正确测试跳表的并行读写？</a></li><li><a href="/2024/09/13/gpto1_hands_on/" title="实际例子上手体验 OpenAI o1-preview，比预期差一点？">实际例子上手体验 OpenAI o1-preview，比预期差一点？</a></li><li><a href="/2024/09/09/leveldb_source_skiplist/" title="LevelDB 源码阅读：跳表的原理、实现以及可视化">LevelDB 源码阅读：跳表的原理、实现以及可视化</a></li><li><a href="/2024/09/05/claude35_prompt/" title="Claude3.5 系统提示词解密：不道歉、脸盲、幻觉...">Claude3.5 系统提示词解密：不道歉、脸盲、幻觉...</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">顺序读文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">随机读文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pread-%E9%9A%8F%E6%9C%BA%E8%AF%BB"><span class="toc-number">2.1.</span> <span class="toc-text">pread 随机读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-%E9%9A%8F%E6%9C%BA%E8%AF%BB"><span class="toc-number">2.2.</span> <span class="toc-text">mmap 随机读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">顺序写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">资源并发限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Env-%E5%B0%81%E8%A3%85%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">Env 封装接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.</span> <span class="toc-text">工厂构造对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">文件工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">文件操作总结</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>