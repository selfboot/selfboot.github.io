<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="深入剖析 LevelDB 跳表实现的测试方法,重点探讨并行读写场景下的正确性验证。详细介绍了测试用Key的巧妙设计、写线程和读线程的操作实现,以及单线程和多线程测试的具体方法。文章还讨论了并行测试的局限性,引入ThreadSanitizer工具进行更深入的数据竞争检测。"><title>LevelDB 源码阅读：如何正确测试跳表的并行读写？</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"><i class="fa fa-scale-balanced"></i><span> 法律普及</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB 源码阅读：如何正确测试跳表的并行读写？</h1><div class="post-meta">2024/09/18<span> | </span><span class="category"><a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/09/18/leveldb_source_skiplist_test/" href="/2024/09/18/leveldb_source_skiplist_test/#disqus_thread"></a><div class="post-content"><p>在上篇 <a href="https://selfboot.cn/2024/09/09/leveldb_source_skiplist/">LevelDB 源码阅读：跳表的原理、实现以及可视化</a>中，从当前二叉搜索树和平衡树的一些缺点出发，引出了跳表这种数据结构。然后结合论文，解释了跳表的实现原理。接着详细分析了 LevelDB 的代码实现，包括迭代器实现，以及<strong>并行读的极致性能优化</strong>。最后还提供了一个可视化页面，可以直观看到跳表的构建过程。</p>
<p>但是还有两个问题：</p>
<ol>
<li>怎么测试 LevelDB 跳表的代码，保证功能的正确性？特别是怎么<strong>保证读写并行情况下跳表实现的正确性</strong>。</li>
<li>怎么<strong>定量分析</strong>跳表的时间复杂度？</li>
</ol>
<p>接下来通过分析 LevelDB 的测试代码，先来回答第一个问题。跳表的性能定量分析，放到另外单独一篇文章。</p>
<span id="more"></span>

<h2 id="跳表测试分析"><a href="#跳表测试分析" class="headerlink" title="跳表测试分析"></a>跳表测试分析</h2><p><a href="https://selfboot.cn/2024/09/09/leveldb_source_skiplist/">上篇文章</a>分析了 LevelDB 跳表的实现，那么这里的实现是否正确呢？如果要写测试用例，应该怎么写？需要从哪些方面来测试跳表的正确性？我们看看 LevelDB 的测试代码 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/skiplist_test.cc">skiplist_test.cc</a>。</p>
<p>首先是<strong>空跳表的测试</strong>，验证空跳表不包含任何元素，检查空跳表的迭代器操作 SeekToFirst, Seek, SeekToLast 等。接着是插入、查找、迭代器的测试用例，通过不断插入大量随机生成的键值对，验证跳表是否正确包含这些键，以及测试迭代器的前向和后向遍历。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(SkipTest, InsertAndLookup) {</span><br><span class="line">  <span class="comment">// 测试插入和查找功能</span></span><br><span class="line">  <span class="comment">// 插入随机生成的键值对</span></span><br><span class="line">  <span class="comment">// 验证跳表正确包含这些键</span></span><br><span class="line">  <span class="comment">// 测试迭代器的前向和后向遍历</span></span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p>这些都是比较常规的测试用例，这里不展开了。我们重点来看看 LevelDB 的<strong>并行测试</strong>。</p>
<h3 id="测试-Key-设计"><a href="#测试-Key-设计" class="headerlink" title="测试 Key 设计"></a>测试 Key 设计</h3><p>LevelDB 的跳表支持单线程写，多线程并行读，在上篇详细分析过这里的并行读实现细节，那么要如何测试呢？先定义测试目标，多个线程并行读的时候，<strong>每个读线程初始化迭代器后，应该要能读到当前跳表的所有元素</strong>。因为有写线程在同时运行，所以读线程可能<strong>也会读到后续新插入的元素</strong>。读线程在任何时刻，<strong>读到的元素都应该满足跳表的性质</strong>，即前一个元素小于等于后一个元素。</p>
<p>LevelDB 的测试方法设计的还是比较巧妙的。首先是一个<strong>精心设计的元素值 Key</strong>(这里 K 大写来区分)，注释部分写的很清晰：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We generate multi-part keys:</span></span><br><span class="line"><span class="comment">//     &lt;key,gen,hash&gt;</span></span><br><span class="line"><span class="comment">// where:</span></span><br><span class="line"><span class="comment">//     key is in range [0..K-1]</span></span><br><span class="line"><span class="comment">//     gen is a generation number for key</span></span><br><span class="line"><span class="comment">//     hash is hash(key,gen)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The insertion code picks a random key, sets gen to be 1 + the last</span></span><br><span class="line"><span class="comment">// generation number inserted for that key, and sets hash to Hash(key,gen).</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></tbody></table></figure>

<p>跳表元素值由三部分组成，key 是随机生成，gen 是插入的递增序号，hash 是 key 和 gen 的 hash 值。三部分一起放在一个 uint64_t 的整数中，高 24 位是 key，中间 32 位是 gen，低 8 位是 hash。下面是根据 Key 提取三个部分，以及从 key 和 gen 生成 Key 的代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentTest</span> {</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> K = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">key</span><span class="params">(Key key)</span> </span>{ <span class="keyword">return</span> (key &gt;&gt; <span class="number">40</span>); }</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">gen</span><span class="params">(Key key)</span> </span>{ <span class="keyword">return</span> (key &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xffffffff</span>u; }</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>{ <span class="keyword">return</span> key &amp; <span class="number">0xff</span>; }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Key <span class="title">MakeKey</span><span class="params">(<span class="type">uint64_t</span> k, <span class="type">uint64_t</span> g)</span> </span>{</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(Key) == <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>), <span class="string">""</span>);</span><br><span class="line">    <span class="built_in">assert</span>(k &lt;= K);  <span class="comment">// We sometimes pass K to seek to the end of the skiplist</span></span><br><span class="line">    <span class="built_in">assert</span>(g &lt;= <span class="number">0xffffffff</span>u);</span><br><span class="line">    <span class="keyword">return</span> ((k &lt;&lt; <span class="number">40</span>) | (g &lt;&lt; <span class="number">8</span>) | (<span class="built_in">HashNumbers</span>(k, g) &amp; <span class="number">0xff</span>));</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>那<strong>为什么要设计 key 呢</strong>？key 的取值在 0 到 K-1 之间，K 这里是 4。key 虽然占了高 24 位，但是取值范围是 0-3。其实这里键值设计不用高 24 位的 key也是完全可以的，后面的测试逻辑没有大的影响。这里问了下 gpto1 和 claude3.5，给的解释也说不通。结合后续的并行读、写测试代码，个人理解可能是想<strong>模拟在链表中执行跨度比较大的 seek 操作</strong>。欢迎各位在评论区指正，给出其他可以说的通的解释～</p>
<p>至于 gen 和 hash 的好处就比较明显了，插入的时候保证 gen 递增，那么读线程就可以用 gen 来<strong>验证跳表中元素插入的顺序</strong>。每个键低 8 位是 hash，可以用来验证<strong>从跳表中读出来的元素和插入的元素是否一致</strong>，如下 IsValidKey 方法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">HashNumbers</span><span class="params">(<span class="type">uint64_t</span> k, <span class="type">uint64_t</span> g)</span> </span>{</span><br><span class="line">  <span class="type">uint64_t</span> data[<span class="number">2</span>] = {k, g};</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Hash</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(data), <span class="built_in">sizeof</span>(data), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">IsValidKey</span><span class="params">(Key k)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">hash</span>(k) == (<span class="built_in">HashNumbers</span>(<span class="built_in">key</span>(k), <span class="built_in">gen</span>(k)) &amp; <span class="number">0xff</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里取出键值的低 8 位，和从 key 和 gen 生成的 hash 值对比，如果相等，则说明元素是有效的。上面实现都放在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/skiplist_test.cc#L152">ConcurrentTest 类</a>，这个类作为辅助类，定义了系列 Key 相关的方法，以及读写跳表部分。</p>
<h3 id="写线程操作"><a href="#写线程操作" class="headerlink" title="写线程操作"></a>写线程操作</h3><p>接下来看写线程的操作方法 WriteStep，它是 ConcurrentTest 类的 public 成员方法，核心代码如下:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REQUIRES: External synchronization</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteStep</span><span class="params">(Random* rnd)</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> k = rnd-&gt;<span class="built_in">Next</span>() % K;</span><br><span class="line">  <span class="type">const</span> <span class="type">intptr_t</span> g = current_.<span class="built_in">Get</span>(k) + <span class="number">1</span>;</span><br><span class="line">  <span class="type">const</span> Key key = <span class="built_in">MakeKey</span>(k, g);</span><br><span class="line">  list_.<span class="built_in">Insert</span>(key);</span><br><span class="line">  current_.<span class="built_in">Set</span>(k, g);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里随机生成一个 key，然后拿到该 key 对应的上个 gen 值，递增生成新的 gen 值，调用 Insert 方法往跳表插入新的键。新的键是用前面的 MakeKey 方法，<strong>根据 key 和 gen 生成</strong>。插入调表后还要更新 key 对应的 gen 值，这样就保证了每个 key 下插入的元素 gen 是递增的。这里 key 的取值在 0 到 K-1 之间，K 这里取 4。</p>
<p>这里的 current_ 是一个 State 结构体，<strong>保存了每个 key 对应的 gen 值</strong>，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> {</span><br><span class="line">  std::atomic&lt;<span class="type">int</span>&gt; generation[K];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span> </span>{</span><br><span class="line">    generation[k].<span class="built_in">store</span>(v, std::memory_order_release);</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> k)</span> </span>{ <span class="keyword">return</span> generation[k].<span class="built_in">load</span>(std::memory_order_acquire); }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">State</span>() {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; K; k++) {</span><br><span class="line">      <span class="built_in">Set</span>(k, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>State 结构体中有一个 atomic 数组 generation，保存了每个 key 对应的 gen 值。这里用 atomic 原子类型和 memory_order_release, memory_order_acquire 语义来保证，<strong>写线程一旦更新了 key 的 gen 值，读线程立马就能读到新的值</strong>。关于 atomic 内存屏障语义的理解，可以参考上篇跳表实现中 Node 类的设计。</p>
<h3 id="读线程操作"><a href="#读线程操作" class="headerlink" title="读线程操作"></a>读线程操作</h3><p>上面写线程比较简单，一个线程不断往跳表插入新的元素即可。读线程相对复杂了很多，<strong>除了从跳表中读取元素，还需要验证数据是符合预期的</strong>。这里是注释中给出的测试读线程的整体思路：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// At the beginning of a read, we snapshot the last inserted</span></span><br><span class="line"><span class="comment">// generation number for each key.  We then iterate, including random</span></span><br><span class="line"><span class="comment">// calls to Next() and Seek().  For every key we encounter, we</span></span><br><span class="line"><span class="comment">// check that it is either expected given the initial snapshot or has</span></span><br><span class="line"><span class="comment">// been concurrently added since the iterator started.</span></span><br></pre></td></tr></tbody></table></figure>

<p>主要确保跳表在读写并行环境下的正确性，可以从下面 3 个角度来验证：</p>
<ol>
<li>一致性验证：确保读线程在迭代过程中<strong>不会遗漏在迭代器创建时已经存在的键</strong>。</li>
<li>顺序遍历：验证<strong>迭代器遍历的顺序始终是递增</strong>的，避免回退。</li>
<li>并行安全：通过随机的迭代器移动策略，模拟并行读操作场景，检测潜在的竞争条件或数据不一致问题。</li>
</ol>
<p>这里 ReadStep 方法有一个 while(true) 循环，在开始循环之前，先记录下跳表的初始状态到 initial_state 中，然后用 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/skiplist_test.cc#L176">RandomTarget</a> 方法随机生成一个目标键 pos，用 Seek 方法查找。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadStep</span><span class="params">(Random* rnd)</span> </span>{</span><br><span class="line">    <span class="comment">// Remember the initial committed state of the skiplist.</span></span><br><span class="line">    State initial_state;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; K; k++) {</span><br><span class="line">      initial_state.<span class="built_in">Set</span>(k, current_.<span class="built_in">Get</span>(k));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Key pos = <span class="built_in">RandomTarget</span>(rnd);</span><br><span class="line">    SkipList&lt;Key, Comparator&gt;::<span class="function">Iterator <span class="title">iter</span><span class="params">(&amp;list_)</span></span>;</span><br><span class="line">    iter.<span class="built_in">Seek</span>(pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">      ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>之后就是整个验证过程，这里省略了跳表中找不到 pos 的情况，只看核心测试路径。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    Key current;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    current = iter.<span class="built_in">key</span>();</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">IsValidKey</span>(current)) &lt;&lt; current;</span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(pos, current) &lt;&lt; <span class="string">"should not go backwards"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that everything in [pos,current) was not present in</span></span><br><span class="line">    <span class="comment">// initial_state.</span></span><br><span class="line">    <span class="keyword">while</span> (pos &lt; current) {</span><br><span class="line">      <span class="built_in">ASSERT_LT</span>(<span class="built_in">key</span>(pos), K) &lt;&lt; pos;</span><br><span class="line">      <span class="built_in">ASSERT_TRUE</span>((<span class="built_in">gen</span>(pos) == <span class="number">0</span>) ||</span><br><span class="line">                  (<span class="built_in">gen</span>(pos) &gt; <span class="built_in">static_cast</span>&lt;Key&gt;(initial_state.<span class="built_in">Get</span>(<span class="built_in">key</span>(pos)))))</span><br><span class="line">          &lt;&lt; <span class="string">"key: "</span> &lt;&lt; <span class="built_in">key</span>(pos) &lt;&lt; <span class="string">"; gen: "</span> &lt;&lt; <span class="built_in">gen</span>(pos)</span><br><span class="line">          &lt;&lt; <span class="string">"; initgen: "</span> &lt;&lt; initial_state.<span class="built_in">Get</span>(<span class="built_in">key</span>(pos));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Advance to next key in the valid key space</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">key</span>(pos) &lt; <span class="built_in">key</span>(current)) {</span><br><span class="line">        pos = <span class="built_in">MakeKey</span>(<span class="built_in">key</span>(pos) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        pos = <span class="built_in">MakeKey</span>(<span class="built_in">key</span>(pos), <span class="built_in">gen</span>(pos) + <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里找到位置 current 后，会验证 current 位置的键值 hash 是否正确，接着验证 pos &lt;= current。之后用一个 while 循环遍历跳表，验证 <code>[pos, current)</code> 区间内的所有键都没有在初始状态 initial_state 中。这里可以用<strong>反证法思考，如果某个键 tmp 在 [pos, current) 区间内，并且也在 initial_state 中，那么根据跳表的性质，Seek 的时候就会找到 tmp，而不是 current 了</strong>。所以只要链表实现正确，那么 [pos, current) 区间内的所有键都没有在 initial_state 中。</p>
<p>当然这里没有记录下跳表中的键值，只用验证 [pos, current) 区间内所有键的 gen 值大于初始状态下的 gen 值，就能说明开始迭代的时候这个范围内的所有键都不在链表中。</p>
<p>在上面每轮验证后都会重新找到一个新的测试目标键 pos，并更新迭代器，如下代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rnd-&gt;<span class="built_in">Next</span>() % <span class="number">2</span>) {</span><br><span class="line">  iter.<span class="built_in">Next</span>();</span><br><span class="line">  pos = <span class="built_in">MakeKey</span>(<span class="built_in">key</span>(pos), <span class="built_in">gen</span>(pos) + <span class="number">1</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  Key new_target = <span class="built_in">RandomTarget</span>(rnd);</span><br><span class="line">  <span class="keyword">if</span> (new_target &gt; pos) {</span><br><span class="line">    pos = new_target;</span><br><span class="line">    iter.<span class="built_in">Seek</span>(new_target);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里随机决定是 iter.Next() 移动到下一个键，还是创建一个新的目标键并重新定位到该目标键。整个读测试模拟了真实环境下的不确定性，确保跳表在各种访问模式下的稳定性和正确性。</p>
<h3 id="单线程读写"><a href="#单线程读写" class="headerlink" title="单线程读写"></a>单线程读写</h3><p>上面介绍完了测试读写的方法，下面看看具体怎么结合线程来测试。单线程下读、写比较简单，写和读交换执行就好。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple test that does single-threaded testing of the ConcurrentTest</span></span><br><span class="line"><span class="comment">// scaffolding.</span></span><br><span class="line"><span class="built_in">TEST</span>(SkipTest, ConcurrentWithoutThreads) {</span><br><span class="line">  ConcurrentTest test;</span><br><span class="line">  <span class="function">Random <span class="title">rnd</span><span class="params">(test::RandomSeed())</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">    test.<span class="built_in">ReadStep</span>(&amp;rnd);</span><br><span class="line">    test.<span class="built_in">WriteStep</span>(&amp;rnd);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="并行读写测试"><a href="#并行读写测试" class="headerlink" title="并行读写测试"></a>并行读写测试</h3><p>实际场景中，有一个写线程，但是可以有多个读线程，还要测试读和写并行场景下跳表的正确性。核心测试代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">RunConcurrent</span><span class="params">(<span class="type">int</span> run)</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> seed = test::<span class="built_in">RandomSeed</span>() + (run * <span class="number">100</span>);</span><br><span class="line">  <span class="function">Random <span class="title">rnd</span><span class="params">(seed)</span></span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> kSize = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">    <span class="keyword">if</span> ((i % <span class="number">100</span>) == <span class="number">0</span>) {</span><br><span class="line">      std::<span class="built_in">fprintf</span>(stderr, <span class="string">"Run %d of %d\n"</span>, i, N);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TestState <span class="title">state</span><span class="params">(seed + <span class="number">1</span>)</span></span>;</span><br><span class="line">    Env::<span class="built_in">Default</span>()-&gt;<span class="built_in">Schedule</span>(ConcurrentReader, &amp;state);</span><br><span class="line">    state.<span class="built_in">Wait</span>(TestState::RUNNING);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSize; i++) {</span><br><span class="line">      state.t_.<span class="built_in">WriteStep</span>(&amp;rnd);</span><br><span class="line">    }</span><br><span class="line">    state.quit_flag_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">    state.<span class="built_in">Wait</span>(TestState::DONE);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里每个用例中迭代 N 次，每次迭代中使用 Env::Default()-&gt;Schedule 方法，创建了一个新的线程执行 ConcurrentReader 函数，并传入 state 作为参数。ConcurrentReader 会在独立线程中执行读操作，模拟并行读环境。接着调用 state.Wait(TestState::RUNNING) 等读线程进入运行状态后，主线程开始写操作。</p>
<p>这里写操作通过循环调用 state.t_.WriteStep(&amp;rnd)，在跳表中执行 kSize 次写操作。每次写操作会插入新的键值对到跳表中，模拟写线程的行为。等执行完写操作后，设置 state.quit_flag_ 为 true，通知读线程停止读取操作并退出。等待读线程完成所有操作并退出，确保当前循环的读写操作全部结束后再进行下一次测试。</p>
<p>这里的测试用到了 TestState 来同步线程状态，还封装了一个 ConcurrentReader 作为读线程方法。此外还调用了 Env 封装的 Schedule 方法，在独立线程中执行读操作。涉及到条件变量、互斥锁以及线程相关内容，这里不展开了。</p>
<p>值得一说的是，这里也只是<strong>测试了一写一读并行的场景，并没有测试一写多读</strong>。可以在每轮迭代中启动多个读线程，所有读线程同时与写操作并发执行。或者维护一个固定数量的读线程池，多个读线程持续运行，与写线程并发操作。不过当前的测试，通过多次重复一写一读的方式，依然能够有效地验证跳表在读写并发下的正确性和稳定性。</p>
<p>下面是执行测试用例的输出截图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_runtest.png/webp" alt="并行测试输出" srcset="https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_runtest.png/webp 2290w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_runtest.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_runtest.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_runtest.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2290" height="1902"></p>
<h2 id="并行测试正确性"><a href="#并行测试正确性" class="headerlink" title="并行测试正确性"></a>并行测试正确性</h2><p>上面并行测试比较详细，但是这里值得再多说一点。对于这种并行下的代码，特别是涉及内存屏障相关的代码，有时候<strong>测试通过可能只是因为没触发问题而已</strong>(出现问题的概率很低，可能和编译器，cpu 型号也有关)。比如这里我把 Insert 操作稍微改下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; i++) {</span><br><span class="line">  <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">  <span class="comment">// we publish a pointer to "x" in prev[i].</span></span><br><span class="line">  x-&gt;<span class="built_in">NoBarrier_SetNext</span>(i, prev[i]-&gt;<span class="built_in">NoBarrier_Next</span>(i));</span><br><span class="line">  prev[i]-&gt;<span class="built_in">NoBarrier_SetNext</span>(i, x); <span class="comment">// Change here, Use NoBarrier_SetNext</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里两个指针都用 NoBarrier_SetNext 方法来设置，然后重新编译 LevelDB 库和测试程序，运行多次，都是能通过测试用例的。</p>
<p>当然这种情况下，可以在不同的硬件配置和负载下进行长时间的测试，可能也可以发现问题。不过缺点就是耗时较长，可能无法重现发现的问题。</p>
<h3 id="ThreadSanitizer-检测数据竞争"><a href="#ThreadSanitizer-检测数据竞争" class="headerlink" title="ThreadSanitizer 检测数据竞争"></a>ThreadSanitizer 检测数据竞争</h3><p>此外也可以使用 clang 的动态分析工具 <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a> 来检测数据竞争。使用也比较简单，编译的时候带上 <code>-fsanitize=thread</code> 选项即可。完整的编译指令如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC=/usr/bin/clang CXX=/usr/bin/clang++  cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_CXX_FLAGS="-fsanitize=thread" -DCMAKE_C_FLAGS="-fsanitize=thread" -DCMAKE_EXE_LINKER_FLAGS="-fsanitize=thread" -DCMAKE_INSTALL_PREFIX=$(pwd) .. &amp;&amp; cmake --build . --target install</span><br></pre></td></tr></tbody></table></figure>

<p>把上面改动后的代码重新编译链接，运行测试用例，结果如下：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_threadsanitizer.png/webp" alt="ThreadSanitizer 检测数据竞争" srcset="https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_threadsanitizer.png/webp 3314w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_threadsanitizer.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_threadsanitizer.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_threadsanitizer.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3314" height="1834"></p>
<p>这里定位到了问题代码，还是很精准的。如果取消这里的错误改动重新编译运行，是不会有问题的。ThreadSanitizer 的实现原理比较复杂，程序被编译时，TSan 在<strong>每个内存访问操作前后插入检查代码</strong>。运行过程中，当程序执行到一个内存访问操作时，插入的代码会被触发，这段代码检查并更新相应的影子内存。它比较当前访问与该内存位置的历史访问记录。如果检测到潜在的数据竞争，TSan 会记录详细信息，包括堆栈跟踪。</p>
<p>它的优点是能够检测到难以通过其他方法发现的微妙数据竞争，同时还提供详细的诊断信息，有助于快速定位和修复问题。不过会显著增加程序的运行时间和内存使用。可能无法检测到所有类型的并发错误，特别是那些依赖于特定时序的错误。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跳表的测试部分也分析完了，我们重点分析了下并行读写场景下的正确性验证。这里插入键值 Key 的设计，读线程的验证方法都很巧妙，值得我们借鉴。同时我们也要认识到，多线程下数据竞争的检测，有时候靠测试用例是很难发现的。借助 ThreadSanitizer 这种工具，可以辅助发现一些问题。</p>
<p>最后欢迎大家留言交流～</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：LevelDB 源码阅读：如何正确测试跳表的并行读写？</p><p>本文链接为：https://selfboot.cn/2024/09/18/leveldb_source_skiplist_test/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2024/09/18/leveldb_source_skiplist_test/';
    this.page.identifier = '2024/09/18/leveldb_source_skiplist_test/';
    this.page.title = 'LevelDB 源码阅读：如何正确测试跳表的并行读写？';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (18)</li><li><a href="/categories/法律普及/">法律普及</a> (26)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (31)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/法律/" style="font-size: 15.00px;">法律</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/婚姻家庭/" style="font-size: 15.00px;">婚姻家庭</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/刑事/" style="font-size: 15.00px;">刑事</a> <a href="/tags/劳动纠纷/" style="font-size: 15.00px;">劳动纠纷</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2024/09/18/leveldb_source_skiplist_test/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li><li><a href="/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB 源码阅读：如何分析跳表的时间复杂度？">LevelDB 源码阅读：如何分析跳表的时间复杂度？</a></li><li><a href="/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB 源码阅读：如何正确测试跳表的并行读写？">LevelDB 源码阅读：如何正确测试跳表的并行读写？</a></li><li><a href="/2024/09/13/gpto1_hands_on/" title="实际例子上手体验 OpenAI o1-preview，比预期差一点？">实际例子上手体验 OpenAI o1-preview，比预期差一点？</a></li><li><a href="/2024/09/09/leveldb_source_skiplist/" title="LevelDB 源码阅读：跳表的原理、实现以及可视化">LevelDB 源码阅读：跳表的原理、实现以及可视化</a></li><li><a href="/2024/09/05/claude35_prompt/" title="Claude3.5 系统提示词解密：不道歉、脸盲、幻觉...">Claude3.5 系统提示词解密：不道歉、脸盲、幻觉...</a></li><li><a href="/2024/08/29/leveldb_source_utils/" title="LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码">LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">跳表测试分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-Key-%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.</span> <span class="toc-text">测试 Key 设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">写线程操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">读线程操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%86%99"><span class="toc-number">1.4.</span> <span class="toc-text">单线程读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.</span> <span class="toc-text">并行读写测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%8B%E8%AF%95%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">并行测试正确性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadSanitizer-%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89"><span class="toc-number">2.1.</span> <span class="toc-text">ThreadSanitizer 检测数据竞争</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>