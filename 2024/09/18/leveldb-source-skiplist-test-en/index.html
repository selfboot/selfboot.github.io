<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-WUJTOV7jES"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="This article delves into the testing methods of LevelDB's skip list implementation, focusing on verifying correctness in parallel read and write scenarios. It details the clever design of test Keys, the implementation of write and read thread operations, and specific methods for single-threaded and multi-threaded testing. The article also discusses the limitations of parallel testing and introduces the ThreadSanitizer tool for deeper data race detection."><title>LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN">中文</option><option value="en" selected="">English</option></select></div><p class="description">Know what it is, and know why it is so. The breadth of knowledge is a byproduct of its depth!</p></div><div id="nav-menu"><a href="/en/."><i class="fa fa-home"></i><span> Home</span></a><a href="/en/archives/"><i class="fa fa-archive"></i><span> Archive</span></a><a href="/en/aboutme.html"><i class="fa fa-user"></i><span> About</span></a><a href="/en/atom.xml"><i class="fa fa-rss"></i><span> RSS</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</h1><div class="post-meta">2024/09/18<span> | </span><span class="category"><a href="/categories/Source-Code-Analysis/">Source Code Analysis</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/09/18/leveldb-source-skiplist-test-en/" href="/2024/09/18/leveldb-source-skiplist-test-en/#disqus_thread"></a><div class="post-content"><p>In the previous article <a href="https://selfboot.cn/en/2024/09/09/leveldb_source_skiplist/">LevelDB Source Code Reading: Principles, Implementation, and Visualization of Skip Lists</a>, we started by discussing the drawbacks of current binary search trees and balanced trees, which led to the introduction of skip lists as a data structure. Then, combining with the original paper, we explained the implementation principles of skip lists. Next, we analyzed in detail the code implementation in LevelDB, including the iterator implementation and <strong>extreme performance optimization for parallel reading</strong>. Finally, we provided a visualization page that intuitively shows the skip list construction process.</p>
<p>However, two questions remain:</p>
<ol>
<li>How to test the LevelDB skip list code to ensure functional correctness? Especially, <strong>how to ensure the correctness of skip list implementation in parallel read and write scenarios</strong>.</li>
<li>How to <strong>quantitatively analyze</strong> the time complexity of skip lists?</li>
</ol>
<p>Next, by analyzing LevelDB’s test code, we’ll first answer the first question. The quantitative analysis of skip list performance will be covered in a separate article.</p>
<span id="more"></span>

<h2 id="Skip-List-Test-Analysis"><a href="#Skip-List-Test-Analysis" class="headerlink" title="Skip List Test Analysis"></a>Skip List Test Analysis</h2><p>In <a href="https://selfboot.cn/en/2024/09/09/leveldb_source_skiplist/">the previous article</a>, we analyzed the implementation of LevelDB’s skip list. So, is this implementation correct? If we were to write test cases, how should we write them? From which aspects should we test the correctness of the skip list? Let’s look at LevelDB’s test code <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/skiplist_test.cc">skiplist_test.cc</a>.</p>
<p>First is the <strong>empty skip list test</strong>, which verifies that an empty skip list contains no elements and checks the iterator operations of an empty skip list such as SeekToFirst, Seek, SeekToLast, etc. Then there are test cases for insertion, lookup, and iterator, which verify whether the skip list correctly contains these keys and test the forward and backward traversal of the iterator by continuously inserting a large number of randomly generated key-value pairs.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(SkipTest, InsertAndLookup) {</span><br><span class="line">  <span class="comment">// Test insertion and lookup functionality</span></span><br><span class="line">  <span class="comment">// Insert randomly generated key-value pairs</span></span><br><span class="line">  <span class="comment">// Verify that the skip list correctly contains these keys</span></span><br><span class="line">  <span class="comment">// Test forward and backward traversal of the iterator</span></span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p>These are fairly standard test cases, so we won’t expand on them here. Let’s focus on LevelDB’s <strong>parallel testing</strong>.</p>
<h3 id="Test-Key-Design"><a href="#Test-Key-Design" class="headerlink" title="Test Key Design"></a>Test Key Design</h3><p>LevelDB’s skip list supports single-threaded write and multi-threaded parallel read. We analyzed the details of parallel read implementation in the previous article, so how should we test it? Let’s first define the test objective: when multiple threads are reading in parallel, <strong>after each read thread initializes its iterator, it should be able to read all the elements currently in the skip list</strong>. Since there’s a write thread running simultaneously, read threads <strong>may also read newly inserted elements</strong>. At any time, <strong>the elements read by read threads should satisfy the properties of a skip list</strong>, i.e., each element should be less than or equal to the next element.</p>
<p>LevelDB’s test method is designed quite cleverly. First is a <strong>carefully designed element value Key</strong> (capitalized here to distinguish from key), with clear comments:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We generate multi-part keys:</span></span><br><span class="line"><span class="comment">//     &lt;key,gen,hash&gt;</span></span><br><span class="line"><span class="comment">// where:</span></span><br><span class="line"><span class="comment">//     key is in range [0..K-1]</span></span><br><span class="line"><span class="comment">//     gen is a generation number for key</span></span><br><span class="line"><span class="comment">//     hash is hash(key,gen)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The insertion code picks a random key, sets gen to be 1 + the last</span></span><br><span class="line"><span class="comment">// generation number inserted for that key, and sets hash to Hash(key,gen).</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></tbody></table></figure>

<p>The skip list element value consists of three parts: key is randomly generated, gen is the incremental insertion sequence number, and hash is the hash value of key and gen. All three parts are placed in a uint64_t integer, with the high 24 bits being key, the middle 32 bits being gen, and the low 8 bits being hash. Below is the code for extracting the three parts from Key and generating Key from key and gen:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> Key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentTest</span> {</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint32_t</span> K = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">key</span><span class="params">(Key key)</span> </span>{ <span class="keyword">return</span> (key &gt;&gt; <span class="number">40</span>); }</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">gen</span><span class="params">(Key key)</span> </span>{ <span class="keyword">return</span> (key &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xffffffff</span>u; }</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>{ <span class="keyword">return</span> key &amp; <span class="number">0xff</span>; }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Key <span class="title">MakeKey</span><span class="params">(<span class="type">uint64_t</span> k, <span class="type">uint64_t</span> g)</span> </span>{</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(Key) == <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>), <span class="string">""</span>);</span><br><span class="line">    <span class="built_in">assert</span>(k &lt;= K);  <span class="comment">// We sometimes pass K to seek to the end of the skiplist</span></span><br><span class="line">    <span class="built_in">assert</span>(g &lt;= <span class="number">0xffffffff</span>u);</span><br><span class="line">    <span class="keyword">return</span> ((k &lt;&lt; <span class="number">40</span>) | (g &lt;&lt; <span class="number">8</span>) | (<span class="built_in">HashNumbers</span>(k, g) &amp; <span class="number">0xff</span>));</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Why design key this way</strong>? The value of key ranges from 0 to K-1, where K is 4 here. Although key occupies the high 24 bits, its value range is 0-3. In fact, the key value design could work perfectly fine without using the high 24 bits, and it wouldn’t significantly affect the subsequent test logic. I asked gpto1 and claude3.5 about this, but their explanations weren’t convincing. Considering the subsequent parallel read and write test code, my personal understanding is that it might be intended to <strong>simulate seek operations with large spans in the linked list</strong>. Feel free to correct me in the comments section if you have a more plausible explanation!</p>
<p>The benefits of gen and hash are more obvious. By ensuring gen increments during insertion, read threads can use gen to <strong>verify the order of elements inserted into the skip list</strong>. The low 8 bits of each key is a hash, which can be used to verify <strong>whether the elements read from the skip list are consistent with the inserted elements</strong>, as shown in the IsValidKey method:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">HashNumbers</span><span class="params">(<span class="type">uint64_t</span> k, <span class="type">uint64_t</span> g)</span> </span>{</span><br><span class="line">  <span class="type">uint64_t</span> data[<span class="number">2</span>] = {k, g};</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Hash</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(data), <span class="built_in">sizeof</span>(data), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">IsValidKey</span><span class="params">(Key k)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">hash</span>(k) == (<span class="built_in">HashNumbers</span>(<span class="built_in">key</span>(k), <span class="built_in">gen</span>(k)) &amp; <span class="number">0xff</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, the low 8 bits of the key value are extracted and compared with the hash value generated from key and gen. If they are equal, it indicates that the element is valid. All the above implementations are placed in the <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/skiplist_test.cc#L152">ConcurrentTest class</a>, which serves as an auxiliary class, defining a series of Key-related methods and read/write skip list parts.</p>
<h3 id="Write-Thread-Operation"><a href="#Write-Thread-Operation" class="headerlink" title="Write Thread Operation"></a>Write Thread Operation</h3><p>Next, let’s look at the write thread operation method WriteStep. It’s a public member method of the ConcurrentTest class, with the core code as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REQUIRES: External synchronization</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteStep</span><span class="params">(Random* rnd)</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> k = rnd-&gt;<span class="built_in">Next</span>() % K;</span><br><span class="line">  <span class="type">const</span> <span class="type">intptr_t</span> g = current_.<span class="built_in">Get</span>(k) + <span class="number">1</span>;</span><br><span class="line">  <span class="type">const</span> Key key = <span class="built_in">MakeKey</span>(k, g);</span><br><span class="line">  list_.<span class="built_in">Insert</span>(key);</span><br><span class="line">  current_.<span class="built_in">Set</span>(k, g);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, a key is randomly generated, then the previous gen value corresponding to that key is obtained, incremented to generate a new gen value, and the Insert method is called to insert a new key into the skip list. The new key is generated using the previously mentioned MakeKey method, <strong>based on key and gen</strong>. After inserting into the skip list, the gen value corresponding to the key is updated, ensuring that the elements inserted under each key have incremental gen values. The value of key here ranges from 0 to K-1, where K is 4.</p>
<p>The current_ here is a State structure that <strong>stores the gen value corresponding to each key</strong>, with the code as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> {</span><br><span class="line">  std::atomic&lt;<span class="type">int</span>&gt; generation[K];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span> </span>{</span><br><span class="line">    generation[k].<span class="built_in">store</span>(v, std::memory_order_release);</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> k)</span> </span>{ <span class="keyword">return</span> generation[k].<span class="built_in">load</span>(std::memory_order_acquire); }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">State</span>() {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; K; k++) {</span><br><span class="line">      <span class="built_in">Set</span>(k, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>The State structure has an atomic array generation that stores the gen value corresponding to each key. The use of atomic types and memory_order_release, memory_order_acquire semantics here ensures that <strong>once the write thread updates the gen value of a key, the read thread can immediately read the new value</strong>. For understanding the memory barrier semantics of atomic, you can refer to the Node class design in the skip list implementation from the previous article.</p>
<h3 id="Read-Thread-Operation"><a href="#Read-Thread-Operation" class="headerlink" title="Read Thread Operation"></a>Read Thread Operation</h3><p>The write thread above is relatively simple, with one thread continuously inserting new elements into the skip list. The read thread is more complex, <strong>not only reading elements from the skip list but also verifying that the data conforms to expectations</strong>. Here’s the overall approach for testing read threads as given in the comments:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// At the beginning of a read, we snapshot the last inserted</span></span><br><span class="line"><span class="comment">// generation number for each key.  We then iterate, including random</span></span><br><span class="line"><span class="comment">// calls to Next() and Seek().  For every key we encounter, we</span></span><br><span class="line"><span class="comment">// check that it is either expected given the initial snapshot or has</span></span><br><span class="line"><span class="comment">// been concurrently added since the iterator started.</span></span><br></pre></td></tr></tbody></table></figure>

<p>To ensure the correctness of the skip list in a parallel read-write environment, we can verify from the following 3 aspects:</p>
<ol>
<li>Consistency verification: Ensure that read threads <strong>do not miss keys that already existed when the iterator was created</strong> during the iteration process.</li>
<li>Sequential traversal: Verify that <strong>the order of iterator traversal is always increasing</strong>, avoiding backtracking.</li>
<li>Parallel safety: Simulate parallel read operation scenarios through random iterator movement strategies to detect potential race conditions or data inconsistency issues.</li>
</ol>
<p>The ReadStep method here has a while(true) loop. Before starting the loop, it first records the initial state of the skip list in initial_state, then uses the <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/skiplist_test.cc#L176">RandomTarget</a> method to randomly generate a target key pos, and uses the Seek method to search.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadStep</span><span class="params">(Random* rnd)</span> </span>{</span><br><span class="line">    <span class="comment">// Remember the initial committed state of the skiplist.</span></span><br><span class="line">    State initial_state;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; K; k++) {</span><br><span class="line">      initial_state.<span class="built_in">Set</span>(k, current_.<span class="built_in">Get</span>(k));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Key pos = <span class="built_in">RandomTarget</span>(rnd);</span><br><span class="line">    SkipList&lt;Key, Comparator&gt;::<span class="function">Iterator <span class="title">iter</span><span class="params">(&amp;list_)</span></span>;</span><br><span class="line">    iter.<span class="built_in">Seek</span>(pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">      ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Then comes the entire verification process. Here, we’ve omitted the case where pos is not found in the skip list and only look at the core test path.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    Key current;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    current = iter.<span class="built_in">key</span>();</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">IsValidKey</span>(current)) &lt;&lt; current;</span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(pos, current) &lt;&lt; <span class="string">"should not go backwards"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that everything in [pos,current) was not present in</span></span><br><span class="line">    <span class="comment">// initial_state.</span></span><br><span class="line">    <span class="keyword">while</span> (pos &lt; current) {</span><br><span class="line">      <span class="built_in">ASSERT_LT</span>(<span class="built_in">key</span>(pos), K) &lt;&lt; pos;</span><br><span class="line">      <span class="built_in">ASSERT_TRUE</span>((<span class="built_in">gen</span>(pos) == <span class="number">0</span>) ||</span><br><span class="line">                  (<span class="built_in">gen</span>(pos) &gt; <span class="built_in">static_cast</span>&lt;Key&gt;(initial_state.<span class="built_in">Get</span>(<span class="built_in">key</span>(pos)))))</span><br><span class="line">          &lt;&lt; <span class="string">"key: "</span> &lt;&lt; <span class="built_in">key</span>(pos) &lt;&lt; <span class="string">"; gen: "</span> &lt;&lt; <span class="built_in">gen</span>(pos)</span><br><span class="line">          &lt;&lt; <span class="string">"; initgen: "</span> &lt;&lt; initial_state.<span class="built_in">Get</span>(<span class="built_in">key</span>(pos));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Advance to next key in the valid key space</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">key</span>(pos) &lt; <span class="built_in">key</span>(current)) {</span><br><span class="line">        pos = <span class="built_in">MakeKey</span>(<span class="built_in">key</span>(pos) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        pos = <span class="built_in">MakeKey</span>(<span class="built_in">key</span>(pos), <span class="built_in">gen</span>(pos) + <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>After finding the position current, it verifies if the hash of the key value at current is correct, then verifies if pos &lt;= current. Afterwards, it uses a while loop to traverse the skip list, verifying that all keys in the <code>[pos, current)</code> interval were not in the initial state initial_state. Here, we can use <strong>proof by contradiction: if there’s a key tmp in the [pos, current) interval that’s also in initial_state, then according to the properties of skip lists, Seek would have found tmp instead of current</strong>. So as long as the linked list is implemented correctly, all keys in the [pos, current) interval should not be in initial_state.</p>
<p>Of course, we haven’t recorded the key values in the skip list here. We only need to verify that the gen values of all keys in the [pos, current) interval are greater than the gen values in the initial state, which can prove that all keys in this range were not in the linked list when iteration began.</p>
<p>After each round of verification above, a new test target key pos is found and the iterator is updated, as shown in the following code:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rnd-&gt;<span class="built_in">Next</span>() % <span class="number">2</span>) {</span><br><span class="line">  iter.<span class="built_in">Next</span>();</span><br><span class="line">  pos = <span class="built_in">MakeKey</span>(<span class="built_in">key</span>(pos), <span class="built_in">gen</span>(pos) + <span class="number">1</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  Key new_target = <span class="built_in">RandomTarget</span>(rnd);</span><br><span class="line">  <span class="keyword">if</span> (new_target &gt; pos) {</span><br><span class="line">    pos = new_target;</span><br><span class="line">    iter.<span class="built_in">Seek</span>(new_target);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, it randomly decides whether to move to the next key with iter.Next() or create a new target key and relocate to that target key. The entire read test simulates the uncertainty in a real environment, ensuring the stability and correctness of the skip list under various access patterns.</p>
<h3 id="Single-threaded-Read-and-Write"><a href="#Single-threaded-Read-and-Write" class="headerlink" title="Single-threaded Read and Write"></a>Single-threaded Read and Write</h3><p>After introducing the methods for testing read and write, let’s see how to combine them with threads for testing. Single-threaded read and write is relatively simple, just alternating between write and read execution.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple test that does single-threaded testing of the ConcurrentTest</span></span><br><span class="line"><span class="comment">// scaffolding.</span></span><br><span class="line"><span class="built_in">TEST</span>(SkipTest, ConcurrentWithoutThreads) {</span><br><span class="line">  ConcurrentTest test;</span><br><span class="line">  <span class="function">Random <span class="title">rnd</span><span class="params">(test::RandomSeed())</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">    test.<span class="built_in">ReadStep</span>(&amp;rnd);</span><br><span class="line">    test.<span class="built_in">WriteStep</span>(&amp;rnd);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Parallel-Read-and-Write-Testing"><a href="#Parallel-Read-and-Write-Testing" class="headerlink" title="Parallel Read and Write Testing"></a>Parallel Read and Write Testing</h3><p>In real scenarios, there’s one write thread but can be multiple read threads, and we need to test the correctness of the skip list in parallel read and write scenarios. The core test code is as follows:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">RunConcurrent</span><span class="params">(<span class="type">int</span> run)</span> </span>{</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> seed = test::<span class="built_in">RandomSeed</span>() + (run * <span class="number">100</span>);</span><br><span class="line">  <span class="function">Random <span class="title">rnd</span><span class="params">(seed)</span></span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> kSize = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">    <span class="keyword">if</span> ((i % <span class="number">100</span>) == <span class="number">0</span>) {</span><br><span class="line">      std::<span class="built_in">fprintf</span>(stderr, <span class="string">"Run %d of %d\n"</span>, i, N);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TestState <span class="title">state</span><span class="params">(seed + <span class="number">1</span>)</span></span>;</span><br><span class="line">    Env::<span class="built_in">Default</span>()-&gt;<span class="built_in">Schedule</span>(ConcurrentReader, &amp;state);</span><br><span class="line">    state.<span class="built_in">Wait</span>(TestState::RUNNING);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSize; i++) {</span><br><span class="line">      state.t_.<span class="built_in">WriteStep</span>(&amp;rnd);</span><br><span class="line">    }</span><br><span class="line">    state.quit_flag_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">    state.<span class="built_in">Wait</span>(TestState::DONE);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, each test case iterates N times. In each iteration, the Env::Default()-&gt;Schedule method is used to create a new thread to execute the ConcurrentReader function, passing state as a parameter. ConcurrentReader will perform read operations in an independent thread, simulating a parallel read environment. Then, it calls state.Wait(TestState::RUNNING) to wait for the read thread to enter the running state before the main thread starts write operations.</p>
<p>Here, write operations are performed by calling state.t_.WriteStep(&amp;rnd) in a loop, executing kSize write operations on the skip list. Each write operation will insert a new key-value pair into the skip list, simulating the behavior of the write thread. After completing the write operations, state.quit_flag_ is set to true, notifying the read thread to stop reading operations and exit. It then waits for the read thread to complete all operations and exit, ensuring that all read and write operations in the current loop have ended before proceeding to the next test.</p>
<p>This test uses TestState to synchronize thread states and encapsulates a ConcurrentReader as the read thread method. It also calls the Schedule method encapsulated by Env to execute read operations in an independent thread. This involves condition variables, mutexes, and thread-related content, which we won’t expand on here.</p>
<p>It’s worth noting that this <strong>only tests the scenario of one write and one read in parallel, and doesn’t test one write with multiple reads</strong>. Multiple read threads could be started in each iteration, with all read threads executing concurrently with the write operation. Alternatively, a fixed pool of read threads could be maintained, with multiple read threads running continuously, operating concurrently with the write thread. However, the current test, through repeated one-write-one-read iterations, can still effectively verify the correctness and stability of the skip list under read-write concurrency.</p>
<p>Below is a screenshot of the test case execution output:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_runtest.png/webp" alt="Parallel test output" srcset="https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_runtest.png/webp 2290w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_runtest.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_runtest.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_runtest.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2290" height="1902"></p>
<h2 id="Correctness-of-Parallel-Testing"><a href="#Correctness-of-Parallel-Testing" class="headerlink" title="Correctness of Parallel Testing"></a>Correctness of Parallel Testing</h2><p>The above parallel testing is quite detailed, but it’s worth elaborating a bit more. For this kind of parallel code, especially code involving memory barriers, sometimes <strong>passing tests might just be because issues weren’t triggered</strong> (the probability of problems occurring is very low, and it might also be related to the compiler and CPU model). For example, if I slightly modify the Insert operation here:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; i++) {</span><br><span class="line">  <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">  <span class="comment">// we publish a pointer to "x" in prev[i].</span></span><br><span class="line">  x-&gt;<span class="built_in">NoBarrier_SetNext</span>(i, prev[i]-&gt;<span class="built_in">NoBarrier_Next</span>(i));</span><br><span class="line">  prev[i]-&gt;<span class="built_in">NoBarrier_SetNext</span>(i, x); <span class="comment">// Change here, Use NoBarrier_SetNext</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here, both pointers use the NoBarrier_SetNext method to set, then recompile the LevelDB library and test program, run multiple times, and all test cases can pass.</p>
<p>Of course, in this case, long-term testing can be conducted under different hardware configurations and loads, which might reveal issues. However, the drawback is that it’s time-consuming and may not be able to reproduce the issues found.</p>
<h3 id="Detecting-Data-Races-with-ThreadSanitizer"><a href="#Detecting-Data-Races-with-ThreadSanitizer" class="headerlink" title="Detecting Data Races with ThreadSanitizer"></a>Detecting Data Races with ThreadSanitizer</h3><p>In addition, we can use clang’s dynamic analysis tool <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a> to detect data races. It’s relatively simple to use, just add the <code>-fsanitize=thread</code> option when compiling. The complete compilation command is as follows:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC=/usr/bin/clang CXX=/usr/bin/clang++  cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_CXX_FLAGS="-fsanitize=thread" -DCMAKE_C_FLAGS="-fsanitize=thread" -DCMAKE_EXE_LINKER_FLAGS="-fsanitize=thread" -DCMAKE_INSTALL_PREFIX=$(pwd) .. &amp;&amp; cmake --build . --target install</span><br></pre></td></tr></tbody></table></figure>

<p>Recompile and link the code with the above modification, run the test case, and the result is as follows:</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_threadsanitizer.png/webp" alt="ThreadSanitizer detecting data race" srcset="https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_threadsanitizer.png/webp 3314w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_threadsanitizer.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_threadsanitizer.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240918_leveldb_source_skiplist_more_threadsanitizer.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3314" height="1834"></p>
<p>It has precisely located the problematic code. If we undo this erroneous modification and recompile and run, there won’t be any issues. The implementation principle of ThreadSanitizer is quite complex. When the program is compiled, TSan <strong>inserts check code before and after each memory access operation</strong>. During runtime, when the program executes a memory access operation, the inserted code is triggered. This code checks and updates the corresponding shadow memory. It compares the current access with the historical access records of that memory location. If a potential data race is detected, TSan records detailed information, including stack traces.</p>
<p>Its advantage is that it can detect subtle data races that are difficult to discover through other methods, while providing detailed diagnostic information, which helps to quickly locate and fix problems. However, it significantly increases the program’s runtime and memory usage. It may not be able to detect all types of concurrent errors, especially those that depend on specific timing.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>We have completed the analysis of the skip list testing part, focusing on the correctness verification in parallel read and write scenarios. The design of the inserted key value Key and the verification method of read threads are both very clever, worthy of our reference. At the same time, we should recognize that in multi-threaded scenarios, data race detection is sometimes difficult to discover through test cases alone. Tools like ThreadSanitizer can assist in discovering some issues.</p>
<p>Finally, welcome everyone to leave comments and exchange ideas!</p>
</div><div class="article-footer-copyright"><p> Written in Chinese, LLM translated into English</p><p>Non-commercial reproduction is allowed with proper attribution to the author and source. </p><p>For commercial reproduction, please contact the <a href="mailto:xuezaigds@gmail.com">author</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="Sponsor"></a><div class="donate_txt"> ↑<br>Good content, Sponsor it<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="WeChat Sponsor"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="Alipay Sponsor"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2024/09/18/leveldb-source-skiplist-test-en/';
    this.page.identifier = '2024/09/18/leveldb-source-skiplist-test-en/';
    this.page.title = 'LevelDB Explained - How to Test Parallel Read and Write of SkipLists?';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Categories</span></div><ul><li><a href="/en/categories/Programming/">Programming</a> (18)</li><li><a href="/en/categories/Source-Code-Analysis/">Source Code Analysis</a> (12)</li><li><a href="/en/categories/Artificial-Intelligence/">Artificial Intelligence</a> (13)</li><li><a href="/en/categories/Discovery/">Discovery</a> (1)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>Tags</span></div><div class="tagcloud"><a href="/en/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/en/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/en/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/en/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/en/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/en/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/en/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/en/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/en/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/en/tags/Frontend/" style="font-size: 15.00px;">Frontend</a> <a href="/en/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/en/tags/SEO/" style="font-size: 15.00px;">SEO</a> <a href="/en/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/en/tags/Web/" style="font-size: 15.00px;">Web</a> <a href="/en/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2024/09/18/leveldb-source-skiplist-test-en/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>Recent</span></div><ul><li><a href="/2024/09/18/leveldb-source-skiplist-test-en/" title="LevelDB Explained - How to Test Parallel Read and Write of SkipLists?">LevelDB Explained - How to Test Parallel Read and Write of SkipLists?</a></li><li><a href="/en/2024/09/13/gpto1_hands_on/" title="Hands-on with OpenAI's o1-preview - Not Better Enough?">Hands-on with OpenAI's o1-preview - Not Better Enough?</a></li><li><a href="/en/2024/09/09/leveldb_source_skiplist/" title="LevelDB Explained - How to implement SkipList">LevelDB Explained - How to implement SkipList</a></li><li><a href="/en/2024/09/05/claude35_prompt/" title="Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...">Claude3.5's System Prompts - No Apologies, Face Blind, Hallucinate...</a></li><li><a href="/en/2024/08/29/leveldb_source_utils/" title="LevelDB Explained - Arena, Random, CRC32, and More.">LevelDB Explained - Arena, Random, CRC32, and More.</a></li><li><a href="/en/2024/08/14/leveldb_source_wal_log/" title="LevelDB Explained - How To Read and Write WAL Logs">LevelDB Explained - How To Read and Write WAL Logs</a></li><li><a href="/en/2024/08/13/leveldb_source_unstand_c++/" title="LevelDB Explained -  Understanding Advanced C++ Techniques">LevelDB Explained -  Understanding Advanced C++ Techniques</a></li><li><a href="/en/2024/08/08/leveldb_source_bloom_filter/" title="LevelDB Explained - Bloom Filter Implementation and Visualization">LevelDB Explained - Bloom Filter Implementation and Visualization</a></li><li><a href="/en/2024/08/06/leveldb_source_prepare/" title="LevelDB Explained - Preparing the Development Environment">LevelDB Explained - Preparing the Development Environment</a></li><li><a href="/en/2024/08/02/leveldb_source_env_posixfile/" title="LevelDB Explained - Posix File Operation Details">LevelDB Explained - Posix File Operation Details</a></li></ul></div><!-- Debug: Current Language = en, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> Contents</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Skip-List-Test-Analysis"><span class="toc-number">1.</span> <span class="toc-text">Skip List Test Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Test-Key-Design"><span class="toc-number">1.1.</span> <span class="toc-text">Test Key Design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Write-Thread-Operation"><span class="toc-number">1.2.</span> <span class="toc-text">Write Thread Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-Thread-Operation"><span class="toc-number">1.3.</span> <span class="toc-text">Read Thread Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Single-threaded-Read-and-Write"><span class="toc-number">1.4.</span> <span class="toc-text">Single-threaded Read and Write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Read-and-Write-Testing"><span class="toc-number">1.5.</span> <span class="toc-text">Parallel Read and Write Testing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Correctness-of-Parallel-Testing"><span class="toc-number">2.</span> <span class="toc-text">Correctness of Parallel Testing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Detecting-Data-Races-with-ThreadSanitizer"><span class="toc-number">2.1.</span> <span class="toc-text">Detecting Data Races with ThreadSanitizer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary"><span class="toc-number">3.</span> <span class="toc-text">Summary</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>Total Site Visits:  <span id="busuanzi_value_site_pv"></span> Times，<span id="busuanzi_container_site_uv"></span>Unique Visitors:  <span id="busuanzi_value_site_uv"></span> People</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>