<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-WUJTOV7jES"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="深入探讨LevelDB源码中的 NoDestructor 模板类，揭示其禁止对象析构的实现原理和背后动机。分析C++静态局部变量析构顺序问题，介绍NoDestructor的设计细节、测试用例及实际应用场景。适合C++开发者和对底层系统感兴趣的程序员阅读，助您掌握高级C++编程技巧。"><title>LevelDB 源码阅读：禁止对象被析构</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LevelDB 源码阅读：禁止对象被析构</h1><a id="logo" href="/.">Just For Fun</a><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/aboutme.html"><i class="fa fa-user"> 关于</i></a><a href="/links.html"><i class="fa fa-user-graduate"> 小盛律师</i></a><a href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"><i class="fa fa-scale-balanced"> 法律普及</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB 源码阅读：禁止对象被析构</h1><div class="post-meta">2024/07/22<span> | </span><span class="category"><a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/07/22/leveldb_source_nodestructor/" href="/2024/07/22/leveldb_source_nodestructor/#disqus_thread"></a><div class="post-content"><p>LevelDB 源码中有一个获取 Comparator 的函数，第一次看到的时候觉得有点奇怪，看起来像是构造了一个单例，但又略复杂。完整代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/comparator.cc</span></span><br><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的 <code>NoDestructor</code> 是一个模板类，看名字是用于<strong>禁止对象析构</strong>。为什么要禁止对象析构，又是如何做到禁止析构呢？这篇文章来深入探讨下这个问题。</p>
<span id="more"></span>

<h2 id="NoDestructor-模板类"><a href="#NoDestructor-模板类" class="headerlink" title="NoDestructor 模板类"></a>NoDestructor 模板类</h2><p>我们先来看看 <code>NoDestructor</code> 模板类，它用于<strong>包装一个实例，使得其析构函数不会被调用</strong>。这个模板类用了比较多的高级特性，如模板编程、完美转发、静态断言、对齐要求、以及原地构造（placement new）等，接下来一一解释。这里先给出完整的代码实现：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/no_destructor.h</span></span><br><span class="line"><span class="comment">// Wraps an instance whose destructor is never called.</span></span><br><span class="line"><span class="comment">// This is intended for use with function-level static variables.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InstanceType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoDestructor</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ConstructorArgTypes&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">NoDestructor</span><span class="params">(ConstructorArgTypes&amp;&amp;... constructor_args)</span> </span>{</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(instance_storage_) &gt;= <span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                  <span class="string">"instance_storage_ is not large enough to hold the instance"</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        <span class="built_in">alignof</span>(<span class="keyword">decltype</span>(instance_storage_)) &gt;= <span class="built_in">alignof</span>(InstanceType),</span><br><span class="line">        <span class="string">"instance_storage_ does not meet the instance's alignment requirement"</span>);</span><br><span class="line">    <span class="keyword">new</span> (&amp;instance_storage_)</span><br><span class="line">        <span class="built_in">InstanceType</span>(std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">NoDestructor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NoDestructor</span>(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  NoDestructor&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">InstanceType* <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;InstanceType*&gt;(&amp;instance_storage_);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typename</span> std::aligned_storage&lt;<span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                                <span class="built_in">alignof</span>(InstanceType)&gt;::type instance_storage_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>先来看构造函数部分。<code>typename... ConstructorArgTypes</code> 表示这是一个变参模板函数，可以接受任意数量和类型的参数。这使得 NoDestructor 类可以用于任何类型的 InstanceType，不管其构造函数需要多少个参数或是什么类型的参数。关于变参模板，也可以看看我之前写的一篇文章：<a href="https://selfboot.cn/2024/05/07/variadic_arguments_in_c++/">C++ 函数可变参实现方法的演进</a>。</p>
<p>构造函数的参数 <code>ConstructorArgTypes&amp;&amp;... constructor_args</code> 是一个万能引用（universal reference）参数包，结合 std::forward 使用，可以实现参数的完美转发。</p>
<p>构造函数开始是两个<strong>静态断言（static_assert），用于检查 instance_storage_ 是否足够大以及是否满足对齐要求</strong>。第一个 static_assert 确保为 InstanceType 分配的存储空间 instance_storage_ 至少要和 InstanceType 实例本身一样大，这是为了<strong>确保有足够的空间来存放该类型的对象</strong>。第二个 static_assert 确保 instance_storage_ 的对齐方式满足 InstanceType 的对齐要求。对象只所以有内存对齐要求，和性能有关，这里不再展开。</p>
<p>接着开始构造对象，这里使用了 <strong>C++ 的原地构造语法（placement new）</strong>。<code>&amp;instance_storage_</code> 提供了一个地址，告诉编译器在这个已经分配好的内存地址上构造 InstanceType 的对象。这样做避免了额外的内存分配，直接在预留的内存块中构造对象。接下来使用完美转发，<code>std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...</code> 确保所有的构造函数参数都以正确的类型（保持左值或右值属性）传递给 InstanceType 的构造函数。这是现代 C++ 中参数传递的最佳实践，能够减少不必要的拷贝或移动操作，提高效率。</p>
<p>前面 placement new 原地构造的时候用的内存地址由成员变量 instance_storage_ 提供，instance_storage_ 的类型由 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/aligned_storage">std::aligned_storage</a> 模板定义。这是一个特别设计的类型，<strong>用于提供一个可以安全地存储任何类型的原始内存块，同时确保所存储的对象类型（这里是 InstanceType）具有适当的大小和对齐要求</strong>。这里 std::aligned_storage 创建的原始内存区域和 NoDestructor 对象所在的内存区域一致，也就是说如果 NoDestructor 被定义为一个函数内的局部变量，那么它和其内的 instance_storage_ 都会位于栈上。如果 NoDestructor 被定义为静态或全局变量，它和 instance_storage_ 将位于静态存储区，静态存储区的对象具有整个程序执行期间的生命周期。</p>
<p>值得注意的是 C++23 标准里，将废弃 std::aligned_storage，具体可以参考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/71828288/why-is-stdaligned-storage-to-be-deprecated-in-c23-and-what-to-use-instead">Why is std::aligned_storage to be deprecated in C++23 and what to use instead?</a>。</p>
<p>回到文章开始的例子，singleton 对象是一个静态局部变量，第一次调用 BytewiseComparator() 时被初始化，它的生命周期和程序的整个生命周期一样长。程序退出的时候，<strong>singleton 对象本身会被析构销毁掉</strong>，但是 NoDestructor 没有在其析构函数中添加任何逻辑来析构 instance_storage_ 中构造的对象，因此 instance_storage_ 中的 BytewiseComparatorImpl 对象永远不会被析构。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>LevelDB 中还提供了一个测试用例，用来验证这里的 NoDestructor 是否符合预期。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>在 <code>util/no_destructor_test.cc</code> 中首先定义了一个结构体 <code>DoNotDestruct</code>，这个结构体在析构函数中调用了 std::abort()。如果程序运行或者最后退出的时候，调用了 DoNotDestruct 对象的析构函数，那么测试程序将会异常终止。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DoNotDestruct</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DoNotDestruct</span>(<span class="type">uint32_t</span> a, <span class="type">uint64_t</span> b) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b) {}</span><br><span class="line">  ~<span class="built_in">DoNotDestruct</span>() { std::<span class="built_in">abort</span>(); }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used to check constructor argument forwarding.</span></span><br><span class="line">  <span class="type">uint32_t</span> a;</span><br><span class="line">  <span class="type">uint64_t</span> b;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>接着定义了 2 个测试用例，一个定义了栈上的 NoDestructor 对象，另一个定义了一个静态的 NoDestructor 对象。这两个测试用例分别验证 NoDestructor 对象在栈上和静态存储区上的行为。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StackInstance) {</span><br><span class="line">  <span class="function">NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StaticInstance) {</span><br><span class="line">  <span class="function"><span class="type">static</span> NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果 NoDestructor 的实现有问题，无法保证传入对象的析构不被执行，那么测试程序将会异常终止掉。我们跑下这两个测试用例，结果如下：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png/webp" alt="测试用例通过，析构函数没有被调用" srcset="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png/webp 2152w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2152" height="634"></p>
<p>这里我们可以增加个测试用例，验证下如果直接定义 DoNotDestruct 对象的话，测试进程会不会异常终止。可以先定义一个栈上的对象来测试，放在其他 2 个测试用例前面，如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, Instance) {</span><br><span class="line">  <span class="function">DoNotDestruct <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下，这个测试用例执行过程中会异常终止，说明 DoNotDestruct 对象的析构函数被调用了。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png/webp" alt="测试进程异常终止，说明调用了析构" srcset="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png/webp 2090w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2090" height="330"></p>
<p>其实这里可以再改下，用 static 直接定义这里的 instance 对象，然后编译重新运行测试用例，就会发现 3 个测试用例都通过了，不过最后测试进程还是 abort 掉，这是因为进程退出的时候，才会析构静态对象，这时 DoNotDestruct 对象的析构函数被调用了。</p>
<h2 id="为什么不能析构？"><a href="#为什么不能析构？" class="headerlink" title="为什么不能析构？"></a>为什么不能析构？</h2><p>上面的例子中，我们看到了 NoDestructor 模板类的实现，它的作用是禁止静态局部的单例对象析构。那么为什么要禁止对象析构呢？简单来说，<strong>C++ 标准没有规定不同编译单元中静态局部变量的析构顺序</strong>，如果静态变量之间存在依赖关系，而它们的析构顺序错误，可能会导致程序访问已经析构的对象，从而产生未定义行为，可能导致程序崩溃。</p>
<p>举一个例子，假设有两个类，一个是日志系统，另一个是某种服务，服务在析构时需要向日志系统记录信息。日志类的代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span> <span class="comment">// Include assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isAlive; <span class="comment">// Flag to check if the object has been destructed</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">static</span> Logger instance; <span class="comment">// 静态局部变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>() : <span class="built_in">isAlive</span>(<span class="literal">true</span>) {} <span class="comment">// Constructor initializes isAlive to true</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logger</span>() {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Logger destroyed."</span> &lt;&lt; std::endl;</span><br><span class="line">        isAlive = <span class="literal">false</span>; <span class="comment">// Mark as destructed</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>{</span><br><span class="line">        <span class="built_in">assert</span>(isAlive); <span class="comment">// Assert the object is not destructed</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Log: "</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>注意这个类的 isAlive 成员变量，在构造函数中初始化为 true，析构函数中置为 false。在 log 函数中，会先检查 isAlive 是否为 true，如果为 false，就会触发断言失败。接着是服务类的代码，这里作为示例，只让它在析构的时候用日志类的静态局部变量记录一条日志。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Service</span>() {</span><br><span class="line">        Logger::<span class="built_in">getInstance</span>().<span class="built_in">log</span>(<span class="string">"Service destroyed."</span>); <span class="comment">// 在析构时记录日志</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>在 main 函数中，使用全局变量 globalService 和 globalLogger，其中 globalService 是一个全局 Service 实例，globalLogger 是一个 Logger 单例。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"service.h"</span></span></span><br><span class="line"></span><br><span class="line">Service globalService; <span class="comment">// 全局Service实例</span></span><br><span class="line">Logger&amp; globalLogger = Logger::<span class="built_in">getInstance</span>(); <span class="comment">// 全局Logger实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编译运行这个程序：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -g -fno-omit-frame-pointer -o main main.cpp</span></span><br></pre></td></tr></tbody></table></figure>

<p>运行后 assert 断言<strong>大概率会失败</strong>。我们知道<strong>在单个编译单元(这里是 main.cpp)中，全局变量按照出现的顺序来初始化，然后按照相反的顺序来析构</strong>。这里 globalLogger 会先析构，然后是 globalService，在 globalService 的析构函数中会调用 Logger 的 log 函数，但这时 globalLogger 已经被析构，isAlive 被置为 false，所以大概率会触发断言失败。之所以说大概率是因为，globalLogger 对象析构后，其占用的内存空间可能还<strong>未被操作系统回收或用于其他目的</strong>，对其成员变量 isAlive 的访问可能仍能“正常”。下面是我运行的结果：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">main: logger.h:22: void Logger::log(const string&amp;): Assertion `isAlive' failed.</span><br><span class="line">[1]    1017435 abort      ./main</span><br></pre></td></tr></tbody></table></figure>

<p>其实这里如果不加 isAlive 相关逻辑，运行的话输出大概率如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">Log: Service destroyed.</span><br></pre></td></tr></tbody></table></figure>

<p>从输出可以看到和前面一样 globalLogger 先析构，lobalService 后析构。只是这里进程大概率不会 crash 掉，这是因为 globalLogger 被析构后，<strong>虽然其生命周期已结束，但是对成员函数的调用仍可能“正常”执行</strong>。这里成员函数的执行通常依赖于类的代码（位于代码段），只要代码段内容没有被重新写，并且方法不依赖于已经被破坏或改变的成员变量，它可能仍能运行而不出错。</p>
<p>当然就算这里没有触发程序崩溃，使用已析构对象的行为在 C++ 中是<a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">未定义的（Undefined Behavior）</a>。未定义行为意味着程序可能崩溃、可能正常运行，或者产生不可预期的结果。此类行为的结果可能在不同的系统或不同的运行时有所不同，我们在开发中一定要避免这种情况的发生。</p>
<p>其实就 LevelDB 这里的实现来说，BytewiseComparatorImpl 是一个平凡可析构 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor">trivially destructible</a> 对象，它不依赖其他全局变量，因此它本身析构不会有问题。如果用它生成一个静态局部的单例对象，然后在其他静态局部对象或者全局对象中使用，那么在这些对象析构时，会调用 BytewiseComparatorImpl 的析构函数。而根据前面的分析，这里 BytewiseComparatorImpl 本身是一个静态局部对象，<strong>在进程结束资源回收时，可能早于使用它的对象被被析构</strong>。这样就会导致重复析构，产生未定义行为。</p>
<p>更多关于静态变量析构的解释也可以参考 <a target="_blank" rel="noopener" href="https://ppwwyyxx.com/blog/2023/Safe-Static-Initialization-No-Destruction/">Safe Static Initialization, No Destruction</a> 这篇文章，作者详细讨论了这个问题。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：LevelDB 源码阅读：禁止对象被析构</p><p>本文链接为：https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="打赏"></a><div class="donate_txt"> ↑<br>内容不错，打赏你啦<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div class="post-nav"><a class="pre" href="/2024/07/23/lawer_sexual_harassment/">从法院判决书看性骚扰行为的后果</a><a class="next" href="/2024/06/22/claude35_artifacts/">免费版 Claude3.5 配合 Artifacts，一句话就能写个游戏</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/';
    this.page.identifier = '2024/07/22/leveldb_source_nodestructor/';
    this.page.title = 'LevelDB 源码阅读：禁止对象被析构';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a><span class="category-list-count">29</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">工具介绍</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/">法律普及</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A4%BE%E4%BC%9A%E7%99%BE%E6%80%81/">社会百态</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%91%E8%9E%8D/">金融</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a><span class="category-list-count">10</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 15px;">教程</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 15px;">总结</a> <a href="/tags/%E6%96%B9%E6%B3%95/" style="font-size: 15px;">方法</a> <a href="/tags/Google/" style="font-size: 15px;">Google</a> <a href="/tags/%E6%80%9D%E8%80%83/" style="font-size: 15px;">思考</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/DNS/" style="font-size: 15px;">DNS</a> <a href="/tags/%E8%A7%81%E9%97%BB/" style="font-size: 15px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15px;">Protocol</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Flask/" style="font-size: 15px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/%E6%B3%95%E5%BE%8B/" style="font-size: 15px;">法律</a> <a href="/tags/ChatGPT/" style="font-size: 15px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15px;">eBPF</a> <a href="/tags/%E5%A9%9A%E5%A7%BB%E5%AE%B6%E5%BA%AD/" style="font-size: 15px;">婚姻家庭</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/%E5%88%91%E4%BA%8B/" style="font-size: 15px;">刑事</a> <a href="/tags/%E5%8A%B3%E5%8A%A8%E7%BA%A0%E7%BA%B7/" style="font-size: 15px;">劳动纠纷</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 15px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15px;">Gemini</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/LLM/" style="font-size: 15px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15px;">LevelDB</a></div></div><!-- Debug: page.path = 2024/07/22/leveldb_source_nodestructor/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul><li><a href="/2024/07/22/leveldb_source_nodestructor/" title="LevelDB 源码阅读：禁止对象被析构">LevelDB 源码阅读：禁止对象被析构</a></li><li><a href="/2024/06/22/claude35_artifacts/" title="免费版 Claude3.5 配合 Artifacts，一句话就能写个游戏">免费版 Claude3.5 配合 Artifacts，一句话就能写个游戏</a></li><li><a href="/2024/06/13/async_pool_block_problem/" title="溢出、异常、线程池、阻塞，奇怪的服务重启问题定位">溢出、异常、线程池、阻塞，奇怪的服务重启问题定位</a></li><li><a href="/2024/05/19/stream_sse_chunk/" title="结合实例理解流式输出的几种实现方法">结合实例理解流式输出的几种实现方法</a></li><li><a href="/2024/05/10/c++_object_model/" title="结合实例深入理解 C++ 对象的内存布局">结合实例深入理解 C++ 对象的内存布局</a></li><li><a href="/2024/05/07/variadic_arguments_in_c++/" title="C++ 函数可变参实现方法的演进">C++ 函数可变参实现方法的演进</a></li><li><a href="/2024/03/15/object_memory_coredump/" title="Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析">Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析</a></li><li><a href="/2024/01/25/why_need_use_gpt_asap/" title="为什么一定要尽快用上 ChatGPT 等大语言模型">为什么一定要尽快用上 ChatGPT 等大语言模型</a></li><li><a href="/2024/01/18/supply_chain_attack_on_pytorch/" title="我们是如何对 PyTorch 发起供应链攻击的 (译文)">我们是如何对 PyTorch 发起供应链攻击的 (译文)</a></li><li><a href="/2024/01/17/c++_string_cow/" title="C++ string 意外修改之深入理解 COW 写时复制">C++ string 意外修改之深入理解 COW 写时复制</a></li></ul></div><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"> 文章目录</i></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NoDestructor-%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">NoDestructor 模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">测试用例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%9E%90%E6%9E%84%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">为什么不能析构？</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量<span id="busuanzi_value_site_pv"></span>次，<span id="busuanzi_container_site_uv"></span>本站访客数<span id="busuanzi_value_site_uv"></span>人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>