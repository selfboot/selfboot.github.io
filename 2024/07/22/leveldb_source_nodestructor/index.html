<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="深入探讨LevelDB源码中的 NoDestructor 模板类，揭示其禁止对象析构的实现原理和背后动机。分析C++静态局部变量析构顺序问题，介绍NoDestructor的设计细节、测试用例及实际应用场景。适合C++开发者和对底层系统感兴趣的程序员阅读，助您掌握高级C++编程技巧。"><title>LevelDB 源码阅读：禁止对象被析构</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}
</script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7746897490519544" crossorigin="anonymous"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"><i class="fa fa-scale-balanced"></i><span> 法律普及</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB 源码阅读：禁止对象被析构</h1><div class="post-meta">2024/07/22<span> | </span><span class="category"><a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2024/07/22/leveldb_source_nodestructor/" href="/2024/07/22/leveldb_source_nodestructor/#disqus_thread"></a><div class="post-content"><p>LevelDB 源码中有一个获取 Comparator 的函数，第一次看到的时候觉得有点奇怪，看起来像是构造了一个单例，但又略复杂。完整代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/comparator.cc</span></span><br><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的 <code>NoDestructor</code> 是一个模板类，看名字是用于<strong>禁止对象析构</strong>。为什么要禁止对象析构，又是如何做到禁止析构呢？这篇文章来深入探讨下这个问题。</p>
<span id="more"></span>

<h2 id="NoDestructor-模板类"><a href="#NoDestructor-模板类" class="headerlink" title="NoDestructor 模板类"></a>NoDestructor 模板类</h2><p>我们先来看看 <code>NoDestructor</code> 模板类，它用于<strong>包装一个实例，使得其析构函数不会被调用</strong>。这个模板类用了比较多的高级特性，如模板编程、完美转发、静态断言、对齐要求、以及原地构造（placement new）等，接下来一一解释。这里先给出完整的代码实现：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/no_destructor.h</span></span><br><span class="line"><span class="comment">// Wraps an instance whose destructor is never called.</span></span><br><span class="line"><span class="comment">// This is intended for use with function-level static variables.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InstanceType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoDestructor</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ConstructorArgTypes&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">NoDestructor</span><span class="params">(ConstructorArgTypes&amp;&amp;... constructor_args)</span> </span>{</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(instance_storage_) &gt;= <span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                  <span class="string">"instance_storage_ is not large enough to hold the instance"</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        <span class="built_in">alignof</span>(<span class="keyword">decltype</span>(instance_storage_)) &gt;= <span class="built_in">alignof</span>(InstanceType),</span><br><span class="line">        <span class="string">"instance_storage_ does not meet the instance's alignment requirement"</span>);</span><br><span class="line">    <span class="keyword">new</span> (&amp;instance_storage_)</span><br><span class="line">        <span class="built_in">InstanceType</span>(std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">NoDestructor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NoDestructor</span>(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  NoDestructor&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">InstanceType* <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;InstanceType*&gt;(&amp;instance_storage_);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typename</span> std::aligned_storage&lt;<span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                                <span class="built_in">alignof</span>(InstanceType)&gt;::type instance_storage_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>先来看构造函数部分。<code>typename... ConstructorArgTypes</code> 表示这是一个变参模板函数，可以接受任意数量和类型的参数。这使得 NoDestructor 类可以用于任何类型的 InstanceType，不管其构造函数需要多少个参数或是什么类型的参数。关于变参模板，也可以看看我之前写的一篇文章：<a href="https://selfboot.cn/2024/05/07/variadic_arguments_in_c++/">C++ 函数可变参实现方法的演进</a>。</p>
<p>构造函数的参数 <code>ConstructorArgTypes&amp;&amp;... constructor_args</code> 是一个万能引用（universal reference）参数包，结合 std::forward 使用，可以实现参数的完美转发。</p>
<p>构造函数开始是两个<strong>静态断言（static_assert），用于检查 instance_storage_ 是否足够大以及是否满足对齐要求</strong>。第一个 static_assert 确保为 InstanceType 分配的存储空间 instance_storage_ 至少要和 InstanceType 实例本身一样大，这是为了<strong>确保有足够的空间来存放该类型的对象</strong>。第二个 static_assert 确保 instance_storage_ 的对齐方式满足 InstanceType 的对齐要求。对象只所以有内存对齐要求，和性能有关，这里不再展开。</p>
<p>接着开始构造对象，这里使用了 <strong>C++ 的原地构造语法（placement new）</strong>。<code>&amp;instance_storage_</code> 提供了一个地址，告诉编译器在这个已经分配好的内存地址上构造 InstanceType 的对象。这样做避免了额外的内存分配，直接在预留的内存块中构造对象。接下来使用完美转发，<code>std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...</code> 确保所有的构造函数参数都以正确的类型（保持左值或右值属性）传递给 InstanceType 的构造函数。这是现代 C++ 中参数传递的最佳实践，能够减少不必要的拷贝或移动操作，提高效率。</p>
<p>前面 placement new 原地构造的时候用的内存地址由成员变量 instance_storage_ 提供，instance_storage_ 的类型由 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/aligned_storage">std::aligned_storage</a> 模板定义。这是一个特别设计的类型，<strong>用于提供一个可以安全地存储任何类型的原始内存块，同时确保所存储的对象类型（这里是 InstanceType）具有适当的大小和对齐要求</strong>。这里 std::aligned_storage 创建的原始内存区域和 NoDestructor 对象所在的内存区域一致，也就是说如果 NoDestructor 被定义为一个函数内的局部变量，那么它和其内的 instance_storage_ 都会位于栈上。如果 NoDestructor 被定义为静态或全局变量，它和 instance_storage_ 将位于静态存储区，静态存储区的对象具有整个程序执行期间的生命周期。</p>
<p>值得注意的是 C++23 标准里，将废弃 std::aligned_storage，具体可以参考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/71828288/why-is-stdaligned-storage-to-be-deprecated-in-c23-and-what-to-use-instead">Why is std::aligned_storage to be deprecated in C++23 and what to use instead?</a>。</p>
<p>回到文章开始的例子，singleton 对象是一个静态局部变量，第一次调用 BytewiseComparator() 时被初始化，它的生命周期和程序的整个生命周期一样长。程序退出的时候，<strong>singleton 对象本身会被析构销毁掉</strong>，但是 NoDestructor 没有在其析构函数中添加任何逻辑来析构 instance_storage_ 中构造的对象，因此 instance_storage_ 中的 BytewiseComparatorImpl 对象永远不会被析构。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>LevelDB 中还提供了一个测试用例，用来验证这里的 NoDestructor 是否符合预期。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>在 <code>util/no_destructor_test.cc</code> 中首先定义了一个结构体 <code>DoNotDestruct</code>，这个结构体在析构函数中调用了 std::abort()。如果程序运行或者最后退出的时候，调用了 DoNotDestruct 对象的析构函数，那么测试程序将会异常终止。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DoNotDestruct</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DoNotDestruct</span>(<span class="type">uint32_t</span> a, <span class="type">uint64_t</span> b) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b) {}</span><br><span class="line">  ~<span class="built_in">DoNotDestruct</span>() { std::<span class="built_in">abort</span>(); }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used to check constructor argument forwarding.</span></span><br><span class="line">  <span class="type">uint32_t</span> a;</span><br><span class="line">  <span class="type">uint64_t</span> b;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>接着定义了 2 个测试用例，一个定义了栈上的 NoDestructor 对象，另一个定义了一个静态的 NoDestructor 对象。这两个测试用例分别验证 NoDestructor 对象在栈上和静态存储区上的行为。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StackInstance) {</span><br><span class="line">  <span class="function">NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StaticInstance) {</span><br><span class="line">  <span class="function"><span class="type">static</span> NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果 NoDestructor 的实现有问题，无法保证传入对象的析构不被执行，那么测试程序将会异常终止掉。我们跑下这两个测试用例，结果如下：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png/webp" alt="测试用例通过，析构函数没有被调用" srcset="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png/webp 2152w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2152" height="634"></p>
<p>这里我们可以增加个测试用例，验证下如果直接定义 DoNotDestruct 对象的话，测试进程会不会异常终止。可以先定义一个栈上的对象来测试，放在其他 2 个测试用例前面，如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, Instance) {</span><br><span class="line">  <span class="function">DoNotDestruct <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下，这个测试用例执行过程中会异常终止，说明 DoNotDestruct 对象的析构函数被调用了。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png/webp" alt="测试进程异常终止，说明调用了析构" srcset="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png/webp 2090w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2090" height="330"></p>
<p>其实这里可以再改下，用 static 直接定义这里的 instance 对象，然后编译重新运行测试用例，就会发现 3 个测试用例都通过了，不过最后测试进程还是 abort 掉，这是因为进程退出的时候，才会析构静态对象，这时 DoNotDestruct 对象的析构函数被调用了。</p>
<h2 id="为什么不能析构？"><a href="#为什么不能析构？" class="headerlink" title="为什么不能析构？"></a>为什么不能析构？</h2><p>上面的例子中，我们看到了 NoDestructor 模板类的实现，它的作用是禁止静态局部的单例对象析构。那么为什么要禁止对象析构呢？简单来说，<strong>C++ 标准没有规定不同编译单元中静态局部变量的析构顺序</strong>，如果静态变量之间存在依赖关系，而它们的析构顺序错误，可能会导致程序访问已经析构的对象，从而产生未定义行为，可能导致程序崩溃。</p>
<p>举一个例子，假设有两个类，一个是日志系统，另一个是某种服务，服务在析构时需要向日志系统记录信息。日志类的代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span> <span class="comment">// Include assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isAlive; <span class="comment">// Flag to check if the object has been destructed</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">static</span> Logger instance; <span class="comment">// 静态局部变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>() : <span class="built_in">isAlive</span>(<span class="literal">true</span>) {} <span class="comment">// Constructor initializes isAlive to true</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logger</span>() {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Logger destroyed."</span> &lt;&lt; std::endl;</span><br><span class="line">        isAlive = <span class="literal">false</span>; <span class="comment">// Mark as destructed</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>{</span><br><span class="line">        <span class="built_in">assert</span>(isAlive); <span class="comment">// Assert the object is not destructed</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Log: "</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>注意这个类的 isAlive 成员变量，在构造函数中初始化为 true，析构函数中置为 false。在 log 函数中，会先检查 isAlive 是否为 true，如果为 false，就会触发断言失败。接着是服务类的代码，这里作为示例，只让它在析构的时候用日志类的静态局部变量记录一条日志。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Service</span>() {</span><br><span class="line">        Logger::<span class="built_in">getInstance</span>().<span class="built_in">log</span>(<span class="string">"Service destroyed."</span>); <span class="comment">// 在析构时记录日志</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>在 main 函数中，使用全局变量 globalService 和 globalLogger，其中 globalService 是一个全局 Service 实例，globalLogger 是一个 Logger 单例。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"service.h"</span></span></span><br><span class="line"></span><br><span class="line">Service globalService; <span class="comment">// 全局Service实例</span></span><br><span class="line">Logger&amp; globalLogger = Logger::<span class="built_in">getInstance</span>(); <span class="comment">// 全局Logger实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编译运行这个程序：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -g -fno-omit-frame-pointer -o main main.cpp</span></span><br></pre></td></tr></tbody></table></figure>

<p>运行后 assert 断言<strong>大概率会失败</strong>。我们知道<strong>在单个编译单元(这里是 main.cpp)中，全局变量按照出现的顺序来初始化，然后按照相反的顺序来析构</strong>。这里 globalLogger 会先析构，然后是 globalService，在 globalService 的析构函数中会调用 Logger 的 log 函数，但这时 globalLogger 已经被析构，isAlive 被置为 false，所以大概率会触发断言失败。之所以说大概率是因为，globalLogger 对象析构后，其占用的内存空间可能还<strong>未被操作系统回收或用于其他目的</strong>，对其成员变量 isAlive 的访问可能仍能“正常”。下面是我运行的结果：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">main: logger.h:22: void Logger::log(const string&amp;): Assertion `isAlive' failed.</span><br><span class="line">[1]    1017435 abort      ./main</span><br></pre></td></tr></tbody></table></figure>

<p>其实这里如果不加 isAlive 相关逻辑，运行的话输出大概率如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">Log: Service destroyed.</span><br></pre></td></tr></tbody></table></figure>

<p>从输出可以看到和前面一样 globalLogger 先析构，lobalService 后析构。只是这里进程大概率不会 crash 掉，这是因为 globalLogger 被析构后，<strong>虽然其生命周期已结束，但是对成员函数的调用仍可能“正常”执行</strong>。这里成员函数的执行通常依赖于类的代码（位于代码段），只要代码段内容没有被重新写，并且方法不依赖于已经被破坏或改变的成员变量，它可能仍能运行而不出错。</p>
<p>当然就算这里没有触发程序崩溃，使用已析构对象的行为在 C++ 中是<a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">未定义的（Undefined Behavior）</a>。未定义行为意味着程序可能崩溃、可能正常运行，或者产生不可预期的结果。此类行为的结果可能在不同的系统或不同的运行时有所不同，我们在开发中一定要避免这种情况的发生。</p>
<p>其实就 LevelDB 这里的实现来说，BytewiseComparatorImpl 是一个平凡可析构 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor">trivially destructible</a> 对象，它不依赖其他全局变量，因此它本身析构不会有问题。如果用它生成一个静态局部的单例对象，然后在其他静态局部对象或者全局对象中使用，那么在这些对象析构时，会调用 BytewiseComparatorImpl 的析构函数。而根据前面的分析，这里 BytewiseComparatorImpl 本身是一个静态局部对象，<strong>在进程结束资源回收时，可能早于使用它的对象被被析构</strong>。这样就会导致重复析构，产生未定义行为。</p>
<p>更多关于静态变量析构的解释也可以参考 <a target="_blank" rel="noopener" href="https://ppwwyyxx.com/blog/2023/Safe-Static-Initialization-No-Destruction/">Safe Static Initialization, No Destruction</a> 这篇文章，作者详细讨论了这个问题。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：LevelDB 源码阅读：禁止对象被析构</p><p>本文链接为：https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/';
    this.page.identifier = '2024/07/22/leveldb_source_nodestructor/';
    this.page.title = 'LevelDB 源码阅读：禁止对象被析构';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (19)</li><li><a href="/categories/法律普及/">法律普及</a> (8)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (31)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/法律/" style="font-size: 15.00px;">法律</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/刑事/" style="font-size: 15.00px;">刑事</a> <a href="/tags/婚姻家庭/" style="font-size: 15.00px;">婚姻家庭</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2024/07/22/leveldb_source_nodestructor/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li><li><a href="/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB 源码阅读：如何分析跳表的时间复杂度？">LevelDB 源码阅读：如何分析跳表的时间复杂度？</a></li><li><a href="/2024/09/18/leveldb_source_skiplist_test/" title="LevelDB 源码阅读：如何正确测试跳表的并行读写？">LevelDB 源码阅读：如何正确测试跳表的并行读写？</a></li><li><a href="/2024/09/13/gpto1_hands_on/" title="实际例子上手体验 OpenAI o1-preview，比预期差一点？">实际例子上手体验 OpenAI o1-preview，比预期差一点？</a></li><li><a href="/2024/09/09/leveldb_source_skiplist/" title="LevelDB 源码阅读：跳表的原理、实现以及可视化">LevelDB 源码阅读：跳表的原理、实现以及可视化</a></li><li><a href="/2024/09/05/claude35_prompt/" title="Claude3.5 系统提示词解密：不道歉、脸盲、幻觉...">Claude3.5 系统提示词解密：不道歉、脸盲、幻觉...</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NoDestructor-%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">NoDestructor 模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">测试用例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%9E%90%E6%9E%84%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">为什么不能析构？</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>