<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本文通过模拟内存泄漏程序，解释了 eBPF 的工作原理和面临的挑战，特别是在处理不完整调用栈时的局限性。文章还讨论了如何用gdb跟踪tcmalloc，并利用FlameGraph生成内存泄露火焰图，最后讨论了编译时默认开启帧指针的争议。"><title>深入理解基于 eBPF 的 C/C++ 内存泄漏分析</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深入理解基于 eBPF 的 C/C++ 内存泄漏分析</h1><div class="post-meta">2023/11/08<span> | </span><span class="category"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2023/11/08/memory_leak_ebpf/" href="/2023/11/08/memory_leak_ebpf/#disqus_thread"></a><div class="post-content"><p>对于 C/C++ 程序员来说，内存泄露问题是一个老生常谈的问题。排查内存泄露的方法有很多，比如使用 valgrind、gdb、asan、tsan 等工具，但是这些工具都有各自的局限性，比如 valgrind 会使程序运行速度变慢，gdb 需要了解代码并且手动打断点，asan 和 tsan 需要重新编译程序。对于比较复杂，并且在运行中的服务来说，这些方法都不是很方便。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231030_memory_leak_ebpf_index.png/webp" alt="ebpf 分析拿到的内存泄露火焰图" srcset="https://slefboot-1251736664.file.myqcloud.com/20231030_memory_leak_ebpf_index.png/webp 2382w, https://slefboot-1251736664.file.myqcloud.com/20231030_memory_leak_ebpf_index.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231030_memory_leak_ebpf_index.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231030_memory_leak_ebpf_index.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2382" height="832"></p>
<p>好在有了 eBPF，我们可以使用它来分析内存泄露问题，不需要重新编译程序，对程序运行速度的影响也很小。eBPF 的强大有目共睹，不过 <strong>eBPF 也不是银弹</strong>，用来分析内存泄露也还是<strong>有很多问题需要解决</strong>，本文接下来就来探讨一下基于 eBPF 检测会遇到的常见问题。</p>
<span id="more"></span>

<h2 id="内存泄露模拟"><a href="#内存泄露模拟" class="headerlink" title="内存泄露模拟"></a>内存泄露模拟</h2><p>在 C/C++ 中，内存泄露是指程序在运行过程中，由于某些原因导致<strong>未能释放已经不再使用的内存</strong>，从而造成系统内存的浪费。内存泄露问题一旦发生，会导致程序运行速度减慢，甚至进程 OOM 被杀掉。内存泄露问题的发生，往往是由于在编写程序时，<strong>没有及时释放内存</strong>；或者是由于程序设计的缺陷，导致程序在运行过程中，无法释放已经不再使用的内存。</p>
<p>下面是一个简单的内存泄露模拟程序，程序会在循环中分配内存，但是没有释放，从而导致内存泄露。main 程序如下，发生泄露的函数调用链路是 <code>main-&gt;caller-&gt;slowMemoryLeak</code>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LeakLib {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slowMemoryLeak</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">caller</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"In caller"</span> &lt;&lt; std::endl;</span><br><span class="line">    LeakLib::<span class="built_in">slowMemoryLeak</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Starting slow memory leak program..."</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">caller</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中内存泄露的代码在 <code>slowMemoryLeak</code> 函数中，具体如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LeakLib {</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slowMemoryLeak</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> arrSize = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[arrSize];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize; ++i) {</span><br><span class="line">                p[i] = i; <span class="comment">// Assign values to occupy physical memory</span></span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// wait for 1 second</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意这里编译的时候，带了帧指针选项（由 <code>-fno-omit-frame-pointer</code> 选项控制），这是因为 eBPF 工具需要用到帧指针来进行调用栈回溯。如果这里忽略掉帧指针的话(<code>-fomit-frame-pointer</code>)，基于 eBPF 的工具就拿不到内存泄露的堆栈信息。完整编译命令如下(-g 可以不用加，不过这里也先加上，方便用 gdb 查看一些信息)：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ main.cpp leak_lib.cpp -o main -fno-omit-frame-pointer -g</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="memleak-分析"><a href="#memleak-分析" class="headerlink" title="memleak 分析"></a>memleak 分析</h2><p>接下来基于 eBPF 来进行内存分析泄露，<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">BCC</a> 自带了一个 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/memleak.py">memleak</a> 内存分析工具，可以用来分析内存泄露的调用堆栈。拿前面的示例泄露代码来说，编译后执行程序，然后执行内存泄露检测 <code>memleak -p $(pgrep main) --combined-only</code>。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231101_memory_leak_ebpf_bcc_new.png/webp" alt="ebpf bcc memleak 内存泄露分析" srcset="https://slefboot-1251736664.file.myqcloud.com/20231101_memory_leak_ebpf_bcc_new.png/webp 2058w, https://slefboot-1251736664.file.myqcloud.com/20231101_memory_leak_ebpf_bcc_new.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231101_memory_leak_ebpf_bcc_new.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231101_memory_leak_ebpf_bcc_new.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2058" height="1056"></p>
<p>目前<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/24822c2e9459f4508fb7071071c26a80d4c9dc5b/tools/memleak.py">版本的 memleak 工具</a>有 bug，在带 <code>--combined-only</code> 打印的时候，会报错。修改比较简单，我已经提了 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/pull/4769/files">PR #4769</a>，已经被合并进 master。仔细看脚本的输出，发现这里调用堆栈其实不太完整，丢失了 <code>slowMemoryLeak</code> 这个函数调用。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[11:19:44] Top 10 stacks with outstanding allocations:</span><br><span class="line">	480 bytes in 12 allocations from stack</span><br><span class="line">		operator new(unsigned long)+0x1c [libstdc++.so.6.0.30]</span><br><span class="line">		caller()+0x31 [main]</span><br><span class="line">		main+0x31 [main]</span><br><span class="line">		__libc_start_call_main+0x7a [libc.so.6]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="调用链不完整"><a href="#调用链不完整" class="headerlink" title="调用链不完整"></a>调用链不完整</h3><p>这里为啥会丢失中间的函数调用呢？我们知道eBPF 相关的工具，是通过 <code>frame pointer</code> 指针来进行调用堆栈回溯的，具体原理可以参考朋友的文章 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WWqPO9Q4BCO5SgyuMk8Ddg">消失的调用栈帧-基于fp的栈回溯原理解析</a>。如果遇到调用链不完整，基本都是因为帧指针丢失，下面来验证下。</p>
<p>首先用 <code>objdump -d -S main &gt; main_with_source.asm</code> 来生成带源码的汇编指令，找到 <code>slowMemoryLeak</code> 函数的汇编代码，如下图所示：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231102_memory_leak_ebpf_src_assembly_code.png/webp" alt="ebpf bcc main 函数对应的汇编代码" srcset="https://slefboot-1251736664.file.myqcloud.com/20231102_memory_leak_ebpf_src_assembly_code.png/webp 2176w, https://slefboot-1251736664.file.myqcloud.com/20231102_memory_leak_ebpf_src_assembly_code.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231102_memory_leak_ebpf_src_assembly_code.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231102_memory_leak_ebpf_src_assembly_code.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2176" height="1286"></p>
<p>从这段汇编代码中，可以看到 <code>new int[]</code> 对应的是一次 <code>_Znam@plt</code> 的调用。这是 C++ 的 operator new[] 的名字修饰（name mangling）后的形式，如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _Znam</span></span><br><span class="line">operator new[](unsigned long)</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道在 C++ 中，new 操作用来动态分配内存，通常会最终调用底层的内存分配函数如 malloc。这里 <code>_Znam@plt</code> 是通过 <code>PLT（Procedure Linkage Table）</code> 进行的，它是一个动态解析的符号，通常是 libstdc++（或其他 C++ 标准库的实现）中实现的 <code>operator new[]</code>。<code>_Znam@plt</code> 对应的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000001030 &lt;_Znam@plt&gt;:</span><br><span class="line">    1030:       ff 25 ca 2f 00 00       jmp    *0x2fca(%rip)        # 4000 &lt;_Znam@GLIBCXX_3.4&gt;</span><br><span class="line">    1036:       68 00 00 00 00          push   $0x0</span><br><span class="line">    103b:       e9 e0 ff ff ff          jmp    1020 &lt;_init+0x20&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>这里并没有像 slowMemoryLeak 调用一样去做 <code>push %rbp</code> 的操作，所以会丢失堆栈信息。这里为什么会没有保留帧指针呢？前面编译的时候带了 <code>-fno-omit-frame-pointer</code> 能保证我们自己的代码带上帧指针，但是对于 libstdc++ 这些依赖到的标准库，我们是无法控制的。当前系统的 C++ 标准库在编译的时候，并没有带上帧指针，可能是因为这样可以减少函数调用的开销(减少执行的指令)。是否在编译的时候默认带上 -fno-omit-frame-pointer 还是比较有争议，文章最后专门放<a href="#%E9%BB%98%E8%AE%A4%E5%BC%80%E5%90%AF%E5%B8%A7%E6%8C%87%E9%92%88">一节：默认开启帧指针</a>来讨论。</p>
<h2 id="tcmalloc-泄露分析"><a href="#tcmalloc-泄露分析" class="headerlink" title="tcmalloc 泄露分析"></a>tcmalloc 泄露分析</h2><p>如果想拿到完整的内存泄露函数调用链路，可以带上帧指针重新编译 <code>libstdc++</code>，不过标准库重新编译比较麻烦。其实日常用的比较多的是 tcmalloc，内存分配管理更加高效些。这里为了验证上面的代码在 tcmalloc 下的表现，我用 -fno-omit-frame-pointer 帧指针编译了 <code>tcmalloc</code> 库。如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/gperftools/gperftools.git</span><br><span class="line">cd gperftools</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure CXXFLAGS="-fno-omit-frame-pointer" --prefix=/path/to/install/dir</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure>

<p>接着运行上面的二进制，重新用 memleak 来检查内存泄露，**注意这里用 <code>-O</code> 把 libtcmalloc.so 动态库的路径也传递给了 memleak。**参数值存在 obj 中，在 attach_uprobe 中用到，指定了要附加 uprobes 或 uretprobes 的二进制对象，可以是要跟踪的函数的库路径或可执行文件。详细文档可以参考 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#4-attach_uprobe">bcc: 4. attach_uprobe</a>。比如下面的调用方法：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 libc 的 getaddrinfo 函数入口打桩，当进入函数时，会调用自定义的 do_entry 函数</span></span><br><span class="line">b.attach_uprobe(name=<span class="string">"c"</span>, sym=<span class="string">"getaddrinfo"</span>, fn_name=<span class="string">"do_entry"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>注意在前面的示例中，没有指定 <code>-O</code>，默认就是 “c”，也就是用 libc 分配内存。在用 tcmalloc 动态库的时候，这里 <code>attach_uprobe</code> 和 <code>attach_uretprobe</code> 必须要指定库路径：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bpf.attach_uprobe(name=obj, sym=sym, fn_name=fn_prefix + <span class="string">"_enter"</span>, pid=pid)</span><br><span class="line">bpf.attach_uretprobe(name=obj, sym=sym, fn_name=fn_prefix + <span class="string">"_exit"</span>, pid=pid)</span><br></pre></td></tr></tbody></table></figure>

<p>不过工具的输出有点出乎语料，这里竟然<strong>没有输出任何泄露的堆栈</strong>了：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">memleak -p $(pgrep main) --combined-only -O /usr/local/lib/libtcmalloc.so</span></span><br><span class="line">Attaching to pid 1409827, Ctrl+C to quit.</span><br><span class="line">[19:55:45] Top 10 stacks with outstanding allocations:</span><br><span class="line"></span><br><span class="line">[19:55:50] Top 10 stacks with outstanding allocations:</span><br></pre></td></tr></tbody></table></figure>

<p>明明 new 分配的内存没有释放，<strong>为什么 eBPF 的工具检测不到呢</strong>？</p>
<h3 id="深入工具实现"><a href="#深入工具实现" class="headerlink" title="深入工具实现"></a>深入工具实现</h3><p>在猜测原因之前，先仔细看下 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/tools/memleak.py">memleak 工具的代码</a>，完整梳理下工具的实现原理。首先能明确的一点是，工具最后的输出部分，是<strong>每个调用栈以及其泄露的内存量</strong>。为了拿到这个结果，用 eBPF <strong>分别在内存分配和释放的时候打桩，记录下当前调用栈的内存分配/释放量</strong>，然后进行统计。核心的逻辑如下：</p>
<ol>
<li><code>gen_alloc_enter</code>: 在各种分配内存的地方，比如 malloc, cmalloc, realloc 等函数入口(malloc_enter)打桩(<code>attach_uprobe</code>)，获取当前调用堆栈 id 和分配的内存大小，记录在名为 sizes 的字典中；</li>
<li><code>gen_alloc_exit2</code>: 在分配内存的函数退出位置(malloc_exit)打桩(<code>attach_uretprobe</code>)，拿到此次分配的内存起始地址，同时从 sizes 字段拿到分配内存大小，记录 (address, stack_info) 在 allocs 字典中；同时用 <code>update_statistics_add</code> 更新最后的结果字典 combined_allocs，存储栈信息和分配的内存大小，次数信息；</li>
<li><code>gen_free_enter</code>: 在释放内存的函数入口处打桩(gen_free_enter)，从前面 allocs 字典中根据要释放的内存起始地址，拿到对应的栈信息，然后用 <code>update_statistics_del</code> 更新结果字典 combined_allocs，也就是在统计中，减去当前堆栈的内存分配总量和次数。</li>
</ol>
<h3 id="GDB-堆栈跟踪"><a href="#GDB-堆栈跟踪" class="headerlink" title="GDB 堆栈跟踪"></a>GDB 堆栈跟踪</h3><p>接着回到前面的问题，tcmalloc 通过 new 分配的内存，为啥统计不到呢？很大可能是因为 tcmalloc 底层分配和释放内存的函数并不是 malloc/free，也不在 memleak 工具的 probe 打桩的函数内。那么怎么知道前面示例代码中，分配内存的调用链路呢？比较简单的方法就是用 GDB 调试来跟踪，注意编译 tcmalloc 库的时候，带上 debug 信息，如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure CXXFLAGS=<span class="string">"-g -fno-omit-frame-pointer"</span> CFLAGS=<span class="string">"-g -fno-omit-frame-pointer"</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>编译好后，可以用 objdump 查看 ELF 文件的头信息和各个段的列表，验证动态库中是否有 debug 信息，如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -h /usr/local/lib/libtcmalloc_debug.so.4 | grep debug</span></span><br><span class="line">/usr/local/lib/libtcmalloc_debug.so.4:     file format elf64-x86-64</span><br><span class="line"> 29 .debug_aranges 000082c0  0000000000000000  0000000000000000  000b8c67  2**0</span><br><span class="line"> 30 .debug_info   00157418  0000000000000000  0000000000000000  000c0f27  2**0</span><br><span class="line"> 31 .debug_abbrev 00018a9b  0000000000000000  0000000000000000  0021833f  2**0</span><br><span class="line"> 32 .debug_line   00028924  0000000000000000  0000000000000000  00230dda  2**0</span><br><span class="line"> 33 .debug_str    0009695d  0000000000000000  0000000000000000  002596fe  2**0</span><br><span class="line"> 34 .debug_ranges 00008b30  0000000000000000  0000000000000000  002f005b  2**0</span><br></pre></td></tr></tbody></table></figure>

<p>接着重新用 debug 版本的动态库编译二进制，用 gdb 跟踪进 new 操作符的内部，得到结果如下图。可以看到确实没有调用 malloc 函数。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231106_memory_leak_ebpf_tcmalloc_gdb.png/webp" alt="tcmalloc new 操作符对应的函数调用" srcset="https://slefboot-1251736664.file.myqcloud.com/20231106_memory_leak_ebpf_tcmalloc_gdb.png/webp 2398w, https://slefboot-1251736664.file.myqcloud.com/20231106_memory_leak_ebpf_tcmalloc_gdb.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231106_memory_leak_ebpf_tcmalloc_gdb.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231106_memory_leak_ebpf_tcmalloc_gdb.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2398" height="802"></p>
<p>其实 tcmalloc 的内存分配策略还是很复杂的，里面有各种预先分配好的内存链表，申请不同大小的内存空间时，有不少的策略来选择合适的内存地址。</p>
<h2 id="正常内存泄露分析"><a href="#正常内存泄露分析" class="headerlink" title="正常内存泄露分析"></a>正常内存泄露分析</h2><p>前面不管是 glibc 还是 tcmalloc，用 new 来分配内存的时候，memleak 拿到的分析结果都不是很完美。这是因为用 eBPF 分析内存泄露，必须满足两个前提：</p>
<ol>
<li>编译二进制的时候带上帧指针(frame pointer)，如果有依赖到标准库或者第三方库，也都必须带上帧指针；</li>
<li>实际分配内存的函数，必须在工具的 probe 打桩的函数内，比如 malloc, cmalloc, realloc 等函数；</li>
</ol>
<p>那么下面就来看下满足这两个条件后，内存泄露的分析结果。修改上面的 leak_lib.cpp 中内存分配的代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int* p = new int[arrSize];</span></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(arrSize * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></tbody></table></figure>

<p>然后重新编译运行程序，这时候 memleak 就能拿到<strong>完整的调用栈信息</strong>了，如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ main.cpp leak_lib.cpp -o main -fno-omit-frame-pointer -g</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run main binary here</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">memleak -p $(pgrep main) --combined-only</span></span><br><span class="line">Attaching to pid 2025595, Ctrl+C to quit.</span><br><span class="line">[10:21:09] Top 10 stacks with outstanding allocations:</span><br><span class="line">	200 bytes in 5 allocations from stack</span><br><span class="line">		LeakLib::slowMemoryLeak()+0x20 [main]</span><br><span class="line">		caller()+0x31 [main]</span><br><span class="line">		main+0x31 [main]</span><br><span class="line">		__libc_start_call_main+0x7a [libc.so.6]</span><br><span class="line">[10:21:14] Top 10 stacks with outstanding allocations:</span><br><span class="line">	400 bytes in 10 allocations from stack</span><br><span class="line">		LeakLib::slowMemoryLeak()+0x20 [main]</span><br><span class="line">		caller()+0x31 [main]</span><br><span class="line">		main+0x31 [main]</span><br><span class="line">		__libc_start_call_main+0x7a [libc.so.6]</span><br></pre></td></tr></tbody></table></figure>

<p>如果分配内存的时候用 tcmalloc，也是可以拿到完整的泄露堆栈。</p>
<h2 id="内存火焰图可视化"><a href="#内存火焰图可视化" class="headerlink" title="内存火焰图可视化"></a>内存火焰图可视化</h2><p>在我之前的 <a href="https://selfboot.cn/2023/10/17/c++_frame_pointer/">复杂 C++ 项目堆栈保留以及 ebpf 性能分析</a> 这篇文章中，用 BCC 工具做 cpu profile 的时候，可以用 <a target="_blank" rel="noopener" href="https://github.com/brendangregg/FlameGraph/tree/master">FlameGraph</a> 把输出结果转成 CPU 火焰图，很清楚就能找到 cpu 的热点代码。对于内存泄露，我们同样也可以生成<strong>内存火焰图</strong>。</p>
<p>内存火焰图的生成步骤也类似 cpu 的，先用采集工具比如 BCC 脚本采集数据，然后将采集到的数据转换为 FlameGraph 可以理解的格式，之后就可以使用 FlameGraph 脚本将转换后的数据生成一个 SVG 图像。<strong>每个函数调用都对应图像中的一块，块的宽度表示该函数在采样中出现的频率，从而可以识别资源使用的热点</strong>。FlameGraph 识别的每行数据的格式通常如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[堆栈跟踪] [采样值]</span><br><span class="line">main;foo;bar 58</span><br></pre></td></tr></tbody></table></figure>

<p>这里的“<strong>堆栈跟踪</strong>”是指函数调用栈的一个快照，通常是一个由分号分隔的函数名列表，表示从调用栈底部（通常是 main 函数或者线程的起点）到顶部（当前执行的函数）的路径。而“采样值”可能是在该调用栈上花费的 CPU 时间、内存使用量或者是其他的资源指标。对于内存泄露分析，<strong>采样值可以是内存泄露量，或者内存泄露次数</strong>。</p>
<p>可惜的是，现在的 memleak 还不支持生成可以转换火焰图的数据格式。不过这里改起来并不难，<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/pull/4766">PR 4766</a> 有实现一个简单的版本，下面就用这个 PR 里的代码为例，来生成内存泄露火焰图。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_svg.png/webp" alt="改动后的 memleak 生成支持火焰图格式的采集文件" srcset="https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_svg.png/webp 2412w, https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_svg.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_svg.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_svg.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2412" height="936"></p>
<p>可以看到这里生成的采集文件很简单，如上面所说的格式：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__libc_start_call_main+0x7a [libc.so.6];main+0x31 [main];caller()+0x31 [main];LeakLib::slowMemoryLeak()+0x20 [main] 480</span><br></pre></td></tr></tbody></table></figure>

<p>最后用 FlameGraph 脚本来生成火焰图，如下：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231108_memory_leak_ebpf_memleak_demo.svg" alt="根据采集文件生成的内存泄露的火焰图"></p>
<h2 id="默认开启帧指针"><a href="#默认开启帧指针" class="headerlink" title="默认开启帧指针"></a>默认开启帧指针</h2><p>文章最后再来解决下前面留下的一个比较有争议的话题，是否在编译的时候默认开启帧指针。我们知道 eBPF 工具依赖帧指针才能进行调用栈回溯，其实栈回溯的方法有不少，比如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dwarfstd.org/">DWARF</a>: 调试信息中增加堆栈信息，不需要帧指针也能进行回溯，但缺点是性能比较差，因为需要将堆栈信息复制到用户空间来进行回溯；</li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v5.3/x86/orc-unwinder.html">ORC</a>: 内核中为了展开堆栈创建的一种格式，其目的与 DWARF 相同，只是简单得多，<strong>不能在用户空间使用</strong>；</li>
<li><a target="_blank" rel="noopener" href="https://sourceware.org/pipermail/binutils/2022-June/121478.html">CTF Frame</a>：一种新的格式，比 eh_frame 更紧凑，展开堆栈速度更快，并且更容易实现。仍在开发中，不知道什么时候能用上。</li>
</ul>
<p>所以如果想用<strong>比较低的开销，拿到完整的堆栈信息，帧指针是目前最好的方法</strong>。既然帧指针这么好，为什么有些地方不默认开启呢？在 Linux 的 Fedora 发行版社区中，是否默认打开该选项引起了激烈的讨论，最终达成一致，在 Fedora Linux 38 中，所有的库都会默认开启 -fno-omit-frame-pointer 编译，详细过程可以看 <a target="_blank" rel="noopener" href="https://fedoraproject.org/wiki/Changes/fno-omit-frame-pointer">Fedora wiki: Changes/fno-omit-frame-pointer</a>。</p>
<p>上面 Wiki 中对打开帧指针带来的影响有一个<strong>性能基准测试</strong>，从结果来看：</p>
<ul>
<li>带帧指针使用 GCC 编译的内核，速度会慢 2.4%；</li>
<li>使用帧指针构建 openssl/botan/zstd 等库，没有受到显着影响；</li>
<li>对于 CPython 的基准测试性能影响在 1-10%；</li>
<li>Redis 的基准测试基本没性能影响；</li>
</ul>
<p>当然，不止是 Fedora 社区倾向默认开启，著名性能优化专家 <a target="_blank" rel="noopener" href="https://www.brendangregg.com/">Brendan Gregg</a> 在一次<a target="_blank" rel="noopener" href="https://www.brendangregg.com/Slides/SCALE2015_Linux_perf_profiling.pdf">分享</a>中，建议在 gcc 中直接将 -fno-omit-frame-pointer 设为<strong>默认编译选项</strong>：</p>
<blockquote>
<p>• Once upon a tme, x86 had fewer registers, and the frame pointer register was reused for general purpose to improve performance. This breaks system stack walking.<br>• gcc provides -fno-omit-frame-pointer to fix this – <strong>Please make this the default in gcc!</strong> </p>
</blockquote>
<p>此外，在<a target="_blank" rel="noopener" href="https://inria.hal.science/hal-02297690/document">一篇关于 DWARF 展开的论文</a> 提到有 Google 的开发者在分享中提到过，google 的核心代码编译的时候都带上了帧指针。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/652850051">基于 eBPF 的内存泄漏（增长）通用分析方法探索</a><br><a target="_blank" rel="noopener" href="https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html">Memory Leak (and Growth) Flame Graphs</a><br><a target="_blank" rel="noopener" href="https://www.polarsignals.com/blog/posts/2022/11/29/dwarf-based-stack-walking-using-ebpf">DWARF-based Stack Walking Using eBPF</a><br><a target="_blank" rel="noopener" href="https://www.reddit.com/r/linuxquestions/comments/piq9tx/trace_all_functions_in_program_with_bpftrace/">Trace all functions in program with bpftrace</a><br><a target="_blank" rel="noopener" href="https://github.com/goldshtn/linux-tracing-workshop/blob/master/bpf-memleak.md">Using BPF Tools: Chasing a Memory Leak</a><br><a target="_blank" rel="noopener" href="https://google.github.io/tcmalloc/overview.html">TCMalloc Overview</a></p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：深入理解基于 eBPF 的 C/C++ 内存泄漏分析</p><p>本文链接为：https://selfboot.cn/2023/11/08/memory_leak_ebpf/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/ChatGPT/"><i class="fa fa-tag"></i>ChatGPT</a><a href="/tags/eBPF/"><i class="fa fa-tag"></i>eBPF</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2023/11/08/memory_leak_ebpf/';
    this.page.identifier = '2023/11/08/memory_leak_ebpf/';
    this.page.title = '深入理解基于 eBPF 的 C/C++ 内存泄漏分析';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (23)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (32)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2023/11/08/memory_leak_ebpf/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/06/27/leveldb_source_table_build/" title="LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程">LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程</a></li><li><a href="/2025/06/13/leveldb_source_LRU_cache/" title="LevelDB 源码阅读：LRU Cache 高性能缓存实现细节">LevelDB 源码阅读：LRU Cache 高性能缓存实现细节</a></li><li><a href="/2025/06/11/leveldb_source_memtable/" title="LevelDB 源码阅读：MemTable 内存表的实现细节">LevelDB 源码阅读：MemTable 内存表的实现细节</a></li><li><a href="/2025/06/10/leveldb_mvcc_intro/" title="LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)">LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)</a></li><li><a href="/2025/05/23/mcp_user_report/" title="使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?">使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?</a></li><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.</span> <span class="toc-text">内存泄露模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memleak-%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">memleak 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%93%BE%E4%B8%8D%E5%AE%8C%E6%95%B4"><span class="toc-number">2.1.</span> <span class="toc-text">调用链不完整</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcmalloc-%E6%B3%84%E9%9C%B2%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">tcmalloc 泄露分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">深入工具实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB-%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA"><span class="toc-number">3.2.</span> <span class="toc-text">GDB 堆栈跟踪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">正常内存泄露分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%81%AB%E7%84%B0%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">内存火焰图可视化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%BC%80%E5%90%AF%E5%B8%A7%E6%8C%87%E9%92%88"><span class="toc-number">6.</span> <span class="toc-text">默认开启帧指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">7.</span> <span class="toc-text">参考文章</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p><p>友情链接：<a rel="dofollow" target="_blank" href="https://puzzles-game.com/">益智游戏</a></p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>