<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-WUJTOV7jES"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录了在 C++ Protobuf 使用中遇到的一个字段丢失的诡异问题，通过排查分析发现是因为链接了不同版本的 Proto 文件导致。介绍了问题的复现、依赖分析、符号查看等定位思路。提醒在使用 Protobuf 时注意链接版本一致非常重要，否则可能导致难以预测的问题。"><title>C++ 中使用 Protobuf 诡异的字段丢失问题排查</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C++ 中使用 Protobuf 诡异的字段丢失问题排查</h1><a id="logo" href="/.">Just For Fun</a><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/aboutme.html"><i class="fa fa-user"> 关于</i></a><a href="/links.html"><i class="fa fa-user-graduate"> 小盛律师</i></a><a href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"><i class="fa fa-scale-balanced"> 法律普及</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C++ 中使用 Protobuf 诡异的字段丢失问题排查</h1><div class="post-meta">2023/09/07<span> | </span><span class="category"><a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2023/09/07/protobuf_redefine/" href="/2023/09/07/protobuf_redefine/#disqus_thread"></a><div class="post-content"><p>在使用 Protobuf 的时候遇到了一个<strong>特别诡异</strong>的问题，排查了一天，最后才发现问题所在。本篇文章记录下问题的排查、定位过程。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_cover.png/webp" alt="Protobuf 字段 set 后丢失" srcset="https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_cover.png/webp 2162w, https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_cover.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_cover.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_cover.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2162" height="1088"></p>
<span id="more"></span>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>我们的一个服务中有这样一个简单的逻辑，设置好 proto 协议中的字段，然后把 pb 转换成 json 后，发送一个 http 请求。在最近的一个变更中，在原来的 proto 里面增加了一个字段 user_type，然后给这个字段赋值。改动很简单，正常来说，新的 http 请求中 json 中应该在相应位置多一个 user_type 字段。但是发到测试环境后发现，新的请求 json 里没有新增字段，原来有的字段也丢失了不少！</p>
<p>这就有点见鬼了，项目中使用了几年的 protobuf，从来没遇见类似的问题呀。只是增加一个 optional 字段然后赋值，为啥老的字段也没了？</p>
<h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>这里首先排除一些可能的点：</p>
<ol>
<li>代码逻辑问题：检查了整个服务代码，确认了没有地方会去删除设置的字段；</li>
<li>proto 版本不一致：重新编译了设置字段以及 pb2json 部分的代码，确实都是用了最新的 proto 文件。</li>
</ol>
<p>那会不会是服务里自己实现 pb2json 反射有问题？会在某些特殊场景，丢掉某些字段？于是不用这个函数，改成用 protobuf 自带的 DebugString 函数来打印 pb 的内容，发现还是有丢失字段。</p>
<p>有点不可思议，DebugString 函数是 protobuf 自带的，应该没问题才对。前面排查问题，需要加日志，改服务上线，比较麻烦。为了缩小代码排除其他干扰，<strong>快速验证改动</strong>，就单独写了一个工具，在工具里设置 proto 中的字段，然后打印出来，结果还是丢失了字段！</p>
<p>再思考下整个改动，这里因为 proto 增加了 user_type 字段，然后代码里给这个字段设置了一个值，接着就出问题了。那么这里只改动 proto，不给新加的 user_type 字段设值，会不会有问题呢？改了下工具，发现这样打印出来的字段也是有丢失！</p>
<p><strong>只是因为 proto 增加了一个字段，DebugString 打印出来的字段就会漏掉部分？</strong>！这不科学啊，虽然我们的 protobuf 版本很老，但是用了这么久也没出现过这种问题。这里的 proto 和之前其他 proto 的差别在于有很多层嵌套 message，以前倒也没这么多层嵌套的，会不会和这个有关系呢？于是直接设置 user_type 所在的 message，不管其他嵌套 message，结果还是有问题！</p>
<p>到这就有点怀疑 protobuf 了，<strong>是不是老版本有某些 bug</strong>？我们用的是 2.6.1 版本，大概 10 年前版本了，难道这个特殊 proto 触发了它的某个神秘 bug？在网上搜了一圈 “profobuf c++ lack field” 之类的关键词，并没有看到相关的 bug 描述。</p>
<p>有点抓狂，<strong>理智告诉我即便是低版本的 protobuf 也不会有这么低级的 Bug</strong>，但是又实在找不出我的用法有啥问题会导致这么奇怪的表现。于是把问题抛给了一些小伙伴，毕竟自己各种尝试，实在找不到头绪了。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>果然，高手在身边啊，小伙伴去复现了后，立马提到一个关键点，在项目中有另一个 proto，和这个几乎一样。我也想起来，这个模块其实从其他模块拷过来的，进行了一些更改。但是用的 proto 协议还是一样的，只是这里的增加了一个新的字段。</p>
<p>直觉告诉我问题应该就是小伙伴发现的这里了，为了快速验证，在这个新的 proto 里换了一个 namespace，然后重新编译运行，一切恢复了正常！看来确实是因为这里链接二进制的时候，读错了 proto 文件，导致字段解析出现了问题，才丢失了部分字段值。</p>
<p>不过还有不少疑问需要解决：</p>
<ol>
<li><strong>什么时候引入了另一个 proto？</strong></li>
<li><strong>两个 proto 有一样的字段和函数，为啥没有链接符号重定义错误，并且最终用了错误的 proto？</strong></li>
<li><strong>为啥链接了另一个 proto，就导致 DebugString 函数读取的字段不一样？</strong></li>
</ol>
<p>带着这些疑问，继续往下深入。首先想着得有一个简单可以复现的代码，毕竟项目的代码比较庞大，编译慢，并且干扰也比较多，分析起来麻烦。另外，项目代码也涉及了很多业务信息，不方便公开。所以得有一个和当前项目完全无关，并且足够简单，只关注核心问题的代码。</p>
<h2 id="最少复现代码"><a href="#最少复现代码" class="headerlink" title="最少复现代码"></a>最少复现代码</h2><p>实际动手起来，发现复现这里的问题比想象中简单，只用下面少量代码即可。主要就两个 proto 文件和一个 main.cpp 文件。</p>
<p>首先是 <code>modelA/data.proto</code>，里面记录一个字段，对应我们项目中比较老的 proto：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line">package model;</span><br><span class="line">message HWPushAndroid{</span><br><span class="line">    optional string bi_tag = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后是 <code>modelB/data.proto</code>，里面的 proto package 和 message name 都和 <code>modelA/data.proto</code> 一样，但是里面多了两个字段，对应项目中比较新的 proto：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line">package model;</span><br><span class="line">message HWPushAndroid{</span><br><span class="line">    optional int32 collapse_key = <span class="number">1</span> [<span class="keyword">default</span> = <span class="number">-1</span>];</span><br><span class="line">    optional string bi_tag = <span class="number">2</span>;</span><br><span class="line">    optional int32 target_user_type = <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着我们在 <code>main.cpp</code> 中使用 <code>modelB/data.proto</code> 中的字段，先给每个字段赋值，然后打印出来：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"modelB/data.pb.h"</span>  <span class="comment">// 假设我们想使用 modelB 的版本</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    model::HWPushAndroid androidMessage;</span><br><span class="line">    androidMessage.<span class="built_in">set_collapse_key</span>(<span class="number">100</span>);    <span class="comment">// 这个字段只在 modelB 的版本中存在</span></span><br><span class="line">    androidMessage.<span class="built_in">set_bi_tag</span>(<span class="string">"example_tag"</span>);</span><br><span class="line">    androidMessage.<span class="built_in">set_target_user_type</span>(<span class="number">1</span>);  <span class="comment">// 这个字段只在 modelB 的版本中存在</span></span><br><span class="line">    std::cout &lt;&lt; androidMessage.<span class="built_in">DebugString</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>先用 protoc 编译 proto 文件，如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=. modelA/data.proto</span><br><span class="line">protoc --cpp_out=. modelB/data.proto</span><br></pre></td></tr></tbody></table></figure>

<p>接着编译、链接 main 如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -I./ -o main ./modelA/data.pb.cc -lprotobuf</span><br></pre></td></tr></tbody></table></figure>

<p>运行后就会发现一个奇怪的输出：<code>bi_tag: "example_tag"</code>；注意这里的输出和 protoc 的版本也有关系，这个是 <code>3.21.12</code> 版本输出的 DebugString，在一些老的版本比如 2.6.1，这里输出可能不同，甚至是丢掉某些字段值。</p>
<p>我们明明设置了三个字段，为啥输出只有一个呢？很简单，因为链接错了 <code>data.proto</code>; 链接的 prpto 里面只有 <code>bi_tag</code> 字段，所以只有这个字段的值被打印出来了。其实这里也看 protoc 的版本，在老版本输出可能是空的，甚至析构的时候会 core 掉。新版本的 protoc 做的比较好，能够兼容这种情况。</p>
<p>正常的编译、链接应该命令应该是 <code>g++ main.cpp -I./ -o main ./modelB/data.pb.cc -lprotobuf</code>，这样就能正常输出三个字段了。</p>
<h2 id="补充思考"><a href="#补充思考" class="headerlink" title="补充思考"></a>补充思考</h2><p>我们已经成功复现了这里的问题，接下来得回答前面几个问题了。</p>
<h3 id="项目依赖关系"><a href="#项目依赖关系" class="headerlink" title="项目依赖关系"></a>项目依赖关系</h3><p>第一个问题是，什么时候引入了另一个 proto？我们的 C++ 项目用 <a target="_blank" rel="noopener" href="https://bazel.build/?hl=zh-cn">bazel</a> 来构建，我构建的 target <strong>理论上</strong> 不会依赖modelA 里面错误的 proto。但是实际上确实依赖了，可以用 query 来查看下依赖关系：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bazel query 'deps(//**/**:demo_tools)' --output graph &gt; graph.in</span><br><span class="line">dot -Tpng graph.in -o graph.png</span><br></pre></td></tr></tbody></table></figure>

<p>上面会输出一个依赖关系图，发现构建 target 确实同时依赖了 <code>modelA</code> 和 <code>modelB</code> 中的 proto，原因是 tools 直接依赖一个 comm 库，comm 库又依赖了 <code>modelA</code>，modelB 则是被 tools 直接依赖。</p>
<p>接着就是第 2 个疑问：<strong>既然同时依赖两个库，proto 里面又有相同的函数，为啥链接没有报符号重复定义，并且最终用了错误的 proto ？</strong></p>
<h3 id="链接符号决议"><a href="#链接符号决议" class="headerlink" title="链接符号决议"></a>链接符号决议</h3><p>在解答上面疑问之前，回到前面的复现代码，编译的时候同时引入 modelA 和 modelB 中的 <code>data.pb.cc</code>，看看会发生什么：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -I./ -o main ./modelB/data.pb.cc ./modelA/data.pb.cc -lprotobuf</span><br></pre></td></tr></tbody></table></figure>

<p>结果如下图，报了符号重复定义的错误：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230905_protobuf_redefine.png/webp" alt="同时依赖两个模块导致链接失败" srcset="https://slefboot-1251736664.file.myqcloud.com/20230905_protobuf_redefine.png/webp 2432w, https://slefboot-1251736664.file.myqcloud.com/20230905_protobuf_redefine.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230905_protobuf_redefine.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230905_protobuf_redefine.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2432" height="786"></p>
<p>这是因为<strong>链接器在目标文件中找到了两个相同的强符号定义，没法选择具体用哪个，于是直接报链接错误</strong>。但是实际项目中，这两个 proto 在不同模块，先编译成库之后再链接的。链接分动态库和静态库，这里先看 C++ 动态库的情况，把这两个 proto 编译成动态库，然后用动态链接。具体命令如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -c -fPIC modelA/data.pb.cc -o modelA/data.pb.o -I.</span><br><span class="line">g++ -c -fPIC modelB/data.pb.cc -o modelB/data.pb.o -I.</span><br><span class="line">g++ -shared -o libmodelA.so modelA/data.pb.o</span><br><span class="line">g++ -shared -o libmodelB.so modelB/data.pb.o</span><br><span class="line">g++ main.cpp -I./ -o main -L./ -lmodelA -lmodelB -lprotobuf -Wl,-rpath,./</span><br><span class="line">g++ main.cpp -I./ -o main -L./ -lmodelB -lmodelA -lprotobuf -Wl,-rpath,./</span><br></pre></td></tr></tbody></table></figure>

<p>链接的时候，modelA 和 modelB 有两种链接顺序，二进制运行的结果也有两种：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_linkorder.png/webp" alt="动态链接顺序不同，结果也不同" srcset="https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_linkorder.png/webp 1984w, https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_linkorder.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_linkorder.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_linkorder.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1984" height="496"></p>
<p>静态链接又是什么表现呢？静态链接的命令如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -c modelA/data.pb.cc -o modelA/data.pb.o -I.</span><br><span class="line">g++ -c modelB/data.pb.cc -o modelB/data.pb.o -I.</span><br><span class="line">ar rcs libmodelA.a modelA/data.pb.o</span><br><span class="line">ar rcs libmodelB.a modelB/data.pb.o</span><br><span class="line">g++ main.cpp -I./ -o main -L./  -lmodelA -lmodelB -lprotobuf</span><br><span class="line">g++ main.cpp -I./ -o main -L./  -lmodelB -lmodelA -lprotobuf</span><br></pre></td></tr></tbody></table></figure>

<p>发现和动态链接一样，链接顺序不同，结果也不同。从实验的结果来看，链接的时候，<strong>不管是动态链接还是静态链接，实际用的都是靠前面的库的符号定义</strong>。这种行为是由于链接器的设计决定的，不特定于静态或动态链接。不过，要注意这并不是所有链接器都会这样做，这是特定于 GNU 链接器（通常用于 Linux）的行为，其他链接器可能有不同的行为或选项。</p>
<p>在经典大作<a target="_blank" rel="noopener" href="https://hansimov.gitbook.io/csapp/">《深入理解计算机系统》</a>一书中，7.6.3 <strong>链接器如何使用静态库来解析引用</strong>对这里有详细的解释。</p>
<h3 id="链接了哪些符号"><a href="#链接了哪些符号" class="headerlink" title="链接了哪些符号"></a>链接了哪些符号</h3><p>接着来回答第三个问题：为啥链接了另一个 proto，就导致 DebugString 函数读取的字段不一样？</p>
<p>通过上面的实验，我们知道因为链接顺序不对，导致 protobuf 的 <code>DebugString</code> 读出来的字段不一样。那么具体是因为哪些符号决议错误，导致输出不对呢？我们可以用 <code>objdump</code> 命令来查看下二进制里面的符号，先来看下 DebugString 符号，具体命令如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -tT  main | grep DebugString</span></span><br><span class="line">0000000000000000       F *UND*	0000000000000000              _ZNK6google8protobuf7Message11DebugStringB5cxx11Ev</span><br><span class="line">0000000000000000      DF *UND*	0000000000000000  Base        _ZNK6google8protobuf7Message11DebugStringB5cxx11Ev</span><br></pre></td></tr></tbody></table></figure>

<p>不同链接顺序生成的二进制文件中，DebugString 函数都是被标记为 <code>UND</code>（未定义），这意味着这个函数在当前二进制文件中并没有定义，而是在运行时从某个动态库中加载。通过 ldd 找到二进制依赖的 protobuf 动态库地址，然后用 readelf 可以验证确实在 libprotobuf 这个动态库里面：</p>
<figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ldd mainA</span><br><span class="line">	linux-vdso.<span class="keyword">so</span>.<span class="number">1</span> (<span class="number">0</span>x00007ffe53b86000)</span><br><span class="line">	libprotobuf.<span class="keyword">so</span>.<span class="number">32</span> =&gt; /lib/x86_64-linux-gnu/libprotobuf.<span class="keyword">so</span>.<span class="number">32</span> (<span class="number">0</span>x00007f6682359000)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">nm</span> -D /lib/x86_64-linux-gnu/libprotobuf.<span class="keyword">so</span>.<span class="number">32</span> | <span class="keyword">grep</span> DebugString</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p><code>DebugString</code> 的实现在 <a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/text_format.cc#L131">protobuf/src/google/protobuf/text_format.cc</a> 中，用到了<strong>反射机制</strong>，比较复杂，暂时没搞明白，等有时间可以继续研究下，整理一个专门的文章。这里我们只是想知道为啥没输出 <code>target_user_type</code>，所以先试着过滤这个符号，看看不同顺序下的二进制有没有区别，如下图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_sysbol.png/webp" alt="动态链接顺序不同，结果也不同" srcset="https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_sysbol.png/webp 2434w, https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_sysbol.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_sysbol.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_sysbol.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2434" height="544"></p>
<p>可以看到两种链接顺序下，都有 modelB 里面的符号 <code>set_target_user_type</code>，对应了两个函数：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZN5model13HWPushAndroid20set_target_user_typeEi</span></span><br><span class="line">model::HWPushAndroid::set_target_user_type(int)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZN5model13HWPushAndroid30_internal_set_target_user_typeEi</span></span><br><span class="line">model::HWPushAndroid::_internal_set_target_user_type(int)</span><br></pre></td></tr></tbody></table></figure>

<p>这个是符合预期的，因为 main 里面调用了这个函数来设置，modelA 里面没有这个字段，不论什么顺序，都会链接到 modelB 的符号实现。但是 modelA 在前面的情况下，缺少了下面的符号：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZN5model13HWPushAndroid9_Internal24set_has_target_user_typeEPN6google8protobuf8internal7HasBitsILm1EEE</span></span><br><span class="line">model::HWPushAndroid::_Internal::set_has_target_user_type(google::protobuf::internal::HasBits&lt;1ul&gt;*)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZNK5model13HWPushAndroid26_internal_target_user_typeEv</span></span><br><span class="line">model::HWPushAndroid::_internal_target_user_type() const</span><br></pre></td></tr></tbody></table></figure>

<p>对于 protobuf 来说，在生成的消息类型中，关联有这个类型的所有字段、嵌套类型等元信息。这样运行时就可以进行非常丰富的反射操作，包括但不限于查找字段、动态创建消息、动态设置和获取字段值等。而这里先链接 modelA 里面的 pb，导致 proto 里面的消息类型没有关联到字段 target_user_type，就没有用到函数 <code>_internal_target_user_type()</code> 和 <code>set_has_target_user_type</code>，所以二进制中没有这 2 个符号。</p>
<p>再进一步，如果我在 main.cpp 直接访问这里的 target_user_type 字段，会发生什么呢？如下代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">std::cout &lt;&lt; androidMessage.<span class="built_in">target_user_type</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; androidMessage.<span class="built_in">DebugString</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，DebugString 的输出还是和链接顺序有关系，但是不论在哪种顺序下，直接输出 target_user_type 都是可以的。这一次因为直接用到了 target_user_type() 函数，所有二进制中都有下面的符号：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZNK5model13HWPushAndroid16target_user_typeEv</span></span><br><span class="line">model::HWPushAndroid::target_user_type() const</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZNK5model13HWPushAndroid26_internal_target_user_typeEv</span></span><br><span class="line">model::HWPushAndroid::_internal_target_user_type() const</span><br></pre></td></tr></tbody></table></figure>

<p>至此文章的三个疑问也都解决了。我们在用 protobuf 的时候，一定要注意<strong>链接的 proto 实现是否正确</strong>，如果有多个 proto 的字段有重复，可以用 namespace 来区分出来，这样就不会出现本文的链接错误问题。</p>
<p>这个问题排查过程中，真的是有“见鬼”了的感觉，明明简单而又常用的用法，也会有这么超出预期的表现。经过各种排除法的调试，一点也没有定位到问题所在，真是有种遇到“鬼打墙”的无力感。好在有小伙伴的提点，才拨开迷雾，最终定位到问题。并通过复现，进一步深入理解这背后的原因。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：C++ 中使用 Protobuf 诡异的字段丢失问题排查</p><p>本文链接为：https://selfboot.cn/2023/09/07/protobuf_redefine/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="打赏"></a><div class="donate_txt"> ↑<br>内容不错，打赏你啦<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/ChatGPT/"><i class="fa fa-tag"></i>ChatGPT</a><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/%E6%96%B9%E6%B3%95/"><i class="fa fa-tag"></i>方法</a></div><div class="post-nav"><a class="pre" href="/2023/09/08/divorce_money_hide/">必读的离婚法律指南：不得不防的恶意转移财产！</a><a class="next" href="/2023/09/04/batch_docx_replace/">用 Python 模板库 docxtpl 批量制作 Word 文档</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2023/09/07/protobuf_redefine/';
    this.page.identifier = '2023/09/07/protobuf_redefine/';
    this.page.title = 'C++ 中使用 Protobuf 诡异的字段丢失问题排查';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">工具介绍</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/">法律普及</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A4%BE%E4%BC%9A%E7%99%BE%E6%80%81/">社会百态</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%91%E8%9E%8D/">金融</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">项目实战</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a><span class="category-list-count">7</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/ChatGPT/" style="font-size: 15px;">ChatGPT</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 15px;">教程</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Plugin/" style="font-size: 15px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/%E6%B3%95%E5%BE%8B/" style="font-size: 15px;">法律</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Prompt/" style="font-size: 15px;">Prompt</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15px;">eBPF</a> <a href="/tags/%E5%A9%9A%E5%A7%BB%E5%AE%B6%E5%BA%AD/" style="font-size: 15px;">婚姻家庭</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/%E6%96%B9%E6%B3%95/" style="font-size: 15px;">方法</a> <a href="/tags/%E5%88%91%E4%BA%8B/" style="font-size: 15px;">刑事</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 15px;">总结</a> <a href="/tags/Google/" style="font-size: 15px;">Google</a> <a href="/tags/%E6%80%9D%E8%80%83/" style="font-size: 15px;">思考</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/DNS/" style="font-size: 15px;">DNS</a> <a href="/tags/%E8%A7%81%E9%97%BB/" style="font-size: 15px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15px;">Protocol</a> <a href="/tags/Flask/" style="font-size: 15px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/%E5%8A%B3%E5%8A%A8%E7%BA%A0%E7%BA%B7/" style="font-size: 15px;">劳动纠纷</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 15px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15px;">Gemini</a> <a href="/tags/google/" style="font-size: 15px;">google</a></div></div><!-- Debug: page.path = 2023/09/07/protobuf_redefine/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul><li><a href="/2023/12/28/black_hat_SEO/" title="从外围引流贴看黑产的搜索引擎排名优化生意">从外围引流贴看黑产的搜索引擎排名优化生意</a></li><li><a href="/2023/12/25/how-to-use-chatgpt/" title="安全、快速、便宜访问 ChatGPT，最新最全实践教程！">安全、快速、便宜访问 ChatGPT，最新最全实践教程！</a></li><li><a href="/2023/12/10/google-gemini-bard-hands-on/" title="Google Gemini Pro 深度体验，离 GPT4 还有多大差距？">Google Gemini Pro 深度体验，离 GPT4 还有多大差距？</a></li><li><a href="/2023/12/06/bert_nlp_classify/" title="零基础用 Bert 训练并部署文本分类模型">零基础用 Bert 训练并部署文本分类模型</a></li><li><a href="/2023/11/15/how_to_crack_GPTs/" title="OpenAI 的 GPTs 提示词泄露攻击与防护实战">OpenAI 的 GPTs 提示词泄露攻击与防护实战</a></li><li><a href="/2023/11/11/chatgpt_no_such_file/" title="ChatGPT 协助分析诡异的 no such file 问题">ChatGPT 协助分析诡异的 no such file 问题</a></li><li><a href="/2023/11/08/memory_leak_ebpf/" title="深入理解基于 eBPF 的 C/C++ 内存泄漏分析">深入理解基于 eBPF 的 C/C++ 内存泄漏分析</a></li><li><a href="/2023/10/26/chatgpt_impact/" title="ChatGPT 渗透力分析：搜索热度、需求图谱与人群特征">ChatGPT 渗透力分析：搜索热度、需求图谱与人群特征</a></li><li><a href="/2023/10/19/C++_zip_memory_problem/" title="C++ 内存问题排查：创建 Zip 压缩包，解压后内容错乱">C++ 内存问题排查：创建 Zip 压缩包，解压后内容错乱</a></li><li><a href="/2023/10/17/c++_frame_pointer/" title="复杂 C++ 项目堆栈保留以及 eBPF 性能分析">复杂 C++ 项目堆栈保留以及 eBPF 性能分析</a></li></ul></div><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"> 文章目录</i></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">问题背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">排查过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E5%A4%8D%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">最少复现代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%80%9D%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">补充思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">5.1.</span> <span class="toc-text">项目依赖关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E5%86%B3%E8%AE%AE"><span class="toc-number">5.2.</span> <span class="toc-text">链接符号决议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E7%AC%A6%E5%8F%B7"><span class="toc-number">5.3.</span> <span class="toc-text">链接了哪些符号</span></a></li></ol></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量<span id="busuanzi_value_site_pv"></span>次，<span id="busuanzi_container_site_uv"></span>本站访客数<span id="busuanzi_value_site_uv"></span>人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>