<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-WUJTOV7jES"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录了排查 C++ 客户端请求 Go 服务端时出现的 HTTP 请求超时问题的全过程。通过对比抓包分析发现与 Expect 100-continue 请求头相关，并深入剖析了该头部的实现机制。最后定位到 Mesh 层未正确处理该头部导致问题，并给出了代码层面解决方案。"><title>由 HTTP Header 引起的请求超时问题排查</title><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/css/all.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true; 
  hm.src = 'https://hm.baidu.com/hm.js?' + 'fd3ab4b3c488cbb43afa1c2669f06648';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">由 HTTP Header 引起的请求超时问题排查</h1><a id="logo" href="/.">Just For Fun</a><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/aboutme.html"><i class="fa fa-user"> 关于</i></a><a href="/links.html"><i class="fa fa-user-graduate"> 小盛律师</i></a><a href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"><i class="fa fa-scale-balanced"> 法律普及</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">由 HTTP Header 引起的请求超时问题排查</h1><div class="post-meta">2023/08/08<span> | </span><span class="category"><a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2023/08/08/http_100_continue/" href="/2023/08/08/http_100_continue/#disqus_thread"></a><div class="post-content"><p>在实际业务中遇到了一个很奇怪的问题，服务 A 通过 HTTP 请求访问 Go 语言的服务 B，少部分请求会超时。进一步分析发现，如果一个请求超时，其重试也一定会超时，说明针对特定请求内容，超时是必然发生的问题。通过检查服务 B 的处理日志发现，对于超时的请求，其业务逻辑处理的耗时正常。</p>
<p>一开始通过排除法来分析，逐步替换怀疑有问题的模块，结果并没有定位到问题。后来通过抓包，分析正常包与超时包的区别，合理猜测有问题的部分并进行验证，最终定位到原来是 <code>Expect: 100-continue</code> 这个请求 HTTP header 导致了这里的超时。整个排查和修复过程，踩了不少坑，记录下来可以给大家参考。</p>
<p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230807_http_100_continue_summary.png" alt="WireShark 抓包 HTTP expect: 100-continue 的包"></p>
<span id="more"></span>

<h2 id="排除法"><a href="#排除法" class="headerlink" title="排除法"></a>排除法</h2><p>业务平时都是 C++ 开发，这里的 HTTP Client 库用的 <a target="_blank" rel="noopener" href="https://curl.se/libcurl/">libcurl</a>，一直也比较稳定，没有出什么问题，所以第一时间怀疑是 Go 服务 B 的问题。Go 服务其实也比较简单，是用 <a target="_blank" rel="noopener" href="https://github.com/gin-gonic/gin">gin 框架</a>实现的 HTTP 协议代理，用来把业务请求解包后，再重新按照第三方的协议封包后转发到第三方。通过加日志等方法排除了业务逻辑部分代码的问题，初步怀疑是我们用 gin 的姿势不对。为了快速验证，我就用 gin 简单写了一个 go 的 server，用业务的 client 来请求 mock 的 server。</p>
<h3 id="替换-go-server"><a href="#替换-go-server" class="headerlink" title="替换 go server"></a>替换 go server</h3><p>用 gin 来写一个简单的 HTTP server 还是比较简单的，这里为了<strong>尽量模拟</strong>业务场景，会读请求包中的内容，然后回复一段比较长的随机内容。完整代码在 <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/7d45051f39785adc6f46a92eb585af43">gist: mock_server.go</a>，核心部分代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MeshCall</span><span class="params">(meshPath <span class="type">string</span>, c *gin.Context)</span></span> &#123;</span><br><span class="line">        start := time.Now()</span><br><span class="line"></span><br><span class="line">        uinStr := c.Query(<span class="string">&quot;uin&quot;</span>)</span><br><span class="line">        uin, err := strconv.ParseUint(uinStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                c.Status(http.StatusBadRequest)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        body, _ := ioutil.ReadAll(c.Request.Body)</span><br><span class="line">        log.Println(<span class="string">&quot;Request Body: &quot;</span>, <span class="type">string</span>(body))</span><br><span class="line"></span><br><span class="line">        c.Status(http.StatusOK)</span><br><span class="line">        c.Writer.Header().Add(<span class="string">&quot;code&quot;</span>, strconv.FormatInt(<span class="type">int64</span>(uin), <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate a 1MB random string</span></span><br><span class="line">        randomStr := StringWithCharset(<span class="number">1024</span>*<span class="number">1024</span>, charset)</span><br><span class="line">        c.Writer.Write([]<span class="type">byte</span>(randomStr))</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">&quot;Request processed in %s\n&quot;</span>, time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 mock 的 server 代码，包含了业务服务 B 里面的核心逻辑，比如用 <code>ReadAll</code> 来拿请求数据，用 <code>c.Writer</code> 来写回包内容。在 8089 启动服务后，不论是直接用命令行 curl 工具，还是用 C++ 的 client 去调用，都能正常得到 HTTP 回复。看来业务上 go 服务里 gin 的用法是没有问题，基本可以排除是 gin 自身的问题。替换 server 没发现问题，接下来替换下 client 看看？</p>
<h3 id="替换-go-client"><a href="#替换-go-client" class="headerlink" title="替换 go client"></a>替换 go client</h3><p>C++ 的 client 逻辑很简单，将一个图片设到 protobuf 的字段中，序列化后用 libcurl 发起 HTTP 请求，然后就等着回包。在 ChatGPT 的帮助下，很快就用 go 写了一个 client，一样的请求逻辑。完整代码在 <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/a88f2c4cc8f7bd5ef99097be34b988f6">gist: mock_client.go</a>，这里省略了 proto 部分，其中核心代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    req, err: = http.NewRequestWithContext(context.Background(), http.MethodPost, <span class="string">&quot;http://localhost:8089&quot;</span>, bytes.NewBuffer(serializedImageDataTwice))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to create request: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-protobuf&quot;</span>)</span><br><span class="line"></span><br><span class="line">    client: = &amp; http.Client &#123;&#125;</span><br><span class="line">    resp, err: = client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to send request: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;response header: %v&quot;</span>, resp.Header)</span><br><span class="line">    log.Printf(<span class="string">&quot;response body: %v&quot;</span>, resp.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这个 go client 请求前面 mock 的 go server，能正常解析回包。接着<strong>去请求有问题的业务服务 B，发现不再超时了，能正常读到回包</strong>。这下子有点懵了，梳理下前面的实验结果：</p>
<table>
<thead>
<tr>
<th>主调方</th>
<th>被调方</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>C++ Client A</td>
<td>Go Server B</td>
<td>特定请求必现超时</td>
</tr>
<tr>
<td>C++ Client A</td>
<td>Go Mock Server</td>
<td>一切正常</td>
</tr>
<tr>
<td>Go Client</td>
<td>Go Server B</td>
<td>一切正常</td>
</tr>
<tr>
<td>Go Client</td>
<td>Go Mock Server</td>
<td>一切正常</td>
</tr>
</tbody></table>
<p><strong>只有 <code>C++ Client A</code> 和 <code>Go Server B</code> 在一起，特定请求才会超时</strong>。已经没啥好思路来排查，只能尝试抓包，看看正常情况下和超时情况下 TCP&#x2F;HTTP 包有啥区别。</p>
<h2 id="Tcpdump-抓包分析"><a href="#Tcpdump-抓包分析" class="headerlink" title="Tcpdump 抓包分析"></a>Tcpdump 抓包分析</h2><p>Linux 下抓包比较简单，直接用 tcpdump 就行，不过一般需要 root 权限。下面命令过滤指定 ip 和端口的包，并保存为 <code>pcap</code> 格式，方便后面用 <code>Wireshark</code> 来分析。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> tcpdump -i any -s <span class="number">0</span> -w output.pcap &#x27;host <span class="number">11</span>.**.**.** and port <span class="number">1</span>***&#x27;</span><br></pre></td></tr></table></figure>

<p>首先抓 go client(IP 最后是143) 和 Go Server B(IP最后是239) 的包，整个请求响应是完全符合预期的，可以看到 0.35 s 左右请求 TCP 发送完毕，然后在 1.8s 左右开始接收回包。HTTP 请求耗时 1.5s 左右，回包内容也是完全正确的。</p>
<p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230808_http_100_continue_go_client_succ.png" alt="WireShark 抓正常回复的包"></p>
<p>接着是 C++ client 和 Go Server B 的包，这里 C++ 的 client 超时时间设置的 10 秒。可以看到这里中间收到了一个 100 continue 的 HTTP response，然后等到 10 s，客户端关闭了 TCP 连接。</p>
<p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230807_http_100_continue_fail.png" alt="WireShark 抓超时的包"></p>
<p><code>100 continue</code> 是从哪里冒出来的？为啥 Go client 请求服务没有，而 C++ client请求会有呢？</p>
<h3 id="Header-对比"><a href="#Header-对比" class="headerlink" title="Header 对比"></a>Header 对比</h3><p>回复不同一般是因为请求不同，对比这两个请求的 header 部分，发现 <code>Content-Type</code> 不同，不过这个一般没啥作用，顶多影响 server 解析，不会导致超时。除此之外，C++ 的请求 header 还多了一个 <code>Expect: 100-continue</code>，和上面回包中的 continue 也对得上。看来很大概率是这个 header 的问题了。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Go client 的 header 部分</span></span><br><span class="line"><span class="attribute">POST</span> /*** HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Host</span>: **.<span class="number">239</span>:***</span><br><span class="line"><span class="attribute">User</span>-Agent: Go-http-client/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Content</span>-Length: <span class="number">1189188</span></span><br><span class="line"><span class="attribute">Content</span>-Type: application/x-protobuf</span><br><span class="line"><span class="attribute">Accept</span>-Encoding: gzip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># C++ client 的 header 部分</span></span><br><span class="line"><span class="attribute">POST</span> /*** HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Host</span>: **.<span class="number">239</span>:***</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Content</span>-Type: application/octet-stream</span><br><span class="line"><span class="attribute">Content</span>-Length: <span class="number">1189193</span></span><br><span class="line"><span class="attribute">Expect</span>: <span class="number">100</span>-continue</span><br></pre></td></tr></table></figure>

<p>为了快速验证，<strong>在 go client 中添加了这个 header</strong>，然后发起请求，结果也超时了。看来确实是因为这个 header 导致的，那么这个 header 到底是做什么的呢？为啥会导致请求超时呢？</p>
<h2 id="Expect-100-continue"><a href="#Expect-100-continue" class="headerlink" title="Expect: 100-continue"></a>Expect: 100-continue</h2><p>为了解答上面的疑问，需要对 HTTP header 有进一步的了解。HTTP 协议中当客户端要发送一个包含大量数据的请求时（通常是 POST 或 PUT 请求），如果服务器无法处理这个请求（例如因为请求的数据格式不正确或者没有权限），那么客户端会浪费大量的资源来发送这些数据。为了解决这个问题，HTTP&#x2F;1.1引入了 <code>Expect: 100-continue</code> 头部，允许客户端在<strong>发送请求体</strong>前询问服务器是否愿意接收请求。如果服务器不能处理请求，客户端就可以不发送大量数据，从而节省资源。</p>
<p>这里具体的实现原理是把一个完整的 HTTP 请求分成两个阶段来发送。第一个阶段只发送 HTTP 请求的头部，第二个阶段在收到服务器确认后才发送 HTTP 请求的主体。从 HTTP 的角度看，仍然是一个单一的 HTTP 请求，只是改变了请求的发送方式。</p>
<p>这里一般靠网络库和底层的 TCP 协议来实现，当使用了”Expect: 100-continue”头部，网络库(比如 libcurl)会先只发送 Expect 部分的 TCP 数据，然后等待服务器的 100 Continue 响应。收到 TCP 回复后，网络库会接着发送请求主体的 TCP  数据包。如果服务器没有返回 100 Continue 响应，网络库可能会选择等待一段时间，然后发送请求主体，或者关闭连接。</p>
<h3 id="libcurl-实现"><a href="#libcurl-实现" class="headerlink" title="libcurl 实现"></a>libcurl 实现</h3><p>具体到 libcurl 网络库中，<a target="_blank" rel="noopener" href="https://everything.curl.dev/http/post/expect100">Expect 100-continue</a> 有一个详细的说明。<strong>当使用 Post 或者 Put 方法，请求体超过一定大小(一般是 1024 字节)时，libcurl 自动添加”Expect: 100-continue”请求头</strong>。对于上面的抓包中，请求的 body 中有一个比较大的图片，所以 C++ libcurl 的 client 请求中就多了这个 header。</p>
<p>现在只剩下一个问题了，<strong>带有这个 header 为啥会导致请求超时呢</strong>？libcurl 的文档中有提到下面一段：</p>
<blockquote>
<p>Unfortunately, lots of servers in the world do not properly support the Expect: header or do not handle it correctly, so curl will only wait 1000 milliseconds for that first response before it will continue anyway.</p>
</blockquote>
<p>可以看到，很多服务并没有很好支持 <code>Expect: 100-continue</code> 头部，不过 libcurl 也考虑了这种情况，在等待 1s 超时时间后，会继续发 body。从前面的抓包中也能验证这一点：</p>
<p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230808_http_100_continue_wait1000.png" alt="WireShark Expect: 100-continue 等待 1s"></p>
<p>这里 libcurl client(IP最后是 253) 发送 header 后，没有收到服务端回复，所以等待了 1s 左右，开始继续发请求 body。正常情况下，服务器等收到完整响应后，再进行处理然后回包，最多也就浪费了 1s 的等待时间。不过这里我们的 server 表现比较奇特，在收到完整包后，先是回复了 100-continue，然后就没有任何反应了。导致 client 一直在等，直到 10s 超时。这又是什么原因导致的呢？</p>
<h2 id="超时原因及修复"><a href="#超时原因及修复" class="headerlink" title="超时原因及修复"></a>超时原因及修复</h2><p>先来回顾下前面做的实验中，已经知道 C++ Client A 请求 Go Mock Server 的时候，带了 Expect:100-continue 头部，gin 框架的 HTTP server 也是可以正常回复的。整个请求和响应如下图：</p>
<p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230808_http_100_continue_continue_succ.png" alt="WireShark Expect: 100-continue 正常的处理流程"></p>
<p>可以看到 gin 服务在接收到 header 后，直接回复了 100-continue，然后 client 继续传 body，gin 服务收完后，也是正常给了200 的回包。同样是 gin 的服务，<strong>为啥请求我们业务的 Go 服务 B 就会超时呢</strong>？</p>
<p>仔细梳理了下，发现这两者还是有不同之处的。这里实验 mock 的 gin 服务是在本机上开的一个端口，请求直接到这个端口处理。但是业务的 <strong>Go 服务由 mesh 接管所有的流量并进行转发</strong>，如果 mesh 层没有处理好 100-continue，确实会有问题（这里后续可以分析下 mesh 的实现看看是哪里出问题）。</p>
<h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><p>Mesh 层的代码由专人维护，在提交 Issue 后难以确定何时能修复，而业务上又迫切需要解决该问题。于是就只好改 libcurl 的调用方法，在请求的时候去掉这个请求头。问了下 ChatGPT，用 libcurl 发送网络请求时，如何去掉这个 header，得到下面的方法。</p>
<p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230808_http_100_continue_del.png" alt="C++ libcurl 请求去掉 Expect: 100-continue header"></p>
<p>于是就开心的去改了业务发请求部分的代码，在发起网络请求前设置 header，改动如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// Disable &quot;Expect: 100-continue&quot; header</span></span><br><span class="line">    curl_slist *headers = <span class="literal">NULL</span>;</span><br><span class="line">    headers = <span class="built_in">curl_slist_append</span>(headers, <span class="string">&quot;Expect:&quot;</span>);</span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_HTTPHEADER, headers);</span><br><span class="line"></span><br><span class="line">    defer &#123;</span><br><span class="line">        <span class="built_in">curl_slist_free_all</span>(headers);  <span class="comment">// remember to free the headers</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改完后验证了下，到服务 B 的 HTTP 请求确实能收到正常回包了。然后上线的时候，发现调其他三方的网络请求出现了参数错误的告警。回滚后，失败也没了，看来和这个 HTTP 请求的改动有关系了。仔细看了下这里的 libcurl <code>CURLOPT_HTTPHEADER</code> 部分的设置，发现业务上也会设置，这里的<strong>改动会把之前设置的整个 header 覆盖清空</strong>。</p>
<p>ChatGPT 告诉我可以清空这个 Expect 的 header，甚至还告诉我要注意内存泄露，但是 ChatGPT 也没法考虑周全，没考虑到这种方法会直接覆盖我原来的 header。ChatGPT 确实能为我们提供非常有用的建议和解决方案，但是它的答案是基于用户给定的上下文。它并不知道整个系统的细节，也不能预知全部的业务场景。所以，在接受和应用它的建议时，需要非常谨慎，确保将其建议与实际的业务场景相结合。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target=_blank>个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：由 HTTP Header 引起的请求超时问题排查</p><p>本文链接为：https://selfboot.cn/2023/08/08/http_100_continue/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="打赏"></a><div class="donate_txt"> &uarr;<br>内容不错，打赏你啦<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/%E6%96%B9%E6%B3%95/"><i class="fa fa-tag"></i>方法</a><a href="/tags/Go/"><i class="fa fa-tag"></i>Go</a></div><div class="post-nav"><a class="pre" href="/2023/08/10/crime_illegal_business/">罗翔说刑法：非法+经营+数额较大=非法经营罪？？？</a><a class="next" href="/2023/08/05/divorce_legal_longtime/">离婚法律指南：离婚流程要多久？</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2023/08/08/http_100_continue/';
    this.page.identifier = '2023/08/08/http_100_continue/';
    this.page.title = '由 HTTP Header 引起的请求超时问题排查';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://selfboot.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">工具介绍</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/">法律普及</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A4%BE%E4%BC%9A%E7%99%BE%E6%80%81/">社会百态</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%91%E8%9E%8D/">金融</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/ebpf/" style="font-size: 15px;">ebpf</a> <a href="/tags/ChatGPT/" style="font-size: 15px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15px;">Prompt</a> <a href="/tags/%E5%A9%9A%E5%A7%BB%E5%AE%B6%E5%BA%AD/" style="font-size: 15px;">婚姻家庭</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 15px;">教程</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 15px;">总结</a> <a href="/tags/%E6%96%B9%E6%B3%95/" style="font-size: 15px;">方法</a> <a href="/tags/Google/" style="font-size: 15px;">Google</a> <a href="/tags/%E6%80%9D%E8%80%83/" style="font-size: 15px;">思考</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/DNS/" style="font-size: 15px;">DNS</a> <a href="/tags/%E8%A7%81%E9%97%BB/" style="font-size: 15px;">见闻</a> <a href="/tags/GUI/" style="font-size: 15px;">GUI</a> <a href="/tags/Protocol/" style="font-size: 15px;">Protocol</a> <a href="/tags/Flask/" style="font-size: 15px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/%E6%B3%95%E5%BE%8B/" style="font-size: 15px;">法律</a> <a href="/tags/Plugin/" style="font-size: 15px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15px;">Issue</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/%E5%88%91%E4%BA%8B/" style="font-size: 15px;">刑事</a></div></div><!-- Debug: page.path = 2023/08/08/http_100_continue/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul><li><a href="/2023/08/08/http_100_continue/" title="由 HTTP Header 引起的请求超时问题排查">由 HTTP Header 引起的请求超时问题排查</a></li><li><a href="/2023/08/02/redis_python_bug/" title="解密 ChatGPT 数据泄露：Redis Bug 的深度分析">解密 ChatGPT 数据泄露：Redis Bug 的深度分析</a></li><li><a href="/2023/07/28/chatgpt_hacking/" title="提示词破解：绕过 ChatGPT 的安全审查">提示词破解：绕过 ChatGPT 的安全审查</a></li><li><a href="/2023/07/25/gpt4_prompt_evals/" title="ChatGPT Prompt 最佳指南六：系统基准评测">ChatGPT Prompt 最佳指南六：系统基准评测</a></li><li><a href="/2023/07/24/gpt4_prompt_tools/" title="ChatGPT Prompt 最佳指南五：借助外部工具">ChatGPT Prompt 最佳指南五：借助外部工具</a></li><li><a href="/2023/07/20/claude_gpt4_compare/" title="大语言模型 Claude2 和 ChatGPT 实测对比">大语言模型 Claude2 和 ChatGPT 实测对比</a></li><li><a href="/2023/07/17/gpt4_code_interpreter_cpu/" title="ChatGPT 代码解释器：OpenAI 提供了多少 CPU">ChatGPT 代码解释器：OpenAI 提供了多少 CPU</a></li><li><a href="/2023/07/12/gpt4_code_interpreter_image/" title="ChatGPT 代码解释器：自然语言处理图片">ChatGPT 代码解释器：自然语言处理图片</a></li><li><a href="/2023/07/10/gpt4_code_interpreter_data/" title="ChatGPT 代码解释器：数据分析与可视化">ChatGPT 代码解释器：数据分析与可视化</a></li><li><a href="/2023/07/09/gpt4_code_interpreter_limit/" title="ChatGPT 代码解释器：资源限制详解">ChatGPT 代码解释器：资源限制详解</a></li></ul></div><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"> 文章目录</i></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E9%99%A4%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">排除法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2-go-server"><span class="toc-number">1.1.</span> <span class="toc-text">替换 go server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2-go-client"><span class="toc-number">1.2.</span> <span class="toc-text">替换 go client</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tcpdump-%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">Tcpdump 抓包分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Header-%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.</span> <span class="toc-text">Header 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Expect-100-continue"><span class="toc-number">3.</span> <span class="toc-text">Expect: 100-continue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libcurl-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">libcurl 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E5%8E%9F%E5%9B%A0%E5%8F%8A%E4%BF%AE%E5%A4%8D"><span class="toc-number">4.</span> <span class="toc-text">超时原因及修复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D"><span class="toc-number">4.1.</span> <span class="toc-text">问题修复</span></a></li></ol></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量<span id="busuanzi_value_site_pv"></span>次，<span id="busuanzi_container_site_uv"></span>本站访客数<span id="busuanzi_value_site_uv"></span>人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>