<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这篇文章详细分析了在使用 C++ 的 libzip 库动态生成 Zip 压缩包时遇到的一个文件内容错乱的问题。作者通过代码示例重现了问题，并使用 ChatGPT、GDB 等方法进行错误排查，最终定位到问题出在 libzip 的 zip_source_buffer 接口使用不当，在 zip_close 时才真正读取 buffer 中的数据，而此时 buffer 已被释放造成内容错乱。"><title>C++ 内存问题排查：创建 Zip 压缩包，解压后内容错乱</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C++ 内存问题排查：创建 Zip 压缩包，解压后内容错乱</h1><div class="post-meta">2023/10/19<span> | </span><span class="category"><a href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2023/10/19/C++_zip_memory_problem/" href="/2023/10/19/C++_zip_memory_problem/#disqus_thread"></a><div class="post-content"><p>在日常的 C++ 后台开发工作中，很少会动态生成 Zip 包，所以对 C++ 的 libzip 并不熟悉。最近刚好有个场景，需要将后台生成的一份数据压缩为一个 Zip 包以便下载。这里其实之前已经有生成 Zip 包的代码，只是需要在 Zip 包里面增加一个文件。本来是一个简单的需求，但是实现中遇到了一个诡异的问题，解压生成的 Zip 包里，里面<strong>文件开头部分有错乱</strong>。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231018_C++_zip_memory_problem_index.png/webp" alt="C++ 创建 Zip 压缩包乱码问题" srcset="https://slefboot-1251736664.file.myqcloud.com/20231018_C++_zip_memory_problem_index.png/webp 1982w, https://slefboot-1251736664.file.myqcloud.com/20231018_C++_zip_memory_problem_index.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231018_C++_zip_memory_problem_index.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231018_C++_zip_memory_problem_index.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1982" height="1196"></p>
<span id="more"></span>

<p>问题的排查过程中，绕了一些弯路，最后发现是 C++ 的内存问题导致的，这里记录下问题的排查和修复，以及对第三方库 Zip 的源码解读。对 C++ 不熟悉的读者也可以放心阅读，来<strong>感受下 C++ 的内存问题有多难调试</strong>。</p>
<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>业务中是通过一个 <code>RPC</code> 请求拿到了部分数据，然后把这些数据进行处理后，生成一个 Zip 包，最后返回给前端。前端解码 zip 包后发现部分内容乱码，不符合事先约定的协议内容。由于是个必现的问题，比较好定位，<strong>直接加日志调试</strong>，发现 RPC 拿回来的数据并没有问题，但是生成 Zip 包之后，里面的内容就会多了些乱码内容。</p>
<p>这里为了能够方便地复现问题，直接把生成 Zip 包部分抽离出来，写了一个简单的示例，核心代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">zip* archive = <span class="built_in">zip_open</span>(tmpFile, ZIP_CREATE | ZIP_TRUNCATE, &amp;error);</span><br><span class="line"><span class="keyword">if</span> (archive == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fail to open %s err %d"</span>, tmpFile, error);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">zip_source* s = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : FileInfos) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == (s = <span class="built_in">zip_source_buffer</span>(archive, item.htmltemlate.<span class="built_in">c_str</span>(), item.htmltemlate.<span class="built_in">size</span>(), <span class="number">0</span>)) ||</span><br><span class="line">        <span class="built_in">zip_file_add</span>(archive, (item.filename + <span class="string">"_temp.xhtml"</span>).<span class="built_in">c_str</span>(), s, ZIP_FL_ENC_UTF_8 | ZIP_FL_OVERWRITE) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">zip_source_free</span>(s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail to add info.txt err %s"</span>, <span class="built_in">zip_strerror</span>(archive));</span><br><span class="line">        error = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">zip_close</span>(archive) &lt; <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fail to close %s ret %d"</span>, tmpFile, error);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>完整代码在 <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/acda3473f687f610dc1f6230e555df03">Gist</a> 上。逻辑比较简单，将代码里一段 string 放进去一个文件，然后添加到 tar 包中去。压缩后再用 <code>unzip</code> 工具来尝试解压 tar 包，打印文件内容。注意需要在系统中安装 <code>libzip</code> 库。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_error.png/webp" alt="C++ 创建 Zip 乱码复现" srcset="https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_error.png/webp 2048w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_error.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_error.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_error.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2048" height="396"></p>
<p>文件原来的内容是<code>(&lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;demo</code>，但是上面的运行结果可以看到，输出的内容直接乱码了。为了能够看到这里解压后的文件到底是什么内容，这里直接用 <code>hexdump</code> 来查看文件的内容：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hexdump -C file1_temp.xhtml</span><br><span class="line">00000000  00 dc 14 b3 f8 55 00 00  50 a2 2a a1 07 7f 00 00  |.....U..P.*.....|</span><br><span class="line">00000010  00 a2 2a a1 07 7f 00 00  c4 02 00 00 00 04 00 00  |..*.............|</span><br><span class="line">00000020  c4 00 00 00 00 02 00 00  00 02 00 00 00 00 00 00  |................|</span><br><span class="line">00000030  00 01 00 00 00 00 00 00  87 05                    |..........|</span><br><span class="line">0000003a</span><br></pre></td></tr></tbody></table></figure>

<p>发现整个内容和输入字符串完全不一样，并且错乱的内容也很奇怪，没有任何地方会生成这些错乱内容。这时候最好是用 GDB 调试，或者直接去看 zip 库的文档或者源码，看看这里是哪里出了问题。</p>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>不过自从有了 ChatGPT，遇见问题的第一反应就是丢给 ChatGPT 来看看。先把这部分写 zip 包的代码直接丢给 ChatGPT，然后提问“这样往里面添加文件是合理的吗？”。ChatGPT 认为<strong>这段代码基本是合理的</strong>，没有什么错误使用方法。没关系，继续追问，这次提示词提供了更多细节，参考<a href="https://selfboot.cn/2023/06/12/gpt4_prompt_reference/">ChatGPT Prompt 最佳指南二：提供参考文本</a>，如下：</p>
<blockquote>
<p>我用上面的代码，生成的 zip 文件，用 unzip 解压缩后，file1_temp.xhtml 文件的内容为啥不等于 htmltemlate，在前面部分有乱码的内容。</p>
<p>hexdump -C file1_temp.xhtml<br>00000000  00 dc 14 b3 f8 55 00 00  50 a2 2a a1 07 7f 00 00  |.....U..P.*.....|<br>00000010  00 a2 2a a1 07 7f 00 00  c4 02 00 00 00 04 00 00  |..*.............|</p>
</blockquote>
<p>ChatGPT 果真是江湖百晓通，一下子就给出了一个看起来正确的答案：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231018_C++_zip_memory_problem_gpt.png/webp" alt="ChatGPT Zip 包乱码问题分析" srcset="https://slefboot-1251736664.file.myqcloud.com/20231018_C++_zip_memory_problem_gpt.png/webp 1966w, https://slefboot-1251736664.file.myqcloud.com/20231018_C++_zip_memory_problem_gpt.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231018_C++_zip_memory_problem_gpt.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231018_C++_zip_memory_problem_gpt.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="1966" height="1356"></p>
<p>按照 ChatGPT 的回答，这里循环 FileInfos 执行完后，zip_close 被调用之前，<code>item.htmltemlate</code> 内存里的内容可能已经被释放了，所以这里添加的内容不对。这个结论很容易<strong>验证</strong>是不是靠谱，直接改下这行代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item : FileInfos) {</span><br></pre></td></tr></tbody></table></figure>

<p>把这里改成引用(其实本来也应该用引用，这样可以<strong>减少拷贝操作</strong>)，重新跑下，发现问题果然解决了。</p>
<h2 id="GDB-验证"><a href="#GDB-验证" class="headerlink" title="GDB 验证"></a>GDB 验证</h2><p>定位到了问题后，再回过头来，用 GDB 验证下输出乱码的程序执行过程。这里 libzip 的实现还是比较复杂的，不过最关键在于 zip_source_buffer 和 zip_close 两个函数。按照前面的代码，可以<strong>合理猜测</strong> zip_source_buffer 添加 htmltemlate 的时候，没有复制内存里的内容，只是引用了地址。然后在 zip_close 的时候，才去读取这个 htmltemlate 里的内容。可是这时候 htmltemlate 内存已经被释放了，里面的内容是未定义的，可能是乱码，也可能还是旧的值。</p>
<p>由于没有那么多精力花在读 libzip 源码上，为了快速验证这里的猜想，可以用 GDB 一步步调试。为了用 GDB 能看到 libzip 库的调试符号，下载 libzip 的源码，用 <code>-g</code> 重新编译。</p>
<h3 id="添加调试符号"><a href="#添加调试符号" class="headerlink" title="添加调试符号"></a>添加调试符号</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/nih-at/libzip.git</span><br><span class="line">$ <span class="built_in">cd</span> libzip</span><br><span class="line">$ <span class="built_in">mkdir</span> build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_FLAGS=<span class="string">"-fno-omit-frame-pointer"</span> -DCMAKE_CXX_FLAGS=<span class="string">"-fno-omit-frame-pointer"</span> -DCMAKE_INSTALL_PREFIX=./install ..</span><br><span class="line">$ make</span><br><span class="line">$ make install </span><br></pre></td></tr></tbody></table></figure>

<p>然后重新编译前面的代码，这里需要指定 libzip 的头文件和库文件的路径。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ g++ zip_test.cpp -o zip_test -L/root/libzip/build/install/lib -lzip -Wl,-rpath=/root/libzip/build/install/lib -g -fno-omit-frame-pointer</span><br><span class="line">$ ldd zip_test</span><br><span class="line">    linux-vdso.so.1 (0x00007ffcbc5cf000)</span><br><span class="line">    libzip.so.5 =&gt; /root/libzip/build/install/lib/libzip.so.5 (0x00007fe4bf88a000)</span><br><span class="line">    libstdc++.so.6 =&gt; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007fe4bf667000)</span><br><span class="line">    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fe4bf647000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe4bf466000)</span><br><span class="line">    liblzma.so.5 =&gt; /lib/x86_64-linux-gnu/liblzma.so.5 (0x00007fe4bf437000)</span><br><span class="line">    libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007fe4bf416000)</span><br><span class="line">    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fe4bf337000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007fe4bf8b6000)</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到这里二进制已经用了重新编译的带 debug 信息的 libzip 了。</p>
<h3 id="定位读内存位置"><a href="#定位读内存位置" class="headerlink" title="定位读内存位置"></a>定位读内存位置</h3><p>这里我们想验证的就是，<code>zip_close</code> 的时候，才从 htmltemlate 里面读内容创建压缩包。刚开始，想着简单看下 <a target="_blank" rel="noopener" href="https://github.com/nih-at/libzip/blob/main/lib/zip_close.c">zip_close 的代码</a>，确认下在哪个地方读，然后在相应地方打断点。但是发现这里函数调用一层层下去，段时间很难找到一个合适的地方打断点。</p>
<p>这里走了一些弯路，想着用一些工具能找到 zip_close 的函数调用栈，从而能快速找到核心的函数。</p>
<ol>
<li>尝试用 ebpf 的 stackcount 来跟踪下函数调用栈，<code>stackcount -p $(pgrep zip_test) 'zip_*'</code>，结果一直报错：Failed to attach BPF program b’trace_count’ to kprobe , it’s not traceable (either non-existing, inlined, or marked as “notrace”)；最后<strong>也没有找到解决办法(谁知道原因的可以留言给我)</strong>。</li>
<li>用 <code>Valgrind</code> 的 <code>callgrind</code> 工具，<code>valgrind --tool=callgrind ./zip_test</code>来生成调用关系，然后再用 <code>gprof2dot</code> 和 <code>dot</code> 进行可视化，这里也确实看到了一些执行流程，但是并没有 zip_source_buffer 函数的。</li>
</ol>
<p>既然很难理清楚这里的代码，就<strong>直接从内存地址</strong>入手。我们知道 GDB 可以用 <code>rwatch</code> 监控某个内存地址的读操作，所以可以在 zip_close 结束前，rwatch htmltemlate 的内存地址，看看到底是什么时候会读这里的内容。</p>
<p>整体 GDB 调试思路如下：<strong>首先在 zip_source_buffer 和 zip_close 所在行以及最后退出前设置断点，然后执行到 zip_source_buffer 断点，然后打印 htmltemlate 的内存地址，并设置 rwatch，接着 continue 看看这里的内存地址在哪里被读</strong>。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_gdb_break.png/webp" alt="GDB 调试 Zip 乱码增加断点" srcset="https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_gdb_break.png/webp 2376w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_gdb_break.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_gdb_break.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_gdb_break.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2376" height="648"></p>
<p>上面图片执行到 zip_source_buffer 断点，打印 htmltemlate 的内存地址，然后设置 rwatch，接着 continue 看看这里的内存地址在哪里被读。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_gdb_read.png/webp" alt="GDB 调试 Zip 找到读内存的位置" srcset="https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_gdb_read.png/webp 2410w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_gdb_read.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_gdb_read.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_gdb_read.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2410" height="1684"></p>
<p>到这里就验证了前面的猜想，<code>zip_source_buffer</code> 里面并没有读 htmltemlate 里面的内容，<strong>在 zip_close 的时候才从这里读内容创建压缩包</strong>。这里的内存地址是 <code>0x55555556beb0</code>，这时候打印里面的内容，应该和最后生成的乱码内容一致，如下图所示：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_content.png/webp" alt="GDB 调试内存位置内容和解码后文件内容对比" srcset="https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_content.png/webp 2396w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_content.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_content.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20231019_C++_zip_memory_problem_content.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2396" height="964"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题遇到的人还有不少，比如 Stack Overflow 上的这两个问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/58844649/libzip-with-zip-source-buffer-causes-data-corruption-and-or-segfaults">libzip with zip_source_buffer causes data corruption and/or segfaults</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/73820283/add-multiple-files-from-buffers-to-zip-archive-using-libzip">Add multiple files from buffers to ZIP archive using libzip</a></li>
</ul>
<p>其实 libzip 的官方文档都写的有问题，<a target="_blank" rel="noopener" href="https://libzip.org/documentation/zip_source_buffer.html">zip_source_buffer 官方文档</a> 如下：</p>
<blockquote>
<p>The functions zip_source_buffer() and zip_source_buffer_create() create a zip source from the buffer data of size len. If freep is non-zero, the buffer will be freed when it is no longer needed. data must remain valid for the lifetime of the created source.</p>
</blockquote>
<p>文档说 data 必须和 source 的生命周期保持一致，其实并不准确，这里必须要保证数据在 zip_close 调用前不会被销毁。在其他语言，基本不会有这么奇葩的接口设计，但是在 C 里面，这种设计还是不少。各种比较经典的 C 库里面，都会有这种设计。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：C++ 内存问题排查：创建 Zip 压缩包，解压后内容错乱</p><p>本文链接为：https://selfboot.cn/2023/10/19/C++_zip_memory_problem/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/ChatGPT/"><i class="fa fa-tag"></i>ChatGPT</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2023/10/19/C++_zip_memory_problem/';
    this.page.identifier = '2023/10/19/C++_zip_memory_problem/';
    this.page.title = 'C++ 内存问题排查：创建 Zip 压缩包，解压后内容错乱';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (22)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (32)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2023/10/19/C++_zip_memory_problem/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/06/13/leveldb_source_LRU_cache/" title="LevelDB 源码阅读：LRU Cache 高性能缓存实现细节">LevelDB 源码阅读：LRU Cache 高性能缓存实现细节</a></li><li><a href="/2025/06/11/leveldb_source_memtable/" title="LevelDB 源码阅读：MemTable 内存表的实现细节">LevelDB 源码阅读：MemTable 内存表的实现细节</a></li><li><a href="/2025/06/10/leveldb_mvcc_intro/" title="LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)">LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)</a></li><li><a href="/2025/05/23/mcp_user_report/" title="使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?">使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?</a></li><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li><li><a href="/2024/09/24/leveldb_source_skiplist_time_analysis/" title="LevelDB 源码阅读：如何分析跳表的时间复杂度？">LevelDB 源码阅读：如何分析跳表的时间复杂度？</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%A4%8D%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">问题复现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">2.</span> <span class="toc-text">问题排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB-%E9%AA%8C%E8%AF%81"><span class="toc-number">3.</span> <span class="toc-text">GDB 验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%B0%83%E8%AF%95%E7%AC%A6%E5%8F%B7"><span class="toc-number">3.1.</span> <span class="toc-text">添加调试符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E8%AF%BB%E5%86%85%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.2.</span> <span class="toc-text">定位读内存位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>