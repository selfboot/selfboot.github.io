<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-WUJTOV7jES"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本文探讨不同编译方式下的堆栈可用性。静态链接情况下，哪怕中间层库失去堆栈信息，整体调用堆栈也会错乱，动态链接同理。保留帧指针是获取堆栈的关键，需要编译加入选项。"><title>复杂 C++ 项目堆栈保留以及 eBPF 性能分析</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">复杂 C++ 项目堆栈保留以及 eBPF 性能分析</h1><a id="logo" href="/.">Just For Fun</a><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/aboutme.html"><i class="fa fa-user"> 关于</i></a><a href="/links.html"><i class="fa fa-user-graduate"> 小盛律师</i></a><a href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"><i class="fa fa-scale-balanced"> 法律普及</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">复杂 C++ 项目堆栈保留以及 eBPF 性能分析</h1><div class="post-meta">2023/10/17<span> | </span><span class="category"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2023/10/17/c++_frame_pointer/" href="/2023/10/17/c++_frame_pointer/#disqus_thread"></a><div class="post-content"><p>在构建和维护复杂的 C++ 项目时，性能优化和内存管理是至关重要的。当我们面对性能瓶颈或内存泄露时，可以使用eBPF（Extended Berkeley Packet Filter）和 BCC（BPF Compiler Collection）工具来分析。如我们在<a href="https://selfboot.cn/2023/06/14/bug_redis_deadlock_1/">Redis Issue 分析：流数据读写导致的“死锁”问题(1)</a>文中看到的一样，我们用 BCC 的 profile 工具分析 Redis 的 CPU 占用，画了 CPU 火焰图，然后就能比较容易找到耗时占比大的函数以及其调用链。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230613_bug_redis_deadlock_cpu.svg" alt="CPU 火焰图"></p>
<span id="more"></span>

<p>这里使用 profile 分析的一个大前提就是，服务的二进制文件要保留函数的堆栈信息。堆栈信息是程序执行过程中函数调用和局部变量的记录，当程序执行到某一点时，通过查看堆栈信息，我们可以知道哪些函数被调用，以及它们是如何相互关联的。这对于调试和优化代码至关重要，特别是在处理性能问题和内存泄露时。</p>
<p>但是在实际的项目中，我们用 eBPF 来分析服务的性能瓶颈或者内存泄露的时候，往往会拿不到函数调用堆栈，遇到各种 <code>unknown</code> 的函数调用链。这是因为生产环境为了减少二进制文件的大小，通常不包含调试信息。此外，就算生产环境编译 C++ 代码的时候用了 <code>-g</code> 生成了调试信息，也可能拿不到完整的函数调用堆栈。这里面的原因比较复杂，本文将展开聊一下这个问题。 </p>
<h2 id="程序的堆栈信息"><a href="#程序的堆栈信息" class="headerlink" title="程序的堆栈信息"></a>程序的堆栈信息</h2><p>在计算机科学中，<code>堆栈（Stack）</code>是一种基本的数据结构，它遵循后进先出（LIFO）的原则。这意味着最后一个被添加到堆栈的元素是第一个被移除的。堆栈在程序设计中有很多用途，其中最常见的是在函数调用和局部变量存储中的应用。</p>
<p>在程序执行过程中，堆栈被用于管理函数调用，这称为<code>“调用堆栈”</code>或<code>“执行堆栈”</code>。当一个函数被调用时，一个新的堆栈帧被创建并压入调用堆栈。这个堆栈帧包含：</p>
<ol>
<li>返回地址：函数执行完成后，程序应该继续执行的内存地址。</li>
<li>函数参数：传递给函数的参数。</li>
<li>局部变量：在函数内部定义的变量。</li>
<li>帧指针：指向前一个堆栈帧的指针，以便在当前函数返回时恢复前一个堆栈帧的上下文。</li>
</ol>
<p>当函数执行完成时，其堆栈帧被弹出，控制返回到保存的返回地址。堆栈在内存中的分布如下图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230702_c++_frame_pointer_stack_mem.png/webp" alt="函数调用堆栈内存分布图" srcset="https://slefboot-1251736664.file.myqcloud.com/20230702_c++_frame_pointer_stack_mem.png/webp 836w, https://slefboot-1251736664.file.myqcloud.com/20230702_c++_frame_pointer_stack_mem.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230702_c++_frame_pointer_stack_mem.png/webp800 800w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="836" height="1236"></p>
<h3 id="DWARF-格式的堆栈信息"><a href="#DWARF-格式的堆栈信息" class="headerlink" title="DWARF 格式的堆栈信息"></a>DWARF 格式的堆栈信息</h3><p>函数调用堆栈的信息在二进制文件中以 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> 格式保存。DWARF 是一种用于表示程序的调试信息的标准格式，广泛应用于Unix和Linux系统。它是一种非常灵活和可扩展的格式，能够表示丰富的调试信息，包括但不限于源代码行号、变量名、数据类型、堆栈帧以及它们的关系。</p>
<p>DWARF由一系列的“调试节”组成，每个节包含特定类型的调试信息。比如 <code>.debug_info</code>: 包含关于程序结构的信息，如变量、类型和过程。<code>.debug_line</code>: 包含源代码行号和地址信息的映射，这对于在调试器中定位源代码位置非常有用。可以在 <a target="_blank" rel="noopener" href="https://dwarfstd.org/index.html">DWARF 官网</a> 上看到具体格式标准，比如当前的 <a target="_blank" rel="noopener" href="https://dwarfstd.org/dwarf5std.html">Version 5</a> 版本，有一个 <a target="_blank" rel="noopener" href="https://dwarfstd.org/doc/DWARF5.pdf">PDF</a> 记录详细的规范。</p>
<p><a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information/">How debuggers work: Part 3 - Debugging information</a> 这篇文章用实际代码，结合 objdump 和 readelf 工具，深入探讨了 DWARF 调试信息格式，值得一读。</p>
<p>对于 C++ 项目来说，为了在编译时生成包含 DWARF 调试信息的二进制文件，需要使用编译器的编译选项。对于 GCC 和 Clang 编译器，这通常是通过使用 <code>-g</code> 标志来完成的。下面是一个简单的示例代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dwarf.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">say_hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在生成的 ELF 二进制文件中，我们用 objdump 的 <code>[-h|--section-headers|--headers]</code> 选项，可以打印出所有的 section headers。如果用 <code>-g</code> 编译，生成文件包含 DWARF 调试信息，主要有 <code>debug_aranges</code>，<code>.debug_info</code> 等section。没有 <code>-g</code> 选项的时候，生成的二进制文件则没有这些section。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_dwarf.png/webp" alt="编译带 DWARF 调试信息的 ELF section" srcset="https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_dwarf.png/webp 2190w, https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_dwarf.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_dwarf.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_dwarf.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2190" height="886"></p>
<p>如果二进制 ELF 文件带了 DWARF 信息，用 GDB 调试的时候，就可以设置函数行断点、单步执行代码、检查变量值，并查看函数调用堆栈等。此外，传统的性能分析工具 perf，也可以读取 DWARF 信息来解析函数调用堆栈，如下命令即可：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">perf record --call-graph dwarf ./my_program</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Frame-Pointer-解析堆栈"><a href="#Frame-Pointer-解析堆栈" class="headerlink" title="Frame Pointer 解析堆栈"></a>Frame Pointer 解析堆栈</h3><p>虽然 DWARF 信息对于调试非常有用，但基于 eBPF 的工具不能读取 DWARF 里面的堆栈信息。在 eBPF 中使用另外方法读取堆栈信息，那就是帧指针(frame pointer)，帧指针可以为我们提供完整的堆栈跟踪。帧指针是 perf 的默认堆栈遍历，也是目前 bcc-tools 或 bpftrace 唯一支持的堆栈遍历技术。</p>
<p>为了在生成的二进制文件中保留帧指针，要确保在编译程序时启用帧指针。这可以通过使用编译器标志来完成，例如在 GCC 中使用 <code>-fno-omit-frame-pointer</code>。下面是一个简单的示例代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fp_demo_write.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionA</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">"Inside functionA\n"</span>;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, message, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// cout 的函数调用堆栈不在 main 中;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "Inside functionA" &lt;&lt; std::endl;</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionB</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">functionA</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">"Inside functionB\n"</span>;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, message, <span class="number">16</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionC</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">functionB</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">"Inside functionC\n"</span>;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, message, <span class="number">16</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="built_in">functionC</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>用 <code>-fno-omit-frame-pointer</code> 编译后，可以用 profile 拿到 cpu 耗时的函数调用堆栈，之后用 FlameGraph 可以拿到 cpu 火焰图。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ fp_demo_write.cpp -fno-omit-frame-pointer -o fp_demo_write</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">profile -F 999 -U -f --pid $(pgrep fp_demo_write)  60 &gt; fp_demo_write.stack</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">../FlameGraph/flamegraph.pl fp_demo_write.stack &gt; fp_demo_write.svg</span></span><br></pre></td></tr></tbody></table></figure>

<p>这里 CPU 火焰图如下，可以看到整体函数调用链路，以及各种操作的耗时：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_fp_demo_write.svg" alt="fno-omit-frame-pointer拿到完整的函数堆栈"></p>
<p>上面示例函数中，我们用 <code>write(STDOUT_FILENO, message, 16);</code> 来打印字符串，这里一开始用了c++的 <code>std::cout</code> 来打印，结果 cpu 火焰图有点和预期不一样，可以看到和 <code>__libc_start_call_main</code> 同级别的，有一个 unknown 函数帧，然后在这里面有 <code>write</code> 和 <code>std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::~basic_ostream()</code> 函数。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_fp_demo_cout.svg" alt="cout 拿到的函数堆栈里面有 unknown 部分"></p>
<p>理论上这里所有的函数都应该在 main 的函数栈里面的，但是现在并列有了一个 <code>unknown</code> 的调用堆栈。可能是和 C++ 标准库 glibc 的内部工作方式和缓冲机制有关，在使用 <code>std::cout</code> 写入数据时，数据不会立即写入标准输出，而是存储在内部缓冲区中，直到缓冲区满或显式刷新。这里的输出由 glibc 控制，所以调用堆栈不在 main 中。 </p>
<p>如果想验证我们的二进制文件是否有帧指针的信息，可以用 <code>objdump</code> 拿到反汇编内容，然后看函数的开始指令是不是 <code>push %rbp; mov %rsp,%rbp</code> 即可。对于前面的例子，我们可以看到反汇编结果如下：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_rbp.png/webp" alt="验证二进制汇编中有帧指针 rbp" srcset="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_rbp.png/webp 2230w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_rbp.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_rbp.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_rbp.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2230" height="886"></p>
<p>GCC/G++ 编译器中，是否默认使用<code>-fno-omit-frame-pointer</code>选项依赖于编译器的版本和目标架构。在某些版本和/或架构上，可能默认保留帧指针。如果没有保留帧指针，生成的二进制汇编代码中就没有相关 rbp 的部分。在我的机器上，默认编译也是有帧指针的，用 <code>-O2</code> 开启编译优化后生成的二进制中就没有帧指针了，如下所示：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_no_rbp.png/webp" alt="二进制汇编中没有帧指针 rbp" srcset="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_no_rbp.png/webp 2320w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_no_rbp.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_no_rbp.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_no_rbp.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2320" height="636"></p>
<p>再用 <code>profile</code> 来分析的话，就拿不到完整的函数调用栈信息了，如下图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_fp_demo_write_no.svg" alt="没有帧指针，拿函数堆栈失败"></p>
<p>在实际的项目开发中，建议在默认编译选项中加上 <code>-fno-omit-frame-pointer</code>，方便后面进行分析。在Linux 发行版 fedora 的 wiki 上可以看到有人就提议，默认开启 <a target="_blank" rel="noopener" href="https://fedoraproject.org/wiki/Changes/fno-omit-frame-pointer">Changes/fno-omit-frame-pointer</a>，并列举了这样做的好处以及可能的性能损失。</p>
<h2 id="复杂-C-项目编译"><a href="#复杂-C-项目编译" class="headerlink" title="复杂 C++ 项目编译"></a>复杂 C++ 项目编译</h2><p>上面的例子中都是编译一个简单的 cpp 文件，对于实际项目来说，可能有很多 cpp 文件，同时还有各种复杂的第三方库依赖。如何使最后编译的二进制文件保留完整的堆栈信息，就会变得有挑战。下面我们将重点来看，对于有复杂第三方依赖的项目，编译选项<code>-fno-omit-frame-pointer</code> 如何影响最终生成的二进制文件。</p>
<h3 id="动态链接与静态链接"><a href="#动态链接与静态链接" class="headerlink" title="动态链接与静态链接"></a>动态链接与静态链接</h3><p>C++ 项目依赖第三方库有两种链接方式，静态链接和动态链接。静态链接是在编译时将所有库文件的代码合并到一个单一的可执行文件中，这意味着可执行文件包含了它所需要的所有代码，不依赖于外部的库文件。与静态链接不同，动态链接不会将库代码合并到可执行文件中。相反，它在运行时动态地加载库，这意味着可执行文件只包含对库的引用，而不是库的实际代码。</p>
<p>下面是静态链接和动态链接的一些特点：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>静态链接</th>
<th>动态链接</th>
</tr>
</thead>
<tbody><tr>
<td>部署难度</td>
<td>简单，只需分发一个文件</td>
<td>较复杂，需要确保可执行文件能找到依赖的库</td>
</tr>
<tr>
<td>启动时间</td>
<td>通常更快，因为没有额外的加载开销</td>
<td>可能较慢，因为需要在运行时加载库</td>
</tr>
<tr>
<td>文件大小</td>
<td>通常较大，因为包含所有依赖的代码</td>
<td>通常较小，因为只包含对库的引用</td>
</tr>
<tr>
<td>内存占用</td>
<td>通常较高，每个实例都有其自己的库副本</td>
<td>通常较低，多个实例可以共享同一份库的内存</td>
</tr>
<tr>
<td>兼容性</td>
<td>可以更好地控制版本，因为库是嵌入的，不受外部库更新的影响</td>
<td>可能面临兼容性问题，如果外部库更新并且不向后兼容</td>
</tr>
</tbody></table>
<p>对于一个大型 C++项目来说，具体选择哪种链接方式可能看团队的权衡。总的来说，项目模块之间所有可能的依赖关系可以归类为下图的几种情形：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230703_c++_frame_pointer_stack_depend.svg" alt="C++ 项目的依赖关系"></p>
<p>图片由 <a target="_blank" rel="noopener" href="https://graphviz.org/">Graphviz</a> 渲染，图片源码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    // 设置图的布局方向为从左到右</span><br><span class="line">    // rankdir=LR;</span><br><span class="line">    </span><br><span class="line">    // 设置节点的形状和样式</span><br><span class="line">    node [shape=box, style=filled, color=lightblue];</span><br><span class="line">    </span><br><span class="line">    // 设置边的样式</span><br><span class="line">    edge [color=blue, fontcolor=black];</span><br><span class="line">    </span><br><span class="line">    // 定义节点和边</span><br><span class="line">    main -&gt; static_X;</span><br><span class="line">    main -&gt; static_A;</span><br><span class="line">    main -&gt; dynalic_Y;</span><br><span class="line">    main -&gt; dynalic_B;</span><br><span class="line">    main -&gt; utils_cpp;</span><br><span class="line">    </span><br><span class="line">    static_X -&gt; static_X1;</span><br><span class="line">    static_A -&gt; dynalic_A1;</span><br><span class="line">    dynalic_Y -&gt; dynalic_Y1;</span><br><span class="line">    dynalic_B -&gt; static_B1;</span><br><span class="line">    </span><br><span class="line">    // 设置排名，使相关的节点在同一级</span><br><span class="line">    {rank=same; static_X; static_A; dynalic_Y; dynalic_B;utils_cpp}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这其中最常见的依赖方式是<strong>静态链接库依赖其他静态链接库，动态链接库依赖其他动态链接库</strong>，后面的分析会基于这两种依赖关系。动态库 A 依赖静态库 B 是可行的，并且在某些情况下是有意义的。例如，如果静态库 B 包含一些不经常变化的代码，而动态库 A 包含一些经常更新的代码。不推荐在静态库 B 中依赖动态库 A，因为静态库通常被视为独立的代码块，不依赖于外部的动态链接。</p>
<h3 id="静态链接的堆栈"><a href="#静态链接的堆栈" class="headerlink" title="静态链接的堆栈"></a>静态链接的堆栈</h3><p>接下来我们分析在静态链接情况下，如果中间有第三方依赖没有带编译选项 <code>-fno-omit-frame-pointer</code>，会带来怎么样的影响。</p>
<p>假设有一个 main.cpp 依赖了 utils.cpp 和静态库 static_A，静态库 static_A 依赖了静态库 static_B，这里static_A 编译的时候没带上 -fno-omit-frame-pointer，但是其他都带了-fno-omit-frame-pointer，最终生成的二进制文件中，各静态库和 cpp 文件中的函数会有帧指针吗？这种情况下 eBPF 和 BCC 的工具能最大程度地解析出堆栈信息吗？</p>
<p>我们在本地创建一个完整的示例项目，包含上面的各种依赖关系，代码结构如下，完整代码在 <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/f4943c0a09fe8b333df64f2098eeed16">Gist</a> 上：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">FP_static_demo tree</span></span><br><span class="line">.</span><br><span class="line">├── main.cpp</span><br><span class="line">├── Makefile</span><br><span class="line">├── static_A</span><br><span class="line">│&nbsp;&nbsp; ├── static_A.cpp</span><br><span class="line">│&nbsp;&nbsp; └── static_A.h</span><br><span class="line">├── static_B</span><br><span class="line">│&nbsp;&nbsp; ├── static_B.cpp</span><br><span class="line">│&nbsp;&nbsp; └── static_B.h</span><br><span class="line">├── utils.cpp</span><br><span class="line">└── utils.h</span><br></pre></td></tr></tbody></table></figure>

<p>然后在编译生成的二进制文件中，发现 static_A 里面的函数没有帧指针，但是 static_B 和其他函数都有帧指针。运行二进制后，用 ebpf 的 profile 命令来分析 cpu 耗时堆栈，命令如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">profile -F 999 -U -f --pid $(pgrep main)  60 &gt; depend_main.stack</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./FlameGraph/flamegraph.pl depend_main.stack &gt; depend_main.svg</span></span><br></pre></td></tr></tbody></table></figure>

<p>在生成的 cpu 火焰图中，拿到的函数调用堆栈是错乱的，如下图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_depend_main.svg" alt="中间静态库丢失了帧指针"></p>
<p>正常如果没丢失帧指针的话，火焰图应该如下图所示，</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_depend_main_fp.svg" alt="整体没有丢失帧指针"></p>
<p>通过上面的实验看到，profile 工具分析性能时，依赖帧指针来重建调用堆栈。即使<strong>只丢失中间某个依赖库的帧指针</strong>，整体函数的调用堆栈就会错乱，并不是只丢失这中间的部分函数调用堆栈。</p>
<p>还是上面的场景，如果我们在依赖的<strong>最底层 static_B 编译的时候不保存堆栈信息</strong>，但是其他部分都保存，那么生成的二进制文件中，只有 static_B 中的函数没有帧指针。再次用 profile 分析 cpu 堆栈，发现虽然只是最后一层函数调用没有帧指针，但是 BCC tools 分析拿到的堆栈信息还是有问题，如下图，<code>printStaticA</code> 和 <code>function_entry</code> 被混到了同一层。这里多次运行，得到的堆栈信息图还可能不一样，不过都是错误的。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20230704_c++_frame_pointer_stack_depend_main_error.svg" alt="整体没有丢失帧指针"></p>
<h3 id="动态链接的堆栈"><a href="#动态链接的堆栈" class="headerlink" title="动态链接的堆栈"></a>动态链接的堆栈</h3><p>动态链接情况下，如果中间有第三方依赖没有带编译选项 <code>-fno-omit-frame-pointer</code>，理论上应该和静态链接一样，堆栈信息会错乱，不过还是写一个例子来验证下。还是上面的 main.cpp 和函数调用关系，把所有静态依赖改成动态依赖，重新改了下目录结构如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── dynamic_A</span><br><span class="line">│&nbsp;&nbsp; ├── dynamic_A.cpp</span><br><span class="line">│&nbsp;&nbsp; └── dynamic_A.h</span><br><span class="line">├── dynamic_B</span><br><span class="line">│&nbsp;&nbsp; ├── dynamic_B.cpp</span><br><span class="line">│&nbsp;&nbsp; └── dynamic_B.h</span><br><span class="line">├── main.cpp</span><br><span class="line">├── Makefile</span><br><span class="line">├── utils.cpp</span><br><span class="line">└── utils.h</span><br></pre></td></tr></tbody></table></figure>

<p>完整代码还是在 <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/e790432ec050646ec3c307b03c6a6784">Gist</a> 上。正常堆栈如下图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231017_c++_frame_pointer_dynamic_normal.svg" alt="动态链接下正常堆栈的火焰图"></p>
<p>修改 Makefile，只在编译 dynamic_A 的的时候忽略堆栈，生成的 CPU 火焰图如下：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231017_c++_frame_pointer_dynamic_lack_A.svg" alt="缺失动态库 A 的火焰图"></p>
<p>修改 Makefile，只在编译 dynamic_B 的的时候忽略堆栈，生成的 CPU 火焰图如下：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20231017_c++_frame_pointer_dynamic_lack_B.svg" alt="缺失动态库 B 的火焰图"></p>
<p>和我们前面猜想一致，一旦丢失了部分堆栈信息，分析出来的堆栈图就会有错乱。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://medium.com/coccoc-engineering-blog/things-you-should-know-to-begin-playing-with-linux-tracing-tools-part-i-x-225aae1aaf13">Practical Linux tracing ( Part 1/5) : symbols, debug symbols and stack unwinding</a><br><a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information/">How debuggers work: Part 3 - Debugging information</a><br><a target="_blank" rel="noopener" href="https://zhu45.org/posts/2017/Jul/30/understanding-how-function-call-works/">Understanding how function call works</a><br><a target="_blank" rel="noopener" href="https://kuafu1994.github.io/HackWithGDB/ASM.html">Hacking With GDB</a>  </p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：复杂 C++ 项目堆栈保留以及 eBPF 性能分析</p><p>本文链接为：https://selfboot.cn/2023/10/17/c++_frame_pointer/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="打赏"></a><div class="donate_txt"> ↑<br>内容不错，打赏你啦<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/ChatGPT/"><i class="fa fa-tag"></i>ChatGPT</a><a href="/tags/eBPF/"><i class="fa fa-tag"></i>eBPF</a></div><div class="post-nav"><a class="pre" href="/2023/10/19/C++_zip_memory_problem/">C++ 内存问题排查：创建 Zip 压缩包，解压后内容错乱</a><a class="next" href="/2023/10/12/lawer_traffic_accident/">车辆因交通事故导致贬值损失，可以获得赔偿吗？</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2023/10/17/c++_frame_pointer/';
    this.page.identifier = '2023/10/17/c++_frame_pointer/';
    this.page.title = '复杂 C++ 项目堆栈保留以及 eBPF 性能分析';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">工具介绍</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/">法律普及</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A4%BE%E4%BC%9A%E7%99%BE%E6%80%81/">社会百态</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%87%91%E8%9E%8D/">金融</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/">项目实践</a><span class="category-list-count">7</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 15px;">教程</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 15px;">总结</a> <a href="/tags/%E6%96%B9%E6%B3%95/" style="font-size: 15px;">方法</a> <a href="/tags/Google/" style="font-size: 15px;">Google</a> <a href="/tags/%E6%80%9D%E8%80%83/" style="font-size: 15px;">思考</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/DNS/" style="font-size: 15px;">DNS</a> <a href="/tags/%E8%A7%81%E9%97%BB/" style="font-size: 15px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15px;">Protocol</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Flask/" style="font-size: 15px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/%E6%B3%95%E5%BE%8B/" style="font-size: 15px;">法律</a> <a href="/tags/ChatGPT/" style="font-size: 15px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15px;">eBPF</a> <a href="/tags/%E5%A9%9A%E5%A7%BB%E5%AE%B6%E5%BA%AD/" style="font-size: 15px;">婚姻家庭</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/%E5%88%91%E4%BA%8B/" style="font-size: 15px;">刑事</a> <a href="/tags/%E5%8A%B3%E5%8A%A8%E7%BA%A0%E7%BA%B7/" style="font-size: 15px;">劳动纠纷</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 15px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15px;">Gemini</a></div></div><!-- Debug: page.path = 2023/10/17/c++_frame_pointer/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul><li><a href="/2023/12/10/google-gemini-bard-hands-on/" title="Google Gemini Pro 深度体验，离 GPT4 还有多大差距？">Google Gemini Pro 深度体验，离 GPT4 还有多大差距？</a></li><li><a href="/2023/12/06/bert_nlp_classify/" title="零基础用 Bert 训练并部署文本分类模型">零基础用 Bert 训练并部署文本分类模型</a></li><li><a href="/2023/11/15/how_to_crack_GPTs/" title="OpenAI 的 GPTs 提示词泄露攻击与防护实战">OpenAI 的 GPTs 提示词泄露攻击与防护实战</a></li><li><a href="/2023/11/11/chatgpt_no_such_file/" title="ChatGPT 协助分析诡异的 no such file 问题">ChatGPT 协助分析诡异的 no such file 问题</a></li><li><a href="/2023/11/08/memory_leak_ebpf/" title="深入理解基于 eBPF 的 C/C++ 内存泄漏分析">深入理解基于 eBPF 的 C/C++ 内存泄漏分析</a></li><li><a href="/2023/10/26/chatgpt_impact/" title="ChatGPT 渗透力分析：搜索热度、需求图谱与人群特征">ChatGPT 渗透力分析：搜索热度、需求图谱与人群特征</a></li><li><a href="/2023/10/19/C++_zip_memory_problem/" title="C++ 内存问题排查：创建 Zip 压缩包，解压后内容错乱">C++ 内存问题排查：创建 Zip 压缩包，解压后内容错乱</a></li><li><a href="/2023/10/17/c++_frame_pointer/" title="复杂 C++ 项目堆栈保留以及 eBPF 性能分析">复杂 C++ 项目堆栈保留以及 eBPF 性能分析</a></li><li><a href="/2023/10/11/chatgpt_recaptcha/" title="ChatGPT 多模态图像识别可以破解验证码？">ChatGPT 多模态图像识别可以破解验证码？</a></li><li><a href="/2023/10/08/chatgpt_see/" title="ChatGPT 图像理解能力深度体验">ChatGPT 图像理解能力深度体验</a></li></ul></div><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"> 文章目录</i></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">程序的堆栈信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DWARF-%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.</span> <span class="toc-text">DWARF 格式的堆栈信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Frame-Pointer-%E8%A7%A3%E6%9E%90%E5%A0%86%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">Frame Pointer 解析堆栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82-C-%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91"><span class="toc-number">2.</span> <span class="toc-text">复杂 C++ 项目编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">2.1.</span> <span class="toc-text">动态链接与静态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%A0%86%E6%A0%88"><span class="toc-number">2.2.</span> <span class="toc-text">静态链接的堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%A0%86%E6%A0%88"><span class="toc-number">2.3.</span> <span class="toc-text">动态链接的堆栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">参考文章</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量<span id="busuanzi_value_site_pv"></span>次，<span id="busuanzi_container_site_uv"></span>本站访客数<span id="busuanzi_value_site_uv"></span>人次</p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>