<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="深入解析 LevelDB 中 SSTable 文件的创建过程和内部结构设计。本文从问题驱动的角度，详细分析了 SSTable 如何通过分块存储、索引优化、过滤器等机制实现高效的读写性能。重点剖析 TableBuilder 类的实现细节，包括 DataBlock、IndexBlock、FilterBlock 的构建过程，以及索引键优化、压缩策略等工程技巧。通过源码分析展示了 LevelDB 如何解决大规模数据存储中的关键问题：快速定位数据块、减少无效磁盘 I/O、平衡存储空间与查询效率。文章结合具体代码示例和流程图，让读者深入理解 SSTable 文件格式设计的精妙之处，以及 LevelDB 作为高性能键值存储引擎的核心实现原理。"><title>LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程</h1><div class="post-meta">2025/06/27<span> | </span><span class="category"><a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2025/06/27/leveldb_source_table_build/" href="/2025/06/27/leveldb_source_table_build/#disqus_thread"></a><div class="post-content"><p>LevelDB 中，内存表中的键值对在到达一定大小后，会落到磁盘文件 SSTable 中。并且磁盘文件也是分层的，每层包含多个 SSTable 文件，在运行时，LevelDB 会在适当时机，合并、重整 SSTable 文件，将数据不断往下层沉淀。</p>
<p>这里 SSTable 有一套组织数据的格式，目的就是保证数据有序，并且能快速查找。那么  SSTable 内部是怎么存储这些键值对的，又是怎么提高数据的读、写性能的。以及整个 SSTable 文件的实现中有哪些优化点？</p>
<p>本文接下来我们会仔细分析 SSTable 文件的创建过程，一步步拆解来看看这里到底怎么实现的。在开始之前，我先给一个大的图，大家可以先留个印象。</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total.webp/webp" alt="SSTable 构建文件的步骤概览" srcset="https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total.webp/webp 3840w, https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total.webp/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total.webp/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total.webp/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3840" height="1281"></p>
<span id="more"></span>

<h2 id="SSTable-文件格式设计原因"><a href="#SSTable-文件格式设计原因" class="headerlink" title="SSTable 文件格式设计原因"></a>SSTable 文件格式设计原因</h2><p>在开始之前，我们要先搞明白一个关键问题，<strong><span style="color: red;">文件格式该如何设计，才能兼顾高效写入和快速读取？</span></strong> 下面我们从几个基本问题出发，来推测作者是如何设计这里的数据格式。</p>
<h3 id="问题一：键值对该如何存放？"><a href="#问题一：键值对该如何存放？" class="headerlink" title="问题一：键值对该如何存放？"></a>问题一：键值对该如何存放？</h3><p>首先，最核心的数据，也就是用户的键值对，得有个地方放。最简单的方法，把所有键值对按顺序放进 SSTable 这整个大文件。这样有什么问题呢？首先读的时候，如果要找一个 key，需要遍历整个大文件。然后写入过程中，每次添加一个键值对就要写磁盘的话，写 IO 压力会很大，吞吐上不去。</p>
<p>既然太大了不行，那就分块吧。计算机科学中的”分而治之”思想，在 LevelDB 中得到了很好的体现。我们把大文件切分成不同的数据块，按照数据块的粒度来存储键值对。每个块默认大约 4KB。当一个块写满了，就把它作为一个整体写入文件，然后再开始写下一个。这样整体写入的时候，就会减少很多磁盘 IO 了。</p>
<p>这里我再多说一点，分块存储不仅减少了写入磁盘的 IO 次数，通过配合</p>
<p>不过查找问题还没解决，还是要遍历所有的块来查找键值。</p>
<p>要是我们能快速定位到键值在哪个 DataBlock 里，那就只用遍历单个块就好了，效率会提升很多。</p>
<h3 id="问题二：如何快速定位到某个-Data-Block？"><a href="#问题二：如何快速定位到某个-Data-Block？" class="headerlink" title="问题二：如何快速定位到某个 Data Block？"></a>问题二：如何快速定位到某个 Data Block？</h3><p>为了解决这个问题，我们需要一个”目录”。计算机中也叫索引，于是 Index Block (索引块) 诞生了。这个块里存放了一系列的索引记录，每个记录都记录一个 Data Block 的信息，根据这个记录，我们能快速知道某个键所在的 DataBlock。</p>
<p>这样查找键值的时候，只需要在 Index Block 中二分查找，就能快速定位到键值可能在的 DataBlock。索引块只包含一些索引数据，所以整体大小会小很多，通常可以加载到内存中去，所以查找会快很多。</p>
<p>有了索引块之后，我们把扫描整个文件变成了”查索引 -&gt; 精准读取一小块”的操作，效率会大大提升。这里索引具体怎么设计我们先不管，后面再详细分析。</p>
<h3 id="问题三：如何避免无效的磁盘读取？"><a href="#问题三：如何避免无效的磁盘读取？" class="headerlink" title="问题三：如何避免无效的磁盘读取？"></a>问题三：如何避免无效的磁盘读取？</h3><p>通过索引块，我们其实能找到 key <strong>可能</strong> 在哪个块，但它不能百分百确定。为什么呢？因为索引块里记录的只是 key 的区间，并不能保证 key 一定在这个区间里，后面结合代码理解会更清晰。这就导致一个问题，当我们兴冲冲地把 Data Block 从磁盘读到内存后，却发现要找的 key 根本不存在，这不就白白浪费了一次宝贵的磁盘 I/O 吗？尤其是如果业务中，有大量读不存在 key 的场景，那么这种浪费很可观。</p>
<p>这种判断不存在的需求，计算机科学中早就有解法了，常见的就是布隆过滤器。布隆过滤器是位数组和哈希函数的组合，可以快速判断一个元素是否在集合中。本系列之前的文章<a href="https://selfboot.cn/2024/08/08/leveldb_source_bloom_filter/">LevelDB 源码阅读：布隆过滤器原理、实现、测试与可视化</a> 中，有详细介绍布隆过滤器的原理和实现。</p>
<p>LevelDB 中，用同样的解决思路，它支持设置一个可选的过滤块(Filter Block)，在读取 Data Block 之前，先通过 Filter Block 确认键是否存在。如果不存在的话，直接返回，如果可能在，再读取 Data Block 进行确认。通过这种方式，我们极大地减少了对不存在的 key 的无效查询。</p>
<p>看起来一切很美好了，不过等下，还有个问题，我们怎么知道 Index Block 和 Filter Block 在 SSTable 文件的哪个位置呢？</p>
<h3 id="问题四：如何定位索引和过滤块？"><a href="#问题四：如何定位索引和过滤块？" class="headerlink" title="问题四：如何定位索引和过滤块？"></a>问题四：如何定位索引和过滤块？</h3><p>现在我们有很多数据块、一个 Index Block、一个 Filter Block。问题又来了：当我们打开一个 SSTable 文件时，我们怎么知道 Index Block 和 Filter Block 在文件的哪个位置呢？</p>
<p>最朴素的思路就是可以<strong>把这些元信息放到文件的固定偏移位置</strong>。不过如果放到文件头的话，这些记录发生变化的话，整个文件的数据都要移动，这显然不行。</p>
<p>那放文件末尾呢？看起来可行，LevelDB 也是这么设计的。在文件尾部，放一个固定 48 字节的 Footer 区域，里面记录了 Index Block 在文件的偏移位置，以及另一个之前没提到过的 Meta-Index Block 的位置。</p>
<p>这里按理说 Footer 记录 Index Block 和 Filter Block 的位置就行了，为啥引入一个 Meta-Index Block 呢？作者在代码注释里有提到过，主要为了扩展性。Footer 的大小固定，不能增加更多信息了，那万一未来有更多种类的元数据块，比如统计块等，要在哪里存偏移。</p>
<p>所以作者增加了一个元数据的索引——Meta-Index Block。这个块的作用就是一张元数据目录，它的键是元数据的名字（如 “filter.leveldb.BuiltinBloomFilter2”），值是对应元数据块（如 Filter Block）的偏移位置。当前只有过滤块信息，后续可以任意增加元数据块。</p>
<p>这样整个查找过程就串起来了，先拿出尾部 48 字节的固定内容。从里面解析出 Index Block 和 Meta-Index Block 的偏移位置，然后从 Meta-Index Block 中拿到 Filter Block 的偏移位置，最后根据偏移位置读取 Filter Block 的内容。有了 Index Block 和 Filter Block，我们就能快速、高效地”按图索骥”去查找键值了。</p>
<h3 id="答案-SSTable-结构图"><a href="#答案-SSTable-结构图" class="headerlink" title="答案: SSTable 结构图"></a>答案: SSTable 结构图</h3><p>前面已经把 SSTable 中数据块组织方式分析完了，这里我画一个简单的 ASCII 图来描述 SSTable 中的各个块，方便大家理解：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+</span><br><span class="line">|   Data Block 0    |</span><br><span class="line">+-------------------+</span><br><span class="line">|   Data Block 1    |</span><br><span class="line">+-------------------+</span><br><span class="line">|       ...         |</span><br><span class="line">+-------------------+</span><br><span class="line">|   Data Block N    |</span><br><span class="line">+-------------------+</span><br><span class="line">|   Filter Block    |  (可选) &lt;-- 由 Meta-Index Block 索引</span><br><span class="line">+-------------------+</span><br><span class="line">| Meta Index Block  | &lt;-- 由 Footer 索引</span><br><span class="line">+-------------------+</span><br><span class="line">|   Index Block     | &lt;-- 由 Footer 索引</span><br><span class="line">+-------------------+</span><br><span class="line">|      Footer       | (文件末尾，固定大小)</span><br><span class="line">+-------------------+</span><br></pre></td></tr></tbody></table></figure>

<p>不过要怎么提供接口，怎么把键值对保存为上面格式，还是有不少工程细节的。这里顺便说下，<strong><span style="color: red;">LevelDB 代码中的分层抽象是做的真好，一层套一层，把复杂逻辑封装起来，方便理解和维护</span></strong>。比如每个块自己是怎么构建数据的，都封装了单独的实现，后面我会在其他文章里详细说明。</p>
<p>本篇文章，咱们重点关注 SSTable 文件构建的工程细节部分。这部分实现在<a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/table/table_builder.cc">table/table_builder.cc</a> 中，主要就是 TableBuilder 类。</p>
<p>该类只有一个私有成员变量，是一个 Rep* 指针，里面保存各种状态信息，比如当前的 DataBlock、IndexBlock 等。这里 Rep* 用到了 Pimpl 的设计模式，可以看本系列的 <a href="/2024/08/13/leveldb_source_unstand_c++/#Pimpl-%E7%B1%BB%E8%AE%BE%E8%AE%A1">LevelDB 源码阅读：理解其中的 C++ 高级技巧</a> 了解关于 Pimpl 的更多细节。</p>
<p>该类最重要的接口有 Add，这个函数会层层调用其他一些封装好的函数，来完成键值对的添加。接下来从这个接口入手，分析 TableBuilder 类的实现。</p>
<h2 id="Add-添加键值对"><a href="#Add-添加键值对" class="headerlink" title="Add 添加键值对"></a>Add 添加键值对</h2><p><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/table/table_builder.cc#L94">TableBuilder::Add</a> 方法是向 SSTable 文件中添加键值对的核心函数。添加键值对，需要更改上面提到的 DataBlock、IndexBlock、FilterBlock 等各个块。这里为了提高效率，有不少工程优化细节，为了更好理解，我把它主要分 4 部分，这里一个个来说吧。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>{</span><br><span class="line">  <span class="comment">// 1. 前置校验</span></span><br><span class="line">  <span class="comment">// 2. 处理索引块</span></span><br><span class="line">  <span class="comment">// 3. 处理过滤块</span></span><br><span class="line">  <span class="comment">// 4. 处理数据块</span></span><br><span class="line">  <span class="comment">// 5. 适当时机落盘</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="前置校验"><a href="#前置校验" class="headerlink" title="前置校验"></a>前置校验</h3><p>在 Add 方法中，首先会先读出来 rep_ 的数据，做一些前置校验，比如验证文件没有被关闭，保证键值对是有序的。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rep* r = rep_;</span><br><span class="line"><span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (r-&gt;num_entries &gt; <span class="number">0</span>) {</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;options.comparator-&gt;<span class="built_in">Compare</span>(key, <span class="built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>LevelDB 在代码中 <strong><span style="color: red;">加了不少校验逻辑，确保如果有问题，早崩溃早发现</span></strong>，这个理念对于底层库来说，还是很有必要的。Add 方法这里 assert 校验后面插入的键值对永远都是更大的，当然这点需要调用方来保证。为了实现校验逻辑，在每个 TableBuilder 的 Rep 中，都保存了 last_key，用来记录最后一个插入的 key。这个 key 在索引键优化的时候会用到，后面会详细说明。</p>
<h3 id="处理索引记录"><a href="#处理索引记录" class="headerlink" title="处理索引记录"></a>处理索引记录</h3><p>接着会在<strong>适当时机添加新的索引</strong>。我们知道索引记录用来快速查找一个 key 所在的 DataBlock 偏移位置，每一个完整的 DataBlock 对应一个索引记录。我们先看看这里<strong>添加索引记录的时机</strong>，当处理完一个 DataBlock 时，会将 pending_index_entry 设置为 true，等到下次新的 DataBlock 增加第一个 key 时，再更新上个完整的 DataBlock 对应的索引记录。</p>
<p>这部分的核心代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;pending_index_entry) {</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">  r-&gt;options.comparator-&gt;<span class="built_in">FindShortestSeparator</span>(&amp;r-&gt;last_key, key);</span><br><span class="line">  std::string handle_encoding;</span><br><span class="line">  r-&gt;pending_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">  r-&gt;index_block.<span class="built_in">Add</span>(r-&gt;last_key, <span class="built_in">Slice</span>(handle_encoding));</span><br><span class="line">  r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里之所以要等到新 DataBlock 增加第一个 key 的时候才更新索引块，就是 <strong><span style="color: red;">为了尽最大程度减少索引键的长度，从而减少索引块的大小</span></strong>，这也是 LevelDB 工程上的一个优化细节。</p>
<p>这里扩展讲下背景可能更好理解，SSTable 中每个索引记录都由一个分割键 separator_key 和一个指向数据块的 BlockHandle（偏移量+大小）组成。这个 separator_key 的作用就是划分不同 Datablock 的键空间，对于第 N 个数据块（Block N），它的索引键 separator_key_N 必须满足以下条件：</p>
<ul>
<li>separator_key_N &gt;= Block N 中的任何键</li>
<li>separator_key_N &lt; Block N+1 中的任何键</li>
</ul>
<p>这样在查找一个目标键的时候，如果在索引块中找到第一个 separator_key_N &gt; target_key 的条目，那么 target_key 如果存在，就必定在前一个数据块（Block N-1）中。</p>
<p>直观上讲，索引最简单的实现是直接用 Block N 的最后一个键（last_key_N）作为 separator_key_N。但问题是，last_key_N 本身可能非常长。这就导致索引项会很长，进而整个索引块变得很大。<strong>索引块通常需要加载到内存中，索引块越小，内存占用越少，缓存效率越高，查找速度也越快</strong>。</p>
<p>其实我们细想下，我们并不需要一个真实存在的键作为分割索引 key，只需要一个能把前后两个块分开的”隔离键”即可。这个键只需要满足：last_key_N &lt;= separator_key &lt; first_key_N+1。LevelDB 就是这样做的，这里通过调用 options.comparator-&gt;FindShortestSeparator，<strong>找到前一个块最后的键，和下一个块第一个键之间最短分割字符串</strong>。这里 FindShortestSeparator 的默认实现在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/util/comparator.cc#L31C8-L31C29">util/comparator.cc</a>中，本文不再列出来了。</p>
<p>为了更清楚地理解这个优化过程，下面用一个具体的例子来演示：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey.webp/webp" alt="SSTable DataBlock 索引分割键优化" srcset="https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey.webp/webp 3840w, https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey.webp/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey.webp/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey.webp/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="3840" height="1734"></p>
<p>最后再聊下这里每条索引记录的 value，它是<strong>该块在文件内的偏移和 size</strong>，这是通过 pending_handle 来记录的。当通过 WriteRawBlock 将 DataBlock 写文件的时候，会更新 pending_handle 的偏移和大小。然后写索引的时候，用 EncodeTo 将偏移和 size 编码到字符串中，和前面的索引 key 一起插入到 IndexBlock 中。</p>
<h3 id="处理过滤记录"><a href="#处理过滤记录" class="headerlink" title="处理过滤记录"></a>处理过滤记录</h3><p>接着处理 FilterBlock 过滤索引块，前面的索引块只是能找到键<strong>应该在的块的位置</strong>，还需要去读出块的内容才知道键到底存不存在。为了快速判断键值在不在，LevelDB 支持了过滤索引块，<strong>可以快速判断某个 key 是否存在于当前 SSTable 中</strong>。如果设置用到过滤索引块，则在添加 key 的时候，同步添加索引，其核心代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) {</span><br><span class="line">  r-&gt;filter_block-&gt;<span class="built_in">AddKey</span>(key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里添加 key 之后，只是在内存中存储索引，要等到最后 TableBuild 写完所有的 Block 之后，才会将 FilterBlock 写入文件。<strong>FilterBlock 本身是可选的</strong>，通过 options.filter_policy 来设置。在初始化 TableBuilder::Rep 的时候，会根据 options.filter_policy 来初始化 FilterBlockBuilder 指针，如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Rep</span>(<span class="type">const</span> Options&amp; opt, WritableFile* f)</span><br><span class="line">    : <span class="built_in">options</span>(opt),</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="built_in">filter_block</span>(opt.filter_policy == <span class="literal">nullptr</span></span><br><span class="line">                       ? <span class="literal">nullptr</span></span><br><span class="line">                       : <span class="keyword">new</span> <span class="built_in">FilterBlockBuilder</span>(opt.filter_policy)),</span><br><span class="line">      <span class="built_in">pending_index_entry</span>(<span class="literal">false</span>) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里值得注意的是 filter_block 之所以是指针，主要是因为除了用默认的布隆过滤器，还可以<strong>用多态机制使用自己的过滤器</strong>。这里用 new 在堆上创建的对象，为了<strong>防止内存泄露</strong>，在 TableBuilder 析构的时候，先释放掉 filter_block，再接着释放 rep_。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TableBuilder::~<span class="built_in">TableBuilder</span>() {</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;closed);  <span class="comment">// Catch errors where caller forgot to call Finish()</span></span><br><span class="line">  <span class="keyword">delete</span> rep_-&gt;filter_block;</span><br><span class="line">  <span class="keyword">delete</span> rep_;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>之所以需要释放 rep_，是因为它是在 TableBuilder 构造的时候，在堆上创建的，如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TableBuilder::<span class="built_in">TableBuilder</span>(<span class="type">const</span> Options&amp; options, WritableFile* file)</span><br><span class="line">    : <span class="built_in">rep_</span>(<span class="keyword">new</span> <span class="built_in">Rep</span>(options, file)) {</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;filter_block != <span class="literal">nullptr</span>) {</span><br><span class="line">    rep_-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>关于 LevelDB 默认的布隆过滤器实现，可以参考<a href="/leveldb_source_filterblock">LevelDB 源码阅读：布隆过滤器的实现</a>。索引块的构建，后面我单独写一篇来详解，这里我们也不深究细节部分。</p>
<h3 id="处理数据块"><a href="#处理数据块" class="headerlink" title="处理数据块"></a>处理数据块</h3><p>接着需要将键值对添加到 DataBlock 中。DataBlock 是 SSTable 文件中存储实际键值对的地方，代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">r-&gt;num_entries++;</span><br><span class="line">r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> estimated_block_size = r-&gt;data_block.<span class="built_in">CurrentSizeEstimate</span>();</span><br><span class="line"><span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) {</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里调用 BlockBuilder 中的 Add 方法，将键值对添加到 DataBlock 中，关于 BlockBuilder 的实现，后面单独文章来描述。哈哈，<strong>这里 LevelDB 分层抽象是做的真好，搞的我们的文章也只能分层了</strong>。每次添加键值对后，都会检查当前 DataBlock 的大小是否超过了 block_size，如果超过了，则调用 Flush 方法将 DataBlock 写入磁盘文件。这里 block_size 是在 options 中设置的，默认是 4KB。这个是键值压缩前的大小，如果开启了压缩，实际写入文件的大小会小于 block_size。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approximate size of user data packed per block.  Note that the</span></span><br><span class="line"><span class="comment">// block size specified here corresponds to uncompressed data.  The</span></span><br><span class="line"><span class="comment">// actual size of the unit read from disk may be smaller if</span></span><br><span class="line"><span class="comment">// compression is enabled.  This parameter can be changed dynamically.</span></span><br><span class="line"><span class="type">size_t</span> block_size = <span class="number">4</span> * <span class="number">1024</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>这里 Flush 怎么写磁盘呢，我们接着往下看。</p>
<h3 id="Flush-写数据块"><a href="#Flush-写数据块" class="headerlink" title="Flush 写数据块"></a>Flush 写数据块</h3><p>在前面的 Add 方法中，如果一个块的大小凑够 4KB，就会调用 Flush 方法写磁盘文件。Flush 的实现如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>{</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;pending_index_entry);</span><br><span class="line">  <span class="built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) {</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) {</span><br><span class="line">    r-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(r-&gt;offset);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>开始部分也就是一些前置校验，注意 Flush 只是用来刷 DataBlock 部分，如果 data_block 为空，就直接返回。接着调用 WriteBlock 方法(后面详解)将 DataBlock 写入文件，然后<strong>更新 pending_index_entry 为 true，表示下次添加 key 时，需要更新索引块</strong>。</p>
<p>最后调用 file-&gt;Flush() 将目前内存中的数据调用系统 write 写磁盘，注意这里不保证数据已被同步到物理磁盘。数据可能还在系统缓存中，如果操作系统宕机，那有可能丢失没写入成功的数据。这里写文件刷磁盘，可以参考本系列<a href="/2024/08/02/leveldb_source_env_posixfile/">LevelDB 源码阅读：Posix 文件操作接口实现细节</a>中关于文件操作的更多细节。如果有 filter_block，还需要调用 StartBlock 方法，这个方法也比较有意思，等后面我们专门来写 filter block 的时候再详细说明。</p>
<h2 id="WriteBlock-写文件"><a href="#WriteBlock-写文件" class="headerlink" title="WriteBlock 写文件"></a>WriteBlock 写文件</h2><p>上面提到 Flush 中会调用 WriteBlock 方法将 DataBlock 写入文件，该方法在下面要提到的 Finish 中也会被调用，用来在最后写索引块，过滤块等内容。WriteBlock 的实现比较简单，主要用来处理压缩逻辑，然后调用真正的写文件函数 WriteRawBlock 来把块内容写入文件。</p>
<p>压缩并不是必须的，如果调用 leveldb 时设置了需要压缩，并且链接了压缩库，就会选择对应的压缩算法对 Block 进行压缩。LevelDB 这里也做了一点<strong>压缩性能和效果的平衡，如果压缩比 (compression_ratio) 小于等于 0.85，就会将压缩后的数据写入文件，否则直接写入原始数据</strong>。真正写文件部分，调用 WriteRawBlock 方法，主要代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="type">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 CompressionType type, BlockHandle* handle)</span> </span>{</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  handle-&gt;<span class="built_in">set_offset</span>(r-&gt;offset);</span><br><span class="line">  handle-&gt;<span class="built_in">set_size</span>(block_contents.<span class="built_in">size</span>());</span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(block_contents);</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>()) {</span><br><span class="line">    <span class="type">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;</span><br><span class="line">    <span class="type">uint32_t</span> crc = crc32c::<span class="built_in">Value</span>(block_contents.<span class="built_in">data</span>(), block_contents.<span class="built_in">size</span>());</span><br><span class="line">    crc = crc32c::<span class="built_in">Extend</span>(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></span><br><span class="line">    <span class="built_in">EncodeFixed32</span>(trailer + <span class="number">1</span>, crc32c::<span class="built_in">Mask</span>(crc));</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>()) {</span><br><span class="line">      r-&gt;offset += block_contents.<span class="built_in">size</span>() + kBlockTrailerSize;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里在每个块的尾部放了 5 个字节的 trailer 部分，来对数据准确性进行校验。第一个字节是压缩类型，目前支持的压缩算法有 snappy 和 zstd。后面 4 字节是 crc32 校验和，这里用 crc32c::Value 计算数据块的校验和，然后把压缩类型一起计算进去校验和。这里 crc32 部分，可以参考本系列 <a href="/2024/08/29/leveldb_source_utils/">LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码</a> 了解更多细节。</p>
<h2 id="Finish-主动触发落盘"><a href="#Finish-主动触发落盘" class="headerlink" title="Finish 主动触发落盘"></a>Finish 主动触发落盘</h2><p>上面的所有操作，主要用来将键值对不断添加到数据块中，这个过程如果达到 DataBlock 的大小限制，会触发 DataBlock 的落盘。但整个 SSTable 文件还有索引块，过滤块等，<strong>需要主动触发落盘</strong>。那在什么时机触发，又是怎么落盘呢？</p>
<p>LevelDB 中产生 SSTable 文件的时机有很多，这里以保存 immetable 时候触发的落盘时机为例。将 immemtable 保存为 SSTable 文件时，过程如下：首先迭代 immemtable 中的键值对，然后调用上面的 Add 方法来添加。Add 中会更新相关 block 的内容，每当 DataBlock 超过 block_size 时，会调用 Flush 方法将 DataBlock 写入文件。</p>
<p>等所有键值对写完，会主动调用 Finish 方法，来进行一些<strong>收尾工作</strong>，比如将最后一个 Datablock 的数据写入文件，写入 IndexBlock，FilterBlock 等。</p>
<p>Finish 的实现如下，开始之前先用 Flush 把剩余的 DataBlock 部分刷到磁盘文件中，接着会处理其他块，并且在文件尾部添加一个固定大小的 footer 部分，用来记录索引信息。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>{</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">  r-&gt;closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write filter block</span></span><br><span class="line">  <span class="comment">// Write metaindex block</span></span><br><span class="line">  <span class="comment">// Write index block</span></span><br><span class="line">  <span class="comment">// Write footer</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里构建各个块也比较有意思，都是用一个 builder 来处理内容，同时用一个 handler 来记录块的偏移和大小。我们分别来看下。</p>
<h3 id="BlockBuilder-构建块"><a href="#BlockBuilder-构建块" class="headerlink" title="BlockBuilder 构建块"></a>BlockBuilder 构建块</h3><p>先思考一个问题，<strong>这里有这么多类型的块，每个块都要一个自己的 Builder 来拼装数据吗</strong>？</p>
<p>这里要从每个块的数据结构来看，Data/Index/MetaIndex Block 这三种块都具有以下共同特征：</p>
<ul>
<li>键值对结构：都存储键值对形式的数据，虽然这里每个块里面的键值含义不一样，但都是键值对形式;</li>
<li>有序性要求：键必须按顺序排列，因为后面查找的时候，需要支持二分查找或顺序扫描;</li>
</ul>
<p>所以这 3 类块的构建逻辑是类似的，LevelDB 中共用同一个 BlockBuilder 来处理。这里实现在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/table/block_builder.h">table/block_builder.h</a> 中，也有不少优化细节。比如前缀压缩优化，对于相似的键只存储差异部分，节省空间。重启点机制，每隔几个条目设置一个重启点，支持二分查找。后面我会专门用一篇文章来详细说明。封装后用起来比较简单，以 MetaIndex Block 为例，用 Add 添加键值，然后 WriteBlock 落磁盘就好。代码如下:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) {</span><br><span class="line">      <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></span><br><span class="line">      std::string key = <span class="string">"filter."</span>;</span><br><span class="line">      key.<span class="built_in">append</span>(r-&gt;options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">      std::string handle_encoding;</span><br><span class="line">      filter_block_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">      meta_index_block.<span class="built_in">Add</span>(key, handle_encoding);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而 filter block 的数据结构和其他的都不一样，它存储的是布隆过滤器的二进制数据，按文件偏移分组，每 2KB 文件范围对应一个过滤器。所以 filter block 的构建逻辑和其他的都不一样，需要单独处理。这里的实现在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/table/filter_block.cc">table/filter_block.cc</a> 中，后面我单独再展开分析。这里使用倒是很简单，如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write filter block</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) {</span><br><span class="line">  <span class="built_in">WriteRawBlock</span>(r-&gt;filter_block-&gt;<span class="built_in">Finish</span>(), kNoCompression,</span><br><span class="line">                &amp;filter_block_handle);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里 Finish 方法会返回 filter block 的二进制数据，然后调用 WriteRawBlock 方法将数据写入文件。</p>
<h3 id="BlockHandle-记录偏移和大小"><a href="#BlockHandle-记录偏移和大小" class="headerlink" title="BlockHandle 记录偏移和大小"></a>BlockHandle 记录偏移和大小</h3><p>上面用两个 builder 来构建块，但是用同一个 handler 类来记录块的偏移和大小。代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这里 BlockHandle 的实现在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/table/format.h#L23">table/format.h</a> 中，主要告诉系统在文件的第 X 字节位置，有一个大小为 Y 字节的块，仅此而已。不过配合不同块的 handle 信息，就能方便存储不同块的偏移和大小。</p>
<p>至此，我们用两个 builder 来构建各种索引块，同时用一个 handler 来辅助记录块的偏移和大小。就完成了整个块的构建。</p>
<h2 id="创建-SSTable-文件完整步骤"><a href="#创建-SSTable-文件完整步骤" class="headerlink" title="创建 SSTable 文件完整步骤"></a>创建 SSTable 文件完整步骤</h2><p>最后我们可以来看看上层调用方，是如何用 TableBuilder 来构造 SSTable 文件的。</p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/builder.cc#L17">db/builder.cc</a> 中封装了一个函数 BuildTable 来创建 SSTable 文件，它就是调用 TableBuilder 类的接口来实现的。省略其他无关代码，核心代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BuildTable</span><span class="params">(<span class="type">const</span> std::string&amp; dbname, Env* env, <span class="type">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta)</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    TableBuilder* builder = <span class="keyword">new</span> <span class="built_in">TableBuilder</span>(options, file);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Slice key;</span><br><span class="line">    <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) {</span><br><span class="line">      key = iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      builder-&gt;<span class="built_in">Add</span>(key, iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Finish and check for builder errors</span></span><br><span class="line">    s = builder-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里用迭代器 iter 来遍历 immemtable 中的键值对，然后调用 TableBuilder 的 Add 方法将键值对添加到 SSTable 文件中。Memtable 的大小限制默认是 4MB(write_buffer_size = <code>4*1024*1024</code>)，在用 TableBuilder 添加键值对时，会根据 block_size(4*1024) 来划分数据块。每当凑够一个 DataBlock，就会拼装相应 block 的数据，然后用 flush 追增内容到磁盘 SSTable 文件中。最后调用 TableBuilder 的 Finish 方法写入其他 Block，完成整个SSTable 文件的写入。</p>
<p>除了这里 BuildTable 将 immemtable 中的数据写入 level0 的 SSTable 文件外，还有一个场景是在 Compact 过程中，将多个 SSTable 文件合并成一个 SSTable 文件。这个过程在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L897">db/db_impl.cc</a> 中的 DoCompactionWork 函数中实现，整体流程稍微复杂，调用比较深入，等后面我们讲 Compact 的时候再详细分析。</p>
<p>不过这里只讲一个点，在 Compact 过程中，会在某些失败场景调用 TableBuilder 的 Abandon 方法，用来放弃当前的 TableBuilder 写入文件过程。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compact-&gt;builder-&gt;<span class="built_in">Abandon</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>Abandon 主要就是把 TableBuilder 的 Rep 中的 closed 设置为 true，调用方之后就会丢掉这个 TableBuilder 实例，不会用它执行任何写入操作了(写入中一堆断言来检查这个状态)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到开头我们提出的问题，文件格式该如何设计，才能兼顾高效写入和快速读取？通过深入分析 LevelDB 的 SSTable 文件创建过程，我们可以看到作者是如何一步步解决这个问题的。首先SSTable 数据格式设计有几个重要的设计思想：</p>
<ol>
<li><strong>分块存储</strong>：将大文件切分成 4KB 的 DataBlock，既便于管理，又能减少无效的磁盘 I/O，还方便缓存热点数据。</li>
<li><strong>索引加速</strong>：通过 IndexBlock 将”全文扫描”变成”查目录 + 精准读取”，减少磁盘 I/O 次数。</li>
<li><strong>过滤优化</strong>：用 FilterBlock 在源头减少不必要的磁盘读取，提高读取性能。</li>
<li><strong>元信息集中管理</strong>：Footer + Meta-IndexBlock 的设计保证了扩展性，方便后续添加更多元数据块。</li>
</ol>
<p>在 TableBuilder 的实现中，我们也看到了不少值得学习的工程细节，比如：</p>
<ul>
<li><strong>索引键优化</strong>：延迟到下一个块开始时才更新索引，通过 FindShortestSeparator 算法生成最短分割键，大幅减少索引块大小。这个优化看似微小，但在大规模数据下效果显著。</li>
<li><strong>错误处理</strong>：代码中大量的 assert 断言体现了”早崩溃早发现”的理念，对于底层存储系统来说至关重要。</li>
<li><strong>分层抽象</strong>：TableBuilder → BlockBuilder → FilterBlockBuilder 的分层设计，让复杂的文件格式构建变得井井有条。每一层都有明确的职责边界。</li>
<li><strong>性能平衡</strong>：压缩策略中的 0.85 压缩比阈值，体现了对性能与效果的权衡考量。</li>
</ul>
<p>其实 SSTable 的设计回答了存储系统中的几个根本问题。用顺序写入，来保证写入吞吐，用索引结构来保证读取性能。用分块和按需加载以及缓存，在有限内存下处理海量数据。同时用压缩和过滤器来平衡存储空间与查询效率，用元信息分层来保证系统的可扩展性。这些都是计算机软件系统中沉淀多年的经典设计，值得我们学习。</p>
<p>理解了 SSTable 的创建过程后，你可能会产生一些新的疑问：DataBlock 内部是如何组织数据的？读取 SSTable 时的流程是怎样的？多个 SSTable 文件如何协同工作？</p>
<p>这些问题的答案，构成了 LevelDB 这个精巧存储引擎的完整图景。我会在后面的文章中继续深入分析，敬请期待。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程</p><p>本文链接为：https://selfboot.cn/2025/06/27/leveldb_source_table_build/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2025/06/27/leveldb_source_table_build/';
    this.page.identifier = '2025/06/27/leveldb_source_table_build/';
    this.page.title = 'LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (23)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (32)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2025/06/27/leveldb_source_table_build/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/06/27/leveldb_source_table_build/" title="LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程">LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程</a></li><li><a href="/2025/06/13/leveldb_source_LRU_cache/" title="LevelDB 源码阅读：LRU Cache 高性能缓存实现细节">LevelDB 源码阅读：LRU Cache 高性能缓存实现细节</a></li><li><a href="/2025/06/11/leveldb_source_memtable/" title="LevelDB 源码阅读：MemTable 内存表的实现细节">LevelDB 源码阅读：MemTable 内存表的实现细节</a></li><li><a href="/2025/06/10/leveldb_mvcc_intro/" title="LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)">LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)</a></li><li><a href="/2025/05/23/mcp_user_report/" title="使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?">使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?</a></li><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SSTable-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.</span> <span class="toc-text">SSTable 文件格式设计原因</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A%E9%94%AE%E5%80%BC%E5%AF%B9%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%98%E6%94%BE%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">问题一：键值对该如何存放？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%88%B0%E6%9F%90%E4%B8%AA-Data-Block%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">问题二：如何快速定位到某个 Data Block？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89%EF%BC%9A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%97%A0%E6%95%88%E7%9A%84%E7%A3%81%E7%9B%98%E8%AF%BB%E5%8F%96%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">问题三：如何避免无效的磁盘读取？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9B%9B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BF%87%E6%BB%A4%E5%9D%97%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">问题四：如何定位索引和过滤块？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88-SSTable-%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">1.5.</span> <span class="toc-text">答案: SSTable 结构图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Add-%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">2.</span> <span class="toc-text">Add 添加键值对</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.</span> <span class="toc-text">前置校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B4%A2%E5%BC%95%E8%AE%B0%E5%BD%95"><span class="toc-number">2.2.</span> <span class="toc-text">处理索引记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BF%87%E6%BB%A4%E8%AE%B0%E5%BD%95"><span class="toc-number">2.3.</span> <span class="toc-text">处理过滤记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="toc-number">2.4.</span> <span class="toc-text">处理数据块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flush-%E5%86%99%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="toc-number">2.5.</span> <span class="toc-text">Flush 写数据块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WriteBlock-%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">WriteBlock 写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finish-%E4%B8%BB%E5%8A%A8%E8%A7%A6%E5%8F%91%E8%90%BD%E7%9B%98"><span class="toc-number">4.</span> <span class="toc-text">Finish 主动触发落盘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockBuilder-%E6%9E%84%E5%BB%BA%E5%9D%97"><span class="toc-number">4.1.</span> <span class="toc-text">BlockBuilder 构建块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockHandle-%E8%AE%B0%E5%BD%95%E5%81%8F%E7%A7%BB%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.2.</span> <span class="toc-text">BlockHandle 记录偏移和大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-SSTable-%E6%96%87%E4%BB%B6%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.</span> <span class="toc-text">创建 SSTable 文件完整步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p><p>友情链接：<a rel="dofollow" target="_blank" href="https://puzzles-game.com/">益智游戏</a></p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>