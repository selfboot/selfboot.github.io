<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本文深入分析了 C++ 开发中常见的 5 种导致进程 Crash 的典型案例：未捕获的异常处理、数组越界访问、迭代器失效、并发数据竞争以及栈溢出问题。通过真实的代码示例，详细讲解了每种问题的成因、排查方法和解决方案。文章还介绍了如何使用 GDB、Valgrind 等工具来分析 Coredump 问题，是一篇实用的 C++ 参考指南。"><title>5 个导致 C++ 进程 Crash 的真实业务案例</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/atom.xml"><i class="fa fa-rss"></i><span> 订阅</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">5 个导致 C++ 进程 Crash 的真实业务案例</h1><div class="post-meta">2025/01/10<span> | </span><span class="category"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2025/01/10/c++_crash_cases/" href="/2025/01/10/c++_crash_cases/#disqus_thread"></a><div class="post-content"><p>只要你写过比较复杂的 C++ 项目，应该都或多或少遇见过进程 Coredump 的问题。Coredump 是程序运行过程中发生严重错误时，操作系统将程序当前的内存状态记录下来的一种机制。</p>
<p>C++ 中导致进程 Coredump 的原因有很多，比如：</p>
<ol>
<li><strong>访问非法内存地址</strong>：包括空指针解引用、访问已释放的内存、数组越界访问等；</li>
<li><strong>栈溢出</strong>：无限递归、大数组分配在栈上；</li>
<li><strong>段错误</strong>（Segmentation Fault）：试图写入只读内存、访问未映射的内存区域；</li>
<li><strong>异常未捕获</strong>：未处理的异常导致程序终止；</li>
</ol>
<p>遇到 Coredump 问题时，一般需要打开 core 文件，然后根据 core 文件来进行问题分析和调试。分析 core 文件有时候还是比较难的，需要对 C++ 的内存模型、异常处理机制、系统调用等有深入的理解。</p>
<p>本文不会过多介绍分析 core 文件的方法，而是通过几个真实项目中的案例，来让大家在写代码时候，能够有意识地避免这些错误。</p>
<span id="more"></span>

<h2 id="抛异常没有捕获"><a href="#抛异常没有捕获" class="headerlink" title="抛异常没有捕获"></a>抛异常没有捕获</h2><p>业务代码中最常见的导致进程 crash 的原因，就是不小心抛出异常却没有捕获。比如一个字符串转整数的函数中，用了 <a target="_blank" rel="noopener" href="https://cplusplus.com/reference/string/stoi/">std::stoi</a> 来转换。但是这里万一字符串没法转成数字，就会抛出 <code>std::invalid_argument</code> 异常。如果框架层或者调用方没有捕获异常，就会导致进程 crash 掉。</p>
<p>就拿标准库来说，可能抛出异常的函数还是挺多的，常见的有：</p>
<ul>
<li>std::vector::at()：如果访问越界，会抛出 <code>std::out_of_range</code> 异常。</li>
<li>std::vector::push_back()：如果内存分配失败，会抛出 <code>std::bad_alloc</code> 异常。</li>
<li>std::map::at()：如果访问不存在的 key，会抛出 <code>std::out_of_range</code> 异常。</li>
</ul>
<p>在使用这些可能抛出异常的标准库函数的时候，一定要妥善处理好异常。<strong>另外如果是自定义类，不建议抛出异常，可以用错误码来处理。当然对使用异常还是错误码这里一直有争论，可以按照自己比较熟悉或者项目中的惯例来处理就好</strong>。如果是明确不抛出异常的函数，可以加上 noexcept 来告诉编译器和使用方。</p>
<p>这里再补充说下，有时候有些函数调用不会抛异常，但是会导致<a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">未定义行为</a>，也是可能导致进程 crash 的。比如 <a target="_blank" rel="noopener" href="https://cplusplus.com/reference/cstdlib/atoi/?kw=atoi">atoi 函数</a>，如果字符串没法转成数字，这里会导致未定义行为。未定义行为在某些场景下，会导致进程 crash。</p>
<p>平常在使用一些基础函数的时候，如果对该函数不清楚的话，可以查看 <a target="_blank" rel="noopener" href="https://cplusplus.com/">cplusplus</a> 的文档，来确定该函数是否会在某些场景抛异常，是否会导致未定义行为。比如对于 vector ：</p>
<blockquote>
<p>std::vector::front()<br> Calling this function on an empty container causes undefined behavior.</p>
<p>std::vector::push_back()<br> If a reallocation happens, the storage is allocated using the container’s allocator, which may throw exceptions on failure (for the default allocator, bad_alloc is thrown if the allocation request does not succeed).</p>
</blockquote>
<h2 id="数组下标访问越界"><a href="#数组下标访问越界" class="headerlink" title="数组下标访问越界"></a>数组下标访问越界</h2><p>除了抛出异常，还有一类问题也比较常见，那就是数组下标访问越界。我们都知道在 C++ 中<strong>访问数组的时候如果下标越界，会导致访问非法内存地址，可能导致进程 crash</strong>。你可能会觉得，怎么会数组访问越界？我遍历的时候限制长度就行了呀。</p>
<p>别急，看下面来自业务中的真实例子。当然为了演示，这里简化了很多实际业务逻辑，只保留核心部分。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; src = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; src.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="comment">// 可能是后面加的业务过滤逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(src[i] == <span class="number">8</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        dest.<span class="built_in">push_back</span>(src[i] * <span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 继续根据 src 的内容进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; src.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="comment">// 其他对 src 的处理</span></span><br><span class="line">        <span class="comment">// 这种用法虽然有问题，但这里内存在堆上，可能还没被回收，也不会 core</span></span><br><span class="line">        <span class="comment">// dest[i] -= 5; </span></span><br><span class="line">        dest.<span class="built_in">at</span>(i) -= <span class="number">5</span>; <span class="comment">// 这种用法会 core</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里刚开始实现的时候，第一次遍历 src 用来初始化 dest。然后中间有一些其他代码，接着后面又遍历 src，根据 src 的内容对初始化后的 dest 再进行某些处理。</p>
<p>刚开始实现的时候，这样没什么问题，然后某天可能加了个需求，需要过滤掉 src 中某些数据，于是就加了 if 判断来跳过某些内容。改动的人，可能没注意到后面对 src 和 dest 的遍历，没意识到过滤会导致 dest 的长度已经变了。</p>
<p>这个场景有时候比较难触发 coredump，可能只有极少场景才会有过滤导致长度不一样。并且这里就算第二轮访问了越界下标，用 [] 访问的话，也可能不会 core。上面示例代码为了必现 core，故意改成用 at 访问，这样下标越界就会抛异常。</p>
<h2 id="访问失效的迭代器"><a href="#访问失效的迭代器" class="headerlink" title="访问失效的迭代器"></a>访问失效的迭代器</h2><p>除了下标访问越界，还有一类问题比较常见，那就是访问失效的迭代器。迭代器是一种设计模式，它提供了一种方法来访问容器对象中的元素，而无需暴露该对象的内部表示。在 C++ 中，迭代器是一个非常重要的概念，它是容器和算法之间的桥梁。</p>
<p>C++ 标准库中，很多容器都提供了迭代器，比如 vector、list、map 等。<strong>访问这些容器的迭代器时候，如果迭代器已经失效，就会导致未定义行为，可能导致进程 coredump</strong>。</p>
<p>导致迭代器失效的原因有很多，比如 vector 扩容，导致之前的迭代器失效。最常见的一个例子就是删除 vector 中偶数位置的元素，很多新手可能像下面这样写：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">        numbers.<span class="built_in">erase</span>(it);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里当调用 <code>erase</code> 删除元素时，会<strong>导致删除位置和它之后的所有迭代器都失效</strong>。所以循环中接着访问 <code>it</code> 就会导致未定义行为。正确做法是使用 erase 的返回值，来更新迭代器，或者使用 remove_if 和 erase 来删除元素。</p>
<p>当然这个示例比较简单，在实际业务中，我们遇见过一些比较隐蔽的迭代器失效问题。背景是这样，我们有个批处理任务，会用协程池来处理一批 IO 密集的任务，并且把结果写回到一个 vector 中。为了示例，这里代码简化如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟异步任务处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncProcess</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>{</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    value += <span class="number">1</span>;  <span class="comment">// 可能访问已经失效的引用</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        values.<span class="built_in">push_back</span>(i);</span><br><span class="line">        results.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span>&amp; result = results.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;result]() {</span></span></span><br><span class="line"><span class="params"><span class="function">            AsyncProcess(result);  <span class="comment">// 在异步任务中使用引用</span></span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 等待一段时间让任务执行</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里我们保存了 <code>results.back()</code> 的引用，并在异步任务中使用它。在异步任务执行期间，<code>results</code> vector 继续添加新元素。当 vector 需要扩容时，原有的内存会被释放，新的内存会被分配。此时异步任务中持有的引用就变成了悬空引用，访问它会导致未定义行为。</p>
<p>正确的做法应该是使用 <code>reserve</code> 预分配空间，避免扩容。或者保存索引，使用索引值而不是引用。</p>
<h2 id="并发导致的数据竞争"><a href="#并发导致的数据竞争" class="headerlink" title="并发导致的数据竞争"></a>并发导致的数据竞争</h2><p>还有一类 crash 问题，是因为并发导致的数据竞争。经常有这么一个场景，就是服务中有一个后台线程，会从某个配置中心拉取配置更新到本地。然后有多个业务线程，会并发读取这里的配置。</p>
<p>因为是经典的读多写少场景，所以一般会用读写锁来实现。多个读线程可以同时持有读锁，写线程必须独占，写的过程需要保证无其他读或写操作。写操作期间，新的读操作需要等待。一个可能的执行序列如下：</p>
<figure class="highlight nestedtext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Time ──────────────────────────────────────────────────────▶</span></span><br><span class="line"><span class="attribute">Reader 1</span><span class="punctuation">:</span> <span class="string">     RRRR      RRRR      </span></span><br><span class="line"><span class="attribute">Reader 2</span><span class="punctuation">:</span> <span class="string">        RRRR        RRRR</span></span><br><span class="line"><span class="attribute">Reader 3</span><span class="punctuation">:</span> <span class="string">           RRRR         RRRR</span></span><br><span class="line"><span class="attribute">Writer A</span><span class="punctuation">:</span> <span class="string"> W                 W</span></span><br></pre></td></tr></tbody></table></figure>

<p>这里 W 代表一次写入，R 代表一次读取。可以看到，写操作期间，新的读操作需要等待。我们在实际场景中，有遇见过一个 crash 就是错误的使用读写锁。整体比较复杂，下面简化下逻辑，给出核心代码。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataManager</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_mutex mutex_;</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num_keys = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadData</span><span class="params">()</span> </span>{</span><br><span class="line">        std::unordered_map&lt;std::string, std::string&gt; localdata;</span><br><span class="line">        std::vector&lt;std::string&gt; keys;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_keys; i++) {</span><br><span class="line">            keys.<span class="built_in">push_back</span>(<span class="string">"test"</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_keys; i++) {</span><br><span class="line">            localdata[keys[i]] = <span class="string">"test"</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        }</span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            m_data.<span class="built_in">swap</span>(localdata);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function">std::string <span class="title">readData</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>{</span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> m_data[key];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>完整的演示代码在 <a target="_blank" rel="noopener" href="https://gist.github.com/selfboot/dc0d9450ded391bc28a43aecd1045694">core_share.cpp</a> 中，感兴趣的可以看下。这里 loadData 中，先准备好配置数据，然后用写锁来更新配置。在 readData 中，则用读锁来读取配置。</p>
<p>看起来没啥问题呀？因为当时是很偶发的 crash，这里业务代码也很久没动过了，只能开了 core 文件来分析。结果 core 的堆栈很奇怪，在 loadData 方法里，localdata 的<strong>析构过程发生的 crash</strong>。这里 localdata 是局部变量，最后析构前交换了 m_data 和 localdata 的值。那就是 m_data 的数据内存布局有问题了，<strong>m_data 只有这里会写，其他地方全部是“读“</strong>。</p>
<p>又仔细翻了下业务代码，发现 m_data 读的时候，用了 [] 来拿 unordered_map 的值。<strong>对于 unordered_map 来说，如果 key 不存在，[] 会导致插入一个默认值</strong>。啊！！这里本来意图是用读锁保护只读操作，结果不小心还执行了写操作。我们知道，并发写 unordered_map 会有数据竞争，怪不得导致 crash。</p>
<p>当然这里 core 的堆栈其实不一定是析构时候，比如示例的代码，堆栈就是在读线程 readData 的时候，如下图：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png/webp" alt="读线程 crash 堆栈" srcset="https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png/webp 2408w, https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2408" height="1132"></p>
<h2 id="灾难性回溯导致的栈溢出"><a href="#灾难性回溯导致的栈溢出" class="headerlink" title="灾难性回溯导致的栈溢出"></a>灾难性回溯导致的栈溢出</h2><p>上面的示例其实平时多注意的话，还是能避免的。但下面这个，一般人还是很少知道，很容易踩坑。</p>
<p>我们有个地方需要判断字符串中是否有一对括号，于是用了 C++ 的正则表达式。相关代码简化如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string problematic = <span class="string">"(((("</span>;</span><br><span class="line">    problematic += std::<span class="built_in">string</span>(<span class="number">100000</span>, <span class="string">'a'</span>);</span><br><span class="line">    problematic += <span class="string">"))))"</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">re</span><span class="params">(<span class="string">R"(\([^\)]+\))"</span>)</span></span>;</span><br><span class="line">    std::smatch matches;</span><br><span class="line">    <span class="type">bool</span> found = std::<span class="built_in">regex_search</span>(problematic, matches, re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码中，我构造了一个很长的字符串，然后使用正则表达式来匹配。用 g++ 编译后，运行程序，程序就会 coredump 掉。如果用 gdb 看堆栈的话，如下：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png/webp" alt="灾难性回溯导致的栈溢出" srcset="https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png/webp 2412w, https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2412" height="1104"></p>
<p>这是因为正则引擎进行了大量的回溯，每次回溯都会在调用栈上创建新的栈帧。导致这里栈的深度特别长，最终超出栈大小限制，进程 coredump 了。</p>
<p>这个就是所谓的<strong>灾难性回溯（Catastrophic Backtracking）</strong>，实际开发中，对于复杂的文本处理，最好对输入长度进行限制。如果能用循环或者其他非递归的方案解决，就尽量不用正则表达式。如果一定要用正则表达式，可以限制重复次数（使用 {n,m} 而不是 + 或 *），另外也要注意避免嵌套的重复（如 (.+)+）。</p>
<p>上面的正则表达式，可以改成：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">re</span><span class="params">(<span class="string">R"(\([^\)]{1,100}\))"</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>当然除了这里递归回溯导致的栈溢出，还有其他一些场景，比如无限递归、大数组分配在栈上，都可能导致栈溢出。好在栈溢出的话，有 core 文件还是能比较好定位到原因的。</p>
<h2 id="coredump-问题分析"><a href="#coredump-问题分析" class="headerlink" title="coredump 问题分析"></a>coredump 问题分析</h2><p>遇到 crash 问题，一般需要打开 core 文件。真实业务环境中，业务进程如果占内存比较大，crash 后保存 core 文件可能会持续比较久的时间。而真实业务中，一般会有守护进程定时拨测业务进程，如果发现业务进程没回应，有的会用 <code>kill -9</code> 来杀死进程并重启。<strong>这时候，业务进程的 core 文件可能只写了一半，我们拿到的是不完整的 core 文件</strong>。这时候就要修改守护进程，等 core 文件写完再重启进程。</p>
<p>拿到 core 文件后，用 gdb 来分析，如果堆栈比较明确，一般就能很快定位到问题。但很多时候，可能看到的堆栈不完整，是一堆 ??。比如上面访问失效的迭代器，用 gdb 来运行，crash 之后看到堆栈如下：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png/webp" alt="访问失效的迭代器堆栈" srcset="https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png/webp 2054w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2054" height="1192"></p>
<p>这里堆栈没有什么有用的信息，比较难分析。对于示例这种能稳定复现的问题，使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Valgrind">Valgrind</a> 来辅助分析，会更容易定位。上面代码分析结果如下：</p>
<p><img src="https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png/webp" alt="访问失效的迭代器用 Valgrind 分析" srcset="https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png/webp 2408w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png/webp400 400w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png/webp800 800w, https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png/webp1600 1600w" sizes="(min-width: 1150px) 723px, (min-width: 48em) calc((100vw - 120px) * 3 / 4 - 50px), (min-width: 35.5em) calc((100vw - 75px), calc(100vw - 40px)" width="2408" height="1014"></p>
<p>从这里分析结果可以看到，主要有两个问题，无效读取（Invalid read）和无效写入（Invalid write）。发生问题的代码行数这里也有，所以可以很快定位到问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 5 个自己遇到过的导致进程 Coredump 的经典案例：</p>
<ol>
<li><strong>抛异常没有捕获</strong>：使用标准库函数时，要注意其是否会抛出异常。对于可能抛出异常的函数，需要妥善处理异常。对于自定义类，建议使用错误码而不是异常来处理错误。</li>
<li><strong>数组下标访问越界</strong>：在使用数组或容器时，要特别注意下标访问的合法性。尤其是在多处遍历同一容器时，要确保容器的大小没有发生变化。可以使用 <code>at()</code> 方法来进行带边界检查的访问。</li>
<li><strong>访问失效的迭代器</strong>：在使用迭代器时，要注意容器的操作（如删除、插入等）可能会导致迭代器失效。对于 vector 来说，扩容会导致所有迭代器失效；对于其他容器，也要了解其迭代器失效的规则。</li>
<li><strong>并发导致的数据竞争</strong>：在多线程环境下，要特别注意数据的并发访问。即使是看似只读的操作（如 map 的 [] 操作符），也可能会修改容器的内容。使用合适的同步机制（如互斥锁、读写锁等）来保护共享数据。</li>
<li><strong>灾难性回溯导致的栈溢出</strong>：在使用正则表达式等可能导致大量递归的场景下，要注意输入的限制。对于复杂的文本处理，最好使用非递归的方案，或者限制递归深度。</li>
</ol>
<p>当然还有些不常见的 core，比如我之前遇到的：<a href="https://selfboot.cn/2024/03/15/object_memory_coredump/">Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析</a>。大家有遇见过什么印象深刻的 crash 案例，欢迎留言分享。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文标题为：5 个导致 C++ 进程 Crash 的真实业务案例</p><p>本文链接为：https://selfboot.cn/2025/01/10/c++_crash_cases/</p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2025/01/10/c++_crash_cases/';
    this.page.identifier = '2025/01/10/c++_crash_cases/';
    this.page.title = '5 个导致 C++ 进程 Crash 的真实业务案例';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (23)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (32)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2025/01/10/c++_crash_cases/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/06/27/2025-06-27-leveldb-source-table-build/" title="LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程">LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程</a></li><li><a href="/2025/06/13/leveldb_source_LRU_cache/" title="LevelDB 源码阅读：LRU Cache 高性能缓存实现细节">LevelDB 源码阅读：LRU Cache 高性能缓存实现细节</a></li><li><a href="/2025/06/11/leveldb_source_memtable/" title="LevelDB 源码阅读：MemTable 内存表的实现细节">LevelDB 源码阅读：MemTable 内存表的实现细节</a></li><li><a href="/2025/06/10/leveldb_mvcc_intro/" title="LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)">LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)</a></li><li><a href="/2025/05/23/mcp_user_report/" title="使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?">使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?</a></li><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%BC%82%E5%B8%B8%E6%B2%A1%E6%9C%89%E6%8D%95%E8%8E%B7"><span class="toc-number">1.</span> <span class="toc-text">抛异常没有捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE%E8%B6%8A%E7%95%8C"><span class="toc-number">2.</span> <span class="toc-text">数组下标访问越界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%A4%B1%E6%95%88%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">访问失效的迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AF%BC%E8%87%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89"><span class="toc-number">4.</span> <span class="toc-text">并发导致的数据竞争</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%BE%E9%9A%BE%E6%80%A7%E5%9B%9E%E6%BA%AF%E5%AF%BC%E8%87%B4%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">5.</span> <span class="toc-text">灾难性回溯导致的栈溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#coredump-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">coredump 问题分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p><p>友情链接：<a rel="dofollow" target="_blank" href="https://puzzles-game.com/">益智游戏</a></p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>