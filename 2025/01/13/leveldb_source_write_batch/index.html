<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="baidu-site-verification" content="codeva-NxrUEx2EFN"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>LevelDB 源码阅读：如何优雅地合并写入和删除操作</title><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,en/atom.xml"><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;973c5bad683a49b8af76df256779f523&quot;}"></script>
<script defer="" src="https://cloud.umami.is/script.js" data-website-id="3578d9f2-9ea0-49d4-8781-e8d1217ab924" data-domains="selfboot.cn"></script><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="referrer" content="no-referrer-when-downgrade"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-QNFB9JLSPV"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-QNFB9JLSPV');
</script><script async="" type="text/javascript" src="/js/clipboard.min.js"></script><script async="" type="text/javascript" src="/js/toastr.min.js"></script><link rel="stylesheet" href="/css/toastr.min.css"><script>function switchLanguage(lang) {
  var currentPath = window.location.pathname;
  var newPath;
  if (lang === 'en') {
    newPath = '/en' + currentPath.replace(/^\/(zh-CN\/)?/, '/');
  } else {
    newPath = currentPath.replace(/^\/en/, '');
  }
  window.location.href = newPath;
}
</script><link rel="icon" href="https://slefboot-1251736664.file.myqcloud.com/selfboot//favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="https://slefboot-1251736664.file.myqcloud.com/selfboot//apple-touch-icon.png"><link rel="manifest" href="https://slefboot-1251736664.file.myqcloud.com/selfboot//site.webmanifest"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/.">Just For Fun</a><div class="lang-select-wrapper"><i class="fas fa-globe"></i><select id="lang-select" onchange="switchLanguage(this.value)"><option value="zh-CN" selected="">中文</option><option value="en">English</option></select></div><p class="description">知其然，知其所以然。知识广度是深度的副产品！</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"></i><span> 首页</span></a><a href="/archives/"><i class="fa fa-archive"></i><span> 归档</span></a><a href="/aboutme.html"><i class="fa fa-user"></i><span> 关于</span></a><a href="/links.html"><i class="fa fa-user-graduate"></i><span> 小盛律师</span></a><a href="/friends.html"><i class="fa fa-link"></i><span> 友情链接</span></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LevelDB 源码阅读：如何优雅地合并写入和删除操作</h1><div class="post-meta">2025/01/13<span> | </span><span class="category"><a href="/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">源码剖析</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2025/01/13/leveldb_source_write_batch/" href="/2025/01/13/leveldb_source_write_batch/#disqus_thread"></a><div class="post-content"><p>LevelDB 支持写入单个键值对和批量写入多个键值对，这两种操作的处理流程本质上是相同的，都会被封装进一个 WriteBatch 对象中，这样就可以提高写操作的效率。</p>
<p>在 LevelDB 中，WriteBatch 是通过一个简单的数据结构实现的，其中包含了一系列的写入操作。这些操作被序列化（转换为字节流）并存储在内部的一个字符串中。每个操作都包括操作类型（如插入或删除），键和值（对于插入操作）。</p>
<p>当 WriteBatch 被提交给数据库时，其内容被解析并应用到 WAL 日志和 memtable 中。不管 WriteBatch 中包含多少操作，它们都将作为一个整体进行处理和日志记录。</p>
<span id="more"></span>

<p>WriteBatch 的实现主要涉及到 4 个文件，接下来一起看看。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/include/leveldb/write_batch.h">include/leveldb/write_batch.h</a>：对外暴露的接口文件，定义了 WriteBatch 类的接口。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch_internal.h">db/write_batch_internal.h</a>：内部实现文件，定义了 WriteBatchInternal 类，提供了一些操作 WriteBatch 的方法。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch.cc">db/write_batch.cc</a>：WriteBatch 类的实现文件，实现了 WriteBatch 类。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch_test.cc">db/write_batch_test.cc</a>：WriteBatch 类的测试文件，用于测试 WriteBatch 的功能。</li>
</ol>
<h2 id="WriteBatch-接口设计"><a href="#WriteBatch-接口设计" class="headerlink" title="WriteBatch 接口设计"></a>WriteBatch 接口设计</h2><p>我们先来看 write_batch.h 文件，这里定义了 WriteBatch 类对外暴露的一些接口。 LevelDB 代码中的注释十分清晰，不过这里先省略注释：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> WriteBatch {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> Handler {</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Handler</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WriteBatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Intentionally copyable.</span></span><br><span class="line">  <span class="built_in">WriteBatch</span>(<span class="type">const</span> WriteBatch&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  WriteBatch&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WriteBatch&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">WriteBatch</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">ApproximateSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> WriteBatch&amp; source)</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">Iterate</span><span class="params">(Handler* handler)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteBatchInternal</span>;</span><br><span class="line"></span><br><span class="line">  std::string rep_;  <span class="comment">// See comment in write_batch.cc for the format of rep_</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>其中 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/include/leveldb/write_batch.h#L35">WriteBatch::Handler</a> 是一个抽象基类，定义了处理键值对操作的接口，只包括 Put 和 Delete 方法。这样的设计允许 WriteBatch 类实现与<strong>具体存储操作</strong>解耦，使得 WriteBatch 不必直接知道如何将操作应用到底层存储（如 MemTable）。</p>
<p><strong>通过继承 Handler 类，可以创建多种处理器，它们可以以不同的方式实现这些方法</strong>。比如：</p>
<ol>
<li>MemTableInserter： 定义在 db/write_batch.cc 中，将键值操作存储到 MemTable 中。</li>
<li>WriteBatchItemPrinter：定义在 db/dumpfile.cc 中，将键值操作打印到文件中，可以用来测试。</li>
</ol>
<p>另外还有一个 <code>friend class WriteBatchInternal</code> 作为 WriteBatch 的友元类，能够访问其私有和受保护成员。<strong>WriteBatchInternal 主要用来封装一些内部操作，这些方法不需要对外暴露，只在内部用到。通过将内部操作方法隐藏在 WriteBatchInternal 中，保持了对象的接口清晰，可以自由地修改内部实现而不影响到使用这些对象的代码</strong>。</p>
<h3 id="WriteBatch-使用方法"><a href="#WriteBatch-使用方法" class="headerlink" title="WriteBatch 使用方法"></a>WriteBatch 使用方法</h3><p>在应用层，我们可以通过 WriteBatch 来批量写入多个键值对，然后通过 <code>DB::Write</code> 方法将 WriteBatch 写入到数据库中。</p>
<p>这里 WriteBatch 支持 Put 和 Delete 操作，可以合并多个 WriteBatch。如下使用示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WriteBatch batch;</span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">batch.<span class="built_in">Delete</span>(<span class="string">"key3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并另一个批次</span></span><br><span class="line">WriteBatch another_batch;</span><br><span class="line">another_batch.<span class="built_in">Put</span>(<span class="string">"key4"</span>, <span class="string">"value4"</span>);</span><br><span class="line">batch.<span class="built_in">Append</span>(another_batch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据库</span></span><br><span class="line">db-&gt;<span class="built_in">Write</span>(writeOptions, &amp;batch);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="WriteBatch-实现细节"><a href="#WriteBatch-实现细节" class="headerlink" title="WriteBatch 实现细节"></a>WriteBatch 实现细节</h2><p>那么 WriteBatch 是怎么实现的呢？关键在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch.cc">db/write_batch.cc</a>，该类中有一个 private 成员 <code>std::string rep_</code> 来存储序列化后的键值操作。我们先来看看这里的存储数据协议：</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------------+----------------------------------------+</span><br><span class="line">|<span class="string">   Sequence    </span>|<span class="string">     Count     </span>|<span class="string">                Data                    </span>|</span><br><span class="line">|<span class="string">  (8 bytes)    </span>|<span class="string">   (4 bytes)   </span>|<span class="string">                                        </span>|</span><br><span class="line">+---------------+---------------+----------------------------------------+</span><br><span class="line">                                   |<span class="string">                 </span>|<span class="string">                   </span>|</span><br><span class="line">                                   v                 v                   v</span><br><span class="line">                               +-------+         +-------+          +-------+</span><br><span class="line">                               |<span class="string">Record1</span>|<span class="string">         </span>|<span class="string">Record2</span>|<span class="string">   ...    </span>|<span class="string">RecordN</span>|</span><br><span class="line">                               +-------+         +-------+          +-------+</span><br><span class="line">                                  |<span class="string">                 </span>|</span><br><span class="line">                                  v                 v</span><br><span class="line">                        +-----------------+ +-----------------+</span><br><span class="line">                        |<span class="string"> kTypeValue      </span>|<span class="string"> </span>|<span class="string"> kTypeDeletion   </span>|</span><br><span class="line">                        |<span class="string"> Varstring Key   </span>|<span class="string"> </span>|<span class="string"> Varstring Key   </span>|</span><br><span class="line">                        |<span class="string"> Varstring Value </span>|<span class="string"> </span>|<span class="string">                 </span>|</span><br><span class="line">                        +-----------------+ +-----------------+</span><br><span class="line">                        </span><br><span class="line">Varstring (可变长度字符串):</span><br><span class="line">+-------------+-----------------------+</span><br><span class="line">|<span class="string"> Length (varint32) </span>|<span class="string"> Data (uint8[])  </span>|</span><br><span class="line">+-------------+-----------------------+</span><br></pre></td></tr></tbody></table></figure>

<p>该字符串前 12 个字节是头部元数据部分，包括 8 个字节的序列号和 4 个字节的 count 数。接下来是一个或多个操作记录，每个记录包含一个操作类型和键值对。操作类型是一个字节，可以是 Put 或者 Delete 操作。键和值都是可变长度的字符串，格式为 varstring。</p>
<h3 id="LevelDB-的序列号机制"><a href="#LevelDB-的序列号机制" class="headerlink" title="LevelDB 的序列号机制"></a>LevelDB 的序列号机制</h3><p>rep_ 头部 8 个字节代表64位的数字 sequence（序列号），WriteBatchInternal 友元类提供了两个方法来获取和设置 sequence number，内部是用 <a href="https://selfboot.cn/2024/08/29/leveldb_source_utils/#%E6%95%B4%E6%95%B0%E7%BC%96%E3%80%81%E8%A7%A3%E7%A0%81">EncodeFixed64 和 DecodeFixed64</a> 方法来编解码 64 位的序列号。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SequenceNumber <span class="title">WriteBatchInternal::Sequence</span><span class="params">(<span class="type">const</span> WriteBatch* b)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SequenceNumber</span>(<span class="built_in">DecodeFixed64</span>(b-&gt;rep_.<span class="built_in">data</span>()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::SetSequence</span><span class="params">(WriteBatch* b, SequenceNumber seq)</span> </span>{</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(&amp;b-&gt;rep_[<span class="number">0</span>], seq);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>序列号是 LevelDB 中的全局递增标识符，用于实现版本控制和操作排序</strong>。每个 WriteBatch 在执行时会获得一段连续的序列号，批次内的每个操作（Put/Delete）都会分配到其中的一个序列号。序列号在 LevelDB 中有三个核心作用：</p>
<ol>
<li><strong>版本控制</strong>：LevelDB 中的每个 key 可以有多个版本，每个版本都对应一个序列号。在读取时，通过比较序列号来确定应该返回哪个版本的值。较大的序列号表示更新的版本。</li>
<li><strong>多版本并发控制（MVCC）</strong>：写操作获取新的序列号，创建 key 的新版本。读操作可以指定序列号，访问该序列号时间点的数据快照。这种机制使得读写操作可以并发执行，无需互相阻塞。</li>
<li><strong>故障恢复</strong>：WAL（预写日志）中记录了操作的序列号。系统重启时，通过序列号可以准确重建崩溃时的数据状态，避免重复应用已持久化的操作。</li>
</ol>
<p>这种设计让 LevelDB 既保证了数据一致性，又实现了高效的并发控制。</p>
<p>设置序列号的逻辑在 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1222">DBImpl::Write</a> 方法中，首先获取当前最大序列号，然后为 WriteBatch 分配一个新的序列号。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">uint64_t</span> last_sequence = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; updates != <span class="literal">nullptr</span>) {  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">    WriteBatch* write_batch = <span class="built_in">BuildBatchGroup</span>(&amp;last_writer);</span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">    last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果 WriteBatch 包含多个操作，那么这些操作会<strong>连续地分配序列号</strong>。在写入 WAL 日志时，会将 WriteBatch 的序列号写入到日志中，这样在恢复时可以根据序列号来恢复操作的顺序。写入 memtable 之后，会更新当前最大序列号，以便下次分配。</p>
<h3 id="count-记录操作数"><a href="#count-记录操作数" class="headerlink" title="count 记录操作数"></a>count 记录操作数</h3><p>头部还有 4 个字节的 count，用于记录 WriteBatch 中包含的操作数。这里每次 put 或者 delete 操作都会增加 count 的值。如下示例：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WriteBatch batch;</span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">"key1"</span>, <span class="string">"value1"</span>);  <span class="comment">// count = 1</span></span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">"key2"</span>, <span class="string">"value2"</span>);  <span class="comment">// count = 2</span></span><br><span class="line">batch.<span class="built_in">Delete</span>(<span class="string">"key3"</span>);         <span class="comment">// count = 3</span></span><br><span class="line"><span class="type">int</span> num_ops = WriteBatchInternal::<span class="built_in">Count</span>(&amp;batch);  <span class="comment">// = 3</span></span><br></pre></td></tr></tbody></table></figure>

<p>在合并两个 WriteBatch 的时候，也会累计两部分的 count 的值，如下 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch.cc#L144">WriteBatchInternal::Append</a> 方法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::Append</span><span class="params">(WriteBatch* dst, <span class="type">const</span> WriteBatch* src)</span> </span>{</span><br><span class="line">  <span class="built_in">SetCount</span>(dst, <span class="built_in">Count</span>(dst) + <span class="built_in">Count</span>(src));</span><br><span class="line">  <span class="built_in">assert</span>(src-&gt;rep_.<span class="built_in">size</span>() &gt;= kHeader);</span><br><span class="line">  dst-&gt;rep_.<span class="built_in">append</span>(src-&gt;rep_.<span class="built_in">data</span>() + kHeader, src-&gt;rep_.<span class="built_in">size</span>() - kHeader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用 count 的地方主要有两个，一个是在迭代这里每个记录的时候，会用 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch.cc#L75">count 来做完整性检查</a>，确保没有遗漏操作。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatch::Iterate</span><span class="params">(Handler* handler)</span> <span class="type">const</span> </span>{</span><br><span class="line">  <span class="function">Slice <span class="title">input</span><span class="params">(rep_)</span></span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (found != WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>)) {</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"WriteBatch has wrong count"</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>另一个是在 db 写入的时候，根据 count 可以预先知道需要分配多少序列号，保证序列号连续性。如下 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L449">DBImpl::Write</a>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="支持的各种操作"><a href="#支持的各种操作" class="headerlink" title="支持的各种操作"></a>支持的各种操作</h3><p>在头部的 sequence 和 count 之后，rep_ 紧跟着的是一系列的记录，每个记录包含一个操作类型和键值。这里记录可以通过 Put 和 Delete 方法来添加，其中 Put 方法的实现如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>{</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeValue));</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里更新了 count，然后添加了 kTypeValue 操作类型，接着是添加 key 和 value。Delete 操作类似，count 计数也是要加 1，然后操作类型是 kTypeDeletion，最后只用添加 key 即可。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>{</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeDeletion));</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面是往 rep_ 中添加记录，那么如何从 rep_ 中解析出这些记录呢？这里 WriteBatch 类中提供了一个 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch.cc#L42">Iterate</a> 方法，该方法遍历 rep_ 中的每条记录，然后通过传入的 Handler 接口来灵活处理这些记录。 </p>
<p>此外该方法的实现中还有<strong>数据格式验证，会检查头部大小、操作类型、操作数量是否匹配</strong>。可以返回 Corruption 错误，表示数据格式不正确等。Iterate 核心代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatch::Iterate</span><span class="params">(Handler* handler)</span> <span class="type">const</span> </span>{</span><br><span class="line">  <span class="function">Slice <span class="title">input</span><span class="params">(rep_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (input.<span class="built_in">size</span>() &lt; kHeader) {</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"malformed WriteBatch (too small)"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  input.<span class="built_in">remove_prefix</span>(kHeader);</span><br><span class="line">  Slice key, value;</span><br><span class="line">  <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!input.<span class="built_in">empty</span>()) {</span><br><span class="line">    found++;</span><br><span class="line">    <span class="type">char</span> tag = input[<span class="number">0</span>];</span><br><span class="line">    input.<span class="built_in">remove_prefix</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">switch</span> (tag) {</span><br><span class="line">      <span class="keyword">case</span> kTypeValue:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key) &amp;&amp;</span><br><span class="line">            <span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;value)) {</span><br><span class="line">          handler-&gt;<span class="built_in">Put</span>(key, value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"bad WriteBatch Put"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key)) {</span><br><span class="line">          handler-&gt;<span class="built_in">Delete</span>(key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"bad WriteBatch Delete"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">"unknown WriteBatch tag"</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>前面提过 Handler 是 WriteBatch 的抽象基类，可以传入不同的实现。在 LevelDB 写数据的时候，这里传入的是 MemTableInserter 类，该类将操作数据存储到 MemTable 中。具体可以调用这里的实现：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatchInternal::InsertInto</span><span class="params">(<span class="type">const</span> WriteBatch* b, MemTable* memtable)</span> </span>{</span><br><span class="line">  MemTableInserter inserter;</span><br><span class="line">  inserter.sequence_ = WriteBatchInternal::<span class="built_in">Sequence</span>(b);</span><br><span class="line">  inserter.mem_ = memtable;</span><br><span class="line">  <span class="keyword">return</span> b-&gt;<span class="built_in">Iterate</span>(&amp;inserter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>整体上看 WriteBatch 负责存储键值操作的数据，进行编码解码等，而 Handler 负责具体处理里面的每条数据。这样 WriteBatch 的操作就可以被灵活地应用到不同场景中，方便扩展。</p>
<h2 id="测试用例分析"><a href="#测试用例分析" class="headerlink" title="测试用例分析"></a>测试用例分析</h2><p>最后再来看看 <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/main/db/write_batch_test.cc">write_batch_test.cc</a>，这里提供了一些测试用例，用于测试 WriteBatch 的功能。</p>
<p>首先定义了一个 PrintContents 函数，用来输出 WriteBatch 中的所有操作记录。这里用 MemTableInserter 将 WriteBatch 中的操作记录存储到 MemTable 中，然后通过 MemTable 的迭代器遍历所有记录，并保存到字符串中。</p>
<p>这里测试用例覆盖了下面这些情况：</p>
<ol>
<li>Empty：测试空的 WriteBatch 是否正常；</li>
<li>Multiple：测试多个 Put 和 Delete 操作，验证总的 count 数目和每个操作的序列号是否正确；</li>
<li>Corruption：先写进去数据，然后故意截断部分记录，测试能读取尽量多的正常数据；</li>
<li>Append：测试合并两个 WriteBatch，验证合并后序列号的正确性，以及合并空 WriteBatch；</li>
<li>ApproximateSize：测试 ApproximateSize 方法，计算 WriteBatch 的近似大小；</li>
</ol>
<p>这里通过测试用例，基本就能知道怎么使用 WriteBatch 了。比较有意思的是，前面在看 Append 代码的时候，没太留意到合并后这里序列号是用谁的。这里结合测试用例，才发现取的目标 WriteBatch 的序列号。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(WriteBatchTest, Append) {</span><br><span class="line">  WriteBatch b1, b2;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetSequence</span>(&amp;b1, <span class="number">200</span>);</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetSequence</span>(&amp;b2, <span class="number">300</span>);</span><br><span class="line">  b<span class="number">1.</span><span class="built_in">Append</span>(b2);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">""</span>, <span class="built_in">PrintContents</span>(&amp;b1));</span><br><span class="line">  b<span class="number">2.</span><span class="built_in">Put</span>(<span class="string">"a"</span>, <span class="string">"va"</span>);</span><br><span class="line">  b<span class="number">1.</span><span class="built_in">Append</span>(b2);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">"Put(a, va)@200"</span>, <span class="built_in">PrintContents</span>(&amp;b1));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过深入分析 LevelDB 的 WriteBatch 实现，我们可以清晰地看到其设计精妙之处。WriteBatch 通过将多个写入和删除操作封装在一起，不仅提高了写操作的效率，还简化了并发控制和故障恢复的实现。有几个亮点值得借鉴：</p>
<ol>
<li><strong>批量操作</strong>：WriteBatch 允许将多个 Put 和 Delete 操作合并为一个批次，减少了频繁的 I/O 操作，提升了写入性能。</li>
<li><strong>序列号机制</strong>：通过全局递增的序列号，LevelDB 实现了多版本并发控制（MVCC），确保了读写操作的一致性。</li>
<li><strong>Handler 抽象</strong>：通过 Handler 接口，WriteBatch 将操作的具体实现与存储逻辑解耦，使得代码更加灵活和可扩展。</li>
<li><strong>数据格式验证</strong>：在解析 WriteBatch 时，LevelDB 会进行严格的数据格式验证，确保数据的完整性和正确性。</li>
</ol>
<p>当然本篇只是分析 WriteBatch 的实现，并没有串起 LevelDB 的整个写入流程，后续文章我们会继续分析，写入一个 key 的完整流程。</p>
</div><div class="article-footer-copyright"><p>本文由<b>selfboot</b> 发表于<a href="https://selfboot.cn" target="_blank">个人博客</a>，采用<a href="https://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank">署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。</a></p><p>本文章已自动同步在<b style="color:red">个人公众号</b>，欢迎去 <a href="https://selfboot.cn/aboutme.html" target="_blank">个人主页 </a> 扫码关注</p><p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者本人</a></p><p>本文链接为：<a href="https://selfboot.cn/2025/01/13/leveldb_source_write_batch/" target="_blank">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></p></div><div class="post-donate"><div class="donate_bar center" id="donate_board"><a class="btn_donate" id="btn_donate" href="javascript:;" title="赞助"></a><div class="donate_txt"> ↑<br>内容不错，赞助一下<br></div></div><div class="donate_bar center hidden" id="donate_guide"><img src="https://slefboot-1251736664.file.myqcloud.com/weixin.jpg" title="微信打赏"><img src="https://slefboot-1251736664.file.myqcloud.com/zhifubao.jpg" title="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div><div class="addthis_sharing_toolbox"></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C++</a><a href="/tags/LevelDB/"><i class="fa fa-tag"></i>LevelDB</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://selfboot.cn/2025/01/13/leveldb_source_write_batch/';
    this.page.identifier = '2025/01/13/leveldb_source_write_batch/';
    this.page.title = 'LevelDB 源码阅读：如何优雅地合并写入和删除操作';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xuelangZF.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xuelangZF.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xuelangZF.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script></div><script type="text/javascript">document.addEventListener('DOMContentLoaded', function () {
  var disqusThread = document.getElementById('disqus_thread');
  if (!disqusThread) return;
  
  function removeAdIframes() {
    var iframes = disqusThread.getElementsByTagName('iframe');
    for (var i = iframes.length - 1; i >= 0; i--) {
      var iframe = iframes[i];
      if (iframe.src && iframe.src.indexOf("tempest.services.disqus.com/ads-iframe") !== -1) {
        iframe.parentNode.removeChild(iframe);
      }
    }
  }
  
  removeAdIframes();
  
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      removeAdIframes();
    });
  });
  observer.observe(disqusThread, { childList: true, subtree: true });
});
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="https://www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://selfboot.cn"></form></div><div class="widget recommendations-widget"><div class="widget-title"> 推荐内容</div><div class="recommendations-container"><div class="recommendation-item"><a class="promo-link" href="https://puzzles-game.com/" target="_blank"><div class="promo-content"><i class="fa fa-gamepad"></i><span class="promo-text">训练大脑, 保持聪明</span></div></a></div><div class="recommendation-item"><a class="promo-link" href="https://gallery.selfboot.cn" target="_blank"><div class="promo-content"><i class="fa fa-robot"></i><span class="promo-text">人工智能, 助我创造</span></div></a></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>分类</span></div><ul><li><a href="/categories/程序设计/">程序设计</a> (23)</li><li><a href="/categories/工具介绍/">工具介绍</a> (13)</li><li><a href="/categories/数据结构与算法/">数据结构与算法</a> (13)</li><li><a href="/categories/计算机基础/">计算机基础</a> (9)</li><li><a href="/categories/社会百态/">社会百态</a> (11)</li><li><a href="/categories/计算机网络/">计算机网络</a> (4)</li><li><a href="/categories/项目实践/">项目实践</a> (10)</li><li><a href="/categories/源码剖析/">源码剖析</a> (23)</li><li><a href="/categories/金融/">金融</a> (1)</li><li><a href="/categories/人工智能/">人工智能</a> (32)</li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"></i><span>标签</span></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15.00px;">Python</a> <a href="/tags/教程/" style="font-size: 15.00px;">教程</a> <a href="/tags/总结/" style="font-size: 15.00px;">总结</a> <a href="/tags/方法/" style="font-size: 15.00px;">方法</a> <a href="/tags/Google/" style="font-size: 15.00px;">Google</a> <a href="/tags/思考/" style="font-size: 15.00px;">思考</a> <a href="/tags/Django/" style="font-size: 15.00px;">Django</a> <a href="/tags/DNS/" style="font-size: 15.00px;">DNS</a> <a href="/tags/见闻/" style="font-size: 15.00px;">见闻</a> <a href="/tags/前端/" style="font-size: 15.00px;">前端</a> <a href="/tags/Protocol/" style="font-size: 15.00px;">Protocol</a> <a href="/tags/C/" style="font-size: 15.00px;">C++</a> <a href="/tags/Flask/" style="font-size: 15.00px;">Flask</a> <a href="/tags/Thread/" style="font-size: 15.00px;">Thread</a> <a href="/tags/ChatGPT/" style="font-size: 15.00px;">ChatGPT</a> <a href="/tags/Prompt/" style="font-size: 15.00px;">Prompt</a> <a href="/tags/Plugin/" style="font-size: 15.00px;">Plugin</a> <a href="/tags/Leetcode/" style="font-size: 15.00px;">Leetcode</a> <a href="/tags/Redis/" style="font-size: 15.00px;">Redis</a> <a href="/tags/Debug/" style="font-size: 15.00px;">Debug</a> <a href="/tags/Issue/" style="font-size: 15.00px;">Issue</a> <a href="/tags/eBPF/" style="font-size: 15.00px;">eBPF</a> <a href="/tags/Go/" style="font-size: 15.00px;">Go</a> <a href="/tags/数学/" style="font-size: 15.00px;">数学</a> <a href="/tags/Gemini/" style="font-size: 15.00px;">Gemini</a> <a href="/tags/google/" style="font-size: 15.00px;">google</a> <a href="/tags/LLM/" style="font-size: 15.00px;">LLM</a> <a href="/tags/LevelDB/" style="font-size: 15.00px;">LevelDB</a></div></div><!-- Debug: page.path = 2025/01/13/leveldb_source_write_batch/ --><div class="widget"><div class="widget-title"><i class="fa fa-file-o"></i><span>最近文章</span></div><ul><li><a href="/2025/06/27/leveldb_source_table_build/" title="LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程">LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程</a></li><li><a href="/2025/06/13/leveldb_source_LRU_cache/" title="LevelDB 源码阅读：LRU Cache 高性能缓存实现细节">LevelDB 源码阅读：LRU Cache 高性能缓存实现细节</a></li><li><a href="/2025/06/11/leveldb_source_memtable/" title="LevelDB 源码阅读：MemTable 内存表的实现细节">LevelDB 源码阅读：MemTable 内存表的实现细节</a></li><li><a href="/2025/06/10/leveldb_mvcc_intro/" title="LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)">LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)</a></li><li><a href="/2025/05/23/mcp_user_report/" title="使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?">使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?</a></li><li><a href="/2025/01/24/leveldb_source_writedb/" title="LevelDB 源码阅读：写入键值的工程实现和优化细节">LevelDB 源码阅读：写入键值的工程实现和优化细节</a></li><li><a href="/2025/01/13/leveldb_source_write_batch/" title="LevelDB 源码阅读：如何优雅地合并写入和删除操作">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a></li><li><a href="/2025/01/10/c++_crash_cases/" title="5 个导致 C++ 进程 Crash 的真实业务案例">5 个导致 C++ 进程 Crash 的真实业务案例</a></li><li><a href="/2025/01/02/leveldb_source_thread_anno/" title="LevelDB 源码阅读：利用 Clang 的静态线程安全分析">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></li><li><a href="/2024/12/25/leveldb_source_hashtable/" title="LevelDB 源码阅读：如何设计一个高性能哈希表">LevelDB 源码阅读：如何设计一个高性能哈希表</a></li></ul></div><!-- Debug: Current Language = zh-CN, Filtered Posts Count = 10 --><div class="widget" id="toc"><div class="widget-title"><i class="fa fa-list-ul"></i><span> 文章目录</span></div><ul class="dsq-widget-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#WriteBatch-%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">WriteBatch 接口设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WriteBatch-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">WriteBatch 使用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WriteBatch-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">2.</span> <span class="toc-text">WriteBatch 实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LevelDB-%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">LevelDB 的序列号机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count-%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">count 记录操作数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">支持的各种操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">测试用例分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Just For Fun.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/selfboot/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/selfboot"> SelfBoot.</a><p><span id="busuanzi_container_site_pv"></span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次，<span id="busuanzi_container_site_uv"></span>本站访客数: <span id="busuanzi_value_site_uv"></span> 人次</p><p>友情链接：<a rel="dofollow" target="_blank" href="https://puzzles-game.com/">益智游戏</a></p></div></div></div><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="/css/copyright.css"><link rel="stylesheet" type="text/css" href="/css/recommendations.css"><a class="show" id="rocket" href="#top" aria-label="Back to top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer=""></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" defer=""></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/toc.js?v=1.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>