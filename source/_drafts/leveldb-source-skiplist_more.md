---
title: LevelDB 源码阅读：跳表的测试以及性能分析
tags: [C++]
category: 源码剖析
toc: true
date: 2024-08-17 21:00:00
mathjax: true
description: 
---

在上篇 [LevelDB 源码阅读：跳表的原理、实现以及可视化]()中，从当前二叉搜索树和平衡树的一些缺点出发，引出了跳表这种数据结构。然后结合论文，解释了跳表的实现原理。接着详细分析了 LevelDB 的代码实现，包括迭代器实现，以及**并发读的极致性能优化**。最后还提供了一个可视化页面，可以直观看到跳表的构建过程。

但并没有结束，其实还有两个问题：

1. 怎么测试 LevelDB 跳表实现的正确性？
2. 怎么从数学上分析跳表的时间复杂度？

本篇就来解答这两个问题。

<!-- more -->

## 跳表功能测试

上面分析了跳表的实现，那么这里的实现是否正确呢？如果要写测试用例，应该怎么写？需要从哪些方面来测试跳表的正确性？来看看 LevelDB 的测试代码 [skiplist_test.cc](https://github.com/google/leveldb/blob/main/db/skiplist_test.cc)。

首先是**空跳表的测试**，验证空跳表不包含任何元素，检查空跳表的迭代器在 SeekToFirst, Seek, SeekToLast 等操作后的状态。接着是插入、查找、迭代器的测试用例，通过不断插入大量随机生成的键值对，验证跳表是否正确包含这些键，以及测试迭代器的前向和后向遍历。

```cpp
TEST(SkipTest, InsertAndLookup) {
  // 测试插入和查找功能
  // 插入随机生成的键值对
  // 验证跳表正确包含这些键
  // 测试迭代器的前向和后向遍历
}  
```

这些都是比较常规的测试用例，后面就是**硬核的并发读测试**。

### 并发测试难点

上面测试看起来比较全面，并发测试也比较详细。不过对于这种并发读，特别是有内存屏障相关的代码，有时候测试通过可能只是因为没触发问题而已(出现问题的概率很低，可能和编译器，cpu 型号也有关)。比如这里我把 Insert 操作稍微改下：

```cpp
  for (int i = 0; i < height; i++) {
    // NoBarrier_SetNext() suffices since we will add a barrier when
    // we publish a pointer to "x" in prev[i].
    x->NoBarrier_SetNext(i, prev[i]->NoBarrier_Next(i));
    prev[i]->NoBarrier_SetNext(i, x); // Change here, Use NoBarrier_SetNext
  }
```

这里两个指针都用 NoBarrier_SetNext 方法来设置，然后重新编译 LevelDB 库和测试程序，运行多次，都是能通过测试用例的。

## 跳表性能分析

通过上面的原理、实现和可视化工具，我们可以推测出来，在极端情况下，可能每个节点的高度都是 1，那么跳表的查找、插入、删除操作的时间复杂度都会退化到 O(n)。在这种情况下，性能比平衡树差了不少。当然，因为有随机性在里面，所以**没有输入序列能始终导致性能最差**。

跳表的平均性能如何呢？前面给出过结论，和平衡树的平均性能差不多。引入一个简单的随机高度，就能保证跳表的平均性能和平衡树差不多。这背后有没有什么分析方法，能够分析跳表的性能呢？还得看论文，论文中给出了一个不错的分析方法，这里可以一起看看。

## 总结

看到这里，大家应该能彻底理解 LevelDB 的跳表实现了吧。