---
title: 结合实例深入理解 C++ 对象的内存布局
tags: [C++]
category: 程序设计
toc: true
description: 
---

在前面 [Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析](https://selfboot.cn/2024/03/15/object_memory_coredump/) 这篇文章，因为二进制使用了不同版本的 proto 对象，对象的内存布局不一致导致读、写成员的内存地址错乱，进而导致进程 crash 掉。但是当时并没有展开细聊下面的问题：

1. 对象在内存中是怎么布局的?
2. 类方法是如何拿到成员变量的地址？

这些其实涉及 C++ 的对象模型，《深度探索 C++对象模型：Inside the C++ Object Model》这本书全面聊了这个问题，非常值得一读。不过这本书读起来并不容易，有的内容读过后如果没有加以实践，也很难完全理解。本篇文章试着从实际的例子出发，帮助大家对 C++ 类成员变量和函数在内存布局有个直观的理解，后面再读这本书也会容易理解些。

<!-- more -->

## 简单对象内存分布

首先以一个最简单的 Basic 类为例，来看看只含有基本数据类型的对象是怎么分配内存的。

```c++
#include <iostream>
using namespace std;

class Basic {
public:
    int a;
    double b;
};

int main() {
    Basic temp;
    temp.a = 10;
    return 0;
}
```

编译运行后，可以用 GDB 来查看对象的内存分布。如下图：

![Basic 基础数据类的内存分布-GDB调试](https://slefboot-1251736664.file.myqcloud.com/20240326_c++_object_model_basic_gdb.png)

对象 temp 的起始地址是 `0x7fffffffe3b0`，这是整个对象在内存中的位置。成员变量a的地址也是 `0x7fffffffe3b0`，表明int a是对象temp中的第一个成员，位于对象的起始位置。成员变量b的类型为double，其地址是 `0x7fffffffe3b8`(a的地址+8)，内存布局如下图：

![Basic 基础数据类的内存分布示意图](https://slefboot-1251736664.file.myqcloud.com/20240326_c++_object_model_basic_demo.png)

这里 int类型在当前平台上占用4个字节（可以用sizeof(int)验证），而这里double成员的起始地址与int成员的起始地址之间相差8个字节，说明在a之后存在**内存对齐填充**（具体取决于编译器的实现细节和平台的对齐要求）。内存对齐要求数据的起始地址在某个特定大小(比如 4、8)的倍数上，这样可以**优化硬件和操作系统访问内存的效率**。这是因为许多处理器**访问对齐的内存地址比访问非对齐地址更快**。

另外在不进行内存对齐的情况下，较大的数据结构可能会跨越多个缓存行或内存页边界，这会导致额外的缓存行或页的加载，降低内存访问效率。不过开发者通常不需要手动管理内存对齐，因为现代编译器和操作系统会自动处理这些问题。

## 带方法的对象内存分布

接着上面的例子，在类中增加一个方法 setB，用来设置其中成员 b 的值。

```c++
#include <iostream>

class Basic {
public:
    int a;
    double b;

    void setB(double value) {
        b = value; // 直接访问成员变量b
    }
};

int main() {
    Basic temp;
    temp.a = 10;
    temp.setB(3.14);
    return 0;
}
```

用 GDB 打印 temp 对象以及成员变量的地址，发现内存布局和前面不带方法的完全一样。整个对象 size 依然是 16，a 和 b 的内存地址分布也是一致的。那么**新增加的成员方法存储在什么位置**？成员方法中又是**如何拿到成员变量的地址**呢？

### 成员方法的内存布局

可以在 GDB 里面打印下成员方法的地址，如下图所示。

![成员方法的存储地址](https://slefboot-1251736664.file.myqcloud.com/20240329_c++_object_model_method_addr.png)

回忆下 Linux 中进程的内存布局，其中**文本段(也叫代码段)是存储程序执行代码的内存区域**，通常是只读的，以防止程序在运行时意外或恶意修改其执行代码。前面 setB 方法地址 `0x5555555551d2` 是否位于程序的文本段内呢？打印下进程的内存布局，如下：

```
$ cat /proc/2325196/maps
555555554000-555555555000 r--p 00000000 fe:01 554821                     /root/demo/object_memory/basic_method
555555555000-555555556000 r-xp 00001000 fe:01 554821                     /root/demo/object_memory/basic_method
555555556000-555555557000 r--p 00002000 fe:01 554821                     /root/demo/object_memory/basic_method
...
```

其中 `555555555000-555555556000` 位于可执行文件 `basic_method` 映射的范围内，setB 的地址落在这个区间内。这里权限标记（r-xp）中的 x 明确表示这个段是可执行，可执行的映射通常包含代码段。至此前面第一个问题有了答案，成员方法存储在进程的文本段，添加成员方法不会改变类实例对象的内存布局大小，**它们也不占用对象实例的内存空间**。

### 成员变量寻址

在解决第二个疑问前，再来仔细看下 setB 的函数原型`(void (*)(Basic * const, double))`，这里函数的第一个参数是`Basic*` 指针，而在代码中的调用是这样：`temp.setB(3.14)`。这种用法其实是一种语法糖，**编译器在调用成员函数时自动将当前对象的地址作为this指针传递给了函数的**。

```c++
(gdb) p &Basic::setB(double)
$7 = (void (*)(Basic * const, double)) 0x5555555551d2 <Basic::setB(double)>
```

**这里参数传递了对象的地址，但是在函数里面是怎么拿到成员变量 b 的地址呢？**我们在调用 setB 的地方打断点，执行到断点后，用 step 进入到函数，然后查看相应寄存器的值和汇编代码。整个过程如下图：

![成员方法找到变量地址的汇编代码](https://slefboot-1251736664.file.myqcloud.com/20240330_c++_object_model_method_disassemble.png)

这里的汇编代码**展示了如何通过 this指针和偏移量访问b**。可以分为两部分，第一部分是处理 this 指针和参数，第二部分是找到成 b 的内存位置然后进行赋值。

**参数传递部分**。这里`mov %rdi,-0x8(%rbp)`将 this 指针（通过rdi寄存器传入）保存到栈上。将 double 类型的参数value 通过xmm0寄存器传入保存到栈上。这里是 x86_64 机器下 GCC 编译器的传参规定，我们可以通过打印 `$rdi` 保存的地址来验证确实是 temp 对象的开始地址。

**对象赋值部分**。`mov -0x8(%rbp),%rax` 将this指针从栈上加载到 rax 寄存器中。`movsd -0x10(%rbp),%xmm0` 将参数value从栈上重新加载到xmm0寄存器中。`movsd %xmm0,0x8(%rax)` 将value写入到this对象的 b 成员。这里 `0x8(%rax)` 表示rax（即this指针）**加上8字节的偏移，这个偏移正是成员变量b在Basic对象中的位置**。

这个偏移是什么时候，怎么算出来的呢？其实成员变量的地址相对于对象地址是固定的，对象的地址加上成员变量在对象内的偏移量就是成员变量的实际地址。**编译器在编译时，基于类定义中成员变量的声明顺序和编译器的内存布局规则，计算每个成员变量相对于对象起始地址的偏移量。**这使得在运行时，通过基地址（即对象的地址）加上偏移量，就能够计算出每个成员变量的准确地址。这个过程对于程序员来说是透明的，由编译器和运行时系统自动处理。

### 函数调用约定与优化

上面的汇编代码中，setB 的两个参数，都是从寄存器先放到栈上，接着又从栈上放到寄存器进行操作，**为什么要移来移去多此一举呢**？要回答这个问题，需要先了解函数的调用约定和寄存器使用。在x86_64架构的系统调用约定中，前几个整数或指针参数通常通过寄存器（如rdi, rsi, rdx, 等）传递，而浮点参数通过 xmm0 到 xmm7 寄存器传递。这种约定目的是为了**提高函数调用的效率**，因为使用寄存器传递参数比使用栈更快。

而将寄存器上的参数又移动到栈上，是为了**保证寄存器中的值不被覆盖**。因为寄存器是有限的资源，在函数中可能会被多次用于不同的目的。将值保存到栈上可以让函数内部自由地使用寄存器，而不必担心覆盖调用者的数据。

接着又将`-0x8(%rbp)` 放到 rax 寄存器，然后再通过`movsd %xmm0,0x8(%rax)`写入成员变量b的值，为啥不直接从`xmm0`寄存器写到基于rbp的偏移地址呢？这是因为 x86_64 的指令集和其操作模式通常支持使用**寄存器间接寻址方式访问数据**。使用`rax`等通用寄存器作为中间步骤，是一种更通用和兼容的方法。

上面的汇编是在**没有开启优化**的情况下，所以编译器采用了直接但效率不是最高的代码生成策略，包括将参数和局部变量频繁地在栈与寄存器间移动。**而编译器的优化策略可能会影响参数的处理方式**。如果我们开启编译优化，如下：

```shell
$ g++ basic_method.cpp -o basic_method_O2 -O2 -g -std=c++11
```

生成的 main 函数汇编部分如下：

```gdb
(gdb) disassemble /m main
=> 0x0000555555555060 <+0>:	xor    %eax,%eax
   0x0000555555555062 <+2>:	ret
   0x0000555555555063:	data16 nopw %cs:0x0(%rax,%rax,1)
   0x000055555555506e:	xchg   %ax,%ax
```

在 `O2` 优化级别下，编译器认定main函数中的所有操作（包括创建Basic对象和对其成员变量的赋值操作）对程序的最终结果没有影响，因此它们都被优化掉了。这是编译器的“**死代码消除**”，直接移除那些不影响程序输出的代码部分。

## 特殊成员内存分布

上面的成员都是 public 的，如果是 private(私有) 变量，私有方法呢？另外，静态成员变量或者静态成员方法，在内存中又是怎么布局呢？
### 私有成员

先来看私有成员，接着上面的例子，增加私有成员变量和方法。整体代码如下：

```c++
#include <iostream>

class Basic {
public:
    int a;
    double b;

    void setB(double value) {
        b = value; // 直接访问成员变量b
	secret(b);
    }
private:
    int c;
    double d;

    void secret(int temp) {
        d = temp + c;
    }
};

int main() {
    Basic temp;
    temp.a = 10;
    temp.setB(3.14);
    return 0;
}
```

编译之后，通过 GDB，可以打印出所有成员变量的地址，发现这里**私有变量的内存布局并没有什么特殊地方，也是依次顺序存储在对象**中。私有的方法也没有特殊地方，一样存储在文本段。整体布局如下如：

![]()

那么 **private 是在运行期还是编译期进行可见性控制的**呢？首先编译期肯定是有保护的，这个很容易验证，我们无法直接访问 temp.c ，或者调用 secret 方法，因为直接会编译出错。

那么运行期是否有保护呢？我们来验证下。前面已经验证 private 成员变量也是根据偏移来找到内存位置的，我们可以在代码中直接根据偏移找到内存位置并更改里面的值。

```c++
int* pC = reinterpret_cast<int*>(reinterpret_cast<char*>(&temp) + 16);
*pC = 12; // 直接修改c的值
```

这里修改后，可以增加一个show方法打印所有成员的值，发现这里temp.c 确实被改为了 12。私有方法和普通成员方法一样存储在文本段，我们拿到其地址后，可以通过这个地址调用吗？这里需要一些骚操作，我们**在类定义中添加额外的接口来暴露私有成员方法的地址**，然后通过成员函数指针来调用私有成员函数。整体代码如下：

```c++
class Basic {
...
public:
    // 暴露私有成员方法的地址
    static void (Basic::*getSecretPtr())(int) {
        return &Basic::secret;
    }

...
}

int main() {
    // ...
   void (Basic::*funcPtr)(int) = Basic::getSecretPtr();
    // 调用私有成员函数
    (temp.*funcPtr)(10);
    // ...
}
```

上面代码正常运行，你可以通过 print 打印调用前后成员变量的值来验证。看来对于成员函数来说，只是编译期不让直接调用，运行期并没有保护，我们可以绕过编译限制在对象外部调用。

当然实际开发中，**千万不要直接通过地址偏移来访问私有成员变量**，也不要通过各种骚操作来访问私有成员方法，这样不仅破坏了类的封装性，而且是不安全的。

### 静态成员

静态成员变量在类的所有实例之间共享，**不管你创建了多少个类的对象，静态成员变量只有一份数据**。

```c++
#include <iostream>

class Basic {
public:
    int a;
    double b;

    void setB(double value) {
        b = value; // 直接访问成员变量b
	secret(b);
    }
private:
    int c;
    double d;

    void secret(int temp) {
        d = temp + c;
    }
public:
    static float alias;
    static void show() {
        std::cout << alias << std::endl;
    }
};

float Basic::alias = 0.233;
int main() {
    Basic temp;
    temp.a = 10;
    temp.setB(3.14);
    temp.show();
    return 0;
}
```


## 继承类的内存布局

### 不带虚函数的继承
### 带有虚函数的继承


## 地址空间布局随机化

前面的例子中，如果用 GDB 多次运行程序，对象的**虚拟内存地址每次都一样**，这是为什么呢？

我们知道现代操作系统中，每个运行的程序都使用**虚拟内存地址空间**，通过操作系统的内存管理单元（MMU）映射到物理内存的。虚拟内存有很多优势，包括**提高安全性、允许更灵活的内存管理等**。为了防止**缓冲区溢出攻击**等安全漏洞，操作系统还会在每次程序启动时**随机化进程的地址空间布局**，这就是地址空间布局随机化（ASLR，[Address Space Layout Randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization)）。

在 Linux 操作系统上，可以通过 `cat /proc/sys/kernel/randomize_va_space` 查看当前系统的 ASLR 是否启用，基本上默认都是开启状态(值为 2)，如果是 0，则是禁用状态。

前面使用 GDB 进行调试时，之所以观察到内存地址是固定不变的，这是因为 GDB 默认禁用了ASLR，以便于调试过程中更容易重现问题。可以在使用 GDB 时启用 ASLR，从而让调试环境更贴近实际运行环境。启动 GDB 后，可以通过下面命令开启地址空间的随机化。

```
(gdb) set disable-randomization off
```

之后再多次运行，这里的地址就会变化了。

![GDB 开启地址空间布局随机化](https://slefboot-1251736664.file.myqcloud.com/20240319_c++_object_model_gdb_disable.png)

## 总结

