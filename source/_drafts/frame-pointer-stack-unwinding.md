---
title: 一文读懂如何利用帧指针进行栈回溯
tags:
  - C++
  - eBPF
category: 计算机基础
toc: true
description: 
date: 
---

在我之前的两篇文章 [深入理解基于 eBPF 的 C/C++ 内存泄漏分析](https://selfboot.cn/2023/11/08/memory_leak_ebpf/) 和 [复杂 C++ 项目堆栈保留以及 eBPF 性能分析](https://selfboot.cn/2023/10/17/c++_frame_pointer/) 中，多次提到过 **eBPF 通过帧指针进行栈回溯**。如果编译后的二进制文件没有带帧指针，那么 eBPF 就无法拿到函数调用栈，很多场景就不能进行有效的分析。

![如何利用帧指针进行栈回溯](https://slefboot-1251736664.file.myqcloud.com/20231117_frame_pointer_stack_unwinding_index.png)

那么如何根据帧指针进行栈回溯呢？本篇文章从理解函数调用栈，寄存器基础，汇编代码等基础开始，一步步带你理解帧指针回溯的过程。

<!-- more -->

## 理解调用栈

函数的调用栈（Call Stack），是计算机程序在执行函数调用时用来存储有关活动函数的信息的数据结构。它是一个特殊的**栈数据结构**，后进先出，用于管理函数的调用顺序和局部变量的存储。最后被调用的函数的信息位于栈顶，最先被调用的函数的信息位于栈底。函数调用栈的结构可以抽象为下图：

![调用栈的结构，图片来自 WIKI](https://slefboot-1251736664.file.myqcloud.com/20231117_frame_pointer_stack_unwinding_wiki.svg)

上图中左侧标出每个函数的栈帧，从上一个函数的返回地址开始，直到调用下一个函数或者返回。右侧的 `STACK ORIGIN` 指向的是入口函数，`STACK POINTER` 指向的是当前栈顶。右侧每行地址对应的数字，代表内存地址，Linux 下 C++进程的栈空间地址是从高地址向低地址增长的，所以栈顶的地址是最小的。

函数栈的主要作用有下面这些：

1. **存储函数返回地址**：当一个函数调用另一个函数时，它会将返回地址（即调用函数中调用点的下一条指令的地址）压入调用栈。这样，被调用函数完成执行后，程序知道从哪里继续执行。
2. **管理局部变量**：每个函数调用都会在调用栈上分配一段空间（称为栈帧），用于存储其局部变量和一些必要的信息。
3. **记录函数调用顺序**：调用栈记录了程序的函数调用顺序。每当一个新的函数被调用时，一个新的栈帧就被压入栈顶；当函数返回时，其对应的栈帧就被弹出。

每个程序在启动时都会被分配一定的栈空间，如果没有限制，**过深的函数调用或过大的局部变量可能会导致栈空间耗尽**。所以操作系统对于函数调用栈的大小都有限制，Linux 下一般限制 8MB，可以通过 `ulimit -s` 查看。这里的限制是由操作系统决定的，可以通过 `ulimit -s 10240` 来更改调用栈的限制(不建议)。下面的示例代码中，由于创建了过大的栈局部变量，会导致栈溢出，执行可能会 core 掉。

```c++
void function() {
    int num = 10000000;
    int largeArray[num]; // 大数组，占用更多栈空间
    for(int i=0; i<num; i++){
	largeArray[i]=i;
    }
}
```

## 寄存器基础

在了解函数调用栈后，再来了解下计算机中的寄存器。寄存器是 CPU **内部非常小但速度极快的存储元件，它们是容量有限的、高速的存储资源，用于存储指令、数据和地址**。寄存器直接由CPU内部逻辑电路进行操作，因此它们的访问速度远远快于 RAM 等其他形式的存储(典型的空间换时间)。

早期 X86 的时候，还是 32 位指令集 (IA-32)，一个 CPU 包含一组 8 个存储 32 位值的通用寄存器。到 64 位时代，AMD 设计的 X86-64 将 IA32 扩展到 64 位并且新增加了 8 个寄存器，一共16个通用寄存器，如下：

| 寄存器  | 低32位  | 低16位 | 低8位  | 使用惯例         |
|-------|--------|-------|-------|----------------|
| %rax  | %eax   | %ax   | %al   | 保存返回值       |
| %rbx  | %ebx   | %bx   | %bl   | 被调用者保存     |
| %rcx  | %ecx   | %cx   | %cl   | 第4个参数        |
| %rdx  | %edx   | %dx   | %dl   | 第3个参数        |
| %rsi  | %esi   | %si   | %sil  | 第2个参数        |
| %rdi  | %edi   | %di   | %dil  | 第1个参数        |
| %rbp  | %ebp   | %bp   | %bpl  | 被调用者保存     |
| %rsp  | %esp   | %sp   | %spl  | 栈指针           |
| %r8   | %r8d   | %r8w  | %r8b  | 第5个参数        |
| %r9   | %r9d   | %r9w  | %r9b  | 第6个参数        |
| %r10  | %r10d  | %r10w | %r10b | 调用者保存       |
| %r11  | %r11d  | %r11w | %r11b | 调用者保存       |
| %r12  | %r12d  | %r12w | %r12b | 被调用者保存     |
| %r13  | %r13d  | %r13w | %r13b | 被调用者保存     |
| %r14  | %r14d  | %r14w | %r14b | 被调用者保存     |
| %r15  | %r15d  | %r15w | %r15b | 被调用者保存     |

这里寄存器这一列展示了 64 位的通用寄存器名，低 32/16/8 位列分别展示了相应位寄存器的低 32/16/8 位部分的名称，用于 32/16/8 位操作。使用惯例这一列简单列出这个寄存器的主要作用，其中 `%rax` 通常用于保存函数的返回值，`%rdi, %rsi, %rdx, %rcx, %r8, %r9` 用于按顺序传递函数的前六个参数。

**寄存器组是唯一被所有过程共享的资源，在给定时刻只有一个过程是活动的，因此我们需要确保当一个过程(调用者)调用另一个过程(被调用者)时，被调用者不会覆盖调用者稍后会使用的寄存器值**。为此，X86-64采用了一组统一的寄存器使用惯例，所有过程必须遵循。参考《深入理解计算机系统-3.7.5寄存器中的局部存储空间》。
- 调用者保存寄存器：指当P函数调用Q函数时，该寄存器中的内容由调用者P负责保存，Q可以直接使用该寄存器。
- 被调用者保存寄存器(%rbx, %rbp, %r12 到 %r15)：指当 P 函数调用 Q 函数时，该寄存器中的内容由被调用者 Q 负责保存，Q 在使用这些寄存器前应当先把这些寄存器内的值存入栈中，Q 返回之前应当将对应的值从栈中恢复到寄存器上。

这里重点再提下本文用的最多的三个寄存器：

- rsp (Stack Pointer)：栈指针寄存器，用于指向当前的栈顶。在函数调用和返回过程中，rsp 用于定位参数、局部变量和返回地址。
- rip (Instruction Pointer)：指令指针寄存器，用于指向当前正在执行的指令。rip 在程序执行过程中自动更新，指向下一条要执行的指令。
- rbp (Base Pointer)：基指针寄存器，通常用于指向函数的栈帧的开始，可以固定访问函数的参数和局部变量的位置，即便是在栈的其他部分发生变化时。

## 看懂汇编代码

要想真正理解函数调用栈帧，还必须能看懂汇编指令。汇编语言有两种主要的语法风格：Intel 语法和 AT&T 语法。它们在**语法结构、操作数的顺序、寄存器名称和指令后缀**等方面有所不同。主要区别如下：

| 特征  | Intel 语法    | AT&T 语法   |
|-------|-------|--------|
| 操作数顺序 | oper	destination, source | oper source, destination |
| 寄存器名称 | 寄存器前不加前缀   | 寄存器前加 `%` 前缀    |
| 立即数    | 十六进制数以 `0x` 开头  | 立即数前加 `$`，十六进制数以 `0x` 开头            |
| 内存操作  | 使用 `[ ]` 表示内存地址 | 使用 `()` 表示内存地址，并且地址计算方式不同       |
| 指令后缀  | 无 | 指令带有操作数大小后缀，如 `b`（byte）、`w`（word）、`l`（long）、`q`（quad） |
| 指令示例 | mov rbp, rsp  | mov %rsp, %rbp |

本文的汇编指令都以 AT&T 格式展示。在 Intel x86 处理器上，GDB 默认显示汇编指令格式是 AT&T，可以使用 `disassemble /m func` 命令来查看某个函数的汇编指令。

![简单 main 函数用 gdb disassemble 拿到的汇编代码](https://slefboot-1251736664.file.myqcloud.com/20231109_frame_pointer_stack_unwinding_disassemble.png)

注意上面是 gdb 中 `disassemble /m main` 拿到的汇编指令，用 `gcc -S` 也可以生成汇编代码，两者可能会有不同，不过不影响具体执行。也可以在 [godbolt](https://godbolt.org/) 在线为 C++ 代码生成汇编代码，这里可以选择不同的 gcc 版本，也可以选择不同指令风格。在线版有个好处就是，鼠标点击相应的汇编，会对应到相应的代码，还会提示这个汇编代码具体做什么的。

![在线工具 godbolt 拿到的汇编指令](https://slefboot-1251736664.file.myqcloud.com/20231110_frame_pointer_stack_unwinding_online.png)

对于 main 函数，虽然代码只有 3 行，但是 gdb 通过 disassemble /m main 拿到的汇编指令还不少，不过不用怕，这里的指令作用可以细分为 5 类。

**栈帧操作指令**

`push %rbp`: 将帧指针寄存器（rbp）的当前值压入栈，这是**在新的函数调用中保存旧的基指针值的标准做法**。
`mov %rsp, %rbp`: 将栈指针（rsp）的当前值复制到基指针（rbp）中。这样做是为了设置一个新的堆栈帧基点，方便之后通过基指针引用局部变量和函数参数。
`sub $0x10, %rsp`: 从栈指针（rsp）中减去 16（0x10），为局部变量分配栈空间。
`leave`: 在函数结束时，需要清理栈帧并恢复 rbp 和 rsp 的值，以便返回到调用者的上下文。简而言之，leave 指令是`mov %rbp, %rsp` 和 `pop %rbp` 两个操作的结合体。这个指令的作用是撤销栈帧，恢复 rbp 和 rsp 寄存器到调用当前函数之前的状态。

**函数调用指令**

`call 0x5555555553ea <_Z3fooi>`: 调用地址为 0x5555555553ea 的函数（C++函数foo的名称修饰后的版本），**调用前会将返回地址（下一条指令的地址）压入栈**。在 x86 架构的汇编指令中，**call 指令会自动将返回地址压入栈**。这是 call 指令的内置行为，不需要显式的汇编指令来执行这个操作。

`call 0x555555555100 <_ZNSolsEi@plt>`, `call 0x5555555550c0 <_ZNSolsEPFRSoS_E@plt>`: 调用地址为 0x555555555100 和 0x5555555550c0 的函数，这两个地址分别对应着C++的流操作函数，用于将整数和 std::endl 输出到 std::cout。

**数据移动指令**

`mov $0x5, %edi`: 将立即数(也就是代理里的数字常量)5移动到 edi 寄存器中，作为即将调用的函数foo的参数。这里 64 位下会优先用寄存器来存函数调用的参数。
`mov %eax, -0x4(%rbp)`: 将eax寄存器中的值（foo函数的返回值）移动到基指针（rbp）偏移 -4 的位置，也就是 main 函数的result 变量的存储位置。

**地址计算指令**

`lea 0x2b94(%rip), %rax`: 这条lea（**Load Effective Address**，加载有效地址）指令计算并加载一个相对于当前指令指针（rip）的偏移地址到 rax 寄存器。通常用于引用全局变量、数组元素或者是函数的地址。

**函数返回**

`ret`: 从函数返回，这会弹出并跳转到堆栈上的返回地址，继续执行调用这个函数的代码流程。

关于汇编指令，知道这些内容基本就够了。

## 帧指针回溯

接下来终于到了本文的重心部分，如何根据帧指针，来进行函数的调用栈回溯。首先我们写一个简单的示例程序，进入 main 函数，调用 foo，foo 又接着调用 bar，bar 最终调用 hello。这里有一个完整的函数调用栈：main->foor->bar->hello，后续分析都会基于这个程序进行。

```c++
#include <iostream>
#include <string>

void hello(const std::string &c) {
    std::cout << c << std::endl;
}

int bar(int num, int age) {
    std::string demo = "num: " + std::to_string(num) + ", age: " + std::to_string(age);
    hello(demo);
    return 0;
}

int foo(int a) {
    int result = bar(a, 3);
    return result;
}

int main() {
    int result = foo(5);
    std::cout << result << std::endl;
    return 0;
}
```

这里编译的时候，记得带上栈信息，编译命令如下：

```shell
$ g++ -g -fno-omit-frame-pointer -o main test.cpp
```

接下来我们用 GDB 跟踪执行过程中，函数栈的内存空间分布。

## 参考

[如何阅读简单的汇编](https://zhuanlan.zhihu.com/p/368962727)
[AT&T Assembly Syntax](https://csiflabs.cs.ucdavis.edu/~ssdavis/50/att-syntax.htm)
[深入研究goroutine栈](https://www.huamo.online/2019/06/25/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6goroutine%E6%A0%88/)