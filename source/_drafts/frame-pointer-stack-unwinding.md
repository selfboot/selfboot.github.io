---
title: 一文读懂如何利用帧指针进行栈回溯
tags:
  - C++
  - eBPF
category: 计算机基础
toc: true
description: 
date: 
---


## 理解调用栈


## 寄存器基础

计算机中的寄存器是 CPU 内部非常小但速度极快的存储位置。它们是容量有限的、高速的存储资源，用于存储指令、数据和地址。寄存器直接由CPU内部逻辑电路进行操作，因此它们的访问速度远远快于 RAM 等其他形式的存储。

早期 X86 的时候，还是 32 位指令集 (IA-32)，一个 CPU 包含一组 8 个存储 32 位值的通用寄存器。到 64 位时代，AMD 设计的 X86-64 将 IA32 扩展到 64 位并且新增加了 8 个寄存器，一共16个通用寄存器，如下：

| 寄存器  | 低32位  | 低16位 | 低8位  | 使用惯例         |
|-------|--------|-------|-------|----------------|
| %rax  | %eax   | %ax   | %al   | 保存返回值       |
| %rbx  | %ebx   | %bx   | %bl   | 被调用者保存     |
| %rcx  | %ecx   | %cx   | %cl   | 第4个参数        |
| %rdx  | %edx   | %dx   | %dl   | 第3个参数        |
| %rsi  | %esi   | %si   | %sil  | 第2个参数        |
| %rdi  | %edi   | %di   | %dil  | 第1个参数        |
| %rbp  | %ebp   | %bp   | %bpl  | 被调用者保存     |
| %rsp  | %esp   | %sp   | %spl  | 栈指针           |
| %r8   | %r8d   | %r8w  | %r8b  | 第5个参数        |
| %r9   | %r9d   | %r9w  | %r9b  | 第6个参数        |
| %r10  | %r10d  | %r10w | %r10b | 调用者保存       |
| %r11  | %r11d  | %r11w | %r11b | 调用者保存       |
| %r12  | %r12d  | %r12w | %r12b | 被调用者保存     |
| %r13  | %r13d  | %r13w | %r13b | 被调用者保存     |
| %r14  | %r14d  | %r14w | %r14b | 被调用者保存     |
| %r15  | %r15d  | %r15w | %r15b | 被调用者保存     |

这里寄存器这一列展示了 64 位的通用寄存器名，低 32/16/8 位列分别展示了相应位寄存器的低 32/16/8 位部分的名称，用于 32/16/8 位操作。使用惯例这一列简单列出这个寄存器的主要作用，其中 `%rax` 通常用于保存函数的返回值，`%rdi, %rsi, %rdx, %rcx, %r8, %r9` 用于按顺序传递函数的前六个参数。

**寄存器组是唯一被所有过程共享的资源，在给定时刻只有一个过程是活动的，因此我们需要确保当一个过程(调用者)调用另一个过程(被调用者)时，被调用者不会覆盖调用者稍后会使用的寄存器值**。为此，X86-64采用了一组统一的寄存器使用惯例，所有过程必须遵循。参考《深入理解计算机系统-3.7.5寄存器中的局部存储空间》。
- 调用者保存寄存器：指当P函数调用Q函数时，该寄存器中的内容由调用者P负责保存，Q可以直接使用该寄存器。
- 被调用者保存寄存器(%rbx, %rbp, %r12 到 %r15)：指当 P 函数调用 Q 函数时，该寄存器中的内容由被调用者 Q 负责保存，Q 在使用这些寄存器前应当先把这些寄存器内的值存入栈中，Q 返回之前应当将对应的值从栈中恢复到寄存器上。

这里重点再提下本文用的最多的三个寄存器：

- rsp (Stack Pointer)：栈指针寄存器，用于指向当前的栈顶。在函数调用和返回过程中，rsp 用于定位参数、局部变量和返回地址。
- rip (Instruction Pointer)：指令指针寄存器，用于指向当前正在执行的指令。rip 在程序执行过程中自动更新，指向下一条要执行的指令。
- rbp (Base Pointer)：基指针寄存器，通常用于指向函数的栈帧的开始，可以固定访问函数的参数和局部变量的位置，即便是在栈的其他部分发生变化时。

## 看懂汇编代码

汇编语言有两种主要的语法风格：Intel 语法和 AT&T 语法。它们在**语法结构、操作数的顺序、寄存器名称和指令后缀**等方面有所不同。主要区别如下：

| 特征  | Intel 语法    | AT&T 语法   |
|-------|-------|--------|
| 操作数顺序 | oper	destination, source | oper source, destination |
| 寄存器名称 | 寄存器前不加前缀   | 寄存器前加 `%` 前缀    |
| 立即数    | 十六进制数以 `0x` 开头  | 立即数前加 `$`，十六进制数以 `0x` 开头            |
| 内存操作  | 使用 `[ ]` 表示内存地址 | 使用 `()` 表示内存地址，并且地址计算方式不同       |
| 指令后缀  | 无 | 指令带有操作数大小后缀，如 `b`（byte）、`w`（word）、`l`（long）、`q`（quad） |
| 指令示例 | mov rbp, rsp  | mov %rsp, %rbp |

本文的汇编指令也都以 AT&T 格式展示。在 Intel x86 处理器上，GDB 默认显示汇编指令格式是 AT&T，可以使用 `disassemble /m func` 命令来查看某个函数的汇编指令。

![一个简单 main 函数的汇编代码](https://slefboot-1251736664.file.myqcloud.com/20231109_frame_pointer_stack_unwinding_disassemble.png)

一个只有 3 行代码的 main 函数，汇编指令展开后有那么多，不过不用怕，这里的指令起始可以细分为 5 类。

**栈帧操作指令**

`push %rbp`: 将帧指针寄存器（rbp）的当前值压入栈，这是**在新的函数调用中保存旧的基指针值的标准做法**。
`mov %rsp, %rbp`: 将栈指针（rsp）的当前值复制到基指针（rbp）中。这样做是为了设置一个新的堆栈帧基点，方便之后通过基指针引用局部变量和函数参数。
`sub $0x10, %rsp`: 从栈指针（rsp）中减去 16（0x10），为局部变量分配栈空间。
`leave`: 在函数结束时，需要清理栈帧并恢复 rbp 和 rsp 的值，以便返回到调用者的上下文。简而言之，leave 指令是`mov %rbp, %rsp` 和 `pop %rbp` 两个操作的结合体。这个指令的作用是撤销栈帧，恢复 rbp 和 rsp 寄存器到调用当前函数之前的状态。

**函数调用指令**

`call 0x5555555553ea <_Z3fooi>`: 调用地址为 0x5555555553ea 的函数（C++函数foo的名称修饰后的版本），**调用前会将返回地址（下一条指令的地址）压入栈**。在 x86 架构的汇编指令中，**call 指令会自动将返回地址压入栈**。这是 call 指令的内置行为，不需要显式的汇编指令来执行这个操作。

`call 0x555555555100 <_ZNSolsEi@plt>`, `call 0x5555555550c0 <_ZNSolsEPFRSoS_E@plt>`: 调用地址为 0x555555555100 和 0x5555555550c0 的函数，这两个地址分别对应着C++的流操作函数，用于将整数和 std::endl 输出到 std::cout。

**数据移动指令**

`mov $0x5, %edi`: 将立即数(也就是代理里的数字常量)5移动到 edi 寄存器中，作为即将调用的函数foo的参数。这里 64 位下会优先用寄存器来存函数调用的参数。
`mov %eax, -0x4(%rbp)`: 将eax寄存器中的值（foo函数的返回值）移动到基指针（rbp）偏移 -4 的位置，也就是 main 函数的result 变量的存储位置。

**地址计算指令**

`lea 0x2b94(%rip), %rax`: 这条lea（**Load Effective Address**，加载有效地址）指令计算并加载一个相对于当前指令指针（rip）的偏移地址到 rax 寄存器。通常用于引用全局变量、数组元素或者是函数的地址。

**函数返回**

`ret`: 从函数返回，这会弹出并跳转到堆栈上的返回地址，继续执行调用这个函数的代码流程。

## 帧指针回溯


## 参考

[如何阅读简单的汇编](https://zhuanlan.zhihu.com/p/368962727)
[AT&T Assembly Syntax](https://csiflabs.cs.ucdavis.edu/~ssdavis/50/att-syntax.htm)
[深入研究goroutine栈](https://www.huamo.online/2019/06/25/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6goroutine%E6%A0%88/)