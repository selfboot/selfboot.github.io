---
title: LevelDB 源码阅读：如何分析跳表的时间复杂度？
tags: [C++]
category: 源码剖析
toc: true
date: 2024-09-15 21:00:00
mathjax: true
description: 
---

在上篇 [LevelDB 源码阅读：跳表的原理、实现以及可视化](https://selfboot.cn/2024/09/09/leveldb_source_skiplist/)中，详细分析了 LevelDB 中跳表的实现。然后在 [LevelDB 源码阅读：如何正确测试跳表的并行读写？](https://selfboot.cn/2024/09/18/leveldb_source_skiplist_test/) 中，分析了 LevelDB 跳表的测试代码，最后还剩下一个问题，怎么分析跳表的时间复杂度呢？

## 跳表性能分析拆解

在知道 LevelDB 的原理和实现后，我们可以推测出来，在极端情况下，每个节点的高度都是 1，那么跳表的查找、插入、删除操作的时间复杂度都会退化到 O(n)。在这种情况下，性能比平衡树差了不少。当然，因为有随机性在里面，所以**没有输入序列能始终导致性能最差**。

那么跳表的平均性能如何呢？前面给出过结论，和平衡树的平均性能差不多。引入一个简单的随机高度，就能保证跳表的平均性能和平衡树差不多。**这背后有没有什么分析方法，能够分析跳表的性能呢**？

<!-- more -->

还得看论文，论文中给出了一个不错的分析方法，不过这里的思路其实有点难想到，理解起来也有点费劲。我会把问题尽量拆分，然后一步步来推导整个过程，每一步涉及到的数学推导也尽量给出来。哈哈，**这不就是思维链嘛，拆解问题并逐步推理，是人和 AI 解决复杂问题的必备技能啊**。这里的推导可以分为几个小问题：

1. 跳表的查找、插入和删除操作，哪部分操作最影响耗时？
2. 对于查找操作，假设从任意层 k 开始往下找，这里的平均复杂度是多少(遍历多少次)？ 
3. 有没有什么办法，可以在链表中**找到某个层数**，从这层开始查找的遍历次数能代表平均性能？
4. 能不能找到一个公式，来计算总的时间复杂度，并算出这里的平均复杂度上限？

好了，下面我们逐个问题分析。

## 跳表操作瓶颈

第一个小问题比较简单。在前文讲跳表的原理和实现中，我们知道，对于插入和删除操作，也需要先通过查找操作找到对应的位置。之后就是几个指针操作，代价都是常量时间，可以忽略。所以，**跳表操作的时间复杂度就是看查找操作的复杂度**。

查找操作的过程就是往右，往下搜索跳表，直到找到目标元素。如果我们能知道这里搜索的平均复杂度，那么就可以知道跳表操作的平均复杂度。直接分析查找操作的平均复杂度，有点无从下手。按照 LevelDB 里面的实现，每次是从**当前跳表中节点的最高层数**开始找。但是节点高度是随机的，最高层数也是随机的，似乎没法分析从随机高度开始的查找操作的平均复杂度。

## 跳 k 层的期望步数

先放弃直接分析，来尝试回答前面第二个问题。**假设从任意层 k 开始往下找，平均要多少次才能找到目标位置**呢？这里的分析思路比较跳跃，我们**反过来分析从目标位置，往上往左查找，平均要多少步才能往上查 k 层。并且假设链表中节点高度是在反向查找过程中，根据概率 p 来随机决定的**。

这种假设和分析过程得到的平均查找次数和**真实查找情况等价**吗？我们知道往右往下执行查找的时候，节点的高度都是已经决定的了。但是考虑到节点的高度本来就是随机决定的，**假设反向查找时候来决定高度，并且逆向整个搜索过程，在统计上没有什么不同**。

接下来我们假设**当前处在节点 x 的任意一层 i (下图中的情形 a)，从这个位置往上查 k 层置需要 $ C(k) $ 步**。我们不知道节点 x 上面还有没有层，也不知道节点 x 的左边还有没有节点(下图中**用阴影问号**表示这种未知)。再假设 x 不是 header 节点，左边还有节点（其实这里分析的话可以假设左边有无穷多节点）。

![LevelDB 时间复杂度分析从 K 层查找复杂度(图片来自论文)](https://slefboot-1251736664.file.myqcloud.com/20240914_leveldb_source_skiplist_more.png)

那么整个链表的节点情况有两种可能，整体如上图：

- 情形 b: 节点 x 一共就是 i 层，在左边有节点，查找的时候需要从左边节点的第 i 层水平跳到 x 的第 i 层。逆向分析的话，因为按照 $ p $ 的概率决定是否有更高层，所以这里处于情形 b 的概率是 $ 1 - p $。然后**左边节点和 x 在同一层，往上查 k 层仍然需要 $ C(k) $ 步**。因此这种情况下期望的查找步数是: $ (1 - p) * (C(k) + 1) $。
- 情形 c: 节点 x 层高大于 i，那么查找的时候需要从 x 的第 i+1 层往下跳到第 i 层。逆向分析的话，因为按照 $ p $ 的概率决定是否有更高层，所以这里处于情形 c 的概率是 $ p $。然后**从 i+1 层往上查 k 层，等价于从第 i 层往上查找 k-1 层，需要 $ C(k-1) $ 步**。因此期望的查找步数是: $ p * (C(k-1) + 1) $。

也就是说，对于从任意层 i 开始查找，往上跳 $ k $ 层需要的期望步数为：

$$
C(k) = (1 - p) * (C(k) + 1) + p * (C(k-1) + 1)
$$

化简这个方程得到下面结果：

$$
C(k) = 1/p + C(k-1)
$$

$$
C(k) = k/p
$$

这里从任意层 i 开始查找往上跳 k 层需要的期望步数 $ k/p $ ，也等价于从第 k 层开始正常步骤查找，到最底层目标位置需要的期望步数。这个公式很重要，只要**理解了这里的逆向分析步骤，最后公式也比较好推导出来**。但是用这个公式还是没法直接分析出跳表的平均性能，中间缺少了点什么。

## 找到特殊层

从[跳表的实现中](https://selfboot.cn/2024/09/09/leveldb_source_skiplist/)可以知道跳表中节点的层高是随机的，**对于其中某层，可能有多个节点，越往上层，节点数越少**。理想情况下，查找的时候可以从只有一个节点的层开始往下往右查找，这样需要的查询代价是最少的。

## 总结
