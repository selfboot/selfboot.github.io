---
title: LevelDB 源码阅读：如何分析跳表的时间复杂度？
tags: [C++]
category: 源码剖析
toc: true
date: 2024-09-15 21:00:00
mathjax: true
description: 
---

在上篇 [LevelDB 源码阅读：跳表的原理、实现以及可视化](https://selfboot.cn/2024/09/09/leveldb_source_skiplist/)中，详细分析了 LevelDB 中跳表的实现。然后在 [LevelDB 源码阅读：如何正确测试跳表的并行读写？](https://selfboot.cn/2024/09/18/leveldb_source_skiplist_test/) 中，分析了 LevelDB 跳表的测试代码，最后还剩下一个问题，怎么分析跳表的时间复杂度呢？

<!-- more -->

## 跳表性能分析

在知道 LevelDB 的原理和实现后，我们可以推测出来，在极端情况下，每个节点的高度都是 1，那么跳表的查找、插入、删除操作的时间复杂度都会退化到 O(n)。在这种情况下，性能比平衡树差了不少。当然，因为有随机性在里面，所以**没有输入序列能始终导致性能最差**。

那么跳表的平均性能如何呢？前面给出过结论，和平衡树的平均性能差不多。引入一个简单的随机高度，就能保证跳表的平均性能和平衡树差不多。**这背后有没有什么分析方法，能够分析跳表的性能呢**？

还得看论文，论文中给出了一个不错的分析方法，不过这里的分析思路其实有点难想到，理解起来也有点费劲。我会把问题尽量拆分，然后一步步来推导整个过程，每一步涉及到的数学推导也尽量给出来。哈哈，**这不就是思维链嘛，拆解问题并逐步推理，是人和 AI 解决复杂问题的必备技能啊**。这里的推导可以分为几个小问题：

1. 跳表的查找、插入和删除操作，哪部分操作最影响耗时？
2. 对于查找操作，假设我从第 K 层开始往下找，这里的平均复杂度是多少(遍历多少次)？ 
3. 有没有什么办法，可以在链表中**找到某个层数**，从这层开始查找的遍历次数能代表平均性能？
4. 能不能找到一个公式，来计算总的时间复杂度，并算出这里的平均复杂度上限？

好了，下面我们逐个问题分析。

### 跳表操作瓶颈

第一个小问题比较简单。在前文讲跳表的原理和实现中，我们知道，对于插入和删除操作，也需要先通过查找操作找到对应的位置。之后就是几个指针操作，代价都是常量时间，可以忽略。所以，**跳表操作的时间复杂度就是看查找操作的复杂度**。

查找操作的过程就是往右，往下搜索跳表，直到找到目标元素。如果我们能知道这里搜索的平均复杂度，那么就可以知道跳表操作的平均复杂度。直接分析查找操作的平均复杂度，有点无从下手。按照 LevelDB 里面的实现，每次是从**当前跳表中节点的最高层数**开始找。但是节点高度是随机的，最高层数也是随机的，似乎没法分析从随机高度开始的查找操作的平均复杂度。

### K 层查找的平均复杂度

先放弃直接分析，来尝试回答前面第二个问题。**假设从第 K 层开始往下找，平均要多少次才能找到目标位置**呢？这里的分析思路比较跳跃，我们**反过来分析从目标位置，往上往左查找，平均要多少步才能到第 K 层。并且假设在反向查找的过程中，根据概率 p 来决定每个节点的高度**。

这种假设和分析过程得到的平均查找次数和**真实查找情况等价**吗？我们知道往右往下执行查找的时候，节点的高度都是已经决定的了。但是考虑到节点的高度本来就是随机决定的，反向查找时候来决定高度，在统计上没有什么不同。

接下来我们假设当前处在节点 x 的第 i 层，我们不知道 x 上面还有没有层，也不知道 x 的左边还有没有节点。再假设 x 不是 header 节点，左边还有节点（其实这里分析的话可以假设左边有无穷多节点）。那么一共有两种可能，看下图：

![LevelDB 时间复杂度分析从 K 层查找复杂度](https://slefboot-1251736664.file.myqcloud.com/20240914_leveldb_source_skiplist_more.png)


## 总结
