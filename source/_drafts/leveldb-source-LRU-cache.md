---
title: LevelDB 源码阅读：LRU Cache 的实现艺术
tags: [C++, LevelDB]
category: 源码剖析
toc: true
description: 
---

LRU(Least Recently Used) 是一种经典的缓存淘汰策略，它的核心思想是：**当缓存满了的时候，淘汰掉最近最少使用的数据**。这样可以保证缓存中的数据是最近使用过的，提高缓存命中率。这里基于的一个假设就是“如果数据最近被访问过，那么将来被访问的几率也更高”。

在 LevelDB 中，假设每一次读取 DB 都从磁盘读取数据，那么效率会非常低。因此，LevelDB 支持在内存中维护 LRU Cache，用于缓存热点数据，提高读写性能。默认情况下，LevelDB 会对 sstable 和 data block 进行缓存，其中sstable 默认是 990 (1000-10)个，data block 则默认分配了 8MB 的缓存。

LevelDB 实现了一个分片的 LRU 缓存机制，在细节上做了很多优化，以提高性能和效率，值得学习。本文将从经典 LRU 实现思路出发，探讨 LevelDB 中 LRU Cache 的实现细节。

<!-- more -->

## 经典 LRU 实现思路

一个实现良好的 LRU 需要支持 O(1) 时间复杂度的插入和查找操作。经典实现思路是使用**一个双向链表和一个哈希表**，其中：

- 双向链表：**双向链表用于存储缓存中的数据项，并保持缓存项的使用顺序**。最近被访问的数据项被移动到链表的头部，而最久未被访问的数据项则逐渐移向链表的尾部。当缓存达到容量限制而需要淘汰数据时，链表尾部的数据项（即最少被访问的数据项）会被移除。
- 哈希表：**哈希表用于存储键与双向链表中相应节点的对应关系**，这样任何数据项都可以在常数时间内被快速访问和定位。哈希表的键是数据项的键，值则是指向双向链表中对应节点的指针。

**双向链表保证在常数时间内添加和删除节点，哈希表则提供常数时间的数据访问能力。**对于 Get 操作，通过哈希表快速定位到链表中的节点，如果存在则将其移动到链表头部，更新为最近使用。对于插入 Insert 操作，如果数据已存在，更新数据并移动到链表头部；如果数据不存在，则在链表头部插入新节点，并在哈希表中添加映射，如果超出容量则移除链表尾部节点，并从哈希表中删除相应的映射。

## 对外暴露接口



自定义哈希表：LevelDB 实现了自己的哈希表，这比使用标凑库中的哈希表在某些情况下能有更好的性能。

空间效率：通过动态分配和管理内存，以及在哈希表中使用链表解决冲突，LevelDB 尝试优化空间使用。

线程安全：通过在关键操作周围使用互斥锁，保证了缓存操作的线程安全。

这个实现展示了一个高效的缓存系统是如何设计的，包括对性能、内存使用和线程安全的考虑。


插入（Insert）：当一个新的条目被插入时，会根据其键的哈希值决定放入哪个分片。如果条目的键已存在，旧条目会被替换。插入操作会检查缓存是否超过容量，如果是，则会从LRU列表中移除最老的条目。

查找（Lookup）：通过键的哈希值快速定位到相应的分片，然后在分片的哈希表中查找键对应的条目。如果找到，该条目的引用计数会增加，表示它现在被使用中。

释放（Release）：当客户端完成对缓存条目的使用后，会调用此方法减少条目的引用计数。如果引用计数降到1（仅缓存自己持有引用），条目会被移动到LRU列表。

删除（Erase）：从缓存中移除一个条目。如果条目存在，则它会被从哈希表中删除，并减少其引用计数。

修剪（Prune）：移除所有没有被客户端使用的条目，即清空LRU列表。

容量调整：可以设置缓存的总容量，当插入操作导致总容量超标时，最老的未被使用的条目会被移除。



## 实现细节


LRUHandle：代表缓存中的一个条目，包括值、键、哈希值等信息。它通过一个循环双向链表链接起来，以保持访问时间的顺序。

### HandleTable

一个简单的自定义哈希表，用于快速查找缓存条目，这个哈希表对于提高读取速率特别关键。这个哈希表采用了**分离链表**的方法来解决哈希冲突，即每个桶（bucket）都是一个链表，存储所有哈希值相同的缓存条目。`length_` 表示哈希表桶（bucket）的数量，`elems_` 表示当前存储在哈希表中的元素数量，`list_` 是一个指针数组，每个元素指向一个 LRUHandle 链表（每个桶的头部）。

`Lookup(const Slice& key, uint32_t hash)`：通过给定的键和哈希值来查找元素。它使用 `FindPointer` 方法找到指向对应元素的指针或者是链表末尾的指针（如果元素不存在）。
`Insert(LRUHandle* h)`：向哈希表中插入一个新的 `LRUHandle`。它首先使用 FindPointer 方法找到插入点，然后处理链表的链接关系，最后根据元素数量决定是否需要调整哈希表的大小（通过 Resize 方法）。
`Remove(const Slice& key, uint32_t hash)`：移除一个给定键和哈希值的元素。同样，它使用 FindPointer 方法定位元素，然后从链表中移除该元素。


Resize 方法在 HandleTable 的哈希表中用于调整哈希表大小，这通常发生在插入操作中当元素数量超过当前容量时。目的是为了保持链表的平均长度较小，从而优化查找、插入和删除操作的效率。new_length 初始化为4，然后通过循环不断翻倍直到大于当前元素数量 elems_。具体步骤：

1. 遍历当前哈希表的每个桶（list_ 数组的每个元素），对于每个非空桶，遍历其链表中的所有 LRUHandle 节点。
2. 对于每个 LRUHandle 节点，计算它在新哈希表中的位置，这通过 `hash & (new_length - 1)` 完成，与 FindPointer 方法中使用的逻辑相同。
3. 将当前节点插入到新哈希表的相应位置。这是通过**更新节点的 next_hash 指针以指向当前桶的头部**，然后更新桶的头部以指向当前节点来完成的。这样做会反转链表中节点的顺序，但这对于哈希表的功能没有影响。
4. count 用于跟踪重新哈希过程中已处理的元素数量，以验证所有元素都被正确地迁移到了新的哈希表中。
5. 使用 assert 确保重新哈希的元素数量与原哈希表中的元素数量相同，这是一个调试时的一致性检查，确保迁移过程中没有丢失任何元素。
6. 删除旧的哈希表并将 `list_` 指针更新为指向新的哈希表 `new_list`。同时，更新 length_ 为 new_length，以反映哈希表大小的变化。



假设我们有如下情况：

- h 是当前正在迁移的 LRUHandle 节点。
- new_list 是新的哈希表数组。
- ptr 是一个二级指针，指向new_list中某个桶的头部指针的位置。

在迁移过程中，我们需要将h节点插入到`new_list`的正确位置。为此，我们首先通过哈希值计算出 h 应该位于的桶的位置，并通过`ptr = &new_list[hash & (new_length - 1)];`获取该位置的指针。此时，`*ptr`是指向那个桶头部指针的指针，将h赋值给*ptr实际上是更新那个桶的头部，使其指向h节点。

### LRUCache

LRUCache 是一个 LRU 缓存分片的实现，包含了缓存的核心逻辑，如插入、查找、删除等操作。这个类管理着两个主要的列表：一个是使用中的条目列表（**in_use_**），另一个是最近最少使用的条目列表（**lru_**）。当缓存容量达到上限时，可以根据缓存项在LRU列表中的位置（即它们被访问的历史）来决定哪些缓存项被淘汰。

in_use_ 到 lru_ 的转移：当缓存项的引用计数从2变为1（意味着没有外部引用，仅剩缓存自身的引用）时，它会从 in_use_ 列表中移动到 lru_ 列表中。此时，所有外部引用完成了对缓存项的使用，并调用了 Release 方法手动释放了所有权。
lru_ 到 in_use_ 的转移：当缓存项的引用计数从1变为2时，它会从 lru_ 列表中移动到 in_use_ 列表中。


创建一个新的缓存项（LRUHandle对象），尝试将其加入缓存中，如果加入后超出了缓存的容量上限，则移除最老的缓存项。



`lru_`是一个哑元（dummy node），用作 LRU 链表的头部，**其 next 成员指向 LRU 链表中的第一个实际缓存项**。`lru_.next != &lru_` 这个条件用于检查LRU链表是否为空。如果`lru_.next`等于`&lru_`，意味着LRU链表中没有任何缓存项，即链表只有哑元自身，链表为空。如果不等于，说明链表中至少有一个缓存项。

`哑元（dummy node）`在很多数据结构的实现中被用作简化边界条件处理的技巧。在LRU缓存的上下文中，哑元主要是用来作为链表的头部，这样链表的头部始终存在，即使链表为空时也是如此。这种方法可以简化插入和删除操作，因为在插入和删除操作时**不需要对空链表做特殊处理**。例如，当向链表中添加一个新的元素时，可以直接在哑元和当前的第一个元素之间插入它，而不需要检查链表是否为空。同样，当从链表中删除元素时，你不需要担心删除最后一个元素后如何更新链表头部的问题，因为哑元始终在那里。

在 LRUCache 的实现中，哑元是通过在 LRUCache 类内部声明一个 LRUHandle 类型的成员变量（比如`lru_`）来实现的。在LRUCache的构造函数中，这个哑元会被初始化，其next和prev指针都指向它自己：

```c++
LRUCache::LRUCache() : capacity_(0), usage_(0) {
  // Make empty circular linked lists.
  lru_.next = &lru_;
  lru_.prev = &lru_;
  in_use_.next = &in_use_;
  in_use_.prev = &in_use_;
}
```

Ref 函数的目的是增加给定缓存项 e 的引用计数。当缓存项的引用计数从1变为2时，表示**除了缓存自身对该项的引用之外，现在还有另一个外部引用**（例如，客户端代码正在使用该缓存项）。此时，缓存项从“最近最少使用（LRU）”列表移动到“正在使用（in_use）”列表。



`FinishErase` 函数为了从缓存中彻底移除一个缓存项（LRUHandle对象）。当我们从缓存中移除缓存项时，会需要两个步骤：

1. 从哈希表中移除：确保了后续的缓存访问请求不会再找到这个缓存项。
2. 从LRU链表中移除，并处理相关资源，比如减少总的缓存使用量（usage_），以及减少引用计数（通过Unref方法）。



### ShardedLRUCache

通过将缓存分成多个分片来减少锁的竞争，从而提高性能。它使用Shard()函数根据键的哈希值来决定条目属于哪个分片。
