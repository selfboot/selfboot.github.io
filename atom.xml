<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just For Fun</title>
  <icon>https://www.gravatar.com/avatar/0de0c23d97c75300e32f8494b1485fb8</icon>
  <subtitle>知其然，知其所以然。知识广度是深度的副产品！</subtitle>
  <link href="https://selfboot.cn/atom.xml" rel="self"/>
  
  <link href="https://selfboot.cn/"/>
  <updated>2023-10-16T08:41:36.320Z</updated>
  <id>https://selfboot.cn/</id>
  
  <author>
    <name>FeiZhao</name>
    <email>xuezaigds@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>车辆因交通事故导致贬值损失，可以获得赔偿吗？</title>
    <link href="https://selfboot.cn/2023/10/12/lawer_traffic_accident/"/>
    <id>https://selfboot.cn/2023/10/12/lawer_traffic_accident/</id>
    <published>2023-10-12T19:31:02.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>近几年国内的车辆保有量不断上涨，交通事故发生的次数也越来越多。特别是国庆等节假日，车流量比平时多很多，不小心就会发生交通事故。一旦发生交通事故，车辆难免需要维修，维修费用一般会按照事故责任划分，由责任人或者保险来承担，这部分纠纷比较好处理。</p><p>但是除了维修费用，还有因维修导致的<strong>车辆贬值损失</strong>。对于车辆而言，即使维修后，车辆恢复了原有的功能，但是在二手市场上，这辆车的价值很可能因为事故的记录而比一辆未发生事故的同型号车辆要低。这部分贬值损失需要过错方承担吗？</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231012_lawer_traffic_accident_index.webp" alt="交通事故车辆贬值损失赔偿问题"></p><span id="more"></span><p>在我国的法律体系中，这一问题并<strong>没有明确的规定</strong>，大多时候法院倾向于<strong>过错方不用承担</strong>。从实践中可以看到，如果车辆使用年限较短，行驶里程较少，并且受损部位严重，那么在<strong>一些特定情况下，法院可能会考虑支持车辆贬值损失的赔偿</strong>。本文接下来通过分析最高院的答复，以及具体的案例，来和大家一起聊聊这个问题。</p><h2 id="最高院指导"><a href="#最高院指导" class="headerlink" title="最高院指导"></a>最高院指导</h2><p>关于交通事故车辆贬值损失赔偿，最权威的参考是最高人民法院在 2016年03月04日的一个答复 <a href="https://www.court.gov.cn/zixun/xiangqing/17192.html">《关于“关于交通事故车辆贬值损失赔偿问题的建议”的答复》</a>，如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231012_lawer_traffic_accident_reply.png" alt="关于“关于交通事故车辆贬值损失赔偿问题的建议”的答复"></p><p>总结来说就是，考虑到<strong>我国的道路交通状况、鉴定市场的不规范性以及贬值损失普遍存在</strong>的实际情况，当前的立场是持谨慎态度，<strong>原则上不支持贬值损失的赔偿</strong>。但在某些特殊情况下，仍可能予以适当赔偿。具体是否支持赔偿需根据车辆的行驶情况（购买年限、行驶里程、车辆价值），受损严重程度，受损部位，当事人过错、经济状况、负担能力的具体情形。</p><p>此外要注意的是贬损价值作为间接损失，可能<strong>不在商业保险的赔偿范围内</strong>，需由当事人自行承担，并由第三方机构进行评估。接下来会通过几个实际案例，来看看司法实践中对贬损价值的赔偿责任认定。</p><h2 id="不予赔偿案例"><a href="#不予赔偿案例" class="headerlink" title="不予赔偿案例"></a>不予赔偿案例</h2><p>先来看看不予赔偿的案例。</p><p>在(2022)粤01民终10213号案中，广州市中级人民法院认为，关于车辆贬值损失应否支持的问题，因交通事故造成的财产损失赔偿范围不包括车辆贬值损失。车辆贬值损失并非即时发生的直接损失，若车辆存在贬值损失，<strong>一般在车辆交易过程中才可能明确体现</strong>。尚未发生或可能实际不会发生的车辆交易，无法确定车辆贬值损失价值的大小。本案中，晏山嵘主张的涉案车辆贬值损失12万元没有提交任何依据予以证实。晏山嵘虽在二审中主张按照涉案鉴定评估报告认定的23750元作为贬值损失，同前述，其变更后的该项请求仍因缺乏法律依据不能得到支持。且依据<strong>该评估报告也不能当然等同于该贬值损失已实际发生</strong>，故原审不予支持晏山嵘的该项诉讼请求，并无不当，本院予以维持。</p><p>(2021)京民申4754号案，北京市高级人民法院认为，对于购买年限或行驶里程相对较短的车辆造成严重损害，足以使车辆严重贬值，给车辆所有人造成重大损失的，可酌情赔偿其贬值损失。本案中，王建萍称其车辆受损严重，主张车辆贬值损失，但根据其提交的证据显示，其<strong>车辆更换的部件均为可修复性外观部件及可替换性部件，并未涉及车辆关键部位、关键部件的损坏，未对车辆安全使用性能造成严重影响</strong>。故原审法院驳回王建萍关于车辆贬值损失的诉讼请求，并无不当。王建萍主张的车辆贬值损失鉴定依据不足，一审法院未予准许，亦无不当。</p><h2 id="给予赔偿案例"><a href="#给予赔偿案例" class="headerlink" title="给予赔偿案例"></a>给予赔偿案例</h2><p>最高院的回复里提到某些特殊情况下，仍可能予以适当赔偿。那么司法实践中，具体什么才能认定是特殊情况呢，看下面的两个案例。</p><p>在(2021)京0108民初3924号案中，涉案车辆的购买时间为2019年7月23日，事发时间为2019年7月25日，且于2019年7月27日进厂维修的<strong>行驶里程为316公里</strong>，该车辆的<strong>购买年限及行驶里程均相对较短</strong>；另一方面，涉案车辆的含税购买价格为180800元，而维修价格中的维修备件费用为55845.03元，该费用在购买价格中占比达30%左右，<strong>占比较高</strong>，且涉案车辆虽经维修后不影响使用，但相应的驾驶性能、安全性、使用寿命仍将受到影响，进而会影响车辆的使用价值及交易价值。因此，<strong>本案对于车辆贬值损失，应予以支持</strong>。第二，车辆贬值损失为专门性问题，应通过鉴定予以确认。本案中，中源评估公司具备相应资格，鉴定程序合法，而刘卫国虽不认可该鉴定意见，但未就此提供充分证据，不足以证明该鉴定意见明显依据不足，或存在其他不能作为证据使用的情形，故本院采信该鉴定意见，即本案所涉的<strong>车辆贬值损失数额为37000元</strong>。</p><p>(2021)湘0211民初6541号案，湖南省株洲市天元区人民法院认为，在实践中，对于购买年限较短（<strong>不超过6个月，具体案件具体把握</strong>）或行驶里程相对较少（<strong>不超过5000公里，具体案件具体把握</strong>）的车辆造成严重损害，足以使车辆严重贬值，给车辆所有人造成重大损失的，可酌情赔偿其贬值损失。本案中，案涉车辆注册登记日期为2021年5月6日，于2021年8月22日发生交通事故，属于购买年限较短；案涉车辆修理位置涉及车架，参照中华人民共和国交通运输行业标准《事故汽车修复技术规范》（JT&#x2F;T795-2011）的相关规定，<strong>车架损坏属于一级损伤，案涉车辆维修后的安全性、舒适性、密封性、经济性均会降低。</strong>但同时，考虑到赔偿范围应当主要限于必要的、典型的损失类型，否则容易导致道路交通各方参与人的负担过重，因此<strong>不能完全按评估鉴定机购的鉴定结论予以认定</strong>。综上，本院酌情认定案涉车辆贬值损失（含鉴定费）为4,000元。</p><p>通过以上案例，不难看出只有在车辆使用年限较短，里程数较少，车辆受损严重且有进行贬值鉴定的情况下才<strong>有可能支持车辆折旧费</strong>。而折旧费用一般为几千到几万不等（查看相关案例最高为3万左右），由法院根据车辆价值，当事人过错及负担能力进行酌定。</p><hr><p>我是 <a href="https://selfboot.cn/links">小盛律师</a>，欢迎关注我获取更多法律科普。如果有法律纠纷，欢迎付费咨询。</p><div class="pure-g">  <div class="pure-u-1 pure-u-md-1-3" style="width: auto;">    <img src="https://slefboot-1251736664.file.myqcloud.com/20230914_wx_qrcode_2.png" style="height: 200px; margin-right: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  </div>  <div class="pure-u-1 pure-u-md-1-3" style="width: auto;">    <img src="https://slefboot-1251736664.file.myqcloud.com/20230914_xhs_qrcode_2.png" style="height: 200px; margin-right: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  </div>  <div class="pure-u-1 pure-u-md-1-3" style="width: auto;">    <img src="https://slefboot-1251736664.file.myqcloud.com/20230914_dy_qrcode.png" style="height: 200px; margin-right: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  </div></div>]]></content>
    
    
    <summary type="html">交通事故后，车辆往往需维修，除维修费外，还存在贬值损失。是否应由过错方赔偿?最高院指导持谨慎态度，原则上不支持赔偿。仅购买时间短、里程少、损伤严重等特殊情况下可酌情适当赔偿。本文通过几个案例，剖析司法实践中车辆贬值损失的认定，让广大车主明确自己的权益。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="法律" scheme="https://selfboot.cn/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT 多模态图像识别可以破解验证码？</title>
    <link href="https://selfboot.cn/2023/10/11/chatgpt_recaptcha/"/>
    <id>https://selfboot.cn/2023/10/11/chatgpt_recaptcha/</id>
    <published>2023-10-11T11:12:03.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>验证码已成为我们日常网络生活中不可或缺的一部分，为网站和应用程序提供了一道基本的安全屏障。从最开始的简单数字验证码，到现在的各种奇葩验证码，复杂性在逐步增加，用来抵御自动化工具和机器人的攻击。</p><p>下图展示了部分常见的验证码：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231009_chatgpt_recaptcha.png" alt="各种验证码展示"></p><p>这些验证码存在的唯一目的就是<strong>用来区别人和机器</strong>。然而随着 ChatGPT 大模型崛起，特别是 GPT4-Vision 多模态能力的问世，验证码还能拦截住机器吗？</p><span id="more"></span><p>本文接下来尝试以<a href="https://dun.163.com/trial/sense">网易网盾</a>和 Google 的验证码为例，让 ChatGPT 来尝试进行破解，来看看有了视觉能力的 ChatGPT 到底能不能攻破验证码。</p><h2 id="数字字母验证"><a href="#数字字母验证" class="headerlink" title="数字字母验证"></a>数字字母验证</h2><p>先拿最简单的数字验证码试水，这些验证码其实早就已经被神经网络搞定，不用什么大模型都能轻松识别。不过还是拿出来试试水，看看ChatGPT 表现咋样。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231010_chatgpt_recaptcha_number.png" alt="数字/字母类验证码"></p><p>试了很多个图片，全部识别正确，看来对 ChatGPT 来说是小菜一碟了。微软的<a href="https://browse.arxiv.org/pdf/2309.17421.pdf">LLM 视觉报告</a>里，有专门提到一个 <strong>Scene Text Recognition</strong>，对于图片里的小块文本，确实能识别不错。但是<strong>千万不要觉得 ChatGPT 就有 OCR 能力</strong>，我拿几个文本比较多的图片去让 ChatGPT 识别里面的文字，结果有很多错误，甚至完全是胡编乱造的。</p><h2 id="文字点选"><a href="#文字点选" class="headerlink" title="文字点选"></a>文字点选</h2><p>文字点选验证码是一种常见的验证码形式，它要求用户从一组文字中选择或点击特定的字或词汇来完成验证。这类验证码的主要目的是通过模糊的背景、扭曲的字形、或者叠加的线条来使机器识别变得困难。下面就是一个验证码图片示例，一般会要求按照一定顺序点按里面的文字，比如依次点击“素，晴，韩”三个字。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231010_chatgpt_recaptcha_char.png" alt="文字点选验证码示例"></p><p>如果 ChatGPT 能依次给出三个字的位置，那就能破解了。先尝试了下提示词：</p><blockquote><p>你能依次找到图片里的素，晴，韩 三个字的位置，并给出像素位置吗？</p></blockquote><p>然后告诉我不能直接返回图片中文字的像素位置，不过它用相对位置来描述这几个字，可惜的是这里的位置也是不对的。给的结果如下：</p><ul><li>“素”字位于图片的左上方，近中心的左侧。</li><li>“晴”字位于图片的中上方，稍微偏右。</li><li>“韩”字位于图片的上方，接近右上角。</li></ul><p>试了其他提示词：</p><blockquote><p>你是一个中文识别专家，先依次找出图片里面的中文文字，识别出对应的位置。然后按照顺序依次给出素，晴，韩 三个字的位置。</p><p>你是一个中文变形字识别专家，先一步步找出图片里面所有中文文字，识别出对应的位置。注意这里的文字可能有变形，旋转，扭曲等操作。最后按照顺序依次给出素，晴，韩 三个字的位置。</p></blockquote><p>这些提示词 ChatGPT 都给出了<strong>错误的空间位置</strong>。不过微软的<a href="https://browse.arxiv.org/pdf/2309.17421.pdf">LLM 视觉报告</a>里有一节 <strong>Object Localization</strong>，里面有识别图片中物体位置的示例，看起来 ChatGPT 还是有希望做到。于是换了下提示词：</p><blockquote><p>先确定上面图片的尺寸，然后用一个方框定位图片里所有中文字的位置，最后依次输出素，晴，韩 三个字的位置。</p></blockquote><p>这次的效果好了不少，给出图片尺寸为 314x638 像素，然后也给出了中文字的大致定位框（可惜也不是很准确）：</p><ul><li>“素” 左上角 (15, 20)，右下角 (65, 85)</li><li>“日” 左上角 (85, 30)，右下角 (125, 95) </li><li>“晴” 左上角 (130, 70)，右下角 (170, 135)</li><li>“云” 左上角 (250, 25)，右下角 (290, 90)</li><li>“韩” 左上角 (230, 70)，右下角 (280, 135)</li></ul><p>定位框位置不对，识别出的文字也不准，试了其他几张，效果也都不好。</p><h2 id="图标点选"><a href="#图标点选" class="headerlink" title="图标点选"></a>图标点选</h2><p>图标点选验证码是近年来逐渐受到欢迎的验证方式，其核心思想是要求用户<strong>从一组图标中选择或点击特定的图像</strong>来完成验证。这类验证码通常会用到动物、物品、交通工具等日常图像，并可能对它们进行某种变形或扭曲，使得自动化工具难以直接识别。与文字点选相比，图标点选为识别带来了更大的挑战。因为图像的多样性、颜色、形状以及可能的扭曲都增加了验证码的复杂性。</p><p>下面是一个图标点选验证码例子：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231010_chatgpt_recaptcha_logo.png" alt="图标点选验证码示例"></p><p>简单提示词如下：</p><blockquote><p>这个图片下面一行有三个图标，你能在上面的图片里找到相应的位置吗</p></blockquote><p>简单提示得到的效果不行，ChatGPT 虽然知道我们的意图，也识别出来了下面一行的三个图标，还给它们实体化为：房子、书籍和相机，但是给出的位置信息是错误的，基本不可用。</p><p>用 <strong>Object Localization</strong> 里面的方法，修改了下提示词如下，效果还是不行。</p><blockquote><p>先确定上面图片的尺寸，在图片最下面一行有 3 个图标，用方框定位这些方框在图片里的位置，最后输出位置。</p></blockquote><p>看来图标点选依旧没法破解。</p><h2 id="空间推理"><a href="#空间推理" class="headerlink" title="空间推理"></a>空间推理</h2><p>空间推理验证码是一种新兴的验证方式，它融合了传统验证码的识别要求与<strong>用户的空间认知能力</strong>。这种验证码不再仅仅是选择或识别，它要求用户根据给定的空间条件或关系进行逻辑推理，从而找出正确的答案。下面是网易的一个空间推理验证码：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231011_chatgpt_recaptcha_spatial_reasoning.png" alt="空间推理验证码示例"></p><p>这个验证码需要找到“和绿色大写E朝向一样的大写W”，直接拿这个来问 ChatGPT 的话，得到的并不正确(和绿色大写E朝向一样的大写W位于图片的中间右侧)，虽然看起来找到了 W，但是方向不对。继续用 Object Localization 的方法，经过几轮沟通，发现了一个还算可以的提示词：</p><blockquote><p>先确定上面图片的尺寸，然后用一个方框定位图片里所有字母的位置，然后给出和<strong>绿色大写E朝向一样的大写W</strong> 的位置，注意这里字母位置是说字母的摆放角度朝向。</p></blockquote><p>这里关键在于后面强调要注意“<strong>字母的摆放角度朝向</strong>”。不过就算是加了对方位的特别强调，识别结果也不稳定，有的图片还是识别不对。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231011_chatgpt_recaptcha_spatial_reasoning_right.png" alt="空间推理验证码识别正确的例子"></p><p>这个是识别正确的例子，不过要注意的是，这里给出的定位框其实不一定特别精确，这个问题暂时还没啥好办法解决。</p><h2 id="Google-验证码"><a href="#Google-验证码" class="headerlink" title="Google 验证码"></a>Google 验证码</h2><p>说到验证码，不得不提及那个让无数网民又爱又恨的 <strong>Google 验证码</strong>。每次给出一堆图片让你选，一系列的交通信号灯、斑马线、公交车和商店标志，费力看都不一定选对。比如下面这张：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231011_chatgpt_recaptcha_google.png" alt="Google 的验证码示例"></p><p>这次先偷个懒，直接用提示词：</p><blockquote><p>先识别图片上方的文字任务，然后在下方的图片中找到符号要求的块。</p></blockquote><p>得到的不完全正确，ChatGPT 认为含有消防栓的图片是：</p><ul><li>第一行的第一张图（黄色的消防栓）。</li><li>第二行的第三张图（黄色的消防栓，背景有红白相间的道路标记）。</li></ul><p>再次优化下提示词：</p><blockquote><p>这里是一个 3*3图片，每一个小方块里面是一个图片，请选择包含消防栓的所有小图片，并给出具体小方块的位置。</p></blockquote><p>还是和上次一样的答案，认为第二行第三张是黄色消防栓。不过你要提示它错了的话，它又能很快纠正说第二行第二张才是。换了几个验证码图片，识别的正确率不是很高。</p><p>对了，这里如果想触发 Google 的验证码，最简单的方式就是在浏览器的隐身模式下打开 <a href="https://www.google.com/recaptcha/api2/demo">demo</a> 网址即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文前面的实验中，尝试使用 ChatGPT 来破解多种常见的验证码，从最基础的数字和字母识别，到稍微复杂的文字点选、图标点选，再到更为复杂的空间推理和 Google 验证码。可以看到，尽管 ChatGPT 具有强大的多模态能力，但在验证码识别这一领域中，它仍然面临许多挑战。对于简单的数字和字母验证码，ChatGPT 表现得相对出色，能够准确地识别出文字内容。但当涉及到更为复杂的验证码时，并不能稳定的识别成功。</p><p>目前阶段如果想稳定破解验证码，貌似只有通过打码平台，毕竟又便宜效果又稳定。不过随着技术的不断进步，我相信 ChatGPT 以及其他 AI 模型会在当前常见验证码识别上取得突破，不过到时候可能会有别的人机验证方式了，当然这都是后话了。</p>]]></content>
    
    
    <summary type="html">本文探讨了 ChatGPT 是否能够破解各种常见验证码，包括数字和字母识别、文字点选、图标点选、空间推理和 Google 验证码。实验结果显示，尽管 ChatGPT 在简单验证码识别上表现出色，但面对复杂验证码时仍存在挑战。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="ChatGPT" scheme="https://selfboot.cn/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT 图像理解能力深度体验</title>
    <link href="https://selfboot.cn/2023/10/08/chatgpt_see/"/>
    <id>https://selfboot.cn/2023/10/08/chatgpt_see/</id>
    <published>2023-10-08T21:05:16.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>9 月 25 号的时候，OpenAI 公布了 ChatGPT 的新能力：<a href="https://openai.com/blog/chatgpt-can-now-see-hear-and-speak">ChatGPT can now see, hear, and speak</a>，ChatGPT 终于有了“眼睛”，可以看懂图片了。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231007_chatgpt_see_index.webp" alt="ChatGPT 可以看见了"></p><span id="more"></span><p>国庆期间，就被灰度到了图像理解能力，体验了一下，还是很惊艳的。接下来会从下面的一些维度，来带大家一起深度体验 ChatGPT 的图像能力。</p><ul><li>物体识别：检验模型是否能够准确地识别图像中的主要物体或元素。</li><li>情境解释：判断模型是否能够根据图像内容推断出背后的故事或情境。</li><li>细节捕捉：检查模型是否能够注意到并描述图像中的微小细节或难以注意到的部分。</li><li>情绪解读：评估模型是否能够根据图像内容捕捉到其中的人类情感。</li><li>图片对比：当提供多张图片时，检验模型是否能够进行比较和对比。</li></ul><h2 id="物体识别"><a href="#物体识别" class="headerlink" title="物体识别"></a>物体识别</h2><p>先来看看 ChatGPT 的物体识别能力吧，刚好十一出去玩的时候看到用玉石做的一些食物摆件挺逼真的，拿来让 ChatGPT 识别看看。提示词如下：</p><blockquote><p>这个图里面有哪些食物？</p></blockquote><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231008_chatgpt_see_food.png" alt="玉石做的各种美食摆件"></p><p>ChatGPT 的回答还算可以了，识别出了以下的食物。其中部分的回答不是很精确，不过也超出我的预期了。下面是 ChatGPT 的回答，其实这里没看到鸡爪，不知道它把什么识别为了鸡爪了。另外把荷包蛋识别为了猪耳朵，有点逗～</p><ul><li>白色的包子（在黄色的篮子里）</li><li>莲藕片（有孔的圆形切片）</li><li>鸡蛋（看起来像煮熟了的，被切成了两半）</li><li>红枣</li><li>鸡爪</li><li>像是猪耳朵的食物（左下角）</li><li>某种糖果或者水果干（中间的盘子里）</li><li>某种肉片（可能是牛肉或者羊肉，放在碗里）</li><li>黄色的食物，形状像是鸡或者其他禽类</li><li>白色圆形的糯米球</li><li>鸡形状的黄色食品，可能是模型或者糕点制成的</li><li>长条形的绿色蔬菜（可能是四季豆或其他相似的蔬菜）</li></ul><p>还有一个用玉石做的各种古书的图片，ChatGPT 识别出显示的可能是这些古籍的复制品或艺术品，而非实际的古书。也能识别出其中部分书籍的名字，但还是有幻觉，给了一些图片里没有的书籍。</p><h2 id="情境解释"><a href="#情境解释" class="headerlink" title="情境解释"></a>情境解释</h2><p>小的时候经常会有看图写作文的题目，给一个图片，然后让写一段内容来描述图片里的故事或情境。我们来看看 ChatGPT 的能力如何，这里在网上找了一个插图，提示词如下：</p><blockquote><p>可以帮忙描述下这张图片里面的情景吗</p></blockquote><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231008_chatgpt_see_birth.png" alt="生日庆祝的一个场景插图"></p><p>然后直接让 ChatGPT 描述下这张图片里面的情景。ChatGPT 的回答依旧惊艳，总结这张图片展现了一个充满乐趣和欢声笑语的生日派对场景，还给出了详细描述：</p><ul><li>房间的中心有一个正在与大人<strong>玩机器人玩具</strong>的金发小男孩。他们似乎在互动，小男孩伸手向机器人。</li><li>在房间的左侧，有一个戴着生日帽子的棕色小怪兽，它似乎在笑。</li><li>一个绿色的外星人站在一个开启的礼物盒旁边，它持有一个遥控器，好像在控制机器人。</li><li>房间右侧有两位成年人。一个<strong>穿着绿色衬衫</strong>的男人正在给另一个拿着杯子的男人倒饮料。</li><li>后面的墙上挂着一个写有“Happy Birthday”的彩带，并且有一个电视屏幕显示五个人的图片。</li><li>地上散落着许多玩具，如红色的小车、风琴和气球等。</li><li>墙边有一个放着音乐设备的架子，音符从设备中飘出，意味着音乐正在播放。</li><li>其他的装饰和物品，如灯笼、烛台和生日蛋糕，也分布在房间里。</li></ul><p>不过尴尬的一点是，<strong>把墙上相框里面的照片识别成了电视，然后里面的人物数量也不是很准确</strong>。</p><h2 id="细节捕捉"><a href="#细节捕捉" class="headerlink" title="细节捕捉"></a>细节捕捉</h2><p>其实上面的例子中已经可以看出来 ChatGPT 对细节的捕捉能力很强了，注意到了地上散落的玩具小车、气球等。我们还可以继续追问一些细节，比如“图片左侧中间偏上一点的黑色的是什么呢？”。ChatGPT 认为图片左侧中间偏上的黑色物体是一个壁炉（fireplace）。从其结构和位置来看，它应该是房间的一个固定装饰或建筑元素。</p><p>接下来继续追问它墙上相框里照片有多少人，这次 ChatGPT 翻车了，先是说 5 个人，让它重新数，说是 6 个，最后让它“<strong>仔细看下</strong>“，还是回答错误：照片中有五个人，分别是两个成年人和三个孩子。</p><h2 id="情绪解读"><a href="#情绪解读" class="headerlink" title="情绪解读"></a>情绪解读</h2><p>一个不到 1 岁的人类小孩子都能读懂大人的表情，知道大人的情绪，那么 ChatGPT 在看懂表情这里的表现如何呢？这里为了测试起来方便，直接拿了一个有很多张表情的照片来测试。提示词如下：</p><blockquote><p>这个图片里还好多人脸表情，分别是什么情绪呢？你可以一个个给我描述下情绪</p></blockquote><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231008_chatgpt_see_faces.png" alt="各种表情图片"></p><p>ChatGPT 直接从左上角开始，按照从左到右、从上到下的顺序描述，不过开始给了我 <strong>17 个表情描述</strong>，然后告诉他一共有 15 个，让它重新生成描述。为了和图片对应起来，这里我输出一个表格，对应上面的表情的位置。</p><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>思考或困惑</td><td>惊讶</td><td>难过</td><td>思考</td><td>无表情或冷漠</td></tr><tr><td>微笑</td><td>吓到</td><td>开心</td><td>惊喜</td><td>深思</td></tr><tr><td>不悦或皱眉</td><td>大笑</td><td>调皮或开玩笑</td><td>严肃或无表情</td><td>开心或欣然</td></tr></tbody></table><h2 id="图片对比"><a href="#图片对比" class="headerlink" title="图片对比"></a>图片对比</h2><p>大家都玩过一些找左右两张图片不同点的游戏吧，这种对人来说还是挺难的，有时候就是找不出区别来。那么 ChatGPT 表现如何呢，在网上找了一个图片，拿来试试看。提示词如下：</p><blockquote><p>找出这张图片里，左右两部分不同的地方，并逐个描述出来</p></blockquote><p><img src="https://slefboot-1251736664.file.myqcloud.com/20231008_chatgpt_see_diff.png" alt="图片对比找差异"></p><p>ChatGPT 的回答有<strong>比较严重的幻觉</strong>，它认为左右两部分的不同之处：</p><ol><li>第一个明显的差异是左边部分中间的棒棒糖是彩虹色的，而右边部分中间的棒棒糖颜色较为简单。</li><li>在两部分的左上角，有一个巧克力冰淇淋。左边的巧克力冰淇淋中有较多的白色点状装饰，而右边的巧克力冰淇淋上的白色点状装饰较少。</li><li>左部分的彩虹棒棒糖右侧有一个小糖果，而右部分则没有这个小糖果。</li></ol><p>它也能看到左边部分中间有彩虹色的棒棒糖，虽然事实上左右颜色都一样，但是 ChatGPT 认为右侧的颜色较为简单。另外两个不同地方也都是不对的，看来 ChatGPT 在这类任务上能力还是比较差的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过前面的体验，可以看到ChatGPT在图像理解方面的能力还是很不错的，在物体识别、情境解释等方面表现出惊人的潜力。ChatGPT的视觉能力才刚刚开启，仍有不少提升空间。我们有理由相信，随着训练数据的丰富和模型的迭代升级，ChatGPT将来可以做到真正“<strong>看得清</strong>”。</p><p>在视觉能力出来之前，为了让 ChatGPT 生成一些前端代码，还得费尽心思给它描述页面长什么样，以后就直接把设计图或者随手画的草图扔给它，然后坐等它实现代码了。</p>]]></content>
    
    
    <summary type="html">ChatGPT 最新获得了图像理解能力，本文全方位体验其强大，包括物体识别、情境解释、细节捕捉等方面都较出色，但也存在明显缺陷。ChatGPT可解析生日派对图片情境，识别玉石美食，但也误判物体。总的来说，虽然有不少需要提高的地方，但整体也已经超预期了。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="ChatGPT" scheme="https://selfboot.cn/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT 文字生成图片，DALL·E 3 带来全新能力！</title>
    <link href="https://selfboot.cn/2023/09/21/chatgpt_dalle3_coming/"/>
    <id>https://selfboot.cn/2023/09/21/chatgpt_dalle3_coming/</id>
    <published>2023-09-21T12:04:30.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>近年来，随着人工智能技术的快速发展，文本生成图片（Text-to-Image）技术也取得了重大突破。目前 <code>Midjourney</code> 和 <code>Stable-Diffusion</code> 是两款最受欢迎的文生图软件。</p><p>Midjourney 通过简单的文本描述就能生成具有独特艺术风格的图像，可用于创作海报、插画等。而 Stable Diffusion 则以其精细纹理和细节而闻名，更贴近照片般的效果。尽管这两者已可根据文字创作出惊艳的视觉效果，但仍存在<strong>可控性有限、难以处理抽象概念</strong>等问题。此外，这两款都需要使用者了解很多精巧的 Prompt 技巧，比如指定风格，特效等。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230921_chatgpt_dalle3_coming_vs.png" alt="Midjourney, Stable Diffusion, ChatGPT&amp;DALL·E 3"></p><span id="more"></span><p>最近，OpenAI 宣布将在 ChatGPT 中融合最新的文生图模型 <a href="https://openai.com/dall-e-3">DALL·E 3</a>，预计 10 月份上线。不过放出了一个效果视频，从视频看，真的很值得期待。先来看一下官网放出的片段吧：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230921_chatgpt_dalle3_coming_preview.gif" alt="超级厉害的向日葵刺猬 super-duper sunflower hedgehog"></p><h2 id="DALL·E-3-的文本理解"><a href="#DALL·E-3-的文本理解" class="headerlink" title="DALL·E 3 的文本理解"></a>DALL·E 3 的文本理解</h2><p>玩过 Midjourney 和 Stable Diffusion 的都知道，这两个需要很专业的 Prompt 技巧才能生成想要的图片。通过直白的文字描述，可能也会生成精美的图片，但不一定是你想要的“场景”。Midjourney 有专门的<a href="https://docs.midjourney.com/docs/explore-prompting">提示教程</a>来教你生成想要的图片，</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230921_chatgpt_dalle3_coming_midjourney.png" alt="Midjourney 的专业提示词"></p><p>而 DALL·E 则直接打破这点，不需要专业的提示词，只用文字描述想要的场景即可。</p><blockquote><p>DALL·E 3 is now in research preview, and will be available to ChatGPT Plus and Enterprise customers in October, via the API and in Labs later this fall.</p><p>Modern text-to-image systems have a tendency to ignore words or descriptions, forcing users to learn prompt engineering. DALL·E 3 represents a leap forward in our ability to generate images that exactly adhere to the text you provide.</p></blockquote><p>官方也专门提供了一个例子：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230921_chatgpt_dalle3_coming_case.png" alt="DALL·E 3真正理解了文本"></p><p>可以看到描述中的很多关键细节，在图片中都有不错的体现。考虑到 OpenAI 在文本理解上的绝对实力，DALL·E 3 有这个绘图能力也是可以解释的通的。</p><h2 id="ChatGPT-中的文生图"><a href="#ChatGPT-中的文生图" class="headerlink" title="ChatGPT 中的文生图"></a>ChatGPT 中的文生图</h2><p>在 ChatGPT 中，DALL·E 3 的能力得到了原生的融合。当您提出一个创意或想法时，ChatGPT 会自动为 DALL·E 3 生成精心定制的详细提示，从而精准地将您的创意转化为视觉图像。如果生成的图像在某些方面稍有不符，您只需用简短的几句话指示，ChatGPT 就能迅速进行微调，以满足您的具体需求。</p><p>演示视频中，先是生成了一个厉害的向日葵刺猬，然后想给它起一个名字 Larry ，这里其实没有很好的生成名字。不过接着提示：</p><blockquote><p>Can you show me Larry! ‘s house?</p></blockquote><p>于是加了一个房子，并且邮箱上有一个名字了！</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230921_chatgpt_dalle3_coming_house.png" alt="DALL·E 3: Larry! &#39;s house"></p><p>这种能力在其他的文生图 AI 里是没有的，之前就一直想对生成的图片接着做一些修改，但是效果都很差。不止可以修改图片，ChatGPT 还可以接着聊天，让 AI 给你提供一些图片相关的灵感。比如可以接着让 ChatGPT 解释为啥 Larry 如此可爱，会知道原来 Larry 有一颗善良的心，很喜欢助人为乐。接着让它继续画图，来表现 Larry 的助人为乐，提示词：</p><blockquote><p>Awwww.. can you show me Larry being “kind hearted”?</p></blockquote><p>于是来了一个能表现 Larry 友好的图片了：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230921_chatgpt_dalle3_coming_kind.png" alt="DALL·E 3: Larry! &#39;s kind hearted"></p><p>根据放出来的视频，这里的生成速度也是很快的，几乎是秒生成。另外，Plus 用户可以直接使用，不用额外花钱。相比 Midjourney 的订阅费，OpenAI 的 20$ 一个月可真是太划算了。</p><p>其他文生图一般只有英文效果很好，这里得益于 ChatGPT 强大的语言能力，可以用任何语言来描述想生成图片的内容，真的是太方便了。 </p><h2 id="可能的应用"><a href="#可能的应用" class="headerlink" title="可能的应用"></a>可能的应用</h2><p>ChatGPT 和 DALL·E 3 强强联合后，可以用在很多地方了。我能想象到的有：</p><ol><li>制作儿童绘本：上面的例子就是一个很好的绘本材料，这一组合技术提供了一个完美的平台，用于创作富有故事情节和连贯性的儿童绘本。不仅可以生成引人入胜的故事文本，还能自动配上精美和生动的插图，让每一个故事都跃然纸上。</li><li>设计广告和营销材料：企业和广告代理商可以利用这一技术来快速生成吸引人的广告图像和营销材料。只需输入相关的广告文案或概念，系统就能生成与之匹配的高质量图像。</li><li>教育和培训：教师和培训师可以用它来生成教学材料，如科学图表、历史事件的可视化等，以增加课堂的互动性和趣味性。</li><li>虚拟现实和游戏开发：在虚拟现实和游戏开发中，这一技术可以用于生成环境元素或角色设计。开发者只需提供简单的描述，就能得到详细和逼真的图像。</li></ol><p>随着这种多模态技术的不断发展，一些传统的职业，如美工和设计师，可能需要重新思考他们的角色和价值了。</p><p>最后，十分期待 10 月份(2023年)能在 ChatGPT 上用到 DALL·E 3！</p>]]></content>
    
    
    <summary type="html">OpenAI 最新文生图模型DALL·E 3将与ChatGPT结合，实现直观的语言导向图像生成。DALL·E 3可精确理解文本语义，无需复杂提示词就能创作出所想场景。两者配合，可进行图像微调及连贯对话。应用场景广泛，如儿童绘本、广告设计、教育培训等。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="ChatGPT" scheme="https://selfboot.cn/tags/ChatGPT/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 C++ 链接符号决议：从符号重定义说起</title>
    <link href="https://selfboot.cn/2023/09/19/c++_symbol_resolution/"/>
    <id>https://selfboot.cn/2023/09/19/c++_symbol_resolution/</id>
    <published>2023-09-19T22:17:02.000Z</published>
    <updated>2023-09-20T22:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://selfboot.cn/2023/09/07/protobuf_redefine/">C++ 中使用 Protobuf 诡异的字段丢失问题排查</a>这篇文章中，分析过因为两个一样的 proto 文件，导致链接错了 pb，最终反序列化的时候丢失了部分字段。当时也提到过符号决议的过程，不管是动态链接还是静态链接，实际用的都是靠前面的库的符号定义。本来以为对这里的理解很深入了，直到最近又遇见一个奇怪的“<strong>符号重定义</strong>”问题。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_index.webp" alt="C++ 符号编译、链接概图"></p><span id="more"></span><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>最开始有一个 utils 目录，里面有一些基础代码，编译为一个静态库 A。后来项目中其他目录下又拷贝了一份出来，编译成另一个静态库 B。由于项目复杂的依赖关系(剪不断理还乱啊)，有的目标 target 会同时依赖 A 和 B，好在编译和链接一直都是 OK 的。</p><p>最近，在模块 B 中的某个 cpp 中，修改了其中一个类，对构造函数添加了一个默认参数。然后调用的时候，也传了具体的参数进去。结果在编译 target 的时候，报错 <code>multiple definition</code>。</p><p>按照我之前的理解，这里对于静态库中的符号，链接决议的时候，从左到右扫描，如果一个符号在前面已经找到定义，后面就会忽略掉。上面静态库 A 和 B，虽然确实是有重复的函数定义，不过应该每个符号都能找到一个定义，然后丢弃后面出现的，链接不应该出错才对呀。</p><h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><p>项目代码太复杂了，不太好直接拿来分析，先来看看能不能写个简单的例子复现这里的问题。这里复现代码的结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜ tree</span><br><span class="line">.</span><br><span class="line">├── demoA</span><br><span class="line">│   ├── libDemoA.a</span><br><span class="line">│   ├── sum.cpp</span><br><span class="line">│   ├── sum.h</span><br><span class="line">│   └── sum.o</span><br><span class="line">├── demoB</span><br><span class="line">│   ├── libDemoB.a</span><br><span class="line">│   ├── sum.cpp</span><br><span class="line">│   ├── sum.h</span><br><span class="line">│   └── sum.o</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></table></figure><h3 id="简单函数调用"><a href="#简单函数调用" class="headerlink" title="简单函数调用"></a>简单函数调用</h3><p>从最简单的示例入手，demoA 和 demoB 里面的 sum.h 里声明函数如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>具体实现在各自的 cpp 文件中，DemoB 中的输出是 “DemoB”，这样通过输出就知道用的哪个库里面的实现。DemoA 中的 cpp 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DemoA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp 很简单，就是调用一个 sum：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;demoB/sum.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把两个目录分别编译为静态库，然后编译、链接 main.cpp，不同链接顺序下，都可以正常链接生成二进制，并能正常输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ g++ -c -o demoA/sum.o demoA/sum.cpp</span><br><span class="line">➜ ar rcs demoA/libDemoA.a demoA/sum.o</span><br><span class="line">➜ g++ -c -o demoB/sum.o demoB/sum.cpp</span><br><span class="line">➜ ar rcs demoB/libDemoB.a demoB/sum.o</span><br><span class="line">➜ g++ main.cpp -o main -LdemoA -LdemoB -lDemoA -lDemoB</span><br><span class="line">➜ ./main</span><br><span class="line">DemoA</span><br><span class="line">➜ g++ main.cpp -o main -LdemoA -LdemoB -lDemoB -lDemoA</span><br><span class="line">➜ ./main</span><br><span class="line">DemoB</span><br></pre></td></tr></table></figure><p>这里符合之前的认知，虽然有两个 sum 函数的定义，但是静态库在链接的时候，会优先用先找到的，后面的会被丢弃掉。不论这里以何种顺序链接，都不会出现重复定义的错误。</p><h3 id="复现重定义"><a href="#复现重定义" class="headerlink" title="复现重定义"></a>复现重定义</h3><p>前面复现代码和项目中的代码还是有一点不同的，接下来尽量模拟项目中的改动方法。在 demoA 的 sum.h 中增加一个类，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Demo</span>(<span class="type">int</span> a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.cpp</span></span><br><span class="line">Demo::<span class="built_in">Demo</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">    num = a;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DemoA init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对于 DemoB 中的类的构造函数，增加一个默认参数 b：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Demo</span>(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.cpp</span></span><br><span class="line">Demo::<span class="built_in">Demo</span>(<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">    num = a;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DemoB init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后 main 里面增加一个类对象的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="function">Demo <span class="title">de</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里复现了符号重定义的问题了！如果 <code>-lDemoA -lDemoB</code> 的顺序，就会报 sum 的重定义。但是如果反过来 <code>-lDemoB -lDemoA</code>，就一切正常，输出也是符合前面的认知。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230918_c++_symbol_resolution_multiple_definition.png" alt="C++ 符号编译、链接概图"></p><p>问题是复现了，不过自己确实有点迷惑了。这里 DemoA 库在前面的话，应该是先从这里拿到 sum，后面到 DemoB 的时候，<strong>链接器应该丢掉 sum 就可以了</strong>，为啥会报重复定义呢？毕竟<strong>前面只有函数的示例中，就是这样链接的</strong>啊。</p><h2 id="原因猜测"><a href="#原因猜测" class="headerlink" title="原因猜测"></a>原因猜测</h2><p>有了 ChatGPT 之后，都不怎么用搜索了，直接把问题给 ChatGPT，看它怎么解释。其实前面的复现过程中，也都一直跟 ChatGPT 有交流，让它对上下文有了了解。</p><h3 id="ChatGPT-的解释"><a href="#ChatGPT-的解释" class="headerlink" title="ChatGPT 的解释"></a>ChatGPT 的解释</h3><p>这里为了让它全面了解问题细节，又把上面重定义部分的复现代码、编译链接和报错一起喂给了它，于是它解释如下。</p><p>链接器首先查找 libDemoA.a，找到 sum(int, int) 和 Demo::Demo(int)。然后链接器会去 libDemoB.a 查找符号。此时，由于 main.cpp 实际上使用了 demoB 版本的 Demo::Demo(int, int)（注意这里有两个参数），链接器会尝试从 libDemoB.a 中解析这个新符号。在 libDemoB.a 中，链接器找到了与 libDemoA.a 中相冲突的 sum(int, int)，因此报告“多重定义”。</p><p>不过我还是有疑问，<strong>链接器首先查找 libDemoA.a，找到 sum(int, int) ，这时候sum已经被找到，后面在 libDemoB.a 中，就会忽略这个符号的呀</strong>。直接去问 ChatGPT，它就开始“悔过”了：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_error.png" alt="ChatGPT C++符号链接过程的错误回答"></p><p>然后进一步让它解释为啥最开始的复现中没有报错，如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt.png" alt="ChatGPT C++符号链接过程的错误解释"></p><p>看来直接问这条路走不通了。接着想看看能不能打印一些链接的中间过程，于是添加了 <code>-Wl,--verbose</code> 选项进行链接，也没发现啥有用的信息。这里我想如果能打印 ld 链接过程的符号未决议集合和已经决议集合，以及决议符号的具体步骤，就能排查出来。结果没发现有啥办法可以打印这些。</p><h3 id="大胆猜测"><a href="#大胆猜测" class="headerlink" title="大胆猜测"></a>大胆猜测</h3><p>这里其实最好是直接去看链接器的实现，毕竟<strong>源码之下了无秘密</strong>。不过我这里重新回顾了下上面两个测试过程的差异，并做出了一个猜测，拿来问 ChatGPT：</p><blockquote><p>这里我这样测试，demoA&#x2F;sum.h 和 demoB&#x2F;sum.h 如果都是只有 sum 函数，那么无论哪个先链接，都不会有问题。<br>但是一旦里面有 class ，定义不一样，那么就会出错。<strong>这里“第一个赢” 是不是只有在后面出现的库里，没有一个符号被需要的话，才不会重复定义。</strong></p><p><strong>只要后面出现的库，有一个符号被需要，就会重复定义？</strong></p></blockquote><p>终于得到了一个靠谱的解释：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230919_c++_symbol_resolution_chatgpt_right.png" alt="C++ 链接静态库符号重定义的详细解释"></p><p>也就是说<strong>当链接器从静态库的 .o 文件中引用一个符号时，它实际上会把包含该符号的整个对象文件都链接到最终的可执行文件</strong>。为了验证这一点，把 demoB&#x2F;sum.cpp 里面 Demo 类的构造函数定义拆分出来为一个新的编译单元 demo.cpp，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cat demoB/demo.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">Demo::<span class="built_in">Demo</span>(<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">    num = a;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DemoB init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重新编译 DemoB 静态库，编译、链接 main，发现不会有符号重定义了，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜ g++ main.cpp -o main -LdemoA -LdemoB -lDemoB -lDemoA</span><br><span class="line">(base) ➜  link_check ./main</span><br><span class="line">DemoB</span><br><span class="line">DemoB init</span><br><span class="line">(base) ➜  link_check g++ main.cpp -o main -LdemoA -LdemoB -lDemoA -lDemoB</span><br><span class="line">(base) ➜  link_check ./main</span><br><span class="line">DemoA</span><br><span class="line">DemoB init</span><br></pre></td></tr></table></figure><p>这里因为用到的 Demo 在静态库 B 中有一个单独的可重定向目标文件 demo.o，而 sum.o 里面没有任何需要引入的符号，所以没有被链接进去，因此不会有符号重定义了。</p><h2 id="再读经典"><a href="#再读经典" class="headerlink" title="再读经典"></a>再读经典</h2><p>经过上面的验证猜测步骤后，再重新读《深入理解计算机系统》的 <code>7.6 符号解析</code>，才完全明白了这一节讲的内容，整个链接的核心步骤如下。</p><p>链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。如果多个目标文件定义相同名字的全局符号，链接器要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。</p><p>编译器向汇编器输岀每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。Linux 链接器使用下面的规则来处理多重定义的符号名：</p><ul><li>规则 1：不允许有多个同名的强符号。</li><li>规则 2：如果有一个强符号和多个弱符号同名，那么选择强符号。</li><li>规则 3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。</li></ul><p>上面假设链接器读取一组可重定位目标文件，实际上可以链接库。对于静态库来说，它是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置，文件名由后缀 <code>.a</code> 标识。</p><p>在符号解析阶段，链接器<strong>从左到右</strong>按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和静态库文件(存档文件)。扫描中，链接器维护一个可重定位目标文件的<strong>集合 E</strong>。如果输入文件是目标文件，<strong>只要目标文件中有一个符号被用到，整个目标文件就会放进集合 E。要是目标文件的所有符号都没有被引用，那么就会丢弃这个目标文件</strong>。如果输入文件是静态库(存档)文件，则会按照上面的方法遍历其中的每一个可重定向目标文件。</p><p>扫描完所有文件后，链接器会<strong>合并和重定位 E 中的目标文件</strong>，构建输岀的可执行文件。这时候如果有两个目标文件有同样的符号定义，就会报重复定义错误。</p><p>回到前面文章开始部分的重定义问题。在两个库 A 和 B 中都有一个 util.o 目标文件，开始的时候是完全一样的，所以链接顺序上靠后的 B&#x2F;util.o 会被丢掉，这样是没有问题的。后来改动了 B&#x2F;util.cpp，增加了 A 中没有的符号，由于其他地方用到了这个符号，导致 B&#x2F;util.o 也被包含在链接过程。这样就相当于同时链接 A&#x2F;util.o 和 B&#x2F;util.o ，这两个目标文件中有很多重复的函数定义，所以会报符号重定义。</p><h2 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h2><p>文章在 <a href="https://www.v2ex.com/t/975233">V2EX</a> 上引起了一些小伙伴的讨论，其中有些观点还挺不错，这里就记录下来。<a href="https://www.v2ex.com/t/975233#r_13670523">geelaw</a> 这里说到：</p><blockquote><p>无论是看代码还是<strong>问 ChatGPT 却不查证</strong>都是非常糟糕的学习方法，第一步应该是理解 C++ 标准是如何规定的。<br>文章里无论是 int sum(int, int) 还是 class Demo 都是非常严重的 ODR(One-definition rule) violation。</p><p>在 [basic.def.odr]&#x2F;14 里规定了 (14.1) 非内联非模板函数在多个翻译单元中有定义时 (14) 程序不良，且在非模块中无需报错，这适用于 sum 的情况。</p><p>在 [basic.def.odr]&#x2F;14 里规定了 (14.2) 多个翻译单元中有定义的 class 如果不满足 (14.4) 在所有可达的翻译单元中定义是相同的记号（ token ）序列，则 (14) 程序不良，且在非模块中无需报错，这适用于 class Demo 的情况。</p></blockquote><p>至于某个具体的编译器、链接器产生的什么行为，不过是巧合罢了。这里贴一下 C++ 标准的文档地址：<a href="https://eel.is/c++draft/basic.def.odr#14">basic.def.odr#14</a>。就算 sum 这种能编译，链接成功，也是一个很坏的代码习惯。能正常运行的，结果符合预期的，也不一定就是对的实现，可能是编译器的巧合行为，说不定后面就不行了。实际项目中，可以通过<strong>命名空间，或者重构重复部分代码、调整代码结果来避免这样的 ODR 问题</strong>。</p><p>当然，上面是用的 GNU ld 链接，如 <a href="https://www.v2ex.com/t/975233#r_13670827">tool2d</a> 所说:</p><blockquote><p>这算是 gcc 的问题，你换 vc 一开始 sum 就不能链接成功。<br>符号一样，什么前面的函数体去覆盖后面的函数体，对于微软来说，是完全不存在的事情。<br>还有一点，linux so 动态链接库里的符号可以是未决的，但是 dll 缺一个函数，都没办法生成。光是这点，微软就已经领先 100 年。</p></blockquote><p>这里我没试过用 vc 链接，仅供参考。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hansimov.gitbook.io/csapp/part2/ch07-linking/7.6-symbol-resolution">深入理解计算机系统: 7.6 符号解析</a><br><a href="https://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking">Library order in static linking</a></p>]]></content>
    
    
    <summary type="html">本文深入剖析了C++静态库链接时的符号决议机制，以符号重定义错误为切入点，通过简单示例逐步说明了静态库中目标文件全链接的关键。指出了链接器从左向右决议符号，一旦库中目标文件有一个符号被需要，就会引入整个目标文件，并与经典教材内容对比验证。</summary>
    
    
    
    <category term="计算机基础" scheme="https://selfboot.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="ChatGPT" scheme="https://selfboot.cn/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT 老师教我写前端：从零写油猴脚本</title>
    <link href="https://selfboot.cn/2023/09/15/chatgpt_export_script/"/>
    <id>https://selfboot.cn/2023/09/15/chatgpt_export_script/</id>
    <published>2023-09-15T07:50:38.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>可以跟着 ChatGPT 老师学前端？听起来有点不可思议，毕竟前端很多和 UI 有关，和没有<strong>多模态能力</strong>的 ChatGPT 沟通前端，想想都有点难。不过最近在 ChatGPT 的帮助下，很快就写了一个<a href="https://greasyfork.org/en/scripts/475169-chatgpt-export">油猴插件</a>，能够在 ChatGPT 的聊天界面上，复制数学公式的 Latex 文本。</p><p>作为一个后台开发，前端零基础，要写一个油猴插件，如果没有 ChatGPT，首先得去找文档看，写一个雏形都要花很多时间。如果中间遇到了问题，还得自己去找答案，这个过程可能会很漫长，可能中途就放弃了。但是有了 ChatGPT 老师，遇到问题直接提问，整个开发体验就好了太好了。</p><p>再次感叹下，ChatGPT 真的是极大<strong>拓宽个人的技术能力边界，极大提高个人解决问题的能力！</strong></p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230913_chatgpt_export_script_copy.png" alt="ChatGPT export 插件"></p><span id="more"></span><h2 id="油猴脚本背景"><a href="#油猴脚本背景" class="headerlink" title="油猴脚本背景"></a>油猴脚本背景</h2><p>刚好最近看的一本书提到了<strong>向量内积</strong>，就在 ChatGPT 上深入了解了下这里的<a href="https://selfboot.cn/2023/09/14/chatgpt_math_product/">数学知识</a>。然后想把聊天页面这里的公式复制到 markdown 笔记中去，发现直接复制内容不太可行。</p><p>打开浏览器的开发者工具，看到在 html 中其实有公式的 Latex 文本表示，复制后可以在 <a href="https://www.mathjax.org/#demo">mathjax</a> 查看转换后的公式：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230913_chatgpt_export_script_mathjax.png" alt="数学公式在线预览"></p><p>不过总不能每次要复制一个公式，就去开发者工具里面复制吧。于是想着可以写一个油猴脚本，能够在公式旁边放一个复制按钮，点击后就能把 Latex 公式复制出来。</p><h2 id="第一个版本"><a href="#第一个版本" class="headerlink" title="第一个版本"></a>第一个版本</h2><p>之前没搞过油猴脚本，不过不担心，直接问 ChatGPT 老师：</p><blockquote><p>我想写一个油猴脚本，在 chat.openai.com 页面中，对于公式，可以在右边提供一个复制按钮，复制公式的文本内容。比如下面的 html：<br>…<br>…<br>复制 annotation encoding&#x3D;”application&#x2F;x-tex” 里面的内容</p></blockquote><p>很快一个简单的雏形脚本就出来了，不过安装脚本后，没看到复制按钮。就去追问 ChatGPT 老师，结果告诉我对于动态加载的内容，上面脚本依赖的 <code>window.load</code> 事件可能不会完全起作用。因为在 window.load 触发时，这些动态元素可能还没有加载。在这种情况下，一个更可靠的方法是使用 <code>MutationObserver</code> 来监听 DOM 变化。当新的 <strong>.math</strong> 元素被添加到 DOM 时，MutationObserver 将触发，然后可以相应地添加复制按钮。</p><p>然后给了新的脚本逻辑，定义了一个 addCopyButtons 函数，该函数执行与之前相同的任务：查找所有 .math 元素并添加复制按钮。然后，使用 MutationObserver 来监视页面上所有新添加或删除的节点。每当 DOM 发生变化时，addCopyButtons 函数都会被调用，从而确保所有新的 .math 元素也会获得复制按钮。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initial adding</span></span><br><span class="line"><span class="title function_">addCopyButtons</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observe for new formulas</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DOM has changed, rechecking...&quot;</span>);</span><br><span class="line">  <span class="title function_">addCopyButtons</span>();</span><br><span class="line">&#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>用这个脚本后，<strong>打开页面直接卡死</strong>了，看来脚本有某种形式的无限循环或者过度的资源消耗。然后直接把当前代码全部给 ChatGPT，让他帮忙排查卡死的原因，找到了 3 个可能导致性能问题的地方：</p><ol><li>MutationObserver 触发过于频繁: 如果页面的 DOM 频繁地变化，MutationObserver 可能会触发很多次，导致 addCopyButtons 函数也被频繁地调用。</li><li>复杂的 DOM 查询: document.querySelectorAll 和 div.querySelector 可能在复杂的 DOM 结构中变得相对缓慢。</li><li>事件监听器积累: 每次 addCopyButtons 被调用时，你都会给新创建的按钮添加一个点击事件监听器。如果这个函数被多次调用，同一个元素可能会绑定多个相同的事件监听器。</li></ol><p>接着让它修改上面的脚本，增加了一个简单的防抖（debounce）机制来限制 MutationObserver 触发的频率，另外避免重复添加相同的事件监听器。修改部分主要如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">addCopyButtons</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> mathDivs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.math, .math-inline, .math-display&#x27;</span>);</span><br><span class="line">        mathDivs.<span class="title function_">forEach</span>(<span class="function"><span class="params">div</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (div.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-copy-button-added&#x27;</span>) === <span class="string">&#x27;true&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">          div.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-copy-button-added&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">debounceAddCopyButtons</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(debounceTimer);</span><br><span class="line">        debounceTimer = <span class="built_in">setTimeout</span>(addCopyButtons, <span class="number">300</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">addCopyButtons</span>();  <span class="comment">// Run once initially</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DOM has changed, rechecking...&quot;</span>);</span><br><span class="line">        <span class="title function_">debounceAddCopyButtons</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;)();    </span><br></pre></td></tr></table></figure><p>到这里插件基本能工作了，但是复制按钮的样式和 ChatGPT 自带的复制按钮不一样，而且复制成功后没有提示。为了追求完美，这里接续优化。</p><h2 id="复刻前端样式"><a href="#复刻前端样式" class="headerlink" title="复刻前端样式"></a>复刻前端样式</h2><p>对于一个前端零基础的后台开发来说，根本不知道怎么调这些 CSS 样式。这里我想要在每个公式后面的复制按钮，能够和 ChatGPT 自己的复制按钮保持完全一致。在浏览器的开发者工具里，直接复制图标的 SVG 标签过来：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-sm&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1em&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1em&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;8&quot;</span> <span class="attr">y</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;8&quot;</span> <span class="attr">height</span>=<span class="string">&quot;4&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>发现确实有图标，但是<strong>样式不太对，颜色和鼠标停留上去都没效果</strong>，更不用说暗黑模式下的颜色适配了。之前从 GPT 那里学到过，这里样式一般是通过 tag 的 class 来设定的，刚好看到 svg 标签外层有一个 button，里面有很多 class，于是把这个 button 以及它的 class 也都复制过来，样式基本就一致了。</p><p>为了了解某个 class 各自到底负责什么样式，之前都是在开发者工具去掉之后看效果对比，不过有了 ChatGPT 还可以直接问它了：</p><blockquote><p>帮我解释下这里每个 class 负责什么样式：<br>class&#x3D;”flex ml-auto gap-2 rounded-md p-1 hover:bg-gray-100 hover:text-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-gray-200 disabled:dark:hover:text-gray-400”</p></blockquote><p>于是学到了下面的解释，这里使用的是 <code>Tailwind CSS</code> 的类名，每个都对应某种特定的样式：</p><ul><li>flex: 使元素使用 Flexbox 布局。</li><li>ml-auto: 设置左外边距（margin-left）为自动，通常用于将元素推到容器的右边。</li><li>gap-2: 设置 Flex 或 Grid 布局中的元素之间的间距。</li><li>rounded-md: 设置元素的边角为中等大小的圆角。</li><li>p-1: 设置元素的内边距（padding）。</li></ul><p>悬停（Hover）状态</p><ul><li>hover:bg-gray-100: 当鼠标悬停在元素上时，设置背景色为浅灰色。</li><li>hover:text-gray-700: 当鼠标悬停在元素上时，设置文本颜色为深灰色。</li></ul><p>暗黑模式（Dark mode）</p><ul><li>dark:text-gray-400: 在暗黑模式下，设置文本颜色为中灰色。</li><li>dark:hover:bg-gray-700: 在暗黑模式下，鼠标悬停时设置背景颜色为更深的灰色。</li><li>dark:hover:text-gray-200: 在暗黑模式下，鼠标悬停时设置文本颜色为浅灰色。</li></ul><p>暗黑模式 + 禁用（Disabled）状态</p><ul><li>disabled:dark:hover:text-gray-400: 在暗黑模式下，如果元素被禁用，鼠标悬停时设置文本颜色为中灰色。</li></ul><p>这些类名各自负责一个很小但明确的样式设置，这是 Tailwind CSS 的工作方式。通过组合这些类名，可以非常灵活地构建复杂的样式。通过上面的设置，复制按钮和原生的已经保持一致了。<strong>美中不足的是，点原生的复制按钮，复制成功后，图标会变成一个对号，然后又变回去了，目前脚本里的还做不到</strong>。</p><h2 id="捕捉动态内容"><a href="#捕捉动态内容" class="headerlink" title="捕捉动态内容"></a>捕捉动态内容</h2><p>为了追求完美的效果，我想在油猴脚本里实现同样的点击效果。这里首先得知道 ChatGPT 的复制成功对号提示是什么图形。于是问了下：</p><blockquote><p>有个svg 的 button，点击后会变成另一个 svg，但是很快就变回去了。我想看下中间变到的 svg，这里要怎么做？</p></blockquote><p>ChatGPT 给了几个思路：</p><ol><li>当 SVG 改变时，开发者工具通常会高亮显示改变的部分，可以在此时快速复制 SVG 的代码。</li><li>在控制台使用 JavaScript 来暂停 SVG 的变化。如果 SVG 的变化是由某个函数触发的，可以重写该函数以阻止其执行原本的任务。</li><li>找到触发 SVG 变化的 JavaScript 代码，在相应的行设置断点。当代码执行到该行时，它会暂停，允许查看此时的 SVG 状态。</li><li>如果 SVG 是通过网络请求获得的，可以在 Netword 找到对应的请求。然后在“Response”（或“响应”）部分看到 SVG 数据。</li></ol><p>前面几个方法都不太可行，第 1 个方法，没来的及复制就变回去了。第 2、3 个方法，我不知道怎么找到触发 SVG 变化的 JavaScript 代码。第 4 个方法，因为这里没触发网络请求，所以不适用。</p><p>其实断点这个方法看起来最实用，因为直接看 Script 的代码找触发 SVG 变化的部分有难度，ChatGPT 推荐用浏览器开发者工具的”Event Listeners”（事件监听器）功能来查找这个按钮的点击事件。但是我看了 button 元素的 Click 事件，通过事件找到的 JS 代码也不太对。不要慌，继续追问 ChatGPT 老师：</p><blockquote><p>我找不到这里是哪个事件监听，有没有更方便的方法。</p></blockquote><p>ChatGPT 又给我推荐了 3 种方法：</p><p>1、使用 JavaScript 在 Console（控制台）中手动增加这里 button 或 svg 的点击事件，输出点击 button 后变化的内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.text-gray-400&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (e.<span class="property">target</span>.<span class="title function_">closest</span>(<span class="string">&#x27;button&#x27;</span>)) &#123;  <span class="comment">// 检查点击的是否是 button 或其子元素</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 设置一个短暂的延迟以捕获可能的变化</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="title function_">closest</span>(<span class="string">&#x27;.text-gray-400&#x27;</span>).<span class="property">innerHTML</span>);  <span class="comment">// 输出变化后的内容</span></span><br><span class="line">    &#125;, <span class="number">100</span>);  <span class="comment">// 延迟 100 毫秒，可以根据实际情况调整</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是尝试了几次，这里都没有任何输出。</p><p>2、在 “Elements”（元素）面板中找到这个 svg 元素。右键点击这个元素，在出现的菜单中选择 “Break on” -&gt; “attribute modifications”。这样当该元素的属性发生变化时，代码会自动暂停，让你有机会查看或者拷贝当前的 SVG 代码。同样试了几个 tag 下的 Break on，都没有在正确的时机暂停过。</p><p>3、使用 <code>MutationObserver</code>。这是一个更高级的方案，通过 MutationObserver API 可以监听 DOM 的变更，包括元素的添加和删除。</p><p>正是这第三个方法，让我成功拿到了变化后的图标内容。这里提示词也很简单，如下：</p><blockquote><p>这里使用了 MutationObserver，我能在页面发生 dom 变化的时候，就直接输出变化的那一小块吗?</p></blockquote><p>于是拿到了下面的这个 JS 代码(ChatGPT 还贴心的给了注释)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个观察器实例并传入回调函数</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="keyword">function</span>(<span class="params">mutations</span>) &#123;</span><br><span class="line">  mutations.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">mutation</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查是否有子节点被添加或删除</span></span><br><span class="line">    <span class="keyword">if</span> (mutation.<span class="property">type</span> === <span class="string">&#x27;childList&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有子节点被添加</span></span><br><span class="line">      <span class="keyword">if</span> (mutation.<span class="property">addedNodes</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mutation.<span class="property">addedNodes</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Added node:&#x27;</span>, node);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果有子节点被删除</span></span><br><span class="line">      <span class="keyword">if</span> (mutation.<span class="property">removedNodes</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mutation.<span class="property">removedNodes</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Removed node:&#x27;</span>, node);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否有属性变化</span></span><br><span class="line">    <span class="keyword">if</span> (mutation.<span class="property">type</span> === <span class="string">&#x27;attributes&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Attributes changed:&#x27;</span>, mutation.<span class="property">target</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置观察选项</span></span><br><span class="line"><span class="keyword">const</span> config = &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="comment">// 在目标节点上开始观察</span></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, config);</span><br></pre></td></tr></table></figure><p>把这段代码复制并粘贴到浏览器的开发者工具的控制台中运行，然后点击复制，就可以看到输出的内容了，如下图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230913_chatgpt_export_script_dom_change.png" alt="控制台观察到了这里的 Button 变化"></p><p>这里看到 ChatGPT 的对号 HTML 内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;flex ml-auto gap-2 rounded-md p-1 hover:bg-gray-100 hover:text-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-gray-200 disabled:dark:hover:text-gray-400&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">        <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;icon-sm&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1em&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1em&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;20 6 9 17 4 12&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了这个 svg 图标，就好办了，剩下的是点击的时候用这个图标替换原来的。先把这个 html 定义为 copiedButton，然后让 ChatGPT 添加点击事件的代码。 </p><h2 id="设置复制动作"><a href="#设置复制动作" class="headerlink" title="设置复制动作"></a>设置复制动作</h2><p>这里提问的时候，需要把<strong>目前版本的脚本带上去</strong>，这点很重要，因为这样它就会在当前的代码上下文做改动。提示词如下：</p><blockquote><p>我想给下面的油猴脚本增加一个动作：</p><p>&#x2F;&#x2F; &#x3D;&#x3D;UserScript&#x3D;&#x3D;<br>&#x2F;&#x2F; @name         chatgpt-export<br>…<br>…(省略掉)<br>点击 copy ，复制成功公式后，这里 copyButton 变成 copiedButton，过 2s 后自动再复原。</p></blockquote><p>ChatGPT 给出了详细的方法，可以在 click 事件监听器内部进行操作，先将 copyButton 的 innerHTML 改为 copiedButton，然后使用 setTimeout 在2秒后再改回 copyButton。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...省略其他代码</span></span><br><span class="line">copyButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(latexText).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;复制成功！&#x27;</span>);</span><br><span class="line">        <span class="comment">// 复制成功后，更改按钮为 &#x27;copiedButton&#x27;</span></span><br><span class="line">        copyButton.<span class="property">innerHTML</span> = copiedButton;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2秒后复原按钮</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            copyButton.<span class="property">innerHTML</span> = copyButton;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;复制失败:&#x27;</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ...省略其他代码</span></span><br></pre></td></tr></table></figure><p>这里还温馨提示<strong>发现我代码里有一个问题</strong>：在创建 copyButton 时，你再次用了一个<strong>同名的局部变量</strong>。这会导致原始的 copyButton（存储按钮 HTML 的那个）被覆盖。为了避免这个问题，你应该给用于存储 HTML 的 copyButton 变量和用于创建实际 DOM 元素的 copyButton 变量使用不同的名字。</p><p>不过<strong>我没注意到这个问题</strong>，改了后发现 button 没了，变成了 [object HTMLSpanElement]。再次提问 ChatGPT，才知道 copyButton 是一个 HTMLSpanElement 对象，将其设置为自己的 innerHTML 会导致其变成字符串 “[object HTMLSpanElement]”。解决这个问题的方法是使用不同的变量名存储 HTML 内容和 DOM 元素。这样，就可以在需要的时候分别引用它们。关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> copyButtonHtml = <span class="string">`&lt;button **** &lt;/button&gt;`</span> <span class="comment">// 这里名字由 copyButton 改为 copyButtonHtml</span></span><br><span class="line"><span class="keyword">const</span> copyButton = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">copyButton.<span class="property">innerHTML</span> = copyButtonHtml;</span><br></pre></td></tr></table></figure><p>至此这里复制功能就完成了。最后就是发布脚本了，发布的流程自己也不清楚，同样在 ChatGPT 的帮助下，把脚本上传到 Greasy Fork 上，最后奉上油猴脚本地址：<a href="https://greasyfork.org/zh-CN/scripts/475169-chatgpt-export">chatgpt-export</a>。</p><p>装了脚本后，在有数学公式的聊天界面里，对于行内公式和块级公式，在旁边都会多一个复制按钮，点击后就可以复制公式，复制后会短暂显示一个对号，整体效果和官方原生的复制按钮一样。</p><h2 id="意外的结尾"><a href="#意外的结尾" class="headerlink" title="意外的结尾"></a>意外的结尾</h2><p>发布完插件，再来体验的时候，忽然发现官方<strong>自带的复制功能</strong>，就可以导出当前聊天会话的 markdown 内容，也包括了公式里的 latex 文本，所以这个脚本<strong>多少有点鸡肋</strong>。不过这个过程，还是学到了很多前端的知识，对 ChatGPT 的能力也有了更深的认识，还是很值得的。</p><p>也欢迎大家试试这个脚本，毕竟可以只复制一个公式，而不是整段内容～</p>]]></content>
    
    
    <summary type="html">本文记录作为后端开发，在 ChatGPT 指导下从零开发浏览器油猴脚本的过程。涵盖了油猴脚本工作原理、调试前端样式、捕捉 DOM 变化、添加交互等技巧。成功实现了在 ChatGPT 页面抓取Latex 数学公式文本的功能。分享了利用 ChatGPT 学习新技能、提升解决问题能力的独特经历。</summary>
    
    
    
    <category term="项目实践" scheme="https://selfboot.cn/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="前端" scheme="https://selfboot.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="ChatGPT" scheme="https://selfboot.cn/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>跟 ChatGPT 学数学：理解向量点积和余弦相似度</title>
    <link href="https://selfboot.cn/2023/09/14/chatgpt_math_product/"/>
    <id>https://selfboot.cn/2023/09/14/chatgpt_math_product/</id>
    <published>2023-09-14T22:51:07.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看一本机器学习的书，看到这么一句话 “<strong>通过计算两个向量的点积可以知道它们之间的相似度。</strong>“，这里之前一直一知半解，这次打算深入理解下。</p><p>那么怎么理解上面这句话呢？ChatGPT 的解释总结一下就是，<code>点积（Dot Product）</code>是一种数学运算，用于衡量两个向量的相似度。当两个向量完全相同时，点积会达到最大值。当两个向量垂直时，点积为0。点积的结果受向量长度的影响，所以在比较相似度时，常常会将向量单位化。通过点积，可以量化两个向量的相似度，这在各种应用场景中（如自然语言处理、图像识别等）都非常有用。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230914_chatgpt_math_product_index.png" alt="向量点积的理解"></p><span id="more"></span><p>解释很笼统，是这么个道理，但是还是有很多疑问，比如：</p><ul><li>怎么理解这里的相似？</li><li>为啥要用点积衡量相似度？</li><li>怎么理解多维向量？</li><li>向量是怎么得出来的？</li><li>具体计算步骤是怎么样的？</li><li>应用场景有哪些？</li></ul><h2 id="怎么理解相似？"><a href="#怎么理解相似？" class="headerlink" title="怎么理解相似？"></a>怎么理解相似？</h2><p>首先来看第一个问题，怎么理解这里向量的相似？两个向量的相似度并不是类似于数字的相等，而是更多地关注于两个向量是否“<strong>指向</strong>”相同或相似的方向。在<strong>不同的应用场景下，相似度的概念也可能有所不同</strong>，但通常包括以下几个方面：</p><ul><li>方向：向量的方向是相似度最直观的一面。在二维或三维空间里，你可以直观地想象两个向量是否大致指向同一方向。如果两个向量之间的夹角趋近于0度，那么它们就被认为是非常相似的。</li><li>长度：向量的长度（或模）也可以是衡量相似度的一个因素，尤其是在需要考虑“强度”或“大小”的场合。然而，在很多应用中，例如文本相似度计算，通常会忽略向量长度的影响，只考虑方向。</li><li>度量方法：不同的度量方法会给出不同类型的相似性信息。除了点积外，还有余弦相似度、欧氏距离、曼哈顿距离等多种方法。<ul><li>点积: 如前所述，主要衡量方向和长度。</li><li>余弦相似度(Cosine Similarity): 只考虑方向，不考虑长度。是点积的一个归一化版本。</li><li>欧氏距离: 衡量两点之间的“距离”，而非方向。</li></ul></li></ul><p>在不同的应用领域，相似度的解释和重要性也会有所不同。例如，在自然语言处理中，词向量的相似度常用于衡量词语的<strong>语义相似性</strong>；在推荐系统中，可能用于衡量<strong>用户或物品的相似性</strong>。</p><p>概括一下就是，两个向量的相似度是一个多面的概念，<strong>取决于你关注的是方向、长度，还是其他特性</strong>，以及你所处的具体应用场景。</p><h2 id="为啥用点积衡量？"><a href="#为啥用点积衡量？" class="headerlink" title="为啥用点积衡量？"></a>为啥用点积衡量？</h2><p>好了，了解了什么是相似，那么这里就有另一个问题，为啥要用点积来衡量？点积有以下几个重要性质，使其适用于衡量向量间的相似度：</p><ul><li>夹角的度量：点积与两向量之间的夹角有关。当两个向量的方向完全相同（即夹角为0度）时，点积最大。反之，当两个向量正交（即夹角为90度）时，点积为零。</li><li>长度的影响：点积同时考虑了向量的长度和方向。因此，长的、方向相似的向量会有更大的点积。</li><li>计算简便：点积计算相对简单，只涉及基础的算术运算，这使得它在大规模数据处理中非常实用。</li><li>可解释性：点积的结果可以轻易地通过夹角和长度进行解释，这在许多应用场景（如自然语言处理、推荐系统等）中是有用的。</li><li>线性性质：点积满足分配律和结合律，这意味着它可以轻易地应用于更复杂的数学结构和算法中。</li></ul><p>因此，通过计算两个向量的点积，我们可以快速有效地获得它们之间的相似度信息。</p><h2 id="怎么理解多维"><a href="#怎么理解多维" class="headerlink" title="怎么理解多维?"></a>怎么理解多维?</h2><p>前面说的向量，不是 2 维和 3 维空间里的向量，其实可以扩展到更高维度。多维向量的相似度实际上是对高维空间中两点关系的一种量化，与<strong>二维或三维空间的概念在本质上是相同的</strong>，只不过更难以直观地想象。在多维空间中，我们依然可以使用点积、余弦相似度、欧氏距离等方法来计算向量的相似度。</p><p>多维向量的点积是所有维度上对应元素相乘然后求和，这个值反映了两个向量在多维空间中的相似程度。数学表达式与低维空间中的相同。假设我们有两个 n 维向量 $ A &#x3D; [a_1, a_2, \ldots, a_n] $ 和 $ B &#x3D; [b_1, b_2, \ldots, b_n] $，点积定义为：<br>$$ A \cdot B &#x3D; \sum_{i&#x3D;1}^{n} a_i \times b_i $$</p><p>每个向量的范数（长度）定义为：<br>$$ | A | &#x3D; \sqrt{\sum_{i&#x3D;1}^{n} a_i^2} , \quad | B | &#x3D; \sqrt{\sum_{i&#x3D;1}^{n} b_i^2} $$</p><p>之间的夹角 θ 的余弦值定义为：<br>$$ \cos(\theta) &#x3D; \frac{A \cdot B}{| A | \times | B |} $$</p><p>这个定义在二维、三维以及任何更高维的向量空间中都是成立的，因为它是基于向量点积和范数（向量的长度）的基础性质来定义的，而这些性质在所有维度中都是一致的。</p><p>在机器学习、数据挖掘、自然语言处理等多种应用场景下，多维向量的相似度计算都起着关键作用。例如，在文本分类、推荐系统、图像识别等问题中，都会用到这些相似度或距离计算方法。</p><p>因此，即使在多维空间中，我们依然可以通过这些方法有效地量化向量间的相似度或差异性。只是与低维空间相比，高维空间更容易受到“<strong>维度灾难</strong>”（Curse of Dimensionality）的影响，这可能会让某些距离或相似度计算方法在应用上变得不那么直观或有效。</p><h2 id="怎么找到合适的向量？"><a href="#怎么找到合适的向量？" class="headerlink" title="怎么找到合适的向量？"></a>怎么找到合适的向量？</h2><p>其实对于自然语言处理或者其他领域来说，计算向量点积和余弦相似度从来不是难点，难点在于<strong>找出一组合适的高维向量，能够提取出关键信息</strong>，从而通过计算它们的点积来评估相似性。生成向量的方法有很多，比如：</p><p>基于词袋模型（Bag-of-Words）：</p><ul><li>词频（TF）：仅使用词频（Term Frequency）来表示文本。</li><li>TF-IDF（Term Frequency-Inverse Document Frequency）：使用词频（TF）和逆文档频率（IDF）的乘积来表示文本。</li></ul><p>基于词嵌入（Word Embeddings）：</p><ul><li>Word2Vec：利用神经网络模型来构建高维的词向量。</li><li>GloVe（Global Vectors for Word Representation）：通过全局统计信息来构建词向量。</li><li>FastText：与 Word2Vec 类似，但考虑了词内的子结构（如字符 n-grams）。</li></ul><p>基于语言模型：</p><ul><li>BERT（Bidirectional Encoder Representations from Transformers）：使用 Transformer 模型，并考虑了上下文信息。</li><li>GPT（Generative Pre-trained Transformer）：类似于 BERT，但通常用于生成任务。</li></ul><p>选择哪种方法取决于具体的应用场景、可用资源以及所需的准确性。通常，更复杂的方法（如 BERT 或 GPT）能提供更高的准确性，但计算成本也更高。</p><h2 id="具体计算步骤"><a href="#具体计算步骤" class="headerlink" title="具体计算步骤"></a>具体计算步骤</h2><p>向量点积和余弦相似度具体是怎么计算呢？下图是一个简单示例，有两个3维向量，\( \mathbf{A} &#x3D; [2, 4, 3] \) 和 \( \mathbf{B} &#x3D; [1, 3, 2] \)</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230912_chatgpt_math_product_3d_vector.png" alt="三维向量的可视化"></p><h3 id="人工计算"><a href="#人工计算" class="headerlink" title="人工计算"></a>人工计算</h3><p>给定两个 \( n \)-维向量 ，它们的点积计算公式为：</p><p>\[<br>\mathbf{A} \cdot \mathbf{B} &#x3D; a_1 \cdot b_1 + a_2 \cdot b_2 + \ldots + a_n \cdot b_n<br>\]</p><p>在这个例子中：</p><p>\[<br>\mathbf{A} \cdot \mathbf{B} &#x3D; 2 \times 1 + 4 \times 3 + 3 \times 2 &#x3D; 2 + 12 + 6 &#x3D; 20<br>\]</p><p>余弦相似度是通过计算两个向量的点积并将其<strong>归一化</strong>得到的，具体计算公式为：</p><p>\[<br>\text{Cosine Similarity} &#x3D; \frac{\mathbf{A} \cdot \mathbf{B}}{| \mathbf{A} | \times | \mathbf{B} |}<br>\]</p><p>其中，\( | \mathbf{A} | \) 和 \( | \mathbf{B} | \) 是两个向量的模（长度），可以通过以下公式计算：</p><p>\[<br>| \mathbf{A} | &#x3D; \sqrt{a_1^2 + a_2^2 + \ldots + a_n^2}<br>\]<br>\[<br>| \mathbf{B} | &#x3D; \sqrt{b_1^2 + b_2^2 + \ldots + b_n^2}<br>\]</p><p>在这个例子中，余弦相似度计算如下：</p><p>\[<br>\text{Cosine Similarity} &#x3D; \frac{20}{\sqrt{2^2 + 4^2 + 3^2} \times \sqrt{1^2 + 3^2 + 2^2}} \approx \frac{20}{\sqrt{29} \times \sqrt{14}} \approx 0.993<br>\]</p><p>点积为20，这是一个相对较大的值，说明两个向量在多维空间中有很好的对齐性。余弦相似度接近1（最大值为1），表示两个向量几乎指向相同的方向。</p><h3 id="程序计算"><a href="#程序计算" class="headerlink" title="程序计算"></a>程序计算</h3><p>实际中，都是通过程序直接来计算的。下面例子中，我们用 Python 随机生成两个 100 维的向量，计算它们的点积和余弦相似度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成两个 100 维的向量</span></span><br><span class="line">vector1 = np.random.rand(<span class="number">100</span>)</span><br><span class="line">vector2 = np.random.rand(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算点积</span></span><br><span class="line">dot_product = np.dot(vector1, vector2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算余弦相似度</span></span><br><span class="line">cos_similarity = dot_product / (np.linalg.norm(vector1) * np.linalg.norm(vector2))</span><br><span class="line"></span><br><span class="line">dot_product, cos_similarity</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>最后来看看点积有哪些应用场景。在自然语言处理（NLP）领域，点积和余弦相似度有着广泛的应用。下面是一些具体的例子：</p><ul><li>文本相似性和文档检索：通过计算文档或句子的词向量（通常是TF-IDF或词嵌入向量）的点积或余弦相似度，可以快速找出内容相似的文档或句子。这在信息检索、文档分类和聚类等任务中非常有用。</li><li>词义相似性：词嵌入技术（如Word2Vec、GloVe等）生成的词向量可以用点积或余弦相似度来衡量词义的相似性或相关性。</li><li>机器翻译：在序列到序列的模型，比如 Transformer 中，注意力机制经常使用点积来计算不同词或短语之间的关联强度。</li><li>情感分析：在情感分析中，可以通过计算文本与预定义情感词的点积或余弦相似度，来评估文本的情感倾向。</li></ul><p>这些只是点积和余弦相似度在自然语言处理中应用的一部分，其实还有更多的用途和扩展。</p><p>通过和 ChatGPT 不断沟通，和对它回答的一些验证，慢慢对向量的点积和余弦相似度有了一个比较清晰的认识，看来后面可以跟着老师学更多数学知识了。</p>]]></content>
    
    
    <summary type="html">本文通俗易懂地解释了向量点积和余弦相似度的计算原理、多维向量表示及其在自然语言处理等领域的应用，并给出了具体的数学公式和代码实现示例。有助于深刻理解向量相似度度量的本质，掌握运用点积和余弦相似度的技巧。</summary>
    
    
    
    <category term="计算机基础" scheme="https://selfboot.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ChatGPT" scheme="https://selfboot.cn/tags/ChatGPT/"/>
    
    <category term="数学" scheme="https://selfboot.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Protobuf 序列化消息引起的存储失败问题分析</title>
    <link href="https://selfboot.cn/2023/09/09/protobuf_field_merge/"/>
    <id>https://selfboot.cn/2023/09/09/protobuf_field_merge/</id>
    <published>2023-09-09T22:19:40.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>之前在实际业务中遇到过一个 Protobuf 序列化消息导致存储失败的问题，当时这个问题差点导致重大故障，但是也没写文章好好沉淀下来。刚好最近又遇到另一个 Protobuf 的问题，在写完 <a href="https://selfboot.cn/2023/09/07/protobuf_redefine/">C++ 中使用 Protobuf 诡异的字段丢失问题排查</a> 后，又想起前面的这个问题，这里再补一篇文章，好好介绍上次的踩坑过程。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230910_protobuf_field_merge_summary.png" alt="Protobuf 序列化消息引起的存储失败问题分析"></p><span id="more"></span><h2 id="故障回顾"><a href="#故障回顾" class="headerlink" title="故障回顾"></a>故障回顾</h2><p>业务中某个 HTTP 请求必现超时，通过日志，很快定位到是底层的某个服务读 KV 超时了，这里读 KV 在 5s 内都没有结束。因为这是个核心的 kv，监控粒度比较细，平均耗时和 P99 都是毫秒级别的，之前也没出现过耗时这么久的。</p><p>好在出现问题的这个 key 是必现超时，对于必现问题，查起来就容易多了。直接写了个工具，把超时设置久一点，这样就能读到完整的内容。因为这里存的是序列化后的 protobuf，读出来之后，直接解序列化，然后可以用 <code>DebugString</code> 打印内容。奇怪的是打印出来的是正常的业务 proto 字段，字段内容也很少，不应该超时才对。</p><p>于是又返回去重新查看超时的日志，发现日志中有打印从 kv 中读出来的 value 大小<strong>有几十兆</strong>，难怪耗时那么久。不过为啥 DebugString 打印出来的内容只有几个字段呢？为了进一步确认这里读出来的序列化后的内容有多大，进一步改了下工具，输出 value 的大小，确实是几十兆，和 KV 的日志对上了。</p><p>几十兆的内容，<strong>反序列化后输出只有几个字段，那可能就是 proto 没更新了</strong>。于是问了下小伙伴，发现这里 proto 在测试分支中，增加了一个字段，还没来得及提交。拿到新的 proto 后，重新反序列化，发现新增加的字段里有大量重复的内容。进一步梳理了整个流程，发现这里问题的触发过程还是比较隐蔽的：</p><ol><li>一个新的测试模块，set 了新的 proto 字段，序列化之后存储到了 kv；</li><li>另一个老的模块中，创建了一个新的 message，然后 Merge 从 kv 中读出来的 pb，并写回去 kv；</li><li>每次 Merge 操作都会导致 message 膨胀，调用多次后，这里 pb 的体积就会特别大。</li></ol><p>为了很好的展示这个问题，下面就准备一个简单的复现步骤。</p><h2 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h2><p>业务中的服务是用 C++ 实现的，不过这里为了更简单一些（刚好最近也在学着写Go），就用 Go 来复现。我们要模拟两个微服务来操作一个 protobuf 的 message：</p><ul><li>服务 A(下面 serverA) 依赖新添加了字段的 proto 文件，里面会 set 新的字段，然后把序列化后的 pb 存到文件 message.pb 中。</li><li>服务 B(下面 serverB) 是老的服务，用的老的 proto 文件，里面会创建新的 message，然后 Merge 从上面文件读取并反序列化的 pb；</li></ul><p>老的 Proto 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package user;</span><br><span class="line">option go_package = &quot;./;user&quot;;</span><br><span class="line"></span><br><span class="line">message Info &#123;</span><br><span class="line">  string page = 1;</span><br><span class="line">  string title = 2;</span><br><span class="line">  int32 idx = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务 A 中，给这个 proto 增加了字段 <code>string content = 4;</code>，操作都是基于新的 proto 文件。</p><h3 id="serverA"><a href="#serverA" class="headerlink" title="serverA"></a>serverA</h3><p>下面是 serverA 的实现，比较简单，需要注意的是这里用了新的字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">newInfo := &amp;user.Info&#123;</span><br><span class="line">Page:    <span class="string">&quot;example_page&quot;</span>,</span><br><span class="line">Title:   <span class="string">&quot;example_title&quot;</span>,</span><br><span class="line">Idx:     <span class="number">1</span>,</span><br><span class="line">Content: strings.Repeat(<span class="string">&quot;example_content, &quot;</span>, <span class="number">5</span>)[:<span class="built_in">len</span>(<span class="string">&quot;example_content, &quot;</span>)*<span class="number">5</span><span class="number">-2</span>], <span class="comment">// 去掉最后一个逗号和空格</span></span><br><span class="line">&#125;</span><br><span class="line">data, err := proto.Marshal(newInfo)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Marshaling error: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">err = ioutil.WriteFile(<span class="string">&quot;message.pb&quot;</span>, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Failed to write to file: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Serialized data saved to message.pb&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里模拟的是业务中很常见的使用场景，从 kv 拿到某个 pb(这里为了简单，直接创建一个新的)，然后新 set 一个字段重新保存。</p><h3 id="serverB"><a href="#serverB" class="headerlink" title="serverB"></a>serverB</h3><p>接下来是 serverB 的实现了，这个服务中由于没有重新编译，所以 proto 还是用的老的。这种情况还是很常见的，毕竟实际业务中，经常会有多个服务依赖同一个 proto 文件，更新了 proto 后，不一定会立马更新所有服务。</p><p>这里复现代码也很简单，新建 proto meesage，然后 Merge 上面 serverA 保存到文件中的 message。注意这里在一个循环中重复 Merge，模拟于业务中不断触发的过程。整体代码如下，这里只是为了演示核心逻辑，所以去掉了每一步检查 err 的代码，实际项目中一定要注意检查 err。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fileName := <span class="string">&quot;message.pb&quot;</span></span><br><span class="line">data, _ := ioutil.ReadFile(fileName)</span><br><span class="line"></span><br><span class="line">initialInfo := &amp;user.Info&#123;&#125;</span><br><span class="line">proto.Unmarshal(data, initialInfo)</span><br><span class="line"></span><br><span class="line">newInfo := &amp;user.Info&#123;</span><br><span class="line">Page:  <span class="string">&quot;page&quot;</span>,</span><br><span class="line">Title: <span class="string">&quot;title&quot;</span>,</span><br><span class="line">Idx:   <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">proto.Merge(newInfo, initialInfo)</span><br><span class="line">mergedData, _ := proto.Marshal(newInfo)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Iteration %d: Size(bytes) = %d \n&quot;</span>, i+<span class="number">1</span>, <span class="built_in">len</span>(mergedData))</span><br><span class="line">fmt.Printf(<span class="string">&quot;Iteration %d: Content     = %v\n&quot;</span>, i+<span class="number">1</span>, newInfo)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行 serverA，把 pb 序列号保存好文件。然后执行 serverB，读取文件反序列化，并执行后面的循环操作。可以看到下面的输出：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230909_protobuf_field_merge_reproduce.png" alt="不断膨胀的 pb 消息内容"></p><p>这里的 pb 内容不断膨胀，在实际业务中，如果不断触发这个 Merge 的过程，会<strong>慢慢导致</strong>很严重的后果。比如占满 KV 存储空间，或者因为内容过大导致网络传输超时。更糟糕的是，这个<strong>过程可能比较缓慢</strong>，可能是在服务 A 上线后的几个月后，才导致严重后果，排查起来就更加困难了。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>用 Go 语言就是舒服，vscode 里面可以一路跳转，看一些第三方库的代码实现简直不要太方便了。上面 <code>proto.Merge(newInfo, initialInfo)</code> 的实现如下（google.golang.org&#x2F;protobuf v1.31.0）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge merges src into dst, which must be a message with the same descriptor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Populated scalar fields in src are copied to dst, while populated</span></span><br><span class="line"><span class="comment">// singular messages in src are merged into dst by recursively calling Merge.</span></span><br><span class="line"><span class="comment">// The elements of every list field in src is appended to the corresponded</span></span><br><span class="line"><span class="comment">// list fields in dst. The entries of every map field in src is copied into</span></span><br><span class="line"><span class="comment">// the corresponding map field in dst, possibly replacing existing entries.</span></span><br><span class="line"><span class="comment">// The unknown fields of src are appended to the unknown fields of dst.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is semantically equivalent to unmarshaling the encoded form of src</span></span><br><span class="line"><span class="comment">// into dst with the UnmarshalOptions.Merge option specified.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Merge</span><span class="params">(dst, src Message)</span></span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Should nil src be treated as semantically equivalent to a</span></span><br><span class="line"><span class="comment">// untyped, read-only, empty message? What about a nil dst?</span></span><br><span class="line"></span><br><span class="line">dstMsg, srcMsg := dst.ProtoReflect(), src.ProtoReflect()</span><br><span class="line"><span class="keyword">if</span> dstMsg.Descriptor() != srcMsg.Descriptor() &#123;</span><br><span class="line"><span class="keyword">if</span> got, want := dstMsg.Descriptor().FullName(), srcMsg.Descriptor().FullName(); got != want &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;descriptor mismatch: %v != %v&quot;</span>, got, want))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;descriptor mismatch&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">mergeOptions&#123;&#125;.mergeMessage(dstMsg, srcMsg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些经典开源库的代码注释写的很不错，注意这里的注释：</p><blockquote><p>The unknown fields of src are appended to the unknown fields of dst.</p></blockquote><p>前面 ServerA 增加的 content 字段值，对于 ServerB 中的 newInfo 来说就是 <code>unknown fields</code> (因为这里没有更新proto)，每次执行 Merge 操作，都会把 content 的内容 append 到 newInfo 的 unknown fields，所以导致大小不断膨胀。这个 append 的过程在上面 <code>mergeMessage</code> 函数中，具体如下（省略掉无关代码）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o mergeOptions)</span></span> mergeMessage(dst, src protoreflect.Message) &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">src.Range(<span class="function"><span class="keyword">func</span><span class="params">(fd protoreflect.FieldDescriptor, v protoreflect.Value)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">dst.Set(fd, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(src.GetUnknown()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">dst.SetUnknown(<span class="built_in">append</span>(dst.GetUnknown(), src.GetUnknown()...))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到只要 src 有 unknown field，就会执行 append 操作。其实不止 Go 里面 Proto 的 Merge 是这样处理的，C++，Python也都是这样操作 <code>unknow field</code> 的。</p>]]></content>
    
    
    <summary type="html">通过 Go 代码复现了一个典型案例：两个服务使用不同版本的 Protobuf 消息定义，其中一个服务反复 Merge 旧消息和新消息，导致消息体积持续增大。分析了源码中的未知字段处理是导致问题的原因。</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="方法" scheme="https://selfboot.cn/tags/%E6%96%B9%E6%B3%95/"/>
    
    <category term="Go" scheme="https://selfboot.cn/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>必读的离婚法律指南：不得不防的恶意转移财产！</title>
    <link href="https://selfboot.cn/2023/09/08/divorce_money_hide/"/>
    <id>https://selfboot.cn/2023/09/08/divorce_money_hide/</id>
    <published>2023-09-08T11:17:38.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>本文是<a href="https://selfboot.cn/links">小盛律师</a>离婚法律指南系列中的一篇，给大家分享下关于<strong>恶意转移财产</strong>的法律科普。必读的离婚法律指南系列文章如下：</p><p><a href="https://selfboot.cn/2023/07/21/divorce_legal_knowlage/">当婚姻走到了尽头：必读的离婚法律指南</a><br><a href="https://selfboot.cn/2023/08/05/divorce_legal_longtime/">必读的离婚法律指南：离婚流程要多久？</a><br><a href="https://selfboot.cn/2023/07/23/divorce_legal_money/">必读的离婚法律指南：财产分割</a><br><a href="https://selfboot.cn/2023/07/29/divorce_legal_money_parent/">离婚财产分割：父母给的首付钱如何分？</a><br><a href="https://selfboot.cn/2023/08/13/divorce_legal_children/">必读的离婚法律指南：子女的抚养权、抚养费与探视权</a></p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230908_divorce_money_hide.png" alt="不得不防的离婚财产转移"></p><span id="more"></span><p>随着婚姻观念的变迁和社会经济的快速发展，离婚率逐年上升，离婚所涉及的法律问题也日益复杂化。其中，恶意转移财产作为离婚纠纷中的一大难题，越来越受到法律界和社会的关注。</p><p>离婚转移财产，特指在<strong>离婚程序中或离婚前夕</strong>，一方配偶<strong>有意将夫妻共同财产或者部分财产转移、隐匿，以逃避离婚后的财产分割责任。</strong>这种行为通常涉及一系列复杂的法律问题，因为它可能涉及到合同、信托、公司法等多个法律领域。这种行为不仅侵犯了另一方配偶的合法权益，也对法律的公正和公信力造成了严重挑战。在这个复杂的背景下，了解恶意转移财产的定义、形式、如何认定、如何举证以及如何防范，显得尤为重要。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>先来看一个比较典型的公开案例，(2020)川 * 民初2472号。本案件中，夫妻双方于2018年9月25日协议离婚，对子女抚养及双方<strong>明知的实际控制财产</strong>进行了处理和分割。</p><p>本以为自此尘埃落定，双方再无瓜葛了，结果原告在追要一个共同债务的尾款过程中，通过房管局发现被告在<strong>婚姻期间和离婚过程中对原告隐瞒了很多事</strong>，于是<strong>申请人民法院调取被告在包商银行、建设银行的账户</strong>，结果又发现被告还有工商银行、平安银行等账户，于是<strong>再次申请人民法院调取了被告的上述银行账户</strong>，发现了许多资金来往。认为这里面有不少都是恶意转移财产，于是发起了诉讼。</p><p>下面列出了每笔资金的来往以及法院的认定结果与理由，出于隐私保护，这里不列出人名。</p><table><thead><tr><th>转账对象</th><th>转账金额（元）</th><th>认定结果</th><th>事实与理由</th></tr></thead><tbody><tr><td>王**</td><td>140000</td><td>非转移财产</td><td>购买车位，足够证据链证明</td></tr><tr><td>王**</td><td>20000</td><td>非转移财产</td><td>过年红包，合理范围</td></tr><tr><td>王**</td><td>50000</td><td>原告 60%</td><td>除孩子费用外的零花钱，时间点不合理，金额过高</td></tr><tr><td>王**</td><td>10000</td><td>非转移财产</td><td>生病的医院检查费，合理支出</td></tr><tr><td>王**</td><td>50000</td><td>原告 60%</td><td>住院的护理费、营养费、孝顺费，时间点不合理，金额过高</td></tr><tr><td>王**</td><td>50000</td><td>原告 60%</td><td>备用金零花钱，时间点不合理，金额过高</td></tr><tr><td>王**</td><td>100000</td><td>原告 60%</td><td>公司项目款，实际控制人是被告，来源不明</td></tr><tr><td>李*</td><td>5000</td><td>原告 60%</td><td>被告和李*借款还款，时间点，金额，借款需求都不合理</td></tr><tr><td>李*</td><td>20000</td><td>原告 60%</td><td>被告和李*借款还款，时间点，金额，借款需求都不合理</td></tr><tr><td>李*</td><td>50000</td><td>原告 60%</td><td>被告和李*借款还款，时间点，金额，借款需求都不合理</td></tr><tr><td>李*</td><td>50000</td><td>原告 60%</td><td>被告和李*借款还款，时间点，金额，借款需求都不合理</td></tr><tr><td>李*</td><td>50000</td><td>原告 60%</td><td>被告和李*借款还款，时间点，金额，借款需求都不合理</td></tr><tr><td>李*</td><td>50000</td><td>原告 60%</td><td>被告和李*借款还款，时间点，金额，借款需求都不合理</td></tr><tr><td>李*</td><td>50000</td><td>原告 60%</td><td>被告和李*借款还款，时间点，金额，借款需求都不合理</td></tr><tr><td>杨*</td><td>50000</td><td>原告 60%</td><td>公司项目款，公司实际控制人，视为转移</td></tr><tr><td>杨*</td><td>50000</td><td>原告 60%</td><td>公司项目款，公司实际控制人，视为转移</td></tr><tr><td>杨*</td><td>5000</td><td>非转移财产</td><td>借款，已经归还</td></tr><tr><td>张*</td><td>50000</td><td>原告 60%</td><td>缺少证据证明是购买特产用于公司送礼，视为转移</td></tr><tr><td>张*</td><td>30000</td><td>原告 60%</td><td>缺少证据证明是购买特产用于公司送礼，视为转移</td></tr><tr><td>彭*</td><td>300000</td><td>各50%</td><td>离婚后收到的购房尾款，不视为隐匿</td></tr><tr><td>保险</td><td>79312</td><td>各50%</td><td>被告未续费的失效保险可退回现金，不视为隐匿</td></tr><tr><td>理财</td><td>110000</td><td>各50%</td><td>银行理财，不视为隐匿</td></tr></tbody></table><p>法院认定被告在双方离婚前，且<strong>被告已有离婚意愿情形下</strong>，未经原告同意多次对外大额转账，有转移夫妻共同财产之嫌。对于认定的 70.5 万元（王 * 25万元、李 * 27.5万元、杨 * 10万元、张* 8万元）夫妻共同财产，原告分得其中 60% 即423000 元，并由被告直接支付与原告。对于离婚时的银行账户理财产品 11 万，离婚后收到的房屋尾款 30 万，保单失效退款现金 79312，以及其他小额金额共计 498498 元，视为夫妻共同财产，但没有转移财产的嫌疑，所以各分一半。</p><p>其实转移财产在日常案件中并不少见，如果没有这个防备意识，很容易被对方转移财产，导致自己的权益受损。接下来我会给大家普及下相关的法律常识，比如常见形式，如何举证，法院如何认定以及转移的法律后果等。</p><h2 id="常见形式"><a href="#常见形式" class="headerlink" title="常见形式"></a>常见形式</h2><p>下面是离婚恶意转移财产的几种主要方式的详细介绍，每种方式都有其独特的特点和操作手法。</p><h3 id="财产隐匿"><a href="#财产隐匿" class="headerlink" title="财产隐匿"></a>财产隐匿</h3><p>财产隐匿是指一方配偶故意将夫妻共同财产藏匿起来，使其不为法院和另一方所知。常见的财产隐匿方式包括：</p><ul><li>隐藏现金和存款：将现金藏匿在不为另一方所知的地方，或将存款偷偷转移到第三方账户。</li><li>隐瞒收入：将工资、奖金、投资收益等收入存入非夫妻共同名下的账户，或交由亲友保管。</li><li>股权隐匿：通过设立虚假公司、使用架空人等方式，隐匿股权，以逃避财产分割。</li><li>债权隐匿：故意隐瞒或转移债权，如将债权转让给亲友，或以虚假债务的名义减少夫妻共同财产。</li><li>藏匿贵重物品：将贵重物品如珠宝、艺术品等交由第三方保管，或存放在非夫妻共同名下的保险箱中。</li></ul><h3 id="财产转让"><a href="#财产转让" class="headerlink" title="财产转让"></a>财产转让</h3><p>财产转让是指一方在离婚前，故意将夫妻共同财产转让给第三方，以下是一些常见的财产转让方式：</p><ul><li>转移已有存款：将夫妻共同名下的存款转移到第三方账户。</li><li>私自出售房屋：未经另一方配偶同意，私自将夫妻共同名下的房屋出售或转让给第三方。</li><li>私自出售其他夫妻共同财产：包括股权、债权、车辆、珠宝等贵重物品的私自出售或转让。</li></ul><h3 id="财产赠与"><a href="#财产赠与" class="headerlink" title="财产赠与"></a>财产赠与</h3><p>财产赠与是指一方在离婚前，故意无偿转让或赠与夫妻共同财产给第三方，常见的财产赠与方式包括：</p><ul><li>赠与不动产：如将名下的房产赠与给亲友或关联企业，通常需要办理房产过户手续。</li><li>赠与动产：如将名下的车辆、珠宝、艺术品等贵重物品赠与给第三方。</li><li>赠与金融资产：如将股票、基金、债券等金融产品赠与给亲友或关联企业。</li><li>赠与虚拟财产：如游戏账号、数字货币等。</li><li>赠与知识产权：如专利、商标、著作权等。</li></ul><p>赠与行为通常需要有书面证据，如赠与合同、过户文件等。这里还有一种比较特殊的，拒绝接受赠与和继承，一方可能因为担心赠与或继承的财产会在离婚分割中被认定为夫妻共同财产，而选择拒绝接受。</p><h3 id="虚假债务"><a href="#虚假债务" class="headerlink" title="虚假债务"></a>虚假债务</h3><p>虚假债务是指一方配偶故意制造虚假的债务，以减少夫妻共同财产，规避财产分割的责任。以下是一些常见的虚假债务方式：</p><ul><li>制作虚假的欠条：与第三方合谋，制作虚假的欠条或借据，以证明存在债务。</li><li>虚报开支：虚构或夸大开支，如虚报商业支出、医疗费用等。</li><li>在法院打虚假债务官司：与第三方合谋，通过法院诉讼方式确认虚假债务。</li></ul><p>每一种方式都有其特定的操作手法和目的，但都是为了达到规避财产分割的目的。了解这些方式有助于在离婚纠纷中更好地保护自己的合法权益。</p><h2 id="认定与举证"><a href="#认定与举证" class="headerlink" title="认定与举证"></a>认定与举证</h2><p>恶意转移财产在离婚案件中是一个复杂而敏感的问题。认定恶意转移财产需要综合考虑多个因素，并且需要有充分的证据支持。</p><p>认定一般考虑下面几个因素：</p><ul><li>时间因素：恶意转移财产通常发生在离婚诉讼即将开始或已经开始的阶段。因此，法院会特别关注离婚前后夫妻财产的变动情况。</li><li>转移方式：如果财产转移的方式明显不符合常规商业操作，如无偿转让、价格明显偏低的转让等，可能被视为恶意转移的迹象。</li><li>转移对象：如果财产转移的对象是夫妻双方的亲属、好友或关联企业，可能增加恶意转移财产的怀疑。</li><li>转移后的控制权：如果转移后的财产仍然由转移方实际控制和使用，这可能是恶意转移财产的重要证据。</li></ul><p>认定恶意转移财产需要有充分的证据支持，包括但不限于：</p><ul><li>转移前后的财产清单</li><li>转移的合同或协议</li><li>银行、税务等相关记录</li><li>证人证言</li><li>专家鉴定等</li></ul><p>值得注意的是，<strong>不是所有的财产转移都可以被视为恶意的</strong>。被指控方有权提供反驳证据，证明转移是正当和合理的，如转移是为了偿还真实债务等。恶意转移财产的关键在于<span style='color:red'>转移的动机和目的</span>。如果转移是为了规避财产分割责任，那么就可能构成恶意转移。而如果转移是出于正当的商业或个人理由，例如投资、债务偿还等，那么即使在离婚前夕发生，也不一定构成恶意转移。</p><h2 id="如何防止转移"><a href="#如何防止转移" class="headerlink" title="如何防止转移"></a>如何防止转移</h2><p>防止离婚财产转移是一个复杂而敏感的问题，需要综合运用法律和实际操作手段。</p><p>首先需要及时了解财产状况，了解夫妻共同财产的具体情况，包括存款、房产、股权、债权等。日常需要关注财产的变动情况，如银行账户的流水、房产的转让等。在婚姻关系稳定时，双方可以签署财产状态的声明，以便在将来有争议时作为参考。如果怀疑对方可能进行财产转移，应及时寻求专业律师的协助。</p><p>如果可能，与对方沟通协商，达成财产分割的初步协议。协议可以是口头的，也可以是书面的，但书面协议更有法律效力。</p><p>如果走到了离婚诉讼，那么诉讼过程中，可以向法院<span style='color:red'>申请财产保全</span>，以防止对方转移财产。财产保全包括冻结银行账户、查封房产、禁止股权转让等。</p><h2 id="转移的法律后果"><a href="#转移的法律后果" class="headerlink" title="转移的法律后果"></a>转移的法律后果</h2><p>根据中国的《民法典》的相关规定，恶意转移财产可能构成对另一方配偶财产权益的侵害。如果法院认定存在恶意转移，可能会采取一系列措施，如撤销转移、追回财产、赔偿损失等，以保护受害方的合法权益。如果离婚后发现对方的转移行为，可向法院提起诉讼，请求重新分割夫妻共同财产。经法院判决后，恶意转移财产的一方需按照要求予以执行，恶意拒绝履行的，会被登记为失信人员。</p><p>在某些情况下，恶意转移财产可能构成刑事犯罪，如诈骗、侵占等。刑事责任可能包括罚金、监禁等刑罚。</p><p>法律依据，《<a href="http://www.npc.gov.cn/npc/c30834/202006/75ba6483b8344591abd07917e1d25cc8.shtml">中华人民共和国民法典</a>》第一千零九十二条：</p><blockquote><p>夫妻一方隐藏、转移、变卖、毁损、挥霍夫妻共同财产，或者伪造夫妻共同债务企图侵占另一方财产的，在离婚分割夫妻共同财产时，对该方可以少分或者不分。离婚后，另一方发现有上述行为的，可以向人民法院提起诉讼，请求再次分割夫妻共同财产。</p></blockquote><p>如果有需要法律咨询，记得找小盛律师：<a href="https://selfboot.cn/links">https://selfboot.cn/links</a> 哦。</p>]]></content>
    
    
    <summary type="html">介绍了离婚中恶意转移财产的法律风险，通过案例分析阐述了常见的财产隐匿、转让、赠与、虚假债务等方式，并提出了如何认定、举证、防范恶意转移财产的建议。挽回权益的途径包括申请财产保全、提起诉讼重新分割等。旨在提高公众的法律意识，维护合法权益。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="婚姻家庭" scheme="https://selfboot.cn/tags/%E5%A9%9A%E5%A7%BB%E5%AE%B6%E5%BA%AD/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中使用 Protobuf 诡异的字段丢失问题排查</title>
    <link href="https://selfboot.cn/2023/09/07/protobuf_redefine/"/>
    <id>https://selfboot.cn/2023/09/07/protobuf_redefine/</id>
    <published>2023-09-07T22:24:48.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Protobuf 的时候遇到了一个<strong>特别诡异</strong>的问题，排查了一天，最后才发现问题所在。本篇文章记录下问题的排查、定位过程。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_cover.png" alt="Protobuf 字段 set 后丢失"></p><span id="more"></span><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>我们的一个服务中有这样一个简单的逻辑，设置好 proto 协议中的字段，然后把 pb 转换成 json 后，发送一个 http 请求。在最近的一个变更中，在原来的 proto 里面增加了一个字段 user_type，然后给这个字段赋值。改动很简单，正常来说，新的 http 请求中 json 中应该在相应位置多一个 user_type 字段。但是发到测试环境后发现，新的请求 json 里没有新增字段，原来有的字段也丢失了不少！</p><p>这就有点见鬼了，项目中使用了几年的 protobuf，从来没遇见类似的问题呀。只是增加一个 optional 字段然后赋值，为啥老的字段也没了？</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>这里首先排除一些可能的点：</p><ol><li>代码逻辑问题：检查了整个服务代码，确认了没有地方会去删除设置的字段；</li><li>proto 版本不一致：重新编译了设置字段以及 pb2json 部分的代码，确实都是用了最新的 proto 文件。</li></ol><p>那会不会是服务里自己实现 pb2json 反射有问题？会在某些特殊场景，丢掉某些字段？于是不用这个函数，改成用 protobuf 自带的 DebugString 函数来打印 pb 的内容，发现还是有丢失字段。</p><p>有点不可思议，DebugString 函数是 protobuf 自带的，应该没问题才对。前面排查问题，需要加日志，改服务上线，比较麻烦。为了缩小代码排除其他干扰，<strong>快速验证改动</strong>，就单独写了一个工具，在工具里设置 proto 中的字段，然后打印出来，结果还是丢失了字段！</p><p>再思考下整个改动，这里因为 proto 增加了 user_type 字段，然后代码里给这个字段设置了一个值，接着就出问题了。那么这里只改动 proto，不给新加的 user_type 字段设值，会不会有问题呢？改了下工具，发现这样打印出来的字段也是有丢失！</p><p><strong>只是因为 proto 增加了一个字段，DebugString 打印出来的字段就会漏掉部分？</strong>！这不科学啊，虽然我们的 protobuf 版本很老，但是用了这么久也没出现过这种问题。这里的 proto 和之前其他 proto 的差别在于有很多层嵌套 message，以前倒也没这么多层嵌套的，会不会和这个有关系呢？于是直接设置 user_type 所在的 message，不管其他嵌套 message，结果还是有问题！</p><p>到这就有点怀疑 protobuf 了，<strong>是不是老版本有某些 bug</strong>？我们用的是 2.6.1 版本，大概 10 年前版本了，难道这个特殊 proto 触发了它的某个神秘 bug？在网上搜了一圈 “profobuf c++ lack field” 之类的关键词，并没有看到相关的 bug 描述。</p><p>有点抓狂，<strong>理智告诉我即便是低版本的 protobuf 也不会有这么低级的 Bug</strong>，但是又实在找不出我的用法有啥问题会导致这么奇怪的表现。于是把问题抛给了一些小伙伴，毕竟自己各种尝试，实在找不到头绪了。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>果然，高手在身边啊，小伙伴去复现了后，立马提到一个关键点，在项目中有另一个 proto，和这个几乎一样。我也想起来，这个模块其实从其他模块拷过来的，进行了一些更改。但是用的 proto 协议还是一样的，只是这里的增加了一个新的字段。</p><p>直觉告诉我问题应该就是小伙伴发现的这里了，为了快速验证，在这个新的 proto 里换了一个 namespace，然后重新编译运行，一切恢复了正常！看来确实是因为这里链接二进制的时候，读错了 proto 文件，导致字段解析出现了问题，才丢失了部分字段值。</p><p>不过还有不少疑问需要解决：</p><ol><li><strong>什么时候引入了另一个 proto？</strong></li><li><strong>两个 proto 有一样的字段和函数，为啥没有链接符号重定义错误，并且最终用了错误的 proto？</strong></li><li><strong>为啥链接了另一个 proto，就导致 DebugString 函数读取的字段不一样？</strong></li></ol><p>带着这些疑问，继续往下深入。首先想着得有一个简单可以复现的代码，毕竟项目的代码比较庞大，编译慢，并且干扰也比较多，分析起来麻烦。另外，项目代码也涉及了很多业务信息，不方便公开。所以得有一个和当前项目完全无关，并且足够简单，只关注核心问题的代码。</p><h2 id="最少复现代码"><a href="#最少复现代码" class="headerlink" title="最少复现代码"></a>最少复现代码</h2><p>实际动手起来，发现复现这里的问题比想象中简单，只用下面少量代码即可。主要就两个 proto 文件和一个 main.cpp 文件。</p><p>首先是 <code>modelA/data.proto</code>，里面记录一个字段，对应我们项目中比较老的 proto：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line">package model;</span><br><span class="line">message HWPushAndroid&#123;</span><br><span class="line">    optional string bi_tag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 <code>modelB/data.proto</code>，里面的 proto package 和 message name 都和 <code>modelA/data.proto</code> 一样，但是里面多了两个字段，对应项目中比较新的 proto：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line">package model;</span><br><span class="line">message HWPushAndroid&#123;</span><br><span class="line">    optional int32 collapse_key = <span class="number">1</span> [<span class="keyword">default</span> = <span class="number">-1</span>];</span><br><span class="line">    optional string bi_tag = <span class="number">2</span>;</span><br><span class="line">    optional int32 target_user_type = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们在 <code>main.cpp</code> 中使用 <code>modelB/data.proto</code> 中的字段，先给每个字段赋值，然后打印出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;modelB/data.pb.h&quot;</span>  <span class="comment">// 假设我们想使用 modelB 的版本</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    model::HWPushAndroid androidMessage;</span><br><span class="line">    androidMessage.<span class="built_in">set_collapse_key</span>(<span class="number">100</span>);    <span class="comment">// 这个字段只在 modelB 的版本中存在</span></span><br><span class="line">    androidMessage.<span class="built_in">set_bi_tag</span>(<span class="string">&quot;example_tag&quot;</span>);</span><br><span class="line">    androidMessage.<span class="built_in">set_target_user_type</span>(<span class="number">1</span>);  <span class="comment">// 这个字段只在 modelB 的版本中存在</span></span><br><span class="line">    std::cout &lt;&lt; androidMessage.<span class="built_in">DebugString</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先用 protoc 编译 proto 文件，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=. modelA/data.proto</span><br><span class="line">protoc --cpp_out=. modelB/data.proto</span><br></pre></td></tr></table></figure><p>接着编译、链接 main 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -I./ -o main ./modelA/data.pb.cc -lprotobuf</span><br></pre></td></tr></table></figure><p>运行后就会发现一个奇怪的输出：<code>bi_tag: &quot;example_tag&quot;</code>；注意这里的输出和 protoc 的版本也有关系，这个是 <code>3.21.12</code> 版本输出的 DebugString，在一些老的版本比如 2.6.1，这里输出可能不同，甚至是丢掉某些字段值。</p><p>我们明明设置了三个字段，为啥输出只有一个呢？很简单，因为链接错了 <code>data.proto</code>; 链接的 prpto 里面只有 <code>bi_tag</code> 字段，所以只有这个字段的值被打印出来了。其实这里也看 protoc 的版本，在老版本输出可能是空的，甚至析构的时候会 core 掉。新版本的 protoc 做的比较好，能够兼容这种情况。</p><p>正常的编译、链接应该命令应该是 <code>g++ main.cpp -I./ -o main ./modelB/data.pb.cc -lprotobuf</code>，这样就能正常输出三个字段了。</p><h2 id="补充思考"><a href="#补充思考" class="headerlink" title="补充思考"></a>补充思考</h2><p>我们已经成功复现了这里的问题，接下来得回答前面几个问题了。</p><h3 id="项目依赖关系"><a href="#项目依赖关系" class="headerlink" title="项目依赖关系"></a>项目依赖关系</h3><p>第一个问题是，什么时候引入了另一个 proto？我们的 C++ 项目用 <a href="https://bazel.build/?hl=zh-cn">bazel</a> 来构建，我构建的 target <strong>理论上</strong> 不会依赖modelA 里面错误的 proto。但是实际上确实依赖了，可以用 query 来查看下依赖关系：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bazel query &#x27;deps(//**/**:demo_tools)&#x27; --output graph &gt; graph.in</span><br><span class="line">dot -Tpng graph.in -o graph.png</span><br></pre></td></tr></table></figure><p>上面会输出一个依赖关系图，发现构建 target 确实同时依赖了 <code>modelA</code> 和 <code>modelB</code> 中的 proto，原因是 tools 直接依赖一个 comm 库，comm 库又依赖了 <code>modelA</code>，modelB 则是被 tools 直接依赖。</p><p>接着就是第 2 个疑问：<strong>既然同时依赖两个库，proto 里面又有相同的函数，为啥链接没有报符号重复定义，并且最终用了错误的 proto ？</strong></p><h3 id="链接符号决议"><a href="#链接符号决议" class="headerlink" title="链接符号决议"></a>链接符号决议</h3><p>在解答上面疑问之前，回到前面的复现代码，编译的时候同时引入 modelA 和 modelB 中的 <code>data.pb.cc</code>，看看会发生什么：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -I./ -o main ./modelB/data.pb.cc ./modelA/data.pb.cc -lprotobuf</span><br></pre></td></tr></table></figure><p>结果如下图，报了符号重复定义的错误：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230905_protobuf_redefine.png" alt="同时依赖两个模块导致链接失败"></p><p>这是因为<strong>链接器在目标文件中找到了两个相同的强符号定义，没法选择具体用哪个，于是直接报链接错误</strong>。但是实际项目中，这两个 proto 在不同模块，先编译成库之后再链接的。链接分动态库和静态库，这里先看 C++ 动态库的情况，把这两个 proto 编译成动态库，然后用动态链接。具体命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -c -fPIC modelA/data.pb.cc -o modelA/data.pb.o -I.</span><br><span class="line">g++ -c -fPIC modelB/data.pb.cc -o modelB/data.pb.o -I.</span><br><span class="line">g++ -shared -o libmodelA.so modelA/data.pb.o</span><br><span class="line">g++ -shared -o libmodelB.so modelB/data.pb.o</span><br><span class="line">g++ main.cpp -I./ -o main -L./ -lmodelA -lmodelB -lprotobuf -Wl,-rpath,./</span><br><span class="line">g++ main.cpp -I./ -o main -L./ -lmodelB -lmodelA -lprotobuf -Wl,-rpath,./</span><br></pre></td></tr></table></figure><p>链接的时候，modelA 和 modelB 有两种链接顺序，二进制运行的结果也有两种：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_linkorder.png" alt="动态链接顺序不同，结果也不同"></p><p>静态链接又是什么表现呢？静态链接的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -c modelA/data.pb.cc -o modelA/data.pb.o -I.</span><br><span class="line">g++ -c modelB/data.pb.cc -o modelB/data.pb.o -I.</span><br><span class="line">ar rcs libmodelA.a modelA/data.pb.o</span><br><span class="line">ar rcs libmodelB.a modelB/data.pb.o</span><br><span class="line">g++ main.cpp -I./ -o main -L./  -lmodelA -lmodelB -lprotobuf</span><br><span class="line">g++ main.cpp -I./ -o main -L./  -lmodelB -lmodelA -lprotobuf</span><br></pre></td></tr></table></figure><p>发现和动态链接一样，链接顺序不同，结果也不同。从实验的结果来看，链接的时候，<strong>不管是动态链接还是静态链接，实际用的都是靠前面的库的符号定义</strong>。这种行为是由于链接器的设计决定的，不特定于静态或动态链接。不过，要注意这并不是所有链接器都会这样做，这是特定于 GNU 链接器（通常用于 Linux）的行为，其他链接器可能有不同的行为或选项。</p><p>在经典大作<a href="https://hansimov.gitbook.io/csapp/">《深入理解计算机系统》</a>一书中，7.6.3 <strong>链接器如何使用静态库来解析引用</strong>对这里有详细的解释。</p><h3 id="链接了哪些符号"><a href="#链接了哪些符号" class="headerlink" title="链接了哪些符号"></a>链接了哪些符号</h3><p>接着来回答第三个问题：为啥链接了另一个 proto，就导致 DebugString 函数读取的字段不一样？</p><p>通过上面的实验，我们知道因为链接顺序不对，导致 protobuf 的 <code>DebugString</code> 读出来的字段不一样。那么具体是因为哪些符号决议错误，导致输出不对呢？我们可以用 <code>objdump</code> 命令来查看下二进制里面的符号，先来看下 DebugString 符号，具体命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -tT  main | grep DebugString</span></span><br><span class="line">0000000000000000       F *UND*0000000000000000              _ZNK6google8protobuf7Message11DebugStringB5cxx11Ev</span><br><span class="line">0000000000000000      DF *UND*0000000000000000  Base        _ZNK6google8protobuf7Message11DebugStringB5cxx11Ev</span><br></pre></td></tr></table></figure><p>不同链接顺序生成的二进制文件中，DebugString 函数都是被标记为 <code>UND</code>（未定义），这意味着这个函数在当前二进制文件中并没有定义，而是在运行时从某个动态库中加载。通过 ldd 找到二进制依赖的 protobuf 动态库地址，然后用 readelf 可以验证确实在 libprotobuf 这个动态库里面：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ldd mainA</span><br><span class="line">linux-vdso.<span class="keyword">so</span>.<span class="number">1</span> (<span class="number">0</span>x00007ffe53b86000)</span><br><span class="line">libprotobuf.<span class="keyword">so</span>.<span class="number">32</span> =&gt; /lib/x86_64-linux-gnu/libprotobuf.<span class="keyword">so</span>.<span class="number">32</span> (<span class="number">0</span>x00007f6682359000)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">nm</span> -D /lib/x86_64-linux-gnu/libprotobuf.<span class="keyword">so</span>.<span class="number">32</span> | <span class="keyword">grep</span> DebugString</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>DebugString</code> 的实现在 <a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/text_format.cc#L131">protobuf&#x2F;src&#x2F;google&#x2F;protobuf&#x2F;text_format.cc</a> 中，用到了<strong>反射机制</strong>，比较复杂，暂时没搞明白，等有时间可以继续研究下，整理一个专门的文章。这里我们只是想知道为啥没输出 <code>target_user_type</code>，所以先试着过滤这个符号，看看不同顺序下的二进制有没有区别，如下图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230906_protobuf_redefine_sysbol.png" alt="动态链接顺序不同，结果也不同"></p><p>可以看到两种链接顺序下，都有 modelB 里面的符号 <code>set_target_user_type</code>，对应了两个函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZN5model13HWPushAndroid20set_target_user_typeEi</span></span><br><span class="line">model::HWPushAndroid::set_target_user_type(int)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZN5model13HWPushAndroid30_internal_set_target_user_typeEi</span></span><br><span class="line">model::HWPushAndroid::_internal_set_target_user_type(int)</span><br></pre></td></tr></table></figure><p>这个是符合预期的，因为 main 里面调用了这个函数来设置，modelA 里面没有这个字段，不论什么顺序，都会链接到 modelB 的符号实现。但是 modelA 在前面的情况下，缺少了下面的符号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZN5model13HWPushAndroid9_Internal24set_has_target_user_typeEPN6google8protobuf8internal7HasBitsILm1EEE</span></span><br><span class="line">model::HWPushAndroid::_Internal::set_has_target_user_type(google::protobuf::internal::HasBits&lt;1ul&gt;*)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZNK5model13HWPushAndroid26_internal_target_user_typeEv</span></span><br><span class="line">model::HWPushAndroid::_internal_target_user_type() const</span><br></pre></td></tr></table></figure><p>对于 protobuf 来说，在生成的消息类型中，关联有这个类型的所有字段、嵌套类型等元信息。这样运行时就可以进行非常丰富的反射操作，包括但不限于查找字段、动态创建消息、动态设置和获取字段值等。而这里先链接 modelA 里面的 pb，导致 proto 里面的消息类型没有关联到字段 target_user_type，就没有用到函数 <code>_internal_target_user_type()</code> 和 <code>set_has_target_user_type</code>，所以二进制中没有这 2 个符号。</p><p>再进一步，如果我在 main.cpp 直接访问这里的 target_user_type 字段，会发生什么呢？如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">std::cout &lt;&lt; androidMessage.<span class="built_in">target_user_type</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; androidMessage.<span class="built_in">DebugString</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>可以看到，DebugString 的输出还是和链接顺序有关系，但是不论在哪种顺序下，直接输出 target_user_type 都是可以的。这一次因为直接用到了 target_user_type() 函数，所有二进制中都有下面的符号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZNK5model13HWPushAndroid16target_user_typeEv</span></span><br><span class="line">model::HWPushAndroid::target_user_type() const</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c++filt _ZNK5model13HWPushAndroid26_internal_target_user_typeEv</span></span><br><span class="line">model::HWPushAndroid::_internal_target_user_type() const</span><br></pre></td></tr></table></figure><p>至此文章的三个疑问也都解决了。我们在用 protobuf 的时候，一定要注意<strong>链接的 proto 实现是否正确</strong>，如果有多个 proto 的字段有重复，可以用 namespace 来区分出来，这样就不会出现本文的链接错误问题。</p><p>这个问题排查过程中，真的是有“见鬼”了的感觉，明明简单而又常用的用法，也会有这么超出预期的表现。经过各种排除法的调试，一点也没有定位到问题所在，真是有种遇到“鬼打墙”的无力感。好在有小伙伴的提点，才拨开迷雾，最终定位到问题。并通过复现，进一步深入理解这背后的原因。</p>]]></content>
    
    
    <summary type="html">记录了在 C++ Protobuf 使用中遇到的一个字段丢失的诡异问题，通过排查分析发现是因为链接了不同版本的 Proto 文件导致。介绍了问题的复现、依赖分析、符号查看等定位思路。提醒在使用 Protobuf 时注意链接版本一致非常重要，否则可能导致难以预测的问题。</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="方法" scheme="https://selfboot.cn/tags/%E6%96%B9%E6%B3%95/"/>
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="ChatGPT" scheme="https://selfboot.cn/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>用 Python 模板库 docxtpl 批量制作 Word 文档</title>
    <link href="https://selfboot.cn/2023/09/04/batch_docx_replace/"/>
    <id>https://selfboot.cn/2023/09/04/batch_docx_replace/</id>
    <published>2023-09-04T11:59:36.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中，重复性的劳动往往枯燥乏味。利用 Python 的力量来优化工作流程，可以极大地提高效率，事半功倍。本文将详细介绍如何使用 Python 模板库 docxtpl，<strong>在极短的时间内，自动批量生成多份 Word 文档</strong>，节省大量手工操作时间，从而解放双手，轻松完成任务。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230904_batch_docx_replace_summary.png" alt="Python docxtpl 批量制作 word 文件"></p><span id="more"></span><p>事情的起因是这样的，<a href="https://selfboot.cn/links">小盛律师</a> 有一批案件，每个当事人的案情都是差不多的，只是当事人的姓名、身份证号、地址等信息不同。小盛律师需要为每个当事人准备 Word 文件，Word 里面除了当事人的个人信息外，其他都是一样的内容。</p><p>小盛律师有一份 Excel 文件，里面登记了当事人的信息。按照以前的做法，需要打开 Excel，然后一个个复制信息，贴到每个当事人的 Word 文件中去，最后保存。这样的工作量很大，几十个当事人，每个当事人有好多条数据，每个都要复制粘贴到 word 中指定位置，要复制粘贴几百次。除了体力劳动量大，还很容易出错，律师的工作就是要避免出错，所以这种方法不可取。</p><p><strong>既然是重复的体力劳动，程序肯定就能派上用场，机器重复起来精准又快速。</strong>于是，小盛律师就找到了我，希望我能帮她写一个程序，自动根据 excel 文件里面的数据，批量制作合适的 Word 文件。</p><h2 id="简单替换"><a href="#简单替换" class="headerlink" title="简单替换"></a>简单替换</h2><p>小盛<strong>说自己的需求很简单</strong>，读 Excel 拿数据，替换到 Word 里，然后<strong>给我 5 分钟时间</strong>让我搞定(很有当产品经理的天赋)。于是就习惯性先请教 ChatGPT 老师，让它来写代码。在和它沟通半天，不断细化需求后，终于说服 AI 放弃用 <code>python-docx</code> 这个库了。</p><p>因为我在对文本进行替换的同时，需要<strong>保存原来文件中的样式</strong>。在 Word 的 <code>.docx</code> 文件中，样式和文本是分开存储的。一个段落中的文本可能由多个 Run 对象组成，每个 Run 对象可能有不同的样式，在多个 Run 对象中进行文本替换，并保留格式，会非常复杂。此外，这个库的 API 也比较复杂，还要了解 Run 对象，对使用者不友好。好在我足够机智，提醒 ChatGPT 可以考虑其他库来进行文本替换，于是 ChatGPT 老师就推荐了 <code>docxtpl</code> 这个库。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230904_batch_docx_replace_package.png" alt="Python docxtpl 批量制作 word 文件"></p><p><code>docxtpl</code> 是一个基于 <code>python-docx</code> 的模板库，它的作者觉得使用 python-docx 这个库来修改 word 太麻烦了，于是借鉴 Jinja2 模板库的思路，开发了 <code>docxtpl</code> 这个库。它的使用方法很简单，主要分三步：</p><ol><li>在 Word 文档中用 <code>&#123;&#123; &#125;&#125;</code> 包裹起来需要替换的文本；</li><li>用 <code>docxtpl</code> 的 <code>DocxTemplate</code> 类来加载 Word 模板，并且提供替换前、后的内容；</li><li>用 <code>render</code> 方法渲染模板。</li></ol><p>这个就简单多了，把小盛律师的样本 Word 文件拿来后，简单改成一个符合 Jinja2 语法的模板文件，假设某一个字段需要从表格的第 B 列获取，就直接写成 <code>&#123;&#123; B &#125;&#125;</code>。比如下面的内容：</p><blockquote><p>贵院受理的 <code>&#123;&#123; A &#125;&#125;</code> 与 <code>&#123;&#123; B &#125;&#125;</code> 租赁合同纠纷一案</p></blockquote><p>这里的模板变量可以在 Word 里面指定样式，比如字体、字号、颜色等。然后用 pandas 读取 Excel 里面的 A 和 B 列，再用 <code>docxtpl</code> 能很快执行文本替换，同时保留格式，核心代码很简单，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_word_files</span>(<span class="params">excel_filepath, word_template_filepath, output_dir</span>):</span><br><span class="line">    df = pd.read_excel(excel_filepath)</span><br><span class="line">    skip_max_rownum = <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> df.iloc[skip_max_rownum:].iterrows():</span><br><span class="line">        doc = DocxTemplate(word_template_filepath)</span><br><span class="line">        context = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, col_value <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">            col_label = excel_col_label(i)</span><br><span class="line">            context[col_label] = col_value</span><br><span class="line">        doc.render(context)</span><br><span class="line">        new_filename = <span class="string">f&quot;demo_<span class="subst">&#123;row.iloc[<span class="number">1</span>]&#125;</span>.docx&quot;</span></span><br><span class="line">        new_filepath = os.path.join(output_dir, new_filename)</span><br><span class="line">        doc.save(new_filepath)</span><br></pre></td></tr></table></figure><h3 id="日期特殊处理"><a href="#日期特殊处理" class="headerlink" title="日期特殊处理"></a>日期特殊处理</h3><p>写好代码后，执行替换后，发现有部分字段替换后的值不对。在 Excel 中有一列看着是一个日期 ‘2023&#x2F;04&#x2F;12’，但是替换到 Word 里面后成为了 1970.1.1，这是怎么回事呢？</p><p>打印了下 pandas 读取到的值，发现是一个整数，而不是字符串。这是因为 Excel 中的日期是以 <code>1900 年 1 月 1 日</code>为基准的，所以 2023&#x2F;04&#x2F;12 在 Excel 中的值是 44397，这个值是 Excel 用来表示日期的天数，而不是字符串。知道这点后，只需要把这个天数加上开始日期就行，这里 ChatGPT 给的代码是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">excel_date_to_datetime</span>(<span class="params">excel_date</span>):</span><br><span class="line">    <span class="keyword">if</span> pd.isna(excel_date):</span><br><span class="line">        <span class="keyword">return</span> pd.Timestamp(<span class="string">&#x27;1970-01-01&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> datetime(<span class="number">1899</span>, <span class="number">12</span>, <span class="number">30</span>) + timedelta(days=<span class="built_in">float</span>(excel_date))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Failed to convert date: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> pd.Timestamp(<span class="string">&#x27;1970-01-01&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里开始日期变成了 <code>1899.12.30</code>，这是因为 Excel 日期系统中存在一个错误：它把 1900 年当作闰年，实际上它不是。因此，1900 年 2 月有 29 天在 Excel 日期系统里。为了解决这个问题，一种通用的做法是从 1899 年 12 月 30 日开始计算，这样可以在计算日期时跳过这个“多出来”的一天（即 1900 年 2 月 29 日）。ChatGPT 老师还是高，自动帮我避雷了。</p><p>关于 Excel 的 date 日期格式，可以参考这两篇文章：</p><ul><li><a href="https://support.microsoft.com/en-us/office/date-systems-in-excel-e7fe7167-48a9-4b96-bb53-5612a800b487">Date systems in Excel</a></li><li><a href="https://learn.microsoft.com/en-us/office/troubleshoot/excel/wrongly-assumes-1900-is-leap-year">Excel incorrectly assumes that the year 1900 is a leap year</a></li></ul><h2 id="复杂替换"><a href="#复杂替换" class="headerlink" title="复杂替换"></a>复杂替换</h2><p>只是简单替换当然没啥难度，可是工作中也会遇到一些更复杂的替换场景。</p><h3 id="计算后的数据"><a href="#计算后的数据" class="headerlink" title="计算后的数据"></a>计算后的数据</h3><p>这不，小盛律师的文件中有一些计算公式，需要填一些计算后的值，比如内容：</p><blockquote><p>被告的损失为：<code>&#123;&#123; Y &#125;&#125;</code>×120% &#x3D; ??? 元</p></blockquote><p>这里 Excel 的 Y 列是损失费用，但是需要乘以一个系数，填到 Word 里面。Excel 中并没有这个计算后的数据，于是可以在代码里计算好结果，然后用 <code>&#123;&#123; Y_calculated &#125;&#125;</code> 包裹起来，替换到 Word 里面。计算的代码部分也很简单，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> col_label == <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">    context[col_label] = <span class="built_in">int</span>(col_value)</span><br><span class="line">    context[<span class="string">&#x27;Y_calculated&#x27;</span>] = <span class="built_in">int</span>(col_value * <span class="number">1.2</span>)  <span class="comment"># 预先计算</span></span><br></pre></td></tr></table></figure><p>其实这里要是支持在 Jinja2 模板中进行计算就更好了，比如模板可以写成 <code>&#123;&#123; Y | calculate &#125;&#125;</code>，这样就可以在模板中直接计算了。但是 <code>docxtpl</code> 并不支持这样的语法，所以只能在代码中计算好结果，然后替换到 Word 里面。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>小盛的文档中还需要根据 Excel 数据动态显示部分内容，比如费用字段非空时才显示相关文字。这可以通过 <code>docxtpl</code> 支持的条件语句 <code>jinja2</code> 语法来实现。</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">一、</span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> S != 0 %&#125;</span><span class="language-xml">判令被告向原告支付租金</span><span class="template-variable">&#123;&#123; S &#125;&#125;</span><span class="language-xml">元；</span></span><br><span class="line"><span class="language-xml">二、</span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> T != 0 %&#125;</span><span class="language-xml">判令被告向原告支付费用</span><span class="template-variable">&#123;&#123; T &#125;&#125;</span><span class="language-xml">元；</span></span><br><span class="line"><span class="language-xml">三、</span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> Y != 0 %&#125;</span><span class="language-xml">判令被告向原告支付维修费</span><span class="template-variable">&#123;&#123; Y &#125;&#125;</span><span class="language-xml">元；</span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure><p>因为在 Word 里面有列表，为了保持列表格式和数字序号，这里的 <code>&#123;% endif %&#125;</code> 都需要放在合适的位置才行。</p><p>除了前面的简单替换，条件语句等复杂替换，<code>docxtpl</code> 还支持循环语句、表格、设置富文本等，可以参考它的<a href="https://docxtpl.readthedocs.io/en/latest/">文档</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用 100 多行代码，就能实现一个批量制作 Word 文档的程序，这是 Python 的强大之处。相比人工一个个复制粘贴，程序速度飞快，1 分钟就能处理成百上千的文档，而且还不容易出错。对于没有编程功底的人来说，借助 ChatGPT 老师的力量，也能完成这样的任务。这就是目前 AI 的一大用处，<strong>让每个人都能快速上手专业领域以外的知识</strong>，特别是编程领域。</p>]]></content>
    
    
    <summary type="html">介绍了如何用 Python 的 docxtpl 库批量制作 Word 文档，包括简单文本替换与保留样式、处理 Excel 日期格式、插入计算结果、条件判断语句等技巧。通过 pandas 读取 Excel 数据，render 模板，可以在1分钟内批量生成数十份 Word文件。避免手工操作的低效率与错误。利用程序自动化提高工作效率，是 Python 的典型应用场景。</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="方法" scheme="https://selfboot.cn/tags/%E6%96%B9%E6%B3%95/"/>
    
    <category term="ChatGPT" scheme="https://selfboot.cn/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT 代码解释器：离线安装不支持的 Python 包</title>
    <link href="https://selfboot.cn/2023/08/25/gpt4_code_interpreter_module/"/>
    <id>https://selfboot.cn/2023/08/25/gpt4_code_interpreter_module/</id>
    <published>2023-08-25T21:02:25.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>OpenAI 在代码解释器执行环境中预装了很多 Python 包，可以参考<a href="https://selfboot.cn/2023/07/09/gpt4_code_interpreter_limit/">ChatGPT 代码解释器：资源限制详解</a>中的描述。这些库已经能满足大部分的数据分析和可视化需求，但是如果想用的包没有安装，就不能用了吗？</p><p>当然不是了！在 <a href="https://selfboot.cn/2023/08/23/not-smart-chatgpt/">真实例子告诉你 ChatGPT 是多会胡编乱造！</a> 一文的<code>代码解释器库缺失</code> 部分我提到过可以手动安装代码解释器中不支持的 Python 包，比如 jieba 分词，这篇文章就详细聊下这里的安装方法。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230825_gpt4_code_interpreter_module_cover.png" alt="ChatGPT Code Interpreter 安装 Python 库"></p><span id="more"></span><h2 id="代码执行环境"><a href="#代码执行环境" class="headerlink" title="代码执行环境"></a>代码执行环境</h2><p>为了能够在 ChatGPT 的代码执行环境离线安装 Python 库，我们得先了解下当前代码执行环境的能力。目前 OpenAI 尚未公布执行环境的技术实现细节，不过根据我之前的几篇文章：</p><ul><li><a href="https://selfboot.cn/2023/07/17/gpt4_code_interpreter_cpu/">ChatGPT 代码解释器：OpenAI 提供了多少 CPU</a></li><li><a href="https://selfboot.cn/2023/07/12/gpt4_code_interpreter_image/">ChatGPT 代码解释器：自然语言处理图片</a></li><li><a href="https://selfboot.cn/2023/07/10/gpt4_code_interpreter_data/">ChatGPT 代码解释器：数据分析与可视化</a></li><li><a href="https://selfboot.cn/2023/07/09/gpt4_code_interpreter_limit/">ChatGPT 代码解释器：资源限制详解</a></li></ul><p>我们发现这个执行环境中，有一个存储空间 <code>/mnt/data</code> 可以存储我们上传的文件以及程序生成的文件，此外这个沙箱执行环境的表现有点类似 Jupyter，前面导入的变量，在后面的代码中仍然可以访问。长时间不访问对话，重新进入的话，会丢失之前的执行上下文。</p><p>我们知道在 Jupyter 中就可以安装 Python 包， 当前 ChatGPT 的执行环境应该也可以安装，下面接着尝试。</p><h2 id="简单包安装"><a href="#简单包安装" class="headerlink" title="简单包安装"></a>简单包安装</h2><p>在了解过代码解释器执行环境的特点后，尝试让 ChatGPT 本地安装一个比较简单的分词库 jieba。具体步骤还是很简单的，先去 <a href="https://pypi.org/">pypi</a> 找到想使用的包，然后下载源码的打包文件。对于 jieba 分词来说，地址在 <a href="https://pypi.org/">这里</a>。当然，如果包没有在 pypi 发布，也可以直接在 Github 下载。</p><p>然后在代码解释器中，上传下载的包文件，再告诉 ChatGPT 安装就行，如下图对话内容：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230825_gpt4_code_interpreter_jieba.png" alt="ChatGPT Code Interpreter 安装 Python 库 jieba"></p><p>其实这里的安装主要是下面两行代码，可以看到我们上传的压缩包在 <code>/mnt/data/jieba-0.42.1.tar.gz</code> 路径，之后通过 <code>pip install</code> 安装。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Path to the provided jieba tar.gz file</span></span><br><span class="line">jieba_path = <span class="string">&quot;/mnt/data/jieba-0.42.1.tar.gz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Installing the jieba package from the provided file</span></span><br><span class="line">!pip install &#123;jieba_path&#125;</span><br></pre></td></tr></table></figure><p>这样就安装好了，后面在整个对话期间，都可以使用 jieba 分词了，是不是很方便！</p><h2 id="解决复杂依赖"><a href="#解决复杂依赖" class="headerlink" title="解决复杂依赖"></a>解决复杂依赖</h2><p>上面的 jieba 其实比较特殊，因为这个包<strong>不依赖其他任何 Python 包</strong>。但是我们平时日常使用的包，可能会用到很多依赖包，这时候导入的话，要连依赖包一起安装才行。对于那种有几十个依赖的包，如何方便的安装呢？</p><p>好在 pip 提供了 download 功能，可以把一个包和它的所有依赖下载为 <code>whl</code> 格式的文件，然后可以不联网使用这些 whl 文件来安装。具体命令很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">download</span></span><br><span class="line">mkdir my_package</span><br><span class="line">cd my_package</span><br><span class="line">pip download package_name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install</span></span><br><span class="line">cd path/to/my_package</span><br><span class="line">pip install --no-index --find-links . package_name</span><br></pre></td></tr></table></figure><p>了解到这个后，我们就可以方便地在 ChatGPT 的代码解释器中安装一些复杂的包了。具体步骤也很简单：</p><ol><li>找一台有网络访问权限的<strong>和代码解释器一样发行版的机器</strong>，创建一个 Python 虚拟环境，安装和代码解释器相同版本的 Python（目前是3.8）。怎么知道代码解释器的系统版本和 python 版本？看 <a href="https://selfboot.cn/2023/07/09/gpt4_code_interpreter_limit/">ChatGPT 代码解释器：资源限制详解</a></li><li>在这台机器用 ‘pip download’ 下载所有包的 whl 文件，并打包 <code>tar.gz</code> 包；</li><li>把文件上传到代码解释器，然后让 ChatGPT 解压文件并安装；</li></ol><p>通过这个方法，我们就可以安装复杂的 Python 包了。</p><h2 id="实例分享"><a href="#实例分享" class="headerlink" title="实例分享"></a>实例分享</h2><p>这里以我之前写的把印象笔记 html 笔记导入到 notion 笔记本的工具 <a href="https://github.com/selfboot/html2notion">html2notion</a> 包为例。第一步找了一台 Linux 服务器，然后用 <code>conda create --name test python=3.8</code> 创建一个干净的虚拟环境，然后 <code>pip download html2notion</code> 拿到所有依赖包的 whl 文件打包压缩。</p><p>接着把文件上传，然后用如下提示词：</p><blockquote><p>这个压缩包是一堆 Python 的安装包 whl 文件，帮我在当前环境安装里面的 html2notion 包，可以尝试用下面的命令来安装:<br>cd path&#x2F;to&#x2F;my_package<br>pip install –no-index –find-links . package_name</p></blockquote><p>ChatGPT 接着会先切换到包的目录，然后使用提供的命令进行安装。具体执行的代码也很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extracting the newly uploaded tar.gz file again</span></span><br><span class="line">latest_extract_path = <span class="string">&#x27;/mnt/data/latest_html2notion&#x27;</span></span><br><span class="line"><span class="keyword">with</span> tarfile.<span class="built_in">open</span>(<span class="string">&#x27;/mnt/data/html2notion.tar.gz&#x27;</span>， <span class="string">&#x27;r:gz&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.extractall(path=latest_extract_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Listing the extracted files to find the html2notion and dependency packages</span></span><br><span class="line">latest_extracted_files = os.listdir(latest_extract_path)</span><br><span class="line">latest_html2notion_path = os.path.join(latest_extract_path， <span class="string">&#x27;html2notion&#x27;</span>) <span class="keyword">if</span> <span class="string">&#x27;html2notion&#x27;</span> <span class="keyword">in</span> latest_extracted_files <span class="keyword">else</span> latest_extract_path</span><br><span class="line"></span><br><span class="line"><span class="comment"># Changing the directory to the location of the newly uploaded packages</span></span><br><span class="line">os.chdir(latest_html2notion_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Installing html2notion package using the given command</span></span><br><span class="line">latest_install_result = pip_main([<span class="string">&#x27;install&#x27;</span>， <span class="string">&#x27;--no-index&#x27;</span>， <span class="string">&#x27;--find-links&#x27;</span>， <span class="string">&#x27;.&#x27;</span>， <span class="string">&#x27;html2notion&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Confirming the installation</span></span><br><span class="line">latest_installed_html2notion = pip_main([<span class="string">&#x27;list&#x27;</span>])</span><br><span class="line">latest_install_result， latest_installed_html2notion</span><br></pre></td></tr></table></figure><p>至此成功安装了 html2notion 库，可以让 ChatGPT 验证下是否安装成功，整个过程如下图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230825_gpt4_code_interpreter_html2notion.png" alt="ChatGPT Code Interpreter 安装 Python 复杂库"></p><p>不过遗憾的是，这个库需要联网导入笔记，这里就算导入成功，也没法用。这个过程一定要注意，在和解释器相同的系统和 Python 版本上下载库文件，不然可能需要手动解决版本冲突或兼容性问题。我开始在 mac 上下载 whl 文件，导入的时候，发现缺少满足 html2notion 所需的 aiohttp 版本，原来这个库在 mac 和 linux 上还是不同的实现，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aiohttp-3.8.5-cp38-cp38-macos×_11_0_arm64.whl</span><br><span class="line">aiohttp-3.8.5-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl</span><br></pre></td></tr></table></figure><p>通过本文的方法，可以安装大部分包到当前执行环境，我们可以让 ChatGPT 的代码解释器执行更加丰富和实用的功能，大大提升我们的工作效率。</p>]]></content>
    
    
    <summary type="html">本文详细介绍了如何在 ChatGPT 代码解释器环境中安装不支持的 Python 包，包括简单包的安装方法和处理复杂依赖的技巧，并给出具体的实例分享。利用本文的方法可以扩展 ChatGPT 的代码执行能力，让它支持更多实用的数据处理和分析功能。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="ChatGPT" scheme="https://selfboot.cn/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>劳动合同到期不续签，一张图告诉你这些情况有钱可以拿！</title>
    <link href="https://selfboot.cn/2023/08/23/employment_renewal/"/>
    <id>https://selfboot.cn/2023/08/23/employment_renewal/</id>
    <published>2023-08-23T20:03:45.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>每一位劳动者都会面临一个重要时刻：<strong>劳动合同是否续签</strong>？对于很多人来说，这不仅仅是工作的延续，更关乎生活的稳定和未来的规划。而用人单位方面，也需要权衡人员需求与成本控制，因此，劳动合同的续签问题往往牵涉到双方的重大利益。</p><p>然而，在实际操作中，劳动合同到期不续签可能引发一系列法律问题。劳动者和用人单位在这个过程中的权益如何保障？当不续签发生时，是否有经济补偿或赔偿金的问题？特殊情况下的法律保护又是如何规定的？</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230823_employment_renewal_flow.png" alt="劳动合同到期不续签，一张图告诉你这些情况有钱可以拿"></p><p>接下来，我将深入探讨劳动合同到期不续签的法律视角，逐一解析劳动者不续签、用人单位不续签的经济补偿、赔偿金，以及一些特殊情况下的法律保护等问题，并通过实际案例分析，让这些法律条文更贴近生活，帮助大家更好地维护自身的合法权益。</p><span id="more"></span><h2 id="劳动者不续签"><a href="#劳动者不续签" class="headerlink" title="劳动者不续签"></a>劳动者不续签</h2><p>劳动者不续签，是我们日常生活中常见的一种情形。当劳动者选择不续签时，可能涉及换岗位、转行、甚至是退休等不同的生活选择。当劳动者提出不续签时，用人单位是否需要支付经济补偿？如果需要，又应该怎样计算？</p><p>从<a href="https://www.gov.cn/flfg/2007-06/29/content_669394.htm">《劳动合同法》</a>第四十六条第（五）项规定可以看出，劳动合同到期，如果劳动者不续签的，用人单位是否支付经济补偿，需分两种情况对待：</p><p>1、若<strong>用人单位降低原来劳动条件</strong>，劳动者不续签的，则用人单位对劳动者需要支付经济补偿（具体计算方式见下文经济补偿金部分）。<br>2、若用人单位已经维持或者提高了原来劳动条件，劳动者仍然不续签的，则用人单位不需要对劳动者进行经济补偿。</p><p>这里的劳动条件应当作广义理解，不仅指劳动报酬，还包括工作环境等因素，包括但不限于下面几个点：</p><ul><li><strong>劳动报酬降低</strong>：用人单位提出的新合同中，工资、奖金、津贴等经济条件相比原合同有所减少。</li><li><strong>工作环境变差</strong>：例如原先的工作地点、办公设备、工作时间等条件有所恶化，可能会影响劳动者的工作效率和工作舒适度。</li><li><strong>福利减少</strong>：如医疗保险、公积金、员工食堂、休假制度等福利项目的减少或降低。</li><li><strong>职位变动不利</strong>：如将劳动者调整到非专业对口或职责降低的职位上，可能会影响其职业发展。</li></ul><p>另外再提一个比较有意思的话题，如果劳动者不续签，需要<strong>给用人单位支持经济赔偿吗</strong>？绝大多数情况下，劳动者因个人原因选择不续签劳动合同，并不需要向公司支付经济赔偿。这是因为劳动者往往是弱势群体，劳动法旨在<strong>保护劳动者</strong>的权益，因此可以自由选择不续签。当然，在有些特殊情况下，比如明确约定了不续签的经济赔偿责任，则有可能也是要承担赔偿。</p><h2 id="用人单位不续签"><a href="#用人单位不续签" class="headerlink" title="用人单位不续签"></a>用人单位不续签</h2><p>刚刚讨论了劳动者不续签的各种法律问题，那么用人单位不续签呢？用人单位不续签是日常职场中另一个普遍现象，也涉及了许多复杂的法律问题。</p><p>劳动合同到期用人单位<strong>并非必须与劳动者续签</strong>，部分用人单位在劳动合同期满后并不与劳动者续签，法律没有强制要求用人单位或者劳动者必须续签的义务。劳动合同是否续签还是需要根据用人单位及劳动者双方的意愿来确定。</p><p>但是和劳动者不续签的最大区别在于，<strong>如果用人单位不主动和劳动者续签，用人单位一般是要支付经济补偿的，如果涉及到无固定期限劳动合同甚至有可能要支付赔偿金</strong>。所以前面才说，劳动者往往是弱势群体，劳动法旨在保护劳动者的权益。</p><h3 id="经济补偿金"><a href="#经济补偿金" class="headerlink" title="经济补偿金"></a>经济补偿金</h3><p>用人单位在劳动合同到期后不续签的情况下需要支付经济补偿金，是劳动法规定的一项重要权益保障。如果用人单位在劳动合同到期后，<strong>明确表示或者默示不愿意续签劳动合同</strong>，根据《劳动合同法》第四十六条的规定，用人单位需要支付劳动者经济补偿。</p><blockquote><p>第四十六条　有下列情形之一的，用人单位应当向劳动者支付经济补偿：<br>（一）劳动者依照本法第三十八条规定解除劳动合同的；<br>（二）用人单位依照本法第三十六条规定向劳动者提出解除劳动合同并与劳动者协商一致解除劳动合同的；<br>…</p></blockquote><p>《劳动合同法》第四十七条规定了经济补偿的计算方式：经济补偿金的标准为 N 个月均工资，N 即工作年限，不满半年按半年计算，满半年不满一年按一年计算。最多不超过市级人民政府公布的本地区上年度职工月平均工资的三倍，年限 N 最长为12年。</p><blockquote><p>经济补偿按劳动者在本单位工作的年限，每满一年支付一个月工资的标准向劳动者支付。六个月以上不满一年的，按一年计算；不满六个月的，向劳动者支付半个月工资的经济补偿。<br>劳动者月工资高于用人单位所在直辖市、设区的市级人民政府公布的本地区上年度职工月平均工资三倍的，向其支付经济补偿的标准按职工月平均工资三倍的数额支付，向其支付经济补偿的年限最高不超过十二年。<br>本条所称月工资是指劳动者在劳动合同解除或者终止前十二个月的平均工资。</p></blockquote><h3 id="赔偿金"><a href="#赔偿金" class="headerlink" title="赔偿金"></a>赔偿金</h3><p>除了前面的经济补偿之外，其实还有一种情况，用人单位需要支付赔偿金。赔偿金与经济补偿不同，主要涉及特殊情况。当劳动合同到期，若根据《劳动合同法》的相关规定，双方<strong>应当签订无固定期限劳动合同，但用人单位决定不续签时</strong>，这时用人单位就应当<strong>支付赔偿金而非经济补偿金</strong>。赔偿金的金额一般是2N，这个数额远高于一般的经济补偿金。</p><p>这里顺便再普法下，劳动合同分固定期限和无固定期限两种，无固定期限劳动合同是指用人单位与劳动者约定<strong>无确定终止时间</strong>的劳动合同。什么时候可以签订固定期限劳动合同呢？只要有下列情形之一，劳动者提出或者同意续订、订立劳动合同的，除劳动者提出订立固定期限劳动合同外，应当订立无固定期限劳动合同：</p><ol><li>劳动者在该用人单位连续工作满十年的；</li><li>用人单位初次实行劳动合同制度或者国有企业改制重新订立劳动合同时，劳动者在该用人单位连续工作满十年且距法定退休年龄不足十年的；</li><li>连续订立二次固定期限劳动合同，且劳动者不是因为过失被辞退。</li></ol><p>此外，若用人单位自用工之日起<strong>满一年未与劳动者订立书面劳动合同</strong>，则按法律规定，视为用人单位与劳动者已订立无固定期限劳动合同。赔偿金的计算基数和经济补偿一样，也是前 12 个月的平均工资。</p><h3 id="不用赔偿的情形"><a href="#不用赔偿的情形" class="headerlink" title="不用赔偿的情形"></a>不用赔偿的情形</h3><p>当然在某些情况下，用人单位不续签劳动合同，也不用赔偿。这里主要依据是《劳动合同法》的第三十九条，该条款规定了用人单位可以不用赔偿就解除劳动合同的情形。</p><blockquote><p>第三十九条　劳动者有下列情形之一的，用人单位可以解除劳动合同：<br>（一）在试用期间被证明不符合录用条件的；<br>（二）严重违反用人单位的规章制度的；<br>（三）严重失职，营私舞弊，给用人单位造成重大损害的；<br>（四）劳动者同时与其他用人单位建立劳动关系，对完成本单位的工作任务造成严重影响，或者经用人单位提出，拒不改正的；<br>（五）因本法第二十六条第一款第一项规定的情形致使劳动合同无效的；<br>（六）被依法追究刑事责任的。</p></blockquote><p>这一条主要是劳动者因为过失导致公司辞退，此外，还有<strong>第四十条</strong>规定了用人单位可以解除劳动合同的三种无过失性辞退情形：</p><ul><li>劳动者患病或非因工负伤：如果劳动者在规定的医疗期满后不能从事原工作，也不能从事由用人单位另行安排的工作，用人单位可以解除劳动合同。这里的医疗期是指劳动者根据工龄等条件享受的停工医疗期，而非实际需要的医疗期。</li><li>劳动者不能胜任工作：如果劳动者不能按要求完成工作任务，用人单位可以先进行职业培训或调换岗位。如果劳动者仍不能胜任工作，单位可以解除劳动合同。但用人单位<strong>不能故意提高工作标准或随意调动岗位以借口解除合同</strong>。</li><li>客观情况发生重大变化：如果劳动合同订立时所依据的客观情况发生重大变化，导致劳动合同无法履行，且双方未能就变更劳动合同内容达成协议，用人单位可以解除劳动合同。这里的“客觉情况”可能包括自然条件、企业迁移、被兼并、资产转移等。</li></ul><h2 id="平均工资计算"><a href="#平均工资计算" class="headerlink" title="平均工资计算"></a>平均工资计算</h2><p>在司法实践过程中，劳动合同解除时经济补偿或赔偿金的计算经常引发争议，特别是关于劳动者离职前十二个月平均工资的计算。不同地区对于平均工资的计算方法可能有所出入，一般遵循以下原则：</p><ul><li>以劳动者离职前一年内的应得工资为基础进行计算，其中包括按时或按件支付的工资，以及诸如<strong>奖金、津贴和补贴</strong>等的货币性收入。</li><li>所计算的应得工资不仅涵盖常规工作时间的薪资，还包括加班费，并涵盖<strong>个人所缴纳的社会保险、住房公积金及所得税</strong>等部分。（这一部分要看各地具体的政策，比如广州地区，一般按照实际到账的金额计算，个人缴纳的五险一金部分不会计算在内）</li><li>对于劳动者应得的<strong>年终奖或年终双薪</strong>，将其平均分摊到每年的十二个月，计入工资基数。</li><li>若劳动者离职前的十二个月平均工资<strong>低于当地最低工资水平，则需按照当地最低工资标准进行计算</strong>。</li></ul><p>小盛律师温馨提醒：劳动者<strong>保留工资记录</strong>非常关键，不仅是维权的有力依据，还与税务申报和个人信用紧密相关。建议劳动者及时查阅并保存工资条，了解工资构成，并与银行流水记录进行核对。</p><p>综上，我们全面解析了劳动合同到期不续签的相关法律规定，剖析了劳动者不续签、用人单位不续签以及特殊情形下的处理原则。在具体操作中，劳动者要充分了解自己的权利，合理争取应有的经济补偿；用人单位也需正确认识相关法律责任，避免产生新的劳资纠纷。</p><p>劳动关系的和谐稳定有赖于劳资双方的理性沟通与妥协。劳动者需牢记，只有专业工作能力才是立身之本；用人单位也应看到，只有尊重劳动者、关心员工，才能赢得企业发展。</p><hr><p>欢迎扫码关注<a href="https://selfboot.cn/links">小盛律师</a>的公众号，及时收到文章更新通知～</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230721_wx_qrcode.png" alt="关注公众号"></p>]]></content>
    
    
    <summary type="html">本文剖析劳动合同到期不续签的法律规定，帮助劳动者全面理解权益，依法获得应有补偿。劳动者不续签时，评估劳动条件变化决定经济补偿；用人单位不续签时，原则上支付经济补偿或赔偿金，特殊情形可免除赔偿。补偿金按离职前12个月平均工资计算，包含奖金、补贴等。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="劳动纠纷" scheme="https://selfboot.cn/tags/%E5%8A%B3%E5%8A%A8%E7%BA%A0%E7%BA%B7/"/>
    
  </entry>
  
  <entry>
    <title>真实例子告诉你 ChatGPT 是多会胡编乱造！</title>
    <link href="https://selfboot.cn/2023/08/23/not-smart-chatgpt/"/>
    <id>https://selfboot.cn/2023/08/23/not-smart-chatgpt/</id>
    <published>2023-08-23T08:03:32.000Z</published>
    <updated>2023-09-22T22:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>GPT-4，这一人工智能的杰出代表，已经在许多方面超越了普通人类。我的日常也原来越离不开 ChatGPT 了，它大大提高了日常的工作效率。然而，在使用中发现 ChatGPT 还是有时会犯一些“幼稚”的错误，就像一个正在成长的孩子偶尔会出现的调皮行为。</p><p>本文记录<strong>日常使用</strong> ChatGPT 过程中发现的一些错误回答，就像记录孩子成长过程中的出丑时刻一样。等到有一天 AI “长大成人”，也能一起回顾这些“小时候”的出丑时刻。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230817_not_smart_chatgpt_robot.png" alt="ChatGPT 的错误回答集锦"></p><span id="more"></span><p>本文的记录均基于 OpenAI 的 GPT 模型，如果没做特殊说明，都是最新的 GPT4 模型。本文会在个人博客<strong>持续更新</strong>，记录日常使用中发现的各种好玩儿的回答。</p><h2 id="pytz-的北京时区"><a href="#pytz-的北京时区" class="headerlink" title="pytz 的北京时区"></a>pytz 的北京时区</h2><p>背景是这样的，在 <code>postgres</code> 中存储了几个 <code>timestamp with time zone</code> 类型的时间戳，存储的时候，都是按照 utc 时区存储。在读的时候，想转换成北京时区，然后渲染到邮件中去。开始问的时候，不小心问成了转成上海时区，提示词如下：</p><blockquote><p>如果我想对数据库返回的时间，按照上海时区转换后，再渲染到邮件 html 中，要怎么做？</p></blockquote><p>ChatGPT 表现的很不错，直接告诉可以使用 Python 的 <code>pytz</code> 库来处理时区转换。以下是如何将 UTC 时间转换为上海时区的步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> report_data:</span><br><span class="line">    item.createtime = item.createtime.astimezone(shanghai_tz)</span><br><span class="line">    item.updatetime = item.updatetime.astimezone(shanghai_tz)</span><br><span class="line">    item.publishtime = item.publishtime.astimezone(shanghai_tz) <span class="keyword">if</span> item.publishtime <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>其实我还是想转北京时区，于是多嘴问了一句：</p><blockquote><p>如何转成北京时区呢？</p></blockquote><p> ChatGPT 回答可以定义北京时区，因为北京和上海都在同一时区。可以使用 <code>&#39;Asia/Shanghai&#39;</code> 或 <code>&#39;Asia/Beijing&#39;</code> 来定义北京时区。以下是<strong>如何使用 ‘Asia&#x2F;Beijing’ 来定义北京时区的代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> report_data:</span><br><span class="line">    item.createtime = item.createtime.astimezone(beijing_tz)</span><br><span class="line">    item.updatetime = item.updatetime.astimezone(beijing_tz)</span><br><span class="line">    item.publishtime = item.publishtime.astimezone(beijing_tz) <span class="keyword">if</span> item.publishtime <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>我也按照 ChatGPT 的建议，乖乖改了时区。结果遇到了报错，只好把这个错误贴给 ChatGPT，这下 ChatGPT 就意识到错误了。</p><blockquote><p>pytz.exceptions.UnknownTimeZoneError: ‘Asia&#x2F;Beijing’</p></blockquote><p>虽然北京是中国的首都，但在时区数据库中，<strong>中国的时区通常以上海来表示</strong>。所以你应该使用 ‘Asia&#x2F;Shanghai’ 而不是 ‘Asia&#x2F;Beijing’。再次验证了使用 ChatGPT 的黄金哲学：<strong>一定要验证 AI 的回答</strong>。</p><h2 id="房东不退押金？"><a href="#房东不退押金？" class="headerlink" title="房东不退押金？"></a>房东不退押金？</h2><p>我知道 ChatGPT 会有幻觉，不过没想到<strong>这个幻觉竟然能必现</strong>。事情是这样的，有好多咨询问题，我想帮<a href="https://selfboot.cn/links">小盛律师</a>做一个简单的分类筛选，找出里面有用的信息。于是写了一个脚本，用 ChatGPT 来执行一些分类和摘要总结的任务，结果发现对于某些内容为空的记录，ChatGPT 给我一个很奇怪的分类和汇总。</p><p>我的提示词是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">你是一个中国的专业律师，熟悉民法典和其他现行中国法律。</span><br><span class="line">现在你的任务是对用户咨询的问题进行归类、总结，并尝试回答。</span><br><span class="line">你需要输出一个 json，包括下面字段:</span><br><span class="line"></span><br><span class="line">&quot;isneedlawer&quot;: true/false， # 用户是否需要律师的帮忙</span><br><span class="line">&quot;customreplycontent&quot;: &quot;&quot;， # 针对问题给出的一个法律建议，如果无法律建议，则为空字符串，</span><br><span class="line">&quot;cityzone&quot;: &quot;&quot;， # 问题涉及的地点，精确到城市即可，比如广州市。如何没有地点信息，则为空字符串，</span><br><span class="line">&quot;abstract&quot;: &quot;&quot; # 问题的简单概述，不超过 200 字，要包含用户主要传达的信息&quot;</span><br><span class="line"></span><br><span class="line">输出一定要是 json，如果做不到，那么请输出一个空的 json。</span><br><span class="line">用户咨询的内容如下:</span><br><span class="line">&#123;seperator&#125;&#123;question&#125;&#123;seperator&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>seperator</code> 是分隔符，<code>question</code> 则是从其他地方读到的咨询内容。如果咨询内容不为空，则一切符合预期，但是一旦咨询内容为空，ChatGPT 就会返回一个很奇怪的结果，如下图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230821_not_smart_chatgpt.png" alt="ChatGPT 幻觉：房东不退押金"></p><p>难道广州的房东经常不退租客押金，被 ChatGPT 都从网上学到了？有点让人啼笑皆非了。不止在 ChatGPT3.5 下会有这个问题，最新的 GPT4 模型，也是会有同样的问题。</p><h2 id="不能激活的插件"><a href="#不能激活的插件" class="headerlink" title="不能激活的插件"></a>不能激活的插件</h2><p>OpenAI 的 ChatGPT 是离线训练的模型，里面会缺少一些比较新的知识。<a href="https://python.langchain.com/docs/get_started/introduction.html">Langchain</a> 是一个最近刚出来的 LLM 开发框架，ChatGPT 没有其相关知识。为了能够让它回答 langchain 的问题，我开了 Webpolit 插件，并且提供给他文档地址，然后提问如下：</p><blockquote><p>参考 <a href="https://python.langchain.com/docs/get_started/quickstart">https://python.langchain.com/docs/get_started/quickstart</a> 这里 langchain 的文档，帮我给指定中文文本分类，提取下面信息，并输出 json。</p><p>cityzone：提取文本里有提到的位置信息<br>customreplycontent：生成一段回复</p></blockquote><p>然后 GPT4 就自信的说，根据文档和需求，可以用下面的脚本来完成任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> Langchain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Langchain 实例</span></span><br><span class="line">lc = Langchain()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义分析文本的函数</span></span><br><span class="line"><span class="meta">@lc.register</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_text</span>(<span class="params">text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    cityzone = 提取位置信息(text)</span><br><span class="line">    customreplycontent = 生成一段回复(text)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;cityzone&quot;</span>: cityzone，</span><br><span class="line">        <span class="string">&quot;customreplycontent&quot;</span>: customreplycontent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义提取位置信息的函数</span></span><br><span class="line"><span class="meta">@lc.register</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">提取位置信息</span>(<span class="params">text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># 这里添加你的逻辑来提取位置信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;上海&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>这个大聪明怎么忽然这么笨啦？<code>提取位置信息(text)</code> 这都能拿出来作为 python 代码，也太敷衍了。就这还大言不惭，让我通过安装 Langchain 库并运行上述代码来测试这个脚本。没办法，只好提醒他用插件重新读文档来实现，终于变聪明了。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230821_not_smart_chatgpt_webpolit.png" alt="用插件学习后的 ChatGPT"></p><h2 id="图像识别错误"><a href="#图像识别错误" class="headerlink" title="图像识别错误"></a>图像识别错误</h2><p>有一个图片，我用红色标记了其中一部分，然后想把这部分替换为其他图片。自己不熟悉 opencv 的代码，也不太懂图片处理，想着让 ChatGPT 的 <a href="https://selfboot.cn/2023/07/12/gpt4_code_interpreter_image/">Code Interpreter</a> 帮我写个简单的代码来处理一下。于是给它传了图片，然后提问：</p><blockquote><p>如何用 python 识别这个图片里红色方框的坐标位置，并且把里面的内容替换为其他内容</p></blockquote><p>ChatGPT 给出了自己的步骤，看起来是很合理：</p><ol><li>读取图像。</li><li>识别红色方框的坐标位置。</li><li>截取该区域并替换为所需内容。</li><li>将替换的内容粘贴回原始图像。</li></ol><p>然后就是第一步，识别红色方框的坐标位置。信誓旦旦说成功识别了红色方框的坐标位置，它位于图像的 (562，474) 位置，并具有 142 的宽度和 172 的高度。还好心好意地用<strong>蓝色方框</strong>在图片上标记了出来，如下图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230822_not_smart_chatgpt_cv.png" alt="图像识别错误的 ChatGPT"></p><p>把图像中的脸部识别成了红色方框部分，看了下代码，应该是颜色的阈值没设置对导致的。后面把任务拆分了下，让它只识别红色方框位置，同时把方框的红色搞得稍微粗了些，ChatGPT 就能正常识别了。</p><h2 id="画不出来的链表图"><a href="#画不出来的链表图" class="headerlink" title="画不出来的链表图"></a>画不出来的链表图</h2><p>之前读《Redis 设计与实现》这本书的时候，看到作者说配图全部是用 <a href="http://graphviz.org/">Graphviz</a> 生成的，还给出了所有配图的源码 <a href="https://github.com/huangz1990/redisbook1e-gallery">redisbook1e-gallery</a>。当时就觉得用源码生成图片也太酷了，还打开 Graphviz 的官网看了下，奈何文档看起来太多了，上手需要点时间，就搁置了。</p><p>最近刚好想用 Graphviz 画一个简单的图，想着让 ChatGPT 生成源码，岂不快哉？动动嘴图片就出来了，这多好。于是就提问如下：</p><blockquote><p>你是一个 Graphviz 绘图的专家，帮我用 markdown 输出下面描述中的图片的制作代码，要求绘的图简单清晰，结构工整。</p><p>图片描述：有一个int 的链表，里面从头往尾部元素值分别是 1 ，2，3，… ，100，其中有一个箭头指向头部，箭头上有文字 head，有一个带有标题 tail 的箭头指向链表尾部。</p></blockquote><p>ChatGPT 果然会！给出了一个不错的源码，还好心好意提醒我可以将此代码粘贴到一个 Graphviz 编辑器（例如 <a href="http://www.webgraphviz.com/">WebGraphviz</a>）中，然后生成链表的图像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">digraph LinkedList &#123;</span><br><span class="line">    rankdir=LR;</span><br><span class="line">    node [shape=record];</span><br><span class="line">    </span><br><span class="line">    // 定义头部和尾部标签</span><br><span class="line">    head [label=&quot;head&quot;， shape=plaintext];</span><br><span class="line">    tail [label=&quot;tail&quot;， shape=plaintext];</span><br><span class="line">    </span><br><span class="line">    // 定义链表节点</span><br><span class="line">    node1 [label=&quot;&#123; 1 | &lt;p1&gt; &#125;&quot;];</span><br><span class="line">    node2 [label=&quot;&#123; 2 | &lt;p2&gt; &#125;&quot;];</span><br><span class="line">    node3 [label=&quot;&#123; 3 | &lt;p3&gt; &#125;&quot;];</span><br><span class="line">    ellipsis [label=&quot;...&quot;， shape=plaintext];</span><br><span class="line">    node100 [label=&quot;&#123; 100 | &#125;&quot;];</span><br><span class="line">    </span><br><span class="line">    // 定义箭头和连接</span><br><span class="line">    head -&gt; node1 [dir=back， constraint=false];</span><br><span class="line">    node1:p1 -&gt; node2;</span><br><span class="line">    node2:p2 -&gt; node3;</span><br><span class="line">    node3:p3 -&gt; ellipsis;</span><br><span class="line">    ellipsis -&gt; node100;</span><br><span class="line">    tail -&gt; node100 [dir=back， constraint=false];</span><br><span class="line">    </span><br><span class="line">    // 定义排列</span><br><span class="line">    &#123; rank=same; head tail &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我就拿源码贴过去，发现语法都有错误，生成的图片也不对。head 和 tail 画不对，还多了个 svg 出来，如下图了：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230822_not_smart_chatgpt_graphviz.png" alt="画不出一个简单链表 digraph 的 ChatGPT"></p><p>然后试着换了各种更加清晰的提示词，ChatGPT 总是给不出正确的源码，给的许多源码也都有语法错误。难道数据集中没有很多Graphviz 绘图的语料，导致 ChatGPT 没有学会？</p><h2 id="代码解释器库缺失"><a href="#代码解释器库缺失" class="headerlink" title="代码解释器库缺失"></a>代码解释器库缺失</h2><p>ChatGPT 的 <a href="https://selfboot.cn/2023/07/10/gpt4_code_interpreter_data/">Code Interpreter</a> 还是很好用的，不用自己写代码就能用来分析数据，并进行可视化。有次使用过程中，需要对数据中的<strong>中文内容进行分词</strong>，想到了 <a href="https://github.com/fxsjy/jieba">jieba 分词</a>，但是怕 ChatGPT 的代码解释器环境没有安装这个包，于是就问了下 ChatGPT：</p><blockquote><p>你可以用一些中文分词库，比如 jieba 吗？</p></blockquote><p>ChatGPT 就自信回答当然可以使用 jieba 分词库来更准确地分析中文文本，还说这个库能够更好地识别中文词汇和短语。然后就开始刷刷刷写代码了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using jieba to tokenize the consultation texts</span></span><br><span class="line">jieba_words = jieba.cut(consultation_texts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Counting the frequency of each word using jieba tokenization</span></span><br><span class="line">jieba_word_counts = Counter(jieba_words)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finding and returning the top 50 most common words using jieba tokenization</span></span><br><span class="line">top_50_jieba_words = [word <span class="keyword">for</span> word, _ <span class="keyword">in</span> jieba_word_counts.most_common(<span class="number">50</span>) <span class="keyword">if</span> word.strip() <span class="keyword">and</span> word <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;.,;:!?。，；：！？&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Returning the top 50 words with jieba</span></span><br><span class="line">top_50_jieba_words</span><br></pre></td></tr></table></figure><p>然后 ChatGPT 就开始运行代码，果不其然，发现没有安装 jieba 这个库 <code>No module named &#39;jieba&#39;</code>。然后终于意识到当前环境中没有安装 jieba 分词库，所以无法直接使用。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230825_not_smart_chatgpt_jieba.png" alt="Code interpreter 加载 jieba 库失败"></p><p>这个例子其实 AI 的表现也是可以理解的，毕竟这种错误人也经常犯，经常是代码跑一般才发现没有安装某个库。不过 AI 还是可以表现的更好些，可以在跑失败的时候，告诉我怎么<strong>手动在当前环境安装这个库</strong>。毕竟，你都知道我想用这个库，而你也有方法安装这个库，那为啥不告诉我呢？看来还是不够聪明呀～</p><h2 id="Clickhouse-函数"><a href="#Clickhouse-函数" class="headerlink" title="Clickhouse 函数"></a>Clickhouse 函数</h2><p>背景是这样的，我想用 Clickhouse 写一个查询语句，将一个按照位存储的 field 字段，转换成数组出来。每一位(从低位到高位)分别对应:</p><table><thead><tr><th>位</th><th>解释</th></tr></thead><tbody><tr><td>0</td><td>CN</td></tr><tr><td>1</td><td>EN</td></tr><tr><td>2</td><td>HK</td></tr><tr><td>3</td><td>JA</td></tr></tbody></table><p>对于数字 13 (1101)，我想转换为 <code>[CN, HK, JA]</code>，提示词如下：</p><blockquote><p>clickhsoue 里，我查找到了一个 field 字段，是个二进制按位记录的 flag 位，如果转换为一个数组？</p><p>&amp; 1 &#x3D; 1 , CN<br>&amp; 2 &#x3D; 1 , EN</p></blockquote><p>然后让我这样操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayJoin(arrayFilter(x <span class="operator">-</span><span class="operator">&gt;</span> x <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span>, [if(field <span class="operator">&amp;</span> <span class="number">1</span>, <span class="string">&#x27;CN&#x27;</span>, <span class="string">&#x27;&#x27;</span>), if(field <span class="operator">&amp;</span> <span class="number">2</span>, <span class="string">&#x27;EN&#x27;</span>, <span class="string">&#x27;&#x27;</span>)])) <span class="keyword">AS</span> CombinedFlags</span><br></pre></td></tr></table></figure><p>我就开心的拿去测了下，发现不对，最简化一个测试 sql: <code>select 5&amp;1</code>，发现也报错了，于是直接提示：</p><blockquote><p>select 5&amp;1<br>Error running query: Code: 62, e.displayText() &#x3D; DB::Exception: Syntax error: failed at position 335 (‘&amp;’) (line 5, col 9): &amp;1 FORMAT JSON. Unrecognized token: ‘&amp;’ (version 21.8.12.1)</p></blockquote><p>然后 ChatGPT 就认错了，说疏忽了 ClickHouse 的 SQL 语法细节。在 ClickHouse 中，你需要使用 <code>bitAnd</code> 函数来进行按位与运算。例如，要检查数字 5 的第 1 位是否为 1，可以这样写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> bitAnd(<span class="number">5</span>, <span class="number">1</span>) <span class="keyword">AS</span> <span class="keyword">Result</span></span><br></pre></td></tr></table></figure><p>我就又拿来试，发现还是不对。想了下，这里不是求与，应该是测试某一位是否是 1，然后把是 1 的全部拼接起来。<strong>不再靠 ChatGPT 了，直接去查官方文档</strong>，发现了函数 bitTest，这个可以测试某一位是否是 1。最后写了下面的 SQL(可以用 13 替换 field 来测试):</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> arrayFilter(x <span class="operator">-</span><span class="operator">&gt;</span> x <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span>, [if(bitTest(field, <span class="number">0</span>)<span class="operator">=</span><span class="number">1</span>, <span class="string">&#x27;CN&#x27;</span>, <span class="string">&#x27;&#x27;</span>), </span><br><span class="line">    if(bitTest(field, <span class="number">1</span>)<span class="operator">=</span><span class="number">1</span>, <span class="string">&#x27;EN&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    if(bitTest(field, <span class="number">2</span>)<span class="operator">=</span><span class="number">1</span>, <span class="string">&#x27;HK&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    if(bitTest(field, <span class="number">3</span>)<span class="operator">=</span><span class="number">1</span>, <span class="string">&#x27;JA&#x27;</span>, <span class="string">&#x27;&#x27;</span>)]) <span class="keyword">AS</span> combine</span><br></pre></td></tr></table></figure><hr><p>通过这些日常真实案例，我们可以看到当前 ChatGPT 在回答一些问题时，仍会胡编乱造一些<strong>看起来很正确</strong>的答案。但是我们不应因此否定 ChatGPT 的价值，更不应该弃之不用。<strong>认识到其局限并合理使用</strong>，才是我们应有的态度。</p>]]></content>
    
    
    <summary type="html">文章归纳了 ChatGPT 在日常使用中的各类错误回答，如时区设置、法律案例、代码实现、图像识别等都曾出现过失误，虽然它看似智能，但仍存在局限。这些实例提示我们注意验证AI输出，而不是盲目依赖。合理使用ChatGPT，认识其优劣，才能发挥其价值。我们不应因其偶尔的失误否定AI，而应客观理性地对待当前AI水平。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="ChatGPT" scheme="https://selfboot.cn/tags/ChatGPT/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>夫妻忠诚协议真的有用吗？</title>
    <link href="https://selfboot.cn/2023/08/21/loyalty-agreement/"/>
    <id>https://selfboot.cn/2023/08/21/loyalty-agreement/</id>
    <published>2023-08-21T21:50:10.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>在现代社会中，婚姻不仅仅是两个人的结合，它更多地涉及了责任、信任和忠诚的维系。随着人们对婚姻观念的不断演变，夫妻之间的忠诚义务也愈发受到重视。有人将其视为婚姻的坚固基石，也有人为了确保双方的忠诚，进一步采取了书面协议的形式来约束彼此。有些夫妻甚至选择通过签署名为“忠诚协议”的合同，明确彼此在婚姻生活中应当遵循的行为规范，这种做法引起了人们的关注和思考。</p><p>这样的协议是否真能促进夫妻之间的信任和忠诚？又是否在法律上得到了明确的支持和约束？这些问题的答案涉及的并非只是感情的层面，更是一道复杂的法律难题。本文将深入探讨夫妻忠诚协议的基本原则、效力问题以及与离婚协议的区别，帮助理解这一特殊协议在现实生活中的运用与限制。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230821_loyalty_agreement.png" alt="夫妻忠诚协议真的有用吗？"></p><span id="more"></span><h2 id="忠诚协议的基本原则"><a href="#忠诚协议的基本原则" class="headerlink" title="忠诚协议的基本原则"></a>忠诚协议的基本原则</h2><p>夫妻之间的忠诚协议是一项特殊的约定，它不直接适用于《中华人民共和国民法典》合同编的调整。根据民法典的婚姻家庭编，夫妻间的忠诚是<span style='color:red'>道德层面的要求，而非法律义务</span>。忠诚协议允许夫妻双方自由协商婚姻相关事项，但约定内容必须符合法律基本原则和社会公序良俗。</p><ol><li><strong>符合法律规定</strong>：根据《中华人民共和国民法典》的相关规定，夫妻间的协议应符合诚实信用原则，不得违反法律禁止和社会公共利益。</li><li>内容<strong>不得违反公序良俗</strong>：如果协议的内容涉及对不忠行为的经济处罚等，可能会被认为违反公序良俗，从而导致协议的无效。</li><li>夫妻双方<strong>自愿签订</strong>：不存在欺诈、胁迫、乘人之危等可撤销情形，例如如果在一方出轨捉奸后立马签订忠诚协议则容易认定成一方并非自愿签订的情形。</li><li><strong>身份与人权保护</strong>：协议中若有限制一方的基本人权条款，例如离婚自由权、人身自由权、通信自由权等，则该条款无效。同样地，剥夺孩子的抚养权和探望权的条款也是无效的，因为决定孩子抚养权的首要考虑因素是孩子的利益，而探望既是父母的权利也是义务，不应作为对过错方的惩罚手段。此外，家庭财产的分配不应影响任何一方的基本生活需求，约定的赔偿数额必须符合家庭的经济实际情况，如果赔偿数额明显过高，法院将不会予以认可。</li></ol><h2 id="忠诚协议效力与案例"><a href="#忠诚协议效力与案例" class="headerlink" title="忠诚协议效力与案例"></a>忠诚协议效力与案例</h2><p>根据《中华人民共和国民法典婚姻家庭编继承编理解与适用》，夫妻间签订的忠诚协议应在诚信原则的基础上自觉、自愿履行。虽然法律没有禁止夫妻之间签署此类协议，但也没有赋予它强制的法律效力。在整体社会效益的考量下，法院通常对夫妻间因忠诚协议引起的纠纷不予受理，即便是因忠诚协议起诉，也是不会被法院接纳的。</p><p>然而，在离婚诉讼过程中，<strong>忠诚协议并非完全无用</strong>。司法实践中的一些法院可能会参考忠诚协议内关于财产分割和补偿的条款，虽不一定完全支持，但会结合过错方的经济收入、日常消费水平和承受能力，以及当地的生活水平来做出合理分配。此外，忠诚协议还可作为证明一方过错的证据。</p><h3 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h3><p>司法实践中对于忠诚协议效力的认定以及支持的程度各有不同，需结合案件具体情况分析，赋予了法官很大的<strong>自由裁量权</strong>。</p><table><thead><tr><th>案例</th><th>协议内容</th><th>起诉结果</th></tr></thead><tbody><tr><td>A、不支持</td><td>韩某和许某约定不与异性有婚外情等行为，违反则离婚，并放弃婚后财产。</td><td>许某存在影响夫妻关系的行为，但法院未按协议分割财产，韩某的诉求未得到支持。</td></tr><tr><td>B、部分支持</td><td>仇某和张某约定不得有第三者、婚外情等行为，违反则自动放弃夫妻共有财产并支付赔偿金。</td><td>法院认为财产责任过于严厉，不能完全按协议履行。张某获得5万元赔偿金的支持。</td></tr><tr><td>C、支持</td><td>贡某保证如有不正当男女关系，则放弃夫妻财产分割权。后贡某婚外情并生育一男婴。</td><td>贡某的保证有效，违反所作承诺，法院判决房产归杨某所有，贡某上诉被驳回，夫妻共同财产全部归杨某所有。</td></tr></tbody></table><p>值得注意的是，忠诚协议可能会引发更广泛的社会问题。有些人为了抓到配偶的不忠行为，可能会使用各种合法甚至非法的手段来取证，从而增加了社会不稳定的因素。因此，尽管法律未将夫妻签署忠诚协议列为违法行为，但也并不提倡这种做法。</p><h2 id="忠诚协议与离婚协议"><a href="#忠诚协议与离婚协议" class="headerlink" title="忠诚协议与离婚协议"></a>忠诚协议与离婚协议</h2><p>在了解了忠诚协议在法律实践中的效力和一些相关案例分析后，我们可以明白，虽然忠诚协议在某些方面具有一定的作用，但它并不等同于其他法律文件，比如离婚协议。那么，忠诚协议与离婚协议到底有何不同呢？接下来的部分，我们将从目的、效力和财产约定方面深入探讨这两者之间的差异。</p><h3 id="忠诚协议"><a href="#忠诚协议" class="headerlink" title="忠诚协议"></a>忠诚协议</h3><ul><li>目的：忠诚协议主要是为了规范夫妻双方在婚姻关系存续期间的行为，例如忠诚义务。</li><li>财产约定：如果包括财产方面的约定，可能涉及对不忠诚行为的经济处罚等。这些约定必须符合法律规定，否则可能被视为无效。</li><li>效力：如上所述，由于涉及的内容可能较为敏感，忠诚协议的效力可能受到挑战。</li></ul><h3 id="离婚协议"><a href="#离婚协议" class="headerlink" title="离婚协议"></a>离婚协议</h3><ul><li>目的：离婚协议主要用于解决夫妻离婚后的财产分割、子女抚养、债务分担等问题。</li><li>财产约定：离婚协议中关于财产的约定一般涉及夫妻共同财产的分配。根据《中华人民共和国民法典》的规定，夫妻双方可以协商决定财产分割的方式，但必须符合公平原则。</li><li>效力：离婚协议通常在法律上具有明确的效力，只要其内容符合法律要求，一般可被法院承认和执行。</li></ul><p>忠诚协议与离婚协议的主要区别在于，忠诚协议主要关注婚姻期间的行为规范，可能涉及对不忠诚行为的处罚；而离婚协议则专注于解决离婚后的实际问题，如财产分割。在财产约定方面，忠诚协议可能涉及的内容较为有限和特殊，而离婚协议则涵盖了离婚后财产的全面分配。</p><h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>前面详细分析了夫妻忠诚协议的性质、效力和应用场景，揭示了它在法律层面上的地位及其可能引发的社会问题。我们了解到，忠诚协议虽然不被禁止，但也并未得到法律的强制执行力支持，其在离婚诉讼中的使用也需慎重考虑。此外，我们还探讨了忠诚协议与离婚协议的区别，从目的、效力和财产约定方面揭示了两者之间的核心差异。</p><p>这一主题的探讨不仅有助于我们深入理解忠诚协议的法律性质和实际作用，还能引导我们正确看待婚姻生活中的法律约束和伦理责任。同时，也提醒了我们，在签订此类协议时，应遵循诚信原则，同时考虑其可能产生的社会效应和个人责任。</p><p>这里提供一个忠诚协议的<a href="https://slefboot-1251736664.file.myqcloud.com/%E5%A4%AB%E5%A6%BB%E5%BF%A0%E8%AF%9A%E5%8D%8F%E8%AE%AE.docx">简单模板</a>。</p><hr><p>欢迎扫码关注<a href="https://selfboot.cn/links">小盛律师</a>的公众号，及时收到文章更新通知～</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230721_wx_qrcode.png" alt="关注公众号"></p>]]></content>
    
    
    <summary type="html">忠诚协议非强制法律文件，但可作为证据和财产参考。案例显示，法院对其支持程度因案而异。与离婚协议比较，两者目的、效力和财产约定差异显著。忠诚协议无法代替离婚协议，应慎重考虑。本文分析忠诚协议的法律运用与限制，并提供协议模板，有助理解婚姻生活中的伦理与法律。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="婚姻家庭" scheme="https://selfboot.cn/tags/%E5%A9%9A%E5%A7%BB%E5%AE%B6%E5%BA%AD/"/>
    
  </entry>
  
  <entry>
    <title>小盛律师解读帮信罪：条文、案例、防范与问答</title>
    <link href="https://selfboot.cn/2023/08/16/assisting_in_fraud/"/>
    <id>https://selfboot.cn/2023/08/16/assisting_in_fraud/</id>
    <published>2023-08-16T19:13:29.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>近年来，帮助信息网络犯罪活动罪（以下简称<code>帮信罪</code>）已逐渐成为我国第三大罪名，仅次于<strong>危险驾驶罪和盗窃罪</strong>。帮信罪涉及的地区范围广，多数系初犯，30岁以下的占64.8%，18至22岁的占23.7%。犯罪嫌疑人中，低学历、低收入群体占多数，初中以下学历占66.3%、无固定职业的占52.4%。仅2022年上半年，检察机关<a href="https://www.spp.gov.cn/spp/xwfbh/wsfbt/202207/t20220722_566409.shtml#1">起诉帮信犯罪的人数高达6.4万人</a>。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230815_assisting_in_fraud.png" alt="最高检对于帮信罪的一个说明"></p><span id="more"></span><p>上图来自最高检察院的 <a href="https://www.spp.gov.cn/zdgz/tj/202207/t20220723_567126.shtml">“帮信罪”知多少？最高检披露的办案数据中有这些细节……</a>。这些触目惊心的数据揭示了帮信罪的严重性和复杂性，也反映了当前社会对此类犯罪的防范意识不足。本文旨在深入解析帮信罪的法律条文、案例分析，并提供防范策略，以增强公众的法律意识和防范能力。</p><h2 id="法律条文解读"><a href="#法律条文解读" class="headerlink" title="法律条文解读"></a>法律条文解读</h2><p>帮信罪是2015年11月起施行的<a href="https://www.spp.gov.cn/spp/fl/201802/t20180205_364562.shtml">刑法修正案（九）</a>新增罪名。</p><blockquote><p>“第二百八十七条之二明知他人利用信息网络实施犯罪，为其犯罪提供互联网接入、服务器托管、网络存储、通讯传输等技术支持，或者提供广告推广、支付结算等帮助，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金。</p></blockquote><p>帮信罪的法律条文明确了犯罪的要素和刑罚，强调了明知、技术支持、情节严重等关键因素。</p><p><span style='color:red'><strong>明知他人实施犯罪</strong></span>。帮信罪的关键要素之一是“明知”。这意味着被告必须明确知道他们正在协助的活动是犯罪行为。如果没有这种明确的知情，就不构成帮信罪。这一点在法律实践中非常重要，因为它区分了无辜的技术支持和有罪的协助犯罪。但是对具体犯罪行为不要求明知，也不需要知道犯罪是此罪亦或是彼罪。只需要明知有犯罪存在即可，并且明知的主观状态并非以口头表明而能否认。</p><p><strong>提供技术支持</strong>。提供技术支持包括互联网接入、服务器托管、网络存储、通讯传输等。这些支持可以是直接或间接的，技术本身是无罪的，但若与犯罪活动有联系便可能认为是犯罪。例如，如果一个人为一个已知的非法网站提供服务器托管，那么他可能会被控以帮信罪。</p><p><strong>提供广告推广、支付结算等帮助</strong>。除了技术支持外，帮信罪还包括为犯罪活动提供广告推广、支付结算等帮助。这些活动可能涉及更广泛的商业行为，如营销和金融服务。如果这些服务是为已知的犯罪活动提供的，那么提供者可能会面临帮信罪的指控。</p><p><strong>情节严重</strong>。法律条文中提到的“情节严重”是对帮信罪进行定罪和量刑的关键因素。情节严重通常涉及犯罪的规模、影响、涉及的金额等因素。例如，如果提供的技术支持导致了大规模的金融欺诈，那么这种情况可能被视为情节严重。</p><p>对于被判定为帮信罪的人，法律规定的刑罚是三年以下有期徒刑或者拘役，并处或者单处罚金。这一刑罚反映了对帮信罪的严肃态度，旨在震慑那些可能协助犯罪活动的人。</p><p><a href="https://www.spp.gov.cn/spp/xwfbh/wsfbh/201910/t20191025_436138.shtml">关于办理非法利用信息网络、帮助信息网络犯罪活动等刑事案件适用法律若干问题的解释</a> 里进一步对上述法律条文进行了解读，比如怎么认定情节严重？就给出具体的条款，违法所得一万元以上的；或者为三个以上对象提供帮助的。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>帮信罪的界定和执法在实际操作中可能涉及一些复杂和微妙的问题。<strong>例如综合考虑社会危害程度、认罪悔罪态度等情节，认为犯罪情节轻微的，可以不起诉或者免予刑事处罚；情节显著轻微危害不大的，不以犯罪论处。</strong>通过具体案例的分析，我们可以更深入地理解这一罪名的实际应用和法律解读。</p><h3 id="8-套银行卡获刑-10-个月"><a href="#8-套银行卡获刑-10-个月" class="headerlink" title="8 套银行卡获刑 10 个月"></a>8 套银行卡获刑 10 个月</h3><p>真实案例：案号 (2020)川 **** 刑初 373 号</p><p>被告人涂某某和万某某通过网络认识，涂某某长期大量收购他人银行卡用于电信网络诈骗犯罪活动。万某某接触到涂某某后，也参与收购他人银行卡提供给涂某某。2019 年 3 月至 2020 年 1 月期间，万某某<strong>共收购 8 套他人银行卡</strong>提供给涂某某使用。经调查，这些银行卡参与了电信网络诈骗犯罪，涉案金额达 1.5 亿元。涂某某和万某某因涉嫌帮助信息网络犯罪活动罪被公安机关立案侦查并拘留、逮捕。一审法院认定二人的行为构成帮助信息网络犯罪活动罪，分别判处涂某某有期徒刑1年4个月，罚金1万元；万某某有期徒刑 10 个月，罚金 5000 元。</p><p>公诉机关在起诉书中列举了大量书证、证人证言、被告人供述、电子数据查证结果等证据。证明被告人涂某某长期通过网络收购他人银行卡，并通过万某某扩大收购来源。证据还证实，这些银行卡参与了数亿元的电信网络诈骗犯罪活动，充分证实了二被告人的犯罪事实。</p><p>在这一起涉及帮信罪的案件中，被告人因每月几百元的非法收入，提供银行卡给犯罪分子使用。这一行为虽然看似微不足道，但实际上构成了帮信罪，导致被告人身陷囹圄，前途受到严重影响。从法律角度来看，这一案例再次强调了帮信罪的严重性和法律责任的不容忽视。即使是辅助性的参与，也可能触发刑事责任，<strong>哪怕涉及的金额相对较小</strong>。</p><h3 id="转账-13-万幸免获罪"><a href="#转账-13-万幸免获罪" class="headerlink" title="转账 13 万幸免获罪"></a>转账 13 万幸免获罪</h3><p>真实案例： 陕西省旬阳县人民检察院 不起诉决定书（蒙某某帮助信息网络犯罪活动案） 旬阳检刑不诉〔2021〕4号</p><p>蒙某某通过征婚网站与自称美国医生的“johnny”相识，并在微信上确立了恋爱关系。随后，“johnny”以医院办业务为由，请求蒙某某提供银行卡以便转账。在2020年9月，蒙某某便向“johnny”提供了<strong>五张银行卡信息和身份证照片</strong>，并根据其指示，将入账资金转入特定账户。蒙某某涉案的五张银行卡共计转账 131 万元，主要集中在2020年9月至10月10日之间，其<strong>银行卡被冻结</strong>的时间在10月15日，10月15日至案发期间转账共计 <span style='color:red'>13 万余元</span>。</p><p>检察院经审查发现，蒙某某与“johnny”一直保持网恋关系，银行卡信息是被“johnny”欺骗获取的。从蒙某某手机中恢复的微信聊天记录来看，两人之间的对话充满暧昧，且“johnny”曾多次提出想与蒙某某共同组建家庭。综合考虑，证据显示蒙某某在2020年10月15日前并未意识到“johnny”利用其银行卡进行诈骗，而10月15日至案发期间的转账则表明蒙某某有“<strong>主观明知</strong>”，但金额仅13万元，未满足《中华人民共和国刑法》第二百八十七条之二所规定的严重情形。因此蒙某某的行为不构成犯罪，并决定不起诉。</p><p>小盛律师解读：本案中被起诉人在银行卡被冻结前的转账，主观上没有明知。在冻结后的转账，可以看做是经监管部门告知后仍然实施有关行为，所以认定主观明知。好在金额不大，<strong>没有超过 20 万</strong>，所以没有被起诉。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230816_assisting_in_fraud_serious.png" alt="最高检对于帮信罪严重情形的解释"></p><p>虽然蒙某某的行为最终被认定为不构成犯罪，但是于2020年11月25日被旬阳县公安局刑事拘留，于2021年1月1日被旬阳县公安局取保候审，整个过程对她造成了<strong>极大的困扰</strong>。这一案例提醒我们，在与陌生人的交往中，应保持警惕，坚决不提供个人敏感信息，如银行卡号，手机号，身份证等。</p><h2 id="如何避免触犯帮信罪"><a href="#如何避免触犯帮信罪" class="headerlink" title="如何避免触犯帮信罪"></a>如何避免触犯帮信罪</h2><p>帮信罪的形式多样，涉及的领域广泛，犯罪手段也在不断演变和升级。从司法实践中的帮信类案件来看，涉案人员主要有下面 2 种行为：</p><ol><li>非法买卖、提供、转借“两卡”（银行卡和电话卡），为上游犯罪提供转移支付、套现、取现的工具。这也是广大学生最容易涉嫌帮信罪的方式。很多学生为了一点点生活费，就出借银行卡，最终获刑。</li><li>提供专业技术支持和软件工具。例如伪造 IP 地址的软件，批量注册软件，手机号接码平台，验证码破解等，用以提高犯罪效率、降低犯罪成本。</li></ol><p>对于个人来说，要管住心，提高警惕意识。任何<strong>看似轻松就能获得的利益都可能隐藏着风险</strong>。要时刻提醒自己，没有不劳而获的好事，避免因一时的贪念而身陷囹圄。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230816_assisting_in_fraud_2.png" alt="很多不小心就犯了帮信罪的大学生和程序员"></p><p>同时也要多了解相关法律法规，增强法律意识，不参与任何可能涉及非法活动的事情。遇事不决，也可以多咨询下律师，帮忙规避风险。</p><h2 id="问与答"><a href="#问与答" class="headerlink" title="问与答"></a>问与答</h2><p>在技术论坛 <a href="https://www.v2ex.com/">v2ex</a> 上，有非常多的关于帮信罪的疑问。Google 搜素 v2ex 上面的帮信罪关键词，有 1000 多条帖子，说明程序员群体还是比较担心这个罪的。下面列出其中部分问题进行解答。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230815_assisting_in_fraud_v2ex.png" alt="v2ex 上关于帮信罪的帖子"></p><h3 id="程序员接私活"><a href="#程序员接私活" class="headerlink" title="程序员接私活"></a>程序员接私活</h3><blockquote><p><a href="https://www.v2ex.com/t/852164">问题</a>：有人让给开源商城系统接入支付方式，虽然再三保证是合法用途，但还是觉得有些不妥。</p></blockquote><p><a href="https://selfboot.cn/links">小盛律师</a> 建议从下面几个方面来保护好自己：</p><ol><li><strong>严格审查客户资质</strong>。在接受此类工作之前，应要求客户提供营业执照、对公账户信息等合法证明，确保客户的合法性和合规性。</li><li><strong>明确合同条款</strong>。与客户签订合同，明确合同条款，包括服务范围、合作目的、合法合规承诺等，以确保双方的权益。</li><li><strong>遵循法律规定</strong>。根据<a href="https://www.spp.gov.cn/spp/xwfbh/wsfbh/201910/t20191025_436138.shtml">解释</a>的第十一条，为他人实施犯罪提供技术支持或者帮助，具有交易价格或者方式明显异常、提供专门用于违法犯罪的程序、工具等情形的，可以认定行为人明知他人利用信息网络实施犯罪。因此，应避免与<span style='color:red'><strong>可疑客户</strong></span>合作，避免参与可能涉及非法活动的项目。</li><li><strong>保留证据</strong>。在合作过程中，应保留所有与项目有关的沟通记录、文件、合同等证据，以备将来可能的法律纠纷。</li><li><strong>咨询专业法律人士</strong>。在任何不确定的情况下，应及时咨询专业法律人士，确保自己的行为符合法律规定。</li></ol><h3 id="转借信用卡"><a href="#转借信用卡" class="headerlink" title="转借信用卡"></a>转借信用卡</h3><blockquote><p><a href="https://v2ex.com/t/931310">问题</a>：为朋友办了一张信用卡，目前还找我让办信用卡供其使用（套现操作）维系其小公司运作，会不会有帮信罪的风险？</p></blockquote><p>小盛律师回答：</p><p>在当前的司法实践中，涉及“两卡”的收购、出售、出租行为是“帮信罪”最常见的适用情况之一。“两卡”特指：一是<strong>手机卡</strong>，涵盖了通信运营商、虚拟运营商提供的各种手机卡以及物联网卡；二是<strong>银行卡</strong>，包括各商业银行发行的个人银行卡、单位银行账户、结算卡、信用卡等，还有第三方支付机构的支付账户，例如微信支付和支付宝等。(PS: 现在办手机卡、银行卡都会让你先阅读一段说明，并承诺不转借，不售卖)</p><p>如果你知道或者应当知道你的朋友通过你办理的信用卡进行非法套现操作，而你仍然提供信用卡，那么可能涉及帮信罪。建议立即停止提供信用卡，这是防范可能的法律风险的第一步。同时保留与朋友的所有沟通记录和文件，以备将来可能的法律纠纷。</p><p>再补充一下，<span style='color:red'><strong>银行卡、信用卡是坚决不能出租或者转借</strong></span>的。即使是免费转借给他人，严格意义上讲，也违反了《银行卡业务管理办法》，有可能被罚款。</p><h3 id="售卖微信号"><a href="#售卖微信号" class="headerlink" title="售卖微信号"></a>售卖微信号</h3><blockquote><p><a href="https://v2ex.com/t/943127">问题</a>：微信号能卖么？最初是用一个香港手机号注册的，目前是未绑定手机号的状态；使用微信号+密码登录；注册时间大概是 4 年前，最早一条朋友圈是 2019 年 1 月发的；未日常使用，目前是在一台旧手机上登录着；未实名认证；</p></blockquote><p>小盛律师回答：</p><p>售卖微信号涉及的行为可能构成帮信罪。这是因为微信账号可能被用于非法活动，如电信网络诈骗等，那么可能触犯帮信罪，毕竟出售微信号的行为有获利，极易推定认为是<strong>明知有犯罪行为存在的主观状态</strong>。有一案例涉及马某甲和马某乙利用QQ等社交软件收贩大量含登录密码、绑定手机号等信息的微信账号，有偿提供给他人使用，因犯“帮信罪”，马某甲被判处有期徒刑一年，并处罚金1万元。马某乙案发时系未成年，另做处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>帮信罪作为一项相对较新的法律规定，反映了现代社会信息技术与法律之间的紧密联系。它不仅针对直接实施犯罪的人，还针对那些协助犯罪的人。这一罪名的设立，强调了个人在网络环境中的法律责任，促进了信息技术的健康、合法发展。</p><p>每个人都应认识到自己在网络环境中的法律责任，采取积极措施保护自己的合法权益。希望通过本文，能够帮助大家更好地理解帮信罪，增强法律意识，避免不必要的法律风险。</p><hr><p>欢迎扫码关注<a href="https://selfboot.cn/links">小盛律师</a>的公众号，及时收到文章更新通知～</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230721_wx_qrcode.png" alt="关注公众号"></p>]]></content>
    
    
    <summary type="html">本文深入解析帮助信息网络犯罪活动罪的法律条文、典型案例、防范措施，帮助公众全面理解这一新型网络犯罪。通过案例剖析，梳理帮信罪的认定标准，包括主观故意、严重情形等构成要件。并分享程序员、学生等群体该如何规避相关法律风险。本文旨在普及相关法律知识，提高公众的警惕性，促进网络环境的健康发展。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="刑事" scheme="https://selfboot.cn/tags/%E5%88%91%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>必读的离婚法律指南：子女的抚养权、抚养费与探视权</title>
    <link href="https://selfboot.cn/2023/08/13/divorce_legal_children/"/>
    <id>https://selfboot.cn/2023/08/13/divorce_legal_children/</id>
    <published>2023-08-13T20:05:49.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>本文是<a href="https://selfboot.cn/links">小盛律师</a>离婚法律指南系列中的一篇，给大家分享下关于<strong>子女抚养权</strong>的法律科普。必读的离婚法律指南系列文章如下：</p><p><a href="https://selfboot.cn/2023/07/21/divorce_legal_knowlage/">当婚姻走到了尽头：必读的离婚法律指南</a><br><a href="https://selfboot.cn/2023/08/05/divorce_legal_longtime/">必读的离婚法律指南：离婚流程要多久？</a><br><a href="https://selfboot.cn/2023/07/23/divorce_legal_money/">必读的离婚法律指南：财产分割</a><br><a href="https://selfboot.cn/2023/07/29/divorce_legal_money_parent/">离婚财产分割：父母给的首付钱如何分？</a></p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230813_divorce_legal_children_1.png" alt="离婚子女抚养权，抚养费，探视权等说明的思维导图"></p><span id="more"></span><p>在中国，随着社会的快速发展和人们观念的逐渐开放，离婚已不再是一个禁忌话题。随着离婚率的逐年上升，子女的抚养问题，包括抚养权、抚养费以及探视权等，逐渐浮现为一个亟待解决的社会问题，吸引了众多家庭和法律界的广泛关注。对于许多父母来说，虽然婚姻结束了，但他们对子女的关心和责任从未改变。离婚后子女的抚养问题，无疑是他们最为关心和焦虑的部分。</p><p>中国法律在处理这一敏感而复杂的问题时，始终坚持一个核心原则：<strong>以子女的最大利益为出发点</strong>。这意味着，无论在任何情况下，子女的福祉和利益都是首要考虑的。因此，在决定子女抚养权时，法院不仅会考虑父母的意愿和条件，更会深入探讨哪一方更有利于子女的身心健康和全面发展。</p><p>实际的司法实践远比我们想象的复杂。对于抚养权问题，除了子女的意愿，还需要综合考虑双方父母的经济状况、抚养能力、子女的年龄、健康状况、教育需求等多种因素。抚养费的确定和支付，以及非直接抚养一方的探视权，也是判决中需要仔细权衡的问题。这也意味着，每一个判决都是独特的，都是基于具体情况做出的。对于那些正在考虑或已经决定离婚的父母来说，深入了解子女抚养权的相关法律规定和判决标准，不仅可以帮助他们为子女争取到更好的抚养条件，更可以为子女的未来打下坚实的基础。</p><h2 id="抚养权归谁？"><a href="#抚养权归谁？" class="headerlink" title="抚养权归谁？"></a>抚养权归谁？</h2><p>在决定子女抚养权时，法院会综合考虑多种因素，确保判决符合子女的最大利益。正如前文所述，这一决定并不是单纯基于某一方面的考量，而是涉及到许多复杂的因素。其中，子女的意愿是一个非常重要的参考因素，但同样需要与双方父母的经济状况、抚养能力、子女的年龄和健康状况等其他因素一同考虑。</p><h3 id="子女的意愿"><a href="#子女的意愿" class="headerlink" title="子女的意愿"></a>子女的意愿</h3><p>子女的意愿在决定抚养权时占有重要地位。随着社会的进步和法律的完善，子女的意愿在抚养权判定中的权重逐渐增加。这一趋势反映了法律对子女权益的尊重和保护。尤其是对于年龄较大的子女，他们的意见和感受往往会受到法院的高度重视，因为他们已经具备了一定的判断能力和独立思考的能力。</p><p><strong>年龄考虑</strong>：一般来说，8 岁以上的子女已经具有一定的判断能力和独立思考的能力。因此，法院通常会听取这一年龄段子女的意愿，并在可能的情况下尊重他们的选择。而对于年龄较小的子女，法院可能会更多地考虑其他因素，如双方父母的抚养能力和经济条件。2岁以下的，法院一般会直接判给母亲一方。</p><p><strong>意愿的真实性</strong>：法院在听取子女的意愿时，会确保这些意愿是真实、自愿的，而不是受到某一方父母的影响或压力。为此，法院可能会采用私下谈话、心理评估等方式，确保子女在一个没有外界干扰的环境中表达自己的真实想法。</p><p><strong>意愿与实际情况的匹配</strong>：虽然子女的意愿是一个重要的参考因素，但法院也会考虑这一意愿是否与实际情况相匹配。例如，如果子女希望与经济条件较差的一方父母生活，但这一方父母确实无法提供足够的生活和教育条件，那么法院可能会做出与子女意愿不符的判决。</p><p>总的来说，子女的意愿在抚养权判定中起到了关键的作用。但法院在做出判决时，也会充分考虑其他因素，确保判决真正符合子女的最大利益。</p><h3 id="父母经济条件"><a href="#父母经济条件" class="headerlink" title="父母经济条件"></a>父母经济条件</h3><p>离婚后子女的抚养不仅涉及情感和陪伴，还涉及到物质生活的保障。因此，父母的经济条件成为法院判定抚养权的一个重要依据。</p><ol><li>生活保障：法院会考虑哪一方父母更有能力为子女提供稳定的生活环境，包括住房、饮食、衣物、医疗等基本生活需求。例如，如果一方父母的工作提供了更全面的医疗保险，或者居住地靠近有声誉良好的医疗机构，可能会被视为更有利于子女的健康保障和医疗照顾。</li><li>教育投资：教育费用是子女成长中的一大开销。父母是否有能力承担子女的学费、培训费等，也是法院的考量因素。如果一方父母积极支持子女的音乐、体育等特长发展，并愿意投入相应的资源，可能会对抚养权判定产生积极影响。</li><li>未来发展：除了当前的经济状况，法院还会考虑父母的职业稳定性、发展前景等，预测其未来的经济能力。例如一方父母虽然当前经济条件一般，但具有良好的职业发展前景和教育背景，可能会被视为长期更有利于子女的成长。</li></ol><h3 id="父母抚养能力"><a href="#父母抚养能力" class="headerlink" title="父母抚养能力"></a>父母抚养能力</h3><p>除了经济条件，父母的实际抚养能力也是法院重要的考虑因素。</p><ol><li>时间投入：工作繁忙、经常出差或加班的父母可能没有足够的时间照顾子女。</li><li>情感关系：与子女关系亲近、有良好沟通的父母更有可能获得抚养权。法院可能会通过观察、询问子女等方式了解父母与子女的实际关系。</li><li>教育方法：法院会考虑父母的教育观念、方法是否有利于子女的健康成长。</li></ol><h3 id="子女的状况"><a href="#子女的状况" class="headerlink" title="子女的状况"></a>子女的状况</h3><p>子女的具体情况也会影响到抚养权的判定。</p><ol><li>年龄：幼小的子女可能更需要母亲的照顾，而年长的子女可能有自己的生活和学习习惯，更希望与某一方父母生活。</li><li>健康状况：如果子女有特殊的健康需求，法院会考虑哪一方父母更有能力提供医疗和照顾。</li></ol><h2 id="抚养权的变更"><a href="#抚养权的变更" class="headerlink" title="抚养权的变更"></a>抚养权的变更</h2><p>随着时间的推移，父母或子女的情况可能会发生变化，这可能导致<strong>抚养权的重新评估和变更</strong>。例如，如果直接抚养一方出现严重的经济困难或健康问题，或者子女表示强烈的与另一方生活的愿望，法院可能会重新审查抚养权。一些常见的变更的原因如下：</p><ul><li>经济状况的变化：如果直接抚养一方失业、破产或遭受其他经济打击，可能无法继续为子女提供稳定的生活和教育环境。</li><li>健康问题：直接抚养一方如果出现严重的健康问题，可能无法继续照顾子女。</li><li>子女的意愿：随着年龄的增长，子女可能对与哪一方生活有更明确的意愿。如果子女强烈希望与非直接抚养方生活，这可能成为重新评估抚养权的原因。</li><li>其他因素：如直接抚养一方的不当行为，例如虐待、遗弃子女或其他违法行为，都可能导致抚养权的变更。</li></ul><p>如果一方希望变更抚养权，首先需要向法院提出申请，并提供相关证据支持其请求。法院在审查申请时，会全面考虑子女的最大利益，包括子女的意愿、双方父母的经济和抚养能力、子女的健康和教育需求等。在审查过程中，法院可能会要求双方父母、子女以及相关的专家或社工参与。</p><p>总的来说，抚养权的变更并不是一个简单的过程，需要充分的证据和合理的理由。</p><h2 id="抚养费"><a href="#抚养费" class="headerlink" title="抚养费"></a>抚养费</h2><p>抚养费是非直接抚养方为子女支付的一笔费用，用于支持子女的生活和教育。其金额通常基于双方父母的经济状况、子女的实际需求以及当地的生活水平来确定。如果非直接抚养方未按时支付抚养费，他们可能会面临法律制裁。</p><p>抚养费的金额并不是一个固定的数值，而是基于以下几个主要因素来确定的：</p><ol><li>父母的经济状况：法院会考虑<strong>双方的收入、财产、负债以及其他经济责任</strong>，确保抚养费的金额既不会给非直接抚养方带来过重的经济负担，也能满足子女的基本需求。</li><li>子女的实际需求：这包括子女的日常生活费用、医疗费用、教育费用、娱乐和社交活动费用等。</li><li>当地的生活水平：抚养费的金额还会参考当地的消费水平和生活成本，确保子女的生活品质不会因为父母的离婚而受到太大的影响。</li></ol><p>国内大部分地区，抚养费一般占收入的 20% 到 30% 之间，金额大多数在 <strong>800~4500 元&#x2F;月</strong>之间。当然，这里的抚养费一般只到 18 周岁，法律认为18周岁以上公民就具备完全民事行为能力，能自己赚钱了。</p><p>为了避免未来的纠纷，父母双方最好能够签订一个<strong>书面的抚养费协议</strong>，明确约定金额、支付方式和支付时间等细节。随着时间的推移，子女的需求和双方的经济状况都可能发生变化。因此，双方可以约定在一定的时间间隔（如每年或每两年）对抚养费金额进行<strong>重新评估和调整</strong>。</p><h2 id="探视权"><a href="#探视权" class="headerlink" title="探视权"></a>探视权</h2><p>非直接抚养方有给抚养费的义务，也有<strong>与子女见面的权利</strong>，也就是探视权。尽管父母可能因为种种原因而选择分开，但他们对子女的关爱和责任并未因此减少。法院在判定探视权时，通常会根据子女的最大利益、非直接抚养方的请求以及其他相关因素来确定探视的频率和时间。</p><p>常见的探视时间：</p><ul><li>周末探视：非直接抚养方通常可以在周末与子女见面，如每两周的一个周末。</li><li>假期探视：在学校假期，如暑假或寒假，非直接抚养方可以与子女共度更长的时间。</li><li>特殊日子：如子女的生日、公共节假日等，非直接抚养方也有权与子女团聚。</li></ul><p>为了确保探视的顺利进行，双方父母应该尽量协商确定探视的具体时间、地点和方式。例如，可以选择在公共场所如公园、图书馆进行探视，或者由第三方如亲戚、朋友陪同，以确保探视过程中子女的安全和舒适。此外，为了避免因为探视问题再次产生纠纷，双方父母可以选择签订书面的探视协议，明确约定探视的细节。</p><p>探视权的目的是为了保持非直接抚养方与子女之间的亲子关系，让子女在成长过程中能够感受到双方父母的关爱。但是，法院在考虑探视权时，首要的考虑还是子女的福祉。如果探视可能对子女造成伤害或不利影响，如非直接抚养方有不良嗜好、存在家庭暴力历史等，法院可能会<strong>限制或取消探视权</strong>。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>离婚无疑是一次家庭巨变，它不仅影响到配偶间的关系，也深深影响着子女的生活。作为父母，在这艰难的时刻，我们更应秉持以子女最大利益为出发点的原则，通过沟通协商，为他们创造一个充满爱与理解的成长环境。</p><p>子女抚养权的判定是个复杂的问题，需要综合考虑各方面的因素。作为当事人，了解相关的法律规定，可以为子女争取更好的权益。更为重要的是，我们需要保持理性、富有同情心的态度，与另一方保持良好的沟通，积极配合法院的工作，共同为子女的福祉而努力。</p><p>离婚可能会结束一段婚姻，但它绝不能阻碍子女成长中的阳光和温暖。夫妻双方需要携手努力，为子女创造一个美好的明天。</p><hr><p>欢迎扫码关注<a href="https://selfboot.cn/links">小盛律师</a>的公众号，及时收到更新通知～</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230721_wx_qrcode.png" alt="关注公众号"></p>]]></content>
    
    
    <summary type="html">这是一篇关于离婚后子女抚养权的法律科普文章,内容涵盖抚养权判定的法律原则、判定抚养权需要考虑的因素(子女意愿、父母经济条件、抚养能力等)、抚养权变更的情形、抚养费的确定原则、非直接抚养方的探视权等问题。对于准备或正在经历离婚的读者具有重要的参考价值。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="婚姻家庭" scheme="https://selfboot.cn/tags/%E5%A9%9A%E5%A7%BB%E5%AE%B6%E5%BA%AD/"/>
    
  </entry>
  
  <entry>
    <title>罗翔说刑法：非法+经营+数额较大=非法经营罪？？？</title>
    <link href="https://selfboot.cn/2023/08/10/crime_illegal_business/"/>
    <id>https://selfboot.cn/2023/08/10/crime_illegal_business/</id>
    <published>2023-08-10T22:04:36.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自 <a href="https://mp.weixin.qq.com/s/wkcX5eElF11Uzx3PjD0SGw">罗翔说刑法: 非法+经营+数额较大&#x3D;非法经营罪？？？</a>，原作者 <strong>罗翔</strong>，侵权删除。</p></blockquote><p>最近有朋友问我，私开培训机构，教人乐器，构成非法经营罪吗？我说不会吧，他说他上网问了，很多网上的朋友都说构成。</p><p>理由是，私自办学是非法的，而且收费了所以叫做经营，非法加上经营就是非法经营，只要非法经营数额在5万元以上，就构成非法经营罪了。</p><p>我瞬间懵圈了，感觉这些网上的朋友们刑法可能是数学老师教的。</p><p><span style="color:blue;">非法经营罪是一个非常重的罪名，最高可以判处十五年有期徒刑</span>。它的前身是与流氓罪并驾齐驱口袋罪投机倒把罪，1997年刑法修改时，规定了罪刑法定原则，要求刑法分则的罪名保持必要的明确性，因此流氓罪和投机倒把罪都被分解为若干不那么模糊的罪名。</p><span id="more"></span><p>非法经营罪是经济领域中的“口袋罪”，包括四种违反国家规定的非法经营行为：</p><ol><li>未经许可经营法律、行政法规规定的专营、专卖物品或者其他限制买卖的物品的，比如没有执照卖烟、卖酒、卖盐、卖药；</li><li>买卖进出口许可证、进出口原产地证明以及其他法律、行政法规规定的经营许可证或者批准文件的，这就是俗称的买卖批文；</li><li>未经国家有关主管部门批准非法经营证券、期货、保险业务的，或者非法从事资金支付结算业务的，比如没有执照的私募基金，如果向不特定人募集就可能触犯此款；</li><li>其他严重扰乱市场秩序的非法经营行为。</li></ol><p>相信大家看到了，非法经营罪最模糊的是第四款，也就是兜底条款——其他。</p><p>最高司法机关进行了多次解释。非法出版物的经营行为、非法经营电信业务的行为，生产、销售“瘦肉精”的行为，非法经营食盐的行为，特定时期哄抬物价、牟取暴利的行为，非法经营网吧的行为，擅自发行销售彩票的行为，私设生猪屠宰厂（场），从事生猪屠宰、销售等经营活动，先后被解释为非法经营行为。</p><p><span style='color:blue'>为了防止这个罪名被滥用，非法经营罪必须接受形式和实质的双重限缩</span>。</p><p>首先，<span style='color:blue'>在形式上，这个罪名的前提必须是违反国家规定</span>。</p><p>什么是国家规定呢？刑法第96条规定，“本法所称违反国家规定，是指违反全国人民代表大会及其常务委员会制定的法律和决定，国务院制定的行政法规、规定的行政措施、发布的决定和命令。”因此，部门规章和地方性法规都不能染指刑罚权。总之，<span style='color:blue'>非法不是违反习惯法，不是违反一般的法，更不是违反办案人员的看法，而是违反层级较高的法</span>。</p><p>最高人民法院《刑事审判参考》1077号登载了一个权威判例，李某、胡某非法经营案。这两个人开设讨债公司，经营有偿讨债业务，被检察机关指控为非法经营罪。检察机关的主要理由是，多部委 2000 年 6 月 15 日联合发布的《关于取缔各类讨债公司严厉打击非法讨债活动的通知》，这个通知规定：“取缔各类讨债公司，禁止任何单位和个人开办任何形式的讨债公司……对干扰他人正常生活的讨债行为构成犯罪的，依法追究其刑事责任。”</p><p>但人民法院最后认为，《打击非法讨债的通知》不属于刑法中的国家规定，因此无须动用刑罚手段予以制裁。</p><p>多年前，一个学生向我寻求法律帮助，他的年纪比我还大，在取保候审期间找到我，期望我能帮他。他说自己孩子成绩特别好，马上高考，希望不要影响孩子的前途。</p><p>这个学生开设了一个公司，姑且称之为A公司，与B公司签订了一个美化网络舆论的合同，B公司委托A公司向搜索引擎公司提出申请，删除网络上的不实言论。其实B公司完全可以自己申请，但是不想花太多时间，于是委托A公司按照正常程序向搜索引擎公司提出删帖申请，合同约定价格为20万，先支付10万。A公司完美地实现了合同约定，让B公司支付尾款。但B公司拒绝。A公司一生气就把B公司告了。B公司也找了一个律师，在民事法庭上，律师提出了一个匪夷所思的抗辩理由，认为A公司的删帖行为属于非法经营，涉嫌犯罪，因此合同无效，不仅10万不要付，以前付的10万还要A公司退回来。</p><p>这种律师水平太高，我教不出来，估计政法大学也培养不出这么厉害的学生。</p><p>更令人惊诧的是，法院居然认为律师说的有道理，决定中止民事案件的审理，将涉嫌犯罪的A公司移送公安机关处理。这个学生就这样被抓了，还好公安人员也觉得有问题，最后对其进行了取保候审。在等待审判的过程中，这个学生惶惶不可终日，非常害怕再次被羁押，最重要的是，害怕影响孩子的前途。</p><p>公安机关以非法经营罪立案的依据是2013年最高司法机关发布的一个司法解释，该解释认为：违反国家规定，以营利为目的，通过信息网络有偿提供删除信息服务扰乱市场秩序，个人非法经营数额在5万元以上，或者违法所得数额在2万元以上的，或者单位非法经营数额在15万元以上，或者违法所得数额在5万元以上的，属于非法经营行为“情节严重”，以非法经营罪定罪处罚。</p><p>现在A公司非法经营数额是20万，显然达到了入罪标准。</p><p>这个案件的关键在于司法解释说的违反国家规定到底是什么规定，我找到了两个国家规定：</p><p>一个是全国人民代表大会常务委员会《关于维护互联网安全的决定》（以下简称《决定》），还有一个是国务院《互联网信息服务管理办法》（以下简称《管理办法》）。然而，在这两个法律法规中，都没有明确规定删帖服务应当追究刑事责任。</p><p>所以，我认为不构成犯罪。但办案人员不以为然，他们所依据的国家规定是《互联网信息服务管理办法》第十九条：</p><blockquote><p>违反本办法的规定，未取得经营许可证，擅自从事经营性互联网信息服务，或者超出许可的项目提供服务的，由省、自治区、直辖市电信管理机构责令限期改正，有违法所得的，没收违法所得，处违法所得3倍以上5倍以下的罚款；没有违法所得或者违法所得不足5万元的，处10万元以上100万元以下的罚款；情节严重的，责令关闭网站。</p><p>违反本办法的规定，未履行备案手续，擅自从事非经营性互联网信息服务，或者超出备案的项目提供服务的，由省、自治区、直辖市电信管理机构责令限期改正；拒不改正的，责令关闭网站。  </p><p>《互联网信息服务管理办法》第十九条</p></blockquote><p>办案人员说：你看，你没有经营许可证经营互联网业务，非法吧，收了钱，经营了吧，两个加起来就是非法经营吧，而且超过了十五万，达到入罪标准了，三个加一起，不就是非法经营罪吗？定罪逻辑清晰无比，办案机关和你无冤无仇，怎么会冤枉你呢？赶快认罪认罚，争取一个好态度吧。不要再找法盲咨询了。</p><p>然而，第十九条只规定了行政责任，没有任何刑事责任的规定。事实上，《管理办法》第二十条才明确了需要追究刑事责任的范围，“制作、复制、 发布、传播本办法第十五条所列内容之一的信息，构成犯罪的，依法追究刑事责任……” 但是，营利性删帖服务并不属于第十五条和第二十条规定的追究刑事责任的范围。无论是依照全国人大常委会《决定》 还是国务院《管理办法》都没有追究这种营利性删帖服务刑事责任的规定。</p><p>办案人员觉得有点道理，但是还是将案件移送到检察院，让学生找检察机关沟通。</p><p>这个案件的结局还是不错的，检察机关最后做出了相对不起诉决定。</p><p>一个又一个具体的人的喜怒哀乐，一个又一个具体个案涉及的芸芸众生，给我带来的最深刻体悟就是，办理案件不是逻辑运算，不是试卷上的案例分析，不是电脑上的文字游戏，它关系到一个又一个鲜活的人生，以及背后牵肠挂肚的家人和朋友。</p><p>回到私下培训是否构成非法经营罪的问题。</p><p>的确，<span style='color:blue'>私下培训有可能违法，但违法不一定是犯罪</span>。按照《教育法》规定，不好好学习也是违法的，因为该法第四十四条规定，受教育者应当履行下列义务，其中一条就是努力学习，完成规定的学习任务。那是不是不好好学习就要抓起来，坐牢呢？相信只要不是杠精，都可以做出准确的判断。</p><p>私开培训机构教人乐器可能违反《教育法》第七十五条：“违反国家有关规定，举办学校或者其他教育机构的，由教育行政部门或者其他有关行政部门予以撤销；有违法所得的，没收违法所得；对直接负责的主管人员和其他直接责任人员，依法给予处分。”显然，这个条文没有追究刑事责任规定，最多只能进行行政处罚。</p><p>有人认为这种行为可能违反《民办教育促进法》第六十四条的规定：“违反国家有关规定擅自举办民办学校的，由所在地县级以上地方人民政府教育行政部门或者人力资源社会保障行政部门会同同级公安、民政或者市场监督管理等有关部门责令停止办学、退还所收费用，并对举办者处违法所得一倍以上五倍以下罚款；构成违反治安管理行为的，由公安机关依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。”</p><p>然而，培训学校教人乐器并不属于民办教育的范畴，根据《民办教育促进法》第十二条的规定，只有学历教育、学前教育、自学考试助学及其他文化教育才属于民办教育。即便采取极度扩张性的解释，将音乐美术等艺术教育认定为其他文化教育，那么《民办教育促进法》第六十四条的规定，追究法律责任的前提依然需要违反“违反国家有关规定”，这个有关规定显然是《民办教育促进法》以外的其他法律规定。《民办教育促进法》第二条规定：“国家机构以外的社会组织或者个人，利用非国家财政性经费，面向社会举办学校及其他教育机构的活动，适用本法。本法未作规定的，依照教育法和其他有关教育法律执行。” 立法者特别使用了“法律”而非“法律法规”，这就意味着，与民办教育有关的事务，只能由全国人大及其常委会规定的法律做出规定。</p><p>事实上，为了避免兜底罪非法经营罪的兜底条款无节制的扩张，最高人民法院2011年4月8日发布的《关于准确理解和适用刑法中“国家规定”的有关问题的通知》也明确规定：“各级人民法院审理非法经营犯罪案件，要依法严格把握刑法第二百二十五条第（四）的适用范围。对被告人的行为是否属于刑法第二百二十五条第（四）规定的‘其它严重扰乱市场秩序的非法经营行为’，有关司法解释未作明确规定的，应当作为法律适用问题，逐级向最高人民法院请示。”换言之，如果司法解释并没有做出具体的规定，那么是否构成非法经营罪的兜底条款，必须要向最高人民法院请示方能定夺。</p><p>其次是非法经营罪的实质限缩，这主要考虑两点：</p><p><span style='color:blue'>第一是非法经营罪所侵犯的市场经济秩序</span>。一个非常经典的案例就是王力军收购玉米案。王力军从事玉米经销，从农民处收购玉米，但他并未办理粮食收购许可证。根据《粮食收购资格审核管理暂行办法》，“凡常年收购粮食并以营利为目的，或年收购量达到50吨以上的个体工商户，必须取得粮食收购资格”。王力军后被举报。一审法院判决王力军构成非法经营罪，理由是违反国家法律、行政法规规定，未经粮食主管部门许可，非法收购玉米，判处其有期徒刑1年，缓刑2年。该案引起广泛关注，后经最高人民法院就此案做出再审决定。再审法院认为，在本案中，王力军从粮农处收购玉米卖予粮库，没有严重扰乱市场秩序，且不具有与刑法规定的非法经营罪前三项行为相当的社会危害性，不具有刑事处罚的必要性，改判王力军无罪。后来，此案入选当年的“全国十大法治案例”。</p><p>在网约车刚刚出现之时，曾经有观点认为应该以《道路运输条例》第六十四条之规定追究相关人员非法经营罪的责任。从形式上来说，这种观点并无不妥，条例确实有追究刑事责任的规定，“违反本条例的规定，未取得道路运输经营许可，擅自从事道路运输经营的，由县级以上道路运输管理机构责令停止经营；有违法所得的，没收违法所得，处违法所得2倍以上10倍以下的罚款；没有违法所得或者违法所得不足2万元的，处3万元以上10万元以下的罚款；构成犯罪的，依法追究刑事责任”。</p><p>然而，网约车到底是扰乱了市场秩序，还是繁荣了市场秩序？结论毋庸置疑。网约车便利了民众的出行，解决了相当多数人的就业问题。市场秩序不是抽象的行政管理秩序——否则违反行政法规的行为都可以解释为违反某种管理秩序，它必须归结为无数具体人的人身、财产安全。培训学校在没有办学许可的情况下教人乐器的确违反了教育管理秩序，对其可以进行批评、罚款等行政处罚，这它并不一定违反市场秩序。相反，在某种意义上，它可能更好地普及了艺术知识，反而促进了艺术的发展与市场的繁荣。<span style='color:blue'>非法经营罪的立法本意是促进，而不是遏制市场经济的发展</span>。</p><p><span style='color:blue'>第二是罪刑均衡原则所要求的公正</span>。非法经营罪是一种兜底罪，它来源于以前的投机倒把罪，1997年刑法修改时，在经济领域中规定了大量具体的犯罪，这些犯罪以往都是按照投机倒把罪处理的。这些具体的犯罪和非法经营罪是特殊罪和普通罪的关系，有时这些特殊犯罪的刑罚会轻于非法经营罪。然而，当前有一种非常不好的作风，个别司法机关在特殊罪无法入罪的情况下，直接以普通罪定罪量刑，这不仅让刑事辩护辩了一个寂寞，甚至导致一种怪现象——越是认真的律师就越是会让当事人遭受更重的刑事处罚。</p><p>某地涂鸦事件就是一个典型。丁某是街头艺术家，在墙壁上涂鸦，当地故意毁坏财物罪的认定标准是经济损失5000元以上，检察机关最初认为丁某涂鸦造成财物损失共计5638元。但律师认为检察机关出具的价格认定书明显不合理，有几处价格认定和实际损失相差10倍，所以他们提出实际损失不足5000元，故意毁坏财物罪不成立。但是检察机关很快变更了罪名，定为寻衅滋事罪，该罪定罪标准较低，只要造成损失2000元以上，就可以追究刑事责任。比较起来，故意毁坏财物罪无论是基本刑，还是加重刑都比寻衅滋事罪要轻，但这样一来就出现了一个诡异的结果：数额更高的可以认定为轻罪，而数额更低的则会被认定为重罪。轻罪重判，重罪轻判，这不仅违反罪刑相当原则，也与民众朴素的道德良知相抵触。</p><p>同为兜底罪的非法经营罪也常常出现这种现象。以非法行医罪为例，该罪基本刑是三年以下有期徒刑、拘役或者管制，并处或者单处罚金；严重损害就诊人身体健康的，处三年以上十年以下有期徒刑，并处罚金；造成就诊人死亡的，处十年以上有期徒刑，并处罚金。可见，只要造成就诊人死亡才可能和非法经营罪一样，最高判处十五年有期徒刑。2008年的司法解释曾认为黑诊所构成非法行医罪。但是，2016年最高人民法院对此司法解释进行了修改，取消了这个规定。即便医疗机构没有执业许可证，但接诊的大夫属于医生，由于不可能危及民众的身体健康，故不应该构成非法行医罪。然而，个别司法机关认为，虽然黑诊所不构成非法行医罪，但可能构成更重的非法经营罪。</p><p>再如，刑法规定的第一百四十二条之一规定的妨害药品管理罪，“违反药品管理法规，有下列情形之一，足以严重危害人体健康的，处三年以下有期徒刑或者拘役，并处或者单处罚金；对人体健康造成严重危害或者有其他严重情节的，处三年以上七年以下有期徒刑，并处罚金”，其中一种就是未取得药品相关批准证明文件生产、进口药品或者明知是上述药品而销售的。</p><p>以前没有批文生产、销售进口药品，无论药品是否有疗效，都构成生产、销售假药罪。在影片《我不是药神》放映之后，立法机关调整了假药的定义，类似药品不再属于假药。2021年立法机关通过了《刑法修正案（十一）》，生产、销售进口药品虽然不再构成生产、销售假药罪，但如果足以严重危害人体健康的，可以构成妨害药品管理罪。如果一种进口药品没有取得批文，但是有疗效，因为不具有足以严重危害人体健康的具体危险，因此不构成妨害药品管理罪，但个别司法机关却认为，可以构成更为严重的非法经营罪。</p><p><span style='color:blue'>总之，只要本着打击犯罪的立场，一切行为都有可能成为用来开刀的犯罪行为。尤其当人自诩正义的使者时，沙威式的赶尽杀绝、严于律他，反而会让人有一种职业的陶醉感</span>。这就是为什么法学家考夫曼警戒人们：纯粹技术性的法学不过是一个性工作者，可以为任何人服务，也可以被任何人利用。每个受到良好训练的法学家基本上都能证明任何其想要的结果，可以将任何行为解释为犯罪，反而是那些并非法学家的正派人士不屑于使用这一技能。</p><p>《史记·商君列传》记载，商鞅三见秦孝公，向秦孝公讲述了三种治国理论，分别是尧舜帝道，周礼之王道，还有立竿见影的霸道。假设当年孝公选择了王道，估计商鞅也会是一个杰出的儒学专家。对于法律人而言，如果专业的训练只是一种技巧，那么自然也可根据其服务对象变换策略。最后我想以法学家卢埃林的名言和各位共勉：对法律人而言，只有理想而没有技术，那可能是愚蠢的；只有技术而没有理想，那可能是罪恶的。</p><p>那么，私开培训机构，教人乐器，真的构成非法经营罪吗？</p>]]></content>
    
    
    <summary type="html">通过详细剖析非法经营罪的立法目的和适用前提，指出非法加经营不等于非法经营罪，此罪须基于严重扰乱市场秩序。并举实例说明如果扩大解释该罪将违反罪刑相当原则，最后明确私开培训机构不应构成非法经营罪。旨在纠正非法经营罪适用中的错观念，呼吁关注行为的社会危害性，避免滥用刑法压制正常经济活动。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="法律" scheme="https://selfboot.cn/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>由 HTTP Header 引起的请求超时问题排查</title>
    <link href="https://selfboot.cn/2023/08/08/http_100_continue/"/>
    <id>https://selfboot.cn/2023/08/08/http_100_continue/</id>
    <published>2023-08-08T22:09:00.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>在实际业务中遇到了一个很奇怪的问题，服务 A 通过 HTTP 请求访问 Go 语言的服务 B，少部分请求会超时。进一步分析发现，如果一个请求超时，其重试也一定会超时，说明针对特定请求内容，超时是必然发生的问题。通过检查服务 B 的处理日志发现，对于超时的请求，其业务逻辑处理的耗时正常。</p><p>一开始通过排除法来分析，逐步替换怀疑有问题的模块，结果并没有定位到问题。后来通过抓包，分析正常包与超时包的区别，合理猜测有问题的部分并进行验证，最终定位到原来是 <code>Expect: 100-continue</code> 这个请求 HTTP header 导致了这里的超时。整个排查和修复过程，踩了不少坑，记录下来可以给大家参考。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_summary.png" alt="WireShark 抓包 HTTP expect: 100-continue 的包"></p><span id="more"></span><h2 id="排除法"><a href="#排除法" class="headerlink" title="排除法"></a>排除法</h2><p>业务平时都是 C++ 开发，这里的 HTTP Client 库用的 <a href="https://curl.se/libcurl/">libcurl</a>，一直也比较稳定，没有出什么问题，所以第一时间怀疑是 Go 服务 B 的问题。Go 服务其实也比较简单，是用 <a href="https://github.com/gin-gonic/gin">gin 框架</a>实现的 HTTP 协议代理，用来把业务请求解包后，再重新按照第三方的协议封包后转发到第三方。通过加日志等方法排除了业务逻辑部分代码的问题，初步怀疑是我们用 gin 的姿势不对。为了快速验证，我就用 gin 简单写了一个 go 的 server，用业务的 client 来请求 mock 的 server。</p><h3 id="替换-go-server"><a href="#替换-go-server" class="headerlink" title="替换 go server"></a>替换 go server</h3><p>用 gin 来写一个简单的 HTTP server 还是比较简单的，这里为了<strong>尽量模拟</strong>业务场景，会读请求包中的内容，然后回复一段比较长的随机内容。完整代码在 <a href="https://gist.github.com/selfboot/7d45051f39785adc6f46a92eb585af43">gist: mock_server.go</a>，核心部分代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MeshCall</span><span class="params">(meshPath <span class="type">string</span>, c *gin.Context)</span></span> &#123;</span><br><span class="line">        start := time.Now()</span><br><span class="line"></span><br><span class="line">        uinStr := c.Query(<span class="string">&quot;uin&quot;</span>)</span><br><span class="line">        uin, err := strconv.ParseUint(uinStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                c.Status(http.StatusBadRequest)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        body, _ := ioutil.ReadAll(c.Request.Body)</span><br><span class="line">        log.Println(<span class="string">&quot;Request Body: &quot;</span>, <span class="type">string</span>(body))</span><br><span class="line"></span><br><span class="line">        c.Status(http.StatusOK)</span><br><span class="line">        c.Writer.Header().Add(<span class="string">&quot;code&quot;</span>, strconv.FormatInt(<span class="type">int64</span>(uin), <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate a 1MB random string</span></span><br><span class="line">        randomStr := StringWithCharset(<span class="number">1024</span>*<span class="number">1024</span>, charset)</span><br><span class="line">        c.Writer.Write([]<span class="type">byte</span>(randomStr))</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">&quot;Request processed in %s\n&quot;</span>, time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 mock 的 server 代码，包含了业务服务 B 里面的核心逻辑，比如用 <code>ReadAll</code> 来拿请求数据，用 <code>c.Writer</code> 来写回包内容。在 8089 启动服务后，不论是直接用命令行 curl 工具，还是用 C++ 的 client 去调用，都能正常得到 HTTP 回复。看来业务上 go 服务里 gin 的用法是没有问题，基本可以排除是 gin 自身的问题。替换 server 没发现问题，接下来替换下 client 看看？</p><h3 id="替换-go-client"><a href="#替换-go-client" class="headerlink" title="替换 go client"></a>替换 go client</h3><p>C++ 的 client 逻辑很简单，将一个图片设到 protobuf 的字段中，序列化后用 libcurl 发起 HTTP 请求，然后就等着回包。在 ChatGPT 的帮助下，很快就用 go 写了一个 client，一样的请求逻辑。完整代码在 <a href="https://gist.github.com/selfboot/a88f2c4cc8f7bd5ef99097be34b988f6">gist: mock_client.go</a>，这里省略了 proto 部分，其中核心代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    req, err: = http.NewRequestWithContext(context.Background(), http.MethodPost, <span class="string">&quot;http://localhost:8089&quot;</span>, bytes.NewBuffer(serializedImageDataTwice))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to create request: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-protobuf&quot;</span>)</span><br><span class="line"></span><br><span class="line">    client: = &amp; http.Client &#123;&#125;</span><br><span class="line">    resp, err: = client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to send request: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;response header: %v&quot;</span>, resp.Header)</span><br><span class="line">    log.Printf(<span class="string">&quot;response body: %v&quot;</span>, resp.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个 go client 请求前面 mock 的 go server，能正常解析回包。接着<strong>去请求有问题的业务服务 B，发现不再超时了，能正常读到回包</strong>。这下子有点懵了，梳理下前面的实验结果：</p><table><thead><tr><th>主调方</th><th>被调方</th><th>结果</th></tr></thead><tbody><tr><td>C++ Client A</td><td>Go Server B</td><td>特定请求必现超时</td></tr><tr><td>C++ Client A</td><td>Go Mock Server</td><td>一切正常</td></tr><tr><td>Go Client</td><td>Go Server B</td><td>一切正常</td></tr><tr><td>Go Client</td><td>Go Mock Server</td><td>一切正常</td></tr></tbody></table><p><strong>只有 <code>C++ Client A</code> 和 <code>Go Server B</code> 在一起，特定请求才会超时</strong>。已经没啥好思路来排查，只能尝试抓包，看看正常情况下和超时情况下 TCP&#x2F;HTTP 包有啥区别。</p><h2 id="Tcpdump-抓包分析"><a href="#Tcpdump-抓包分析" class="headerlink" title="Tcpdump 抓包分析"></a>Tcpdump 抓包分析</h2><p>Linux 下抓包比较简单，直接用 tcpdump 就行，不过一般需要 root 权限。下面命令过滤指定 ip 和端口的包，并保存为 <code>pcap</code> 格式，方便后面用 <code>Wireshark</code> 来分析。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> tcpdump -i any -s <span class="number">0</span> -w output.pcap &#x27;host <span class="number">11</span>.**.**.** and port <span class="number">1</span>***&#x27;</span><br></pre></td></tr></table></figure><p>首先抓 go client(IP 最后是143) 和 Go Server B(IP最后是239) 的包，整个请求响应是完全符合预期的，可以看到 0.35 s 左右请求 TCP 发送完毕，然后在 1.8s 左右开始接收回包。HTTP 请求耗时 1.5s 左右，回包内容也是完全正确的。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_go_client_succ.png" alt="WireShark 抓正常回复的包"></p><p>接着是 C++ client 和 Go Server B 的包，这里 C++ 的 client 超时时间设置的 10 秒。可以看到这里中间收到了一个 100 continue 的 HTTP response，然后等到 10 s，客户端关闭了 TCP 连接。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230807_http_100_continue_fail.png" alt="WireShark 抓超时的包"></p><p><code>100 continue</code> 是从哪里冒出来的？为啥 Go client 请求服务没有，而 C++ client请求会有呢？</p><h3 id="Header-对比"><a href="#Header-对比" class="headerlink" title="Header 对比"></a>Header 对比</h3><p>回复不同一般是因为请求不同，对比这两个请求的 header 部分，发现 <code>Content-Type</code> 不同，不过这个一般没啥作用，顶多影响 server 解析，不会导致超时。除此之外，C++ 的请求 header 还多了一个 <code>Expect: 100-continue</code>，和上面回包中的 continue 也对得上。看来很大概率是这个 header 的问题了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Go client 的 header 部分</span></span><br><span class="line"><span class="attribute">POST</span> /*** HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Host</span>: **.<span class="number">239</span>:***</span><br><span class="line"><span class="attribute">User</span>-Agent: Go-http-client/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Content</span>-Length: <span class="number">1189188</span></span><br><span class="line"><span class="attribute">Content</span>-Type: application/x-protobuf</span><br><span class="line"><span class="attribute">Accept</span>-Encoding: gzip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># C++ client 的 header 部分</span></span><br><span class="line"><span class="attribute">POST</span> /*** HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Host</span>: **.<span class="number">239</span>:***</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Content</span>-Type: application/octet-stream</span><br><span class="line"><span class="attribute">Content</span>-Length: <span class="number">1189193</span></span><br><span class="line"><span class="attribute">Expect</span>: <span class="number">100</span>-continue</span><br></pre></td></tr></table></figure><p>为了快速验证，<strong>在 go client 中添加了这个 header</strong>，然后发起请求，结果也超时了。看来确实是因为这个 header 导致的，那么这个 header 到底是做什么的呢？为啥会导致请求超时呢？</p><h2 id="Expect-100-continue"><a href="#Expect-100-continue" class="headerlink" title="Expect: 100-continue"></a>Expect: 100-continue</h2><p>为了解答上面的疑问，需要对 HTTP header 有进一步的了解。HTTP 协议中当客户端要发送一个包含大量数据的请求时（通常是 POST 或 PUT 请求），如果服务器无法处理这个请求（例如因为请求的数据格式不正确或者没有权限），那么客户端会浪费大量的资源来发送这些数据。为了解决这个问题，HTTP&#x2F;1.1引入了 <code>Expect: 100-continue</code> 头部，允许客户端在<strong>发送请求体</strong>前询问服务器是否愿意接收请求。如果服务器不能处理请求，客户端就可以不发送大量数据，从而节省资源。</p><p>这里具体的实现原理是把一个完整的 HTTP 请求分成两个阶段来发送。第一个阶段只发送 HTTP 请求的头部，第二个阶段在收到服务器确认后才发送 HTTP 请求的主体。从 HTTP 的角度看，仍然是一个单一的 HTTP 请求，只是改变了请求的发送方式。</p><p>这里一般靠网络库和底层的 TCP 协议来实现，当使用了”Expect: 100-continue”头部，网络库(比如 libcurl)会先只发送 Expect 部分的 TCP 数据，然后等待服务器的 100 Continue 响应。收到 TCP 回复后，网络库会接着发送请求主体的 TCP  数据包。如果服务器没有返回 100 Continue 响应，网络库可能会选择等待一段时间，然后发送请求主体，或者关闭连接。</p><h3 id="libcurl-实现"><a href="#libcurl-实现" class="headerlink" title="libcurl 实现"></a>libcurl 实现</h3><p>具体到 libcurl 网络库中，<a href="https://everything.curl.dev/http/post/expect100">Expect 100-continue</a> 有一个详细的说明。<strong>当使用 Post 或者 Put 方法，请求体超过一定大小(一般是 1024 字节)时，libcurl 自动添加”Expect: 100-continue”请求头</strong>。对于上面的抓包中，请求的 body 中有一个比较大的图片，所以 C++ libcurl 的 client 请求中就多了这个 header。</p><p>现在只剩下一个问题了，<strong>带有这个 header 为啥会导致请求超时呢</strong>？libcurl 的文档中有提到下面一段：</p><blockquote><p>Unfortunately, lots of servers in the world do not properly support the Expect: header or do not handle it correctly, so curl will only wait 1000 milliseconds for that first response before it will continue anyway.</p></blockquote><p>可以看到，很多服务并没有很好支持 <code>Expect: 100-continue</code> 头部，不过 libcurl 也考虑了这种情况，在等待 1s 超时时间后，会继续发 body。从前面的抓包中也能验证这一点：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_wait1000.png" alt="WireShark Expect: 100-continue 等待 1s"></p><p>这里 libcurl client(IP最后是 253) 发送 header 后，没有收到服务端回复，所以等待了 1s 左右，开始继续发请求 body。正常情况下，服务器等收到完整响应后，再进行处理然后回包，最多也就浪费了 1s 的等待时间。不过这里我们的 server 表现比较奇特，在收到完整包后，先是回复了 100-continue，然后就没有任何反应了。导致 client 一直在等，直到 10s 超时。这又是什么原因导致的呢？</p><h2 id="超时原因及修复"><a href="#超时原因及修复" class="headerlink" title="超时原因及修复"></a>超时原因及修复</h2><p>先来回顾下前面做的实验中，已经知道 C++ Client A 请求 Go Mock Server 的时候，带了 Expect:100-continue 头部，gin 框架的 HTTP server 也是可以正常回复的。整个请求和响应如下图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_continue_succ.png" alt="WireShark Expect: 100-continue 正常的处理流程"></p><p>可以看到 gin 服务在接收到 header 后，直接回复了 100-continue，然后 client 继续传 body，gin 服务收完后，也是正常给了200 的回包。同样是 gin 的服务，<strong>为啥请求我们业务的 Go 服务 B 就会超时呢</strong>？</p><p>仔细梳理了下，发现这两者还是有不同之处的。这里实验 mock 的 gin 服务是在本机上开的一个端口，请求直接到这个端口处理。但是业务的 <strong>Go 服务由 mesh 接管所有的流量并进行转发</strong>，如果 mesh 层没有处理好 100-continue，确实会有问题（这里后续可以分析下 mesh 的实现看看是哪里出问题）。</p><h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><p>Mesh 层的代码由专人维护，在提交 Issue 后难以确定何时能修复，而业务上又迫切需要解决该问题。于是就只好改 libcurl 的调用方法，在请求的时候去掉这个请求头。问了下 ChatGPT，用 libcurl 发送网络请求时，如何去掉这个 header，得到下面的方法。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230808_http_100_continue_del.png" alt="C++ libcurl 请求去掉 Expect: 100-continue header"></p><p>于是就开心的去改了业务发请求部分的代码，在发起网络请求前设置 header，改动如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// Disable &quot;Expect: 100-continue&quot; header</span></span><br><span class="line">    curl_slist *headers = <span class="literal">NULL</span>;</span><br><span class="line">    headers = <span class="built_in">curl_slist_append</span>(headers, <span class="string">&quot;Expect:&quot;</span>);</span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_HTTPHEADER, headers);</span><br><span class="line"></span><br><span class="line">    defer &#123;</span><br><span class="line">        <span class="built_in">curl_slist_free_all</span>(headers);  <span class="comment">// remember to free the headers</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改完后验证了下，到服务 B 的 HTTP 请求确实能收到正常回包了。然后上线的时候，发现调其他三方的网络请求出现了参数错误的告警。回滚后，失败也没了，看来和这个 HTTP 请求的改动有关系了。仔细看了下这里的 libcurl <code>CURLOPT_HTTPHEADER</code> 部分的设置，发现业务上也会设置，这里的<strong>改动会把之前设置的整个 header 覆盖清空</strong>。</p><p>ChatGPT 告诉我可以清空这个 Expect 的 header，甚至还告诉我要注意内存泄露，但是 ChatGPT 也没法考虑周全，没考虑到这种方法会直接覆盖我原来的 header。ChatGPT 确实能为我们提供非常有用的建议和解决方案，但是它的答案是基于用户给定的上下文。它并不知道整个系统的细节，也不能预知全部的业务场景。所以，在接受和应用它的建议时，需要非常谨慎，确保将其建议与实际的业务场景相结合。</p>]]></content>
    
    
    <summary type="html">记录了排查 C++ 客户端请求 Go 服务端时出现的 HTTP 请求超时问题的全过程。通过对比抓包分析发现与 Expect 100-continue 请求头相关，并深入剖析了该头部的实现机制。最后定位到 Mesh 层未正确处理该头部导致问题，并给出了代码层面解决方案。</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="方法" scheme="https://selfboot.cn/tags/%E6%96%B9%E6%B3%95/"/>
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="Go" scheme="https://selfboot.cn/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>离婚法律指南：离婚流程要多久？</title>
    <link href="https://selfboot.cn/2023/08/05/divorce_legal_longtime/"/>
    <id>https://selfboot.cn/2023/08/05/divorce_legal_longtime/</id>
    <published>2023-08-05T22:01:25.000Z</published>
    <updated>2023-10-16T08:41:36.320Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://selfboot.cn/2023/07/21/divorce_legal_knowlage/">当婚姻走到了尽头：必读的离婚法律指南</a> 中已经对离婚所涉及的一些法律事项进行了一个总的说明，不过在实际和当事人交流中，发现很多人对离婚要经历多久没有一个认识，本篇文章就展开聊聊。</p><p>在中国，离婚的途径有两种，一是<strong>协议离婚</strong>，二是<strong>诉讼离婚</strong>。在协议离婚中，夫妻双方需要一起到民政局提交离婚申请，受理后等待离婚 30 天冷静期，然后再一起去民政局办理领取离婚证手续，这个过程<strong>最快也要 31 天</strong>。如果夫妻双方对财产分割或者子女抚养问题有争议，那么可能需要更长的时间来协商和解决。</p><p>如果夫妻双方无法达成协议，那么就需要通过诉讼离婚。诉讼离婚的过程通常会更长，因为它涉及到法院的审理和判决。一般来说，诉讼离婚需要几个月甚至一年以上的时间。在这个过程中，夫妻双方需要提交各种证据，参加庭审，等待法院的判决，后面会聊聊每个环节一般会要多久。</p><span id="more"></span><h2 id="协议离婚"><a href="#协议离婚" class="headerlink" title="协议离婚"></a>协议离婚</h2><p>首先来看看协议离婚吧，协议离婚的流程大概是：</p><ol><li><strong>双方达成一致</strong>：在协议离婚的第一步，夫妻双方需要达成离婚的一致意愿。这意味着双方都同意结束婚姻关系，并且对离婚后的各种事项如财产分割、子女抚养等有一个基本的共识。这一步是协议离婚的基础，没有双方的一致意愿，离婚协议就无法达成。</li><li><strong>制定离婚协议</strong>：在双方达成一致后，需要制定一份离婚协议。离婚协议是一份法律文件，详细记录了夫妻双方对离婚后的各种事项的约定，包括但不限于财产分割、子女抚养、债务处理等。在制定离婚协议时，建议双方尽可能详细、清晰地列出各项条款，以避免未来的纠纷。这里建议找<a href="https://selfboot.cn/links">专业律师</a>咨询怎么制定离婚协议。</li><li><strong>民政部门申请</strong>：制定好离婚协议后，夫妻双方需要共同到当地的民政部门提交离婚申请和离婚协议。自2021年1月1日起，新调整后的离婚登记程序包括五个步骤：申请、受理、冷静期、审查和登记（发证）。</li></ol><p>民政部门的流程：</p><ul><li><strong>申请</strong>：夫妻双方自愿离婚的，应当签订书面离婚协议，持有效证件和证明材料共同到具有管辖权的婚姻登记机关提出申请，在婚姻登记机关现场填写<strong>《离婚登记申请书》</strong>。</li><li><strong>受理</strong>：婚姻登记机关对当事人提交的证件和证明材料进行初审，初审无误后，发给《离婚登记申请受理回执单》。不符合离婚登记申请条件的，不予受理。</li><li><strong>冷静期</strong>：离婚登记当事人收到《离婚登记申请受理回执单》之日起三十日内，任何一方不愿离婚的，可以向婚姻登记机关撤回离婚登记申请。自离婚冷静期届满后三十日内，双方未共同到婚姻登记机关申请发给离婚证的，视为撤回离婚登记申请。</li><li><strong>审查</strong>：自离婚冷静期届满后三十日内，双方当事人应持规定有效的证件和证明材料，共同到婚姻登记机关申请发给离婚证。婚姻登记机关依据相关规定对当事人的真实意愿、证件和证明材料、离婚协议书等进行审查。对不符合离婚登记条件的不予办理。</li><li><strong>登记（发证）</strong>：婚姻登记机关按照相关法律法规的规定予以登记，发给离婚证。</li></ul><p>总的来说，在制定好离婚协议后，最快也要 31 天才能领到离婚证。考虑到很多地方婚姻预约登记的难度，这个时间只会更长。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230803_divorce_legal_longtime_1.png" alt="越秀区离婚登记流程图"></p><p>可以参考广州市越秀区发布的 <a href="http://www.yuexiu.gov.cn/ggfw/ztfw/hysy/hy/content/post_7970498.html">国内居民离婚登记须知</a> 。如果离婚有涉外因素，情况会复杂很多，建议咨询<a href="https://selfboot.cn/links">专业律师</a>。</p><h2 id="诉讼离婚"><a href="#诉讼离婚" class="headerlink" title="诉讼离婚"></a>诉讼离婚</h2><p>上面看到协议离婚的流程还是比较简单的，但是一旦无法达成协议，要通过诉讼离婚，事情就麻烦了很多。诉讼离婚牵涉的程序比较复杂，包括起诉阶段、调解阶段、开庭阶段，还可能有重新发起诉讼，程序不同、情况不同，需要的时长也相差很大。</p><p>如果满足一定条件，比如双方都可以送达，金额比较小，争议不大，则可以采取简易程序审理，从立案到判决一般需要 3 个月左右的时间。如果走普通诉讼程序，一般需要6个月左右的时间。</p><p>一审判决判离婚的概率有多大呢？根据最高人民法院 2018 年所作的<a href="https://www.court.gov.cn/upload/file/2018/03/23/09/33/20180323093343_53196.pdf">司法大数据专题报告之离婚纠纷</a>，全国范围内离婚案件一审判决，<strong>65.81% 的案件判定双方维持婚姻关系</strong>。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20230805_divorce_legal_longtime_denied.png" alt="全国范围内离婚案件一审判决维持婚姻关系"></p><p>具体到某些省份，维持婚姻关系比例更高，比如 <a href="https://www.hnlawyer.org/uploads/file/876/437990/2103/1615278313070.pdf">2020 年河南基层法院离婚诉讼大数据分析报告</a> 中提到的，1912 件样本中判决不准离婚的有 1422 件，占比 74.37。在法律实践中，如果夫妻双方中的一方坚持反对离婚，并且没有虐待、遗弃、严重的家庭暴力、与他人同居或重婚等情况，那么法院通常不会轻易判决离婚。即使存在一般性的打骂、通奸、甚至嫖娼等行为，也不一定能在第一次离婚诉讼中成功解除婚姻关系。</p><p>如果一审判决驳回了离婚的请求，那么在一审判决生效<strong>6个月</strong>后，可以<strong>重新起诉</strong>。这里 6 个月的等待期并不是绝对的，如果在等待期间，出现了新的情况或理由，说明夫妻之间的感情确实已经破裂，或者发生了其他重大变化，那么原告也可以在6个月内重新起诉。这些新的情况或理由可能包括但不限于严重的家庭暴力、一方与他人同居、重婚等。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>分居超过两年能自动离婚吗？</p><blockquote><p>即使分居满两年，也不是自动视为离婚，协议离婚的需要去民政局办理离婚手续，起诉离婚的要通过法院起诉，判决离婚生效后才是正式离婚。</p></blockquote><p>一般几次诉讼才能离掉？</p><blockquote><p>总的来说，<strong>起诉离婚的次数越多，离掉的可能性越大</strong>。第一次起诉并非都判不离(判不离的概率比较大)，第二次起诉，判决离婚的可能性较大，但也并非百分百。大部分的婚姻可以<strong>三次诉讼之内离掉</strong>。对于个别案件，如具特殊性，当事人即便四次甚至更多次数起诉离婚，法院仍可能判决不准离婚。</p></blockquote><p>听人说最多 2 年就能保证离婚成功，是怎么一回事？</p><blockquote><p>根据《民法典》第一千零七十九条：“<strong>经人民法院判决不准离婚后，双方又分居满一年，一方再次提起离婚诉讼的，应当准予离婚。</strong>”第一次起诉在三至六个月审结，如果第一次起诉判决不准离婚的，不要上诉，让一审判决生效，然后在根据民法典的规定分居一年，继续发起诉讼，加上这次的三到六个月，基本在二年左右就可以判决离婚。</p></blockquote>]]></content>
    
    
    <summary type="html">详细解析了中国协议离婚和诉讼离婚的法律流程及时间长短。协议离婚从申请到取得离婚证最快需31天,诉讼离婚往往更为复杂冗长。一审驳回离婚请求后,须间隔6个月方可重新起诉。起诉次数越多,离婚可能性越大。经统计,三次诉讼内可达成离婚。民法典规定一审不准离婚后,再分居满一年即可重新起诉,使离婚时间控制在两年内。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="法律" scheme="https://selfboot.cn/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
</feed>
