<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just For Fun</title>
  <icon>https://www.gravatar.com/avatar/0de0c23d97c75300e32f8494b1485fb8</icon>
  <subtitle>知其然，知其所以然。知识广度是深度的副产品！</subtitle>
  <link href="https://selfboot.cn/atom.xml" rel="self"/>
  
  <link href="https://selfboot.cn/"/>
  <updated>2025-07-15T13:42:45.602Z</updated>
  <id>https://selfboot.cn/</id>
  
  <author>
    <name>selfboot</name>
    <email>xuezaigds@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  
  <entry>
    <title>LevelDB 源码阅读：一步步拆解 SSTable 文件的创建过程</title>
    <link href="https://selfboot.cn/2025/06/27/leveldb_source_table_build/"/>
    <id>https://selfboot.cn/2025/06/27/leveldb_source_table_build/</id>
    <published>2025-06-27T13:00:00.000Z</published>
    <updated>2025-07-15T13:42:45.602Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 中，内存表中的键值对在到达一定大小后，会落到磁盘文件 SSTable 中。并且磁盘文件也是分层的，每层包含多个 SSTable 文件，在运行时，LevelDB 会在适当时机，合并、重整 SSTable 文件，将数据不断往下层沉淀。</p><p>这里 SSTable 有一套组织数据的格式，目的就是保证数据有序，并且能快速查找。那么  SSTable 内部是怎么存储这些键值对的，又是怎么提高数据的读、写性能的。以及整个 SSTable 文件的实现中有哪些优化点？</p><p>本文接下来我们会仔细分析 SSTable 文件的创建过程，一步步拆解来看看这里到底怎么实现的。在开始之前，我先给一个大的图，大家可以先留个印象。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250627_leveldb_source_table_build_total.webp" alt="SSTable 构建文件的步骤概览"></p><span id="more"></span><h2 id="SSTable-文件格式设计原因"><a href="#SSTable-文件格式设计原因" class="headerlink" title="SSTable 文件格式设计原因"></a>SSTable 文件格式设计原因</h2><p>在开始之前，我们要先搞明白一个关键问题，<strong><span style="color: red;">文件格式该如何设计，才能兼顾高效写入和快速读取？</span></strong> 下面我们从几个基本问题出发，来推测作者是如何设计这里的数据格式。</p><h3 id="问题一：键值对该如何存放？"><a href="#问题一：键值对该如何存放？" class="headerlink" title="问题一：键值对该如何存放？"></a>问题一：键值对该如何存放？</h3><p>首先，最核心的数据，也就是用户的键值对，得有个地方放。最简单的方法，把所有键值对按顺序放进 SSTable 这整个大文件。这样有什么问题呢？首先读的时候，如果要找一个 key，需要遍历整个大文件。然后写入过程中，每次添加一个键值对就要写磁盘的话，写 IO 压力会很大，吞吐上不去。</p><p>既然太大了不行，那就分块吧。计算机科学中的”分而治之”思想，在 LevelDB 中得到了很好的体现。我们把大文件切分成不同的数据块，按照数据块的粒度来存储键值对。每个块默认大约 4KB。当一个块写满了，就把它作为一个整体写入文件，然后再开始写下一个。这样整体写入的时候，就会减少很多磁盘 IO 了。</p><p>这里我再多说一点，分块存储不仅减少了写入磁盘的 IO 次数，通过配合</p><p>不过查找问题还没解决，还是要遍历所有的块来查找键值。</p><p>要是我们能快速定位到键值在哪个 DataBlock 里，那就只用遍历单个块就好了，效率会提升很多。</p><h3 id="问题二：如何快速定位到某个-Data-Block？"><a href="#问题二：如何快速定位到某个-Data-Block？" class="headerlink" title="问题二：如何快速定位到某个 Data Block？"></a>问题二：如何快速定位到某个 Data Block？</h3><p>为了解决这个问题，我们需要一个”目录”。计算机中也叫索引，于是 Index Block (索引块) 诞生了。这个块里存放了一系列的索引记录，每个记录都记录一个 Data Block 的信息，根据这个记录，我们能快速知道某个键所在的 DataBlock。</p><p>这样查找键值的时候，只需要在 Index Block 中二分查找，就能快速定位到键值可能在的 DataBlock。索引块只包含一些索引数据，所以整体大小会小很多，通常可以加载到内存中去，所以查找会快很多。</p><p>有了索引块之后，我们把扫描整个文件变成了”查索引 -&gt; 精准读取一小块”的操作，效率会大大提升。这里索引具体怎么设计我们先不管，后面再详细分析。</p><h3 id="问题三：如何避免无效的磁盘读取？"><a href="#问题三：如何避免无效的磁盘读取？" class="headerlink" title="问题三：如何避免无效的磁盘读取？"></a>问题三：如何避免无效的磁盘读取？</h3><p>通过索引块，我们其实能找到 key <strong>可能</strong> 在哪个块，但它不能百分百确定。为什么呢？因为索引块里记录的只是 key 的区间，并不能保证 key 一定在这个区间里，后面结合代码理解会更清晰。这就导致一个问题，当我们兴冲冲地把 Data Block 从磁盘读到内存后，却发现要找的 key 根本不存在，这不就白白浪费了一次宝贵的磁盘 I&#x2F;O 吗？尤其是如果业务中，有大量读不存在 key 的场景，那么这种浪费很可观。</p><p>这种判断不存在的需求，计算机科学中早就有解法了，常见的就是布隆过滤器。布隆过滤器是位数组和哈希函数的组合，可以快速判断一个元素是否在集合中。本系列之前的文章<a href="https://selfboot.cn/2024/08/08/leveldb_source_bloom_filter/">LevelDB 源码阅读：布隆过滤器原理、实现、测试与可视化</a> 中，有详细介绍布隆过滤器的原理和实现。</p><p>LevelDB 中，用同样的解决思路，它支持设置一个可选的过滤块(Filter Block)，在读取 Data Block 之前，先通过 Filter Block 确认键是否存在。如果不存在的话，直接返回，如果可能在，再读取 Data Block 进行确认。通过这种方式，我们极大地减少了对不存在的 key 的无效查询。</p><p>看起来一切很美好了，不过等下，还有个问题，我们怎么知道 Index Block 和 Filter Block 在 SSTable 文件的哪个位置呢？</p><h3 id="问题四：如何定位索引和过滤块？"><a href="#问题四：如何定位索引和过滤块？" class="headerlink" title="问题四：如何定位索引和过滤块？"></a>问题四：如何定位索引和过滤块？</h3><p>现在我们有很多数据块、一个 Index Block、一个 Filter Block。问题又来了：当我们打开一个 SSTable 文件时，我们怎么知道 Index Block 和 Filter Block 在文件的哪个位置呢？</p><p>最朴素的思路就是可以<strong>把这些元信息放到文件的固定偏移位置</strong>。不过如果放到文件头的话，这些记录发生变化的话，整个文件的数据都要移动，这显然不行。</p><p>那放文件末尾呢？看起来可行，LevelDB 也是这么设计的。在文件尾部，放一个固定 48 字节的 Footer 区域，里面记录了 Index Block 在文件的偏移位置，以及另一个之前没提到过的 Meta-Index Block 的位置。</p><p>这里按理说 Footer 记录 Index Block 和 Filter Block 的位置就行了，为啥引入一个 Meta-Index Block 呢？作者在代码注释里有提到过，主要为了扩展性。Footer 的大小固定，不能增加更多信息了，那万一未来有更多种类的元数据块，比如统计块等，要在哪里存偏移。</p><p>所以作者增加了一个元数据的索引——Meta-Index Block。这个块的作用就是一张元数据目录，它的键是元数据的名字（如 “filter.leveldb.BuiltinBloomFilter2”），值是对应元数据块（如 Filter Block）的偏移位置。当前只有过滤块信息，后续可以任意增加元数据块。</p><p>这样整个查找过程就串起来了，先拿出尾部 48 字节的固定内容。从里面解析出 Index Block 和 Meta-Index Block 的偏移位置，然后从 Meta-Index Block 中拿到 Filter Block 的偏移位置，最后根据偏移位置读取 Filter Block 的内容。有了 Index Block 和 Filter Block，我们就能快速、高效地”按图索骥”去查找键值了。</p><h3 id="答案-SSTable-结构图"><a href="#答案-SSTable-结构图" class="headerlink" title="答案: SSTable 结构图"></a>答案: SSTable 结构图</h3><p>前面已经把 SSTable 中数据块组织方式分析完了，这里我画一个简单的 ASCII 图来描述 SSTable 中的各个块，方便大家理解：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+</span><br><span class="line">|   Data Block 0    |</span><br><span class="line">+-------------------+</span><br><span class="line">|   Data Block 1    |</span><br><span class="line">+-------------------+</span><br><span class="line">|       ...         |</span><br><span class="line">+-------------------+</span><br><span class="line">|   Data Block N    |</span><br><span class="line">+-------------------+</span><br><span class="line">|   Filter Block    |  (可选) &lt;-- 由 Meta-Index Block 索引</span><br><span class="line">+-------------------+</span><br><span class="line">| Meta Index Block  | &lt;-- 由 Footer 索引</span><br><span class="line">+-------------------+</span><br><span class="line">|   Index Block     | &lt;-- 由 Footer 索引</span><br><span class="line">+-------------------+</span><br><span class="line">|      Footer       | (文件末尾，固定大小)</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure><p>不过要怎么提供接口，怎么把键值对保存为上面格式，还是有不少工程细节的。这里顺便说下，<strong><span style="color: red;">LevelDB 代码中的分层抽象是做的真好，一层套一层，把复杂逻辑封装起来，方便理解和维护</span></strong>。比如每个块自己是怎么构建数据的，都封装了单独的实现，后面我会在其他文章里详细说明。</p><p>本篇文章，咱们重点关注 SSTable 文件构建的工程细节部分。这部分实现在<a href="https://github.com/google/leveldb/blob/main/table/table_builder.cc">table&#x2F;table_builder.cc</a> 中，主要就是 TableBuilder 类。</p><p>该类只有一个私有成员变量，是一个 Rep* 指针，里面保存各种状态信息，比如当前的 DataBlock、IndexBlock 等。这里 Rep* 用到了 Pimpl 的设计模式，可以看本系列的 <a href="/2024/08/13/leveldb_source_unstand_c++/#Pimpl-%E7%B1%BB%E8%AE%BE%E8%AE%A1">LevelDB 源码阅读：理解其中的 C++ 高级技巧</a> 了解关于 Pimpl 的更多细节。</p><p>该类最重要的接口有 Add，这个函数会层层调用其他一些封装好的函数，来完成键值对的添加。接下来从这个接口入手，分析 TableBuilder 类的实现。</p><h2 id="Add-添加键值对"><a href="#Add-添加键值对" class="headerlink" title="Add 添加键值对"></a>Add 添加键值对</h2><p><a href="https://github.com/google/leveldb/blob/main/table/table_builder.cc#L94">TableBuilder::Add</a> 方法是向 SSTable 文件中添加键值对的核心函数。添加键值对，需要更改上面提到的 DataBlock、IndexBlock、FilterBlock 等各个块。这里为了提高效率，有不少工程优化细节，为了更好理解，我把它主要分 4 部分，这里一个个来说吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 前置校验</span></span><br><span class="line">  <span class="comment">// 2. 处理索引块</span></span><br><span class="line">  <span class="comment">// 3. 处理过滤块</span></span><br><span class="line">  <span class="comment">// 4. 处理数据块</span></span><br><span class="line">  <span class="comment">// 5. 适当时机落盘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前置校验"><a href="#前置校验" class="headerlink" title="前置校验"></a>前置校验</h3><p>在 Add 方法中，首先会先读出来 rep_ 的数据，做一些前置校验，比如验证文件没有被关闭，保证键值对是有序的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rep* r = rep_;</span><br><span class="line"><span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (r-&gt;num_entries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;options.comparator-&gt;<span class="built_in">Compare</span>(key, <span class="built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LevelDB 在代码中 <strong><span style="color: red;">加了不少校验逻辑，确保如果有问题，早崩溃早发现</span></strong>，这个理念对于底层库来说，还是很有必要的。Add 方法这里 assert 校验后面插入的键值对永远都是更大的，当然这点需要调用方来保证。为了实现校验逻辑，在每个 TableBuilder 的 Rep 中，都保存了 last_key，用来记录最后一个插入的 key。这个 key 在索引键优化的时候会用到，后面会详细说明。</p><h3 id="处理索引记录"><a href="#处理索引记录" class="headerlink" title="处理索引记录"></a>处理索引记录</h3><p>接着会在<strong>适当时机添加新的索引</strong>。我们知道索引记录用来快速查找一个 key 所在的 DataBlock 偏移位置，每一个完整的 DataBlock 对应一个索引记录。我们先看看这里<strong>添加索引记录的时机</strong>，当处理完一个 DataBlock 时，会将 pending_index_entry 设置为 true，等到下次新的 DataBlock 增加第一个 key 时，再更新上个完整的 DataBlock 对应的索引记录。</p><p>这部分的核心代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">  r-&gt;options.comparator-&gt;<span class="built_in">FindShortestSeparator</span>(&amp;r-&gt;last_key, key);</span><br><span class="line">  std::string handle_encoding;</span><br><span class="line">  r-&gt;pending_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">  r-&gt;index_block.<span class="built_in">Add</span>(r-&gt;last_key, <span class="built_in">Slice</span>(handle_encoding));</span><br><span class="line">  r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里之所以要等到新 DataBlock 增加第一个 key 的时候才更新索引块，就是 <strong><span style="color: red;">为了尽最大程度减少索引键的长度，从而减少索引块的大小</span></strong>，这也是 LevelDB 工程上的一个优化细节。</p><p>这里扩展讲下背景可能更好理解，SSTable 中每个索引记录都由一个分割键 separator_key 和一个指向数据块的 BlockHandle（偏移量+大小）组成。这个 separator_key 的作用就是划分不同 Datablock 的键空间，对于第 N 个数据块（Block N），它的索引键 separator_key_N 必须满足以下条件：</p><ul><li>separator_key_N &gt;&#x3D; Block N 中的任何键</li><li>separator_key_N &lt; Block N+1 中的任何键</li></ul><p>这样在查找一个目标键的时候，如果在索引块中找到第一个 separator_key_N &gt; target_key 的条目，那么 target_key 如果存在，就必定在前一个数据块（Block N-1）中。</p><p>直观上讲，索引最简单的实现是直接用 Block N 的最后一个键（last_key_N）作为 separator_key_N。但问题是，last_key_N 本身可能非常长。这就导致索引项会很长，进而整个索引块变得很大。<strong>索引块通常需要加载到内存中，索引块越小，内存占用越少，缓存效率越高，查找速度也越快</strong>。</p><p>其实我们细想下，我们并不需要一个真实存在的键作为分割索引 key，只需要一个能把前后两个块分开的”隔离键”即可。这个键只需要满足：last_key_N &lt;&#x3D; separator_key &lt; first_key_N+1。LevelDB 就是这样做的，这里通过调用 options.comparator-&gt;FindShortestSeparator，<strong>找到前一个块最后的键，和下一个块第一个键之间最短分割字符串</strong>。这里 FindShortestSeparator 的默认实现在 <a href="https://github.com/google/leveldb/blob/main/util/comparator.cc#L31C8-L31C29">util&#x2F;comparator.cc</a>中，本文不再列出来了。</p><p>为了更清楚地理解这个优化过程，下面用一个具体的例子来演示：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250620_leveldb_source_table_process_indexkey.webp" alt="SSTable DataBlock 索引分割键优化"></p><p>最后再聊下这里每条索引记录的 value，它是<strong>该块在文件内的偏移和 size</strong>，这是通过 pending_handle 来记录的。当通过 WriteRawBlock 将 DataBlock 写文件的时候，会更新 pending_handle 的偏移和大小。然后写索引的时候，用 EncodeTo 将偏移和 size 编码到字符串中，和前面的索引 key 一起插入到 IndexBlock 中。</p><h3 id="处理过滤记录"><a href="#处理过滤记录" class="headerlink" title="处理过滤记录"></a>处理过滤记录</h3><p>接着处理 FilterBlock 过滤索引块，前面的索引块只是能找到键<strong>应该在的块的位置</strong>，还需要去读出块的内容才知道键到底存不存在。为了快速判断键值在不在，LevelDB 支持了过滤索引块，<strong>可以快速判断某个 key 是否存在于当前 SSTable 中</strong>。如果设置用到过滤索引块，则在添加 key 的时候，同步添加索引，其核心代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  r-&gt;filter_block-&gt;<span class="built_in">AddKey</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里添加 key 之后，只是在内存中存储索引，要等到最后 TableBuild 写完所有的 Block 之后，才会将 FilterBlock 写入文件。<strong>FilterBlock 本身是可选的</strong>，通过 options.filter_policy 来设置。在初始化 TableBuilder::Rep 的时候，会根据 options.filter_policy 来初始化 FilterBlockBuilder 指针，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Rep</span>(<span class="type">const</span> Options&amp; opt, WritableFile* f)</span><br><span class="line">    : <span class="built_in">options</span>(opt),</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="built_in">filter_block</span>(opt.filter_policy == <span class="literal">nullptr</span></span><br><span class="line">                       ? <span class="literal">nullptr</span></span><br><span class="line">                       : <span class="keyword">new</span> <span class="built_in">FilterBlockBuilder</span>(opt.filter_policy)),</span><br><span class="line">      <span class="built_in">pending_index_entry</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里值得注意的是 filter_block 之所以是指针，主要是因为除了用默认的布隆过滤器，还可以<strong>用多态机制使用自己的过滤器</strong>。这里用 new 在堆上创建的对象，为了<strong>防止内存泄露</strong>，在 TableBuilder 析构的时候，先释放掉 filter_block，再接着释放 rep_。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TableBuilder::~<span class="built_in">TableBuilder</span>() &#123;</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;closed);  <span class="comment">// Catch errors where caller forgot to call Finish()</span></span><br><span class="line">  <span class="keyword">delete</span> rep_-&gt;filter_block;</span><br><span class="line">  <span class="keyword">delete</span> rep_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以需要释放 rep_，是因为它是在 TableBuilder 构造的时候，在堆上创建的，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TableBuilder::<span class="built_in">TableBuilder</span>(<span class="type">const</span> Options&amp; options, WritableFile* file)</span><br><span class="line">    : <span class="built_in">rep_</span>(<span class="keyword">new</span> <span class="built_in">Rep</span>(options, file)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    rep_-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 LevelDB 默认的布隆过滤器实现，可以参考<a href="/leveldb_source_filterblock">LevelDB 源码阅读：布隆过滤器的实现</a>。索引块的构建，后面我单独写一篇来详解，这里我们也不深究细节部分。</p><h3 id="处理数据块"><a href="#处理数据块" class="headerlink" title="处理数据块"></a>处理数据块</h3><p>接着需要将键值对添加到 DataBlock 中。DataBlock 是 SSTable 文件中存储实际键值对的地方，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">r-&gt;num_entries++;</span><br><span class="line">r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> estimated_block_size = r-&gt;data_block.<span class="built_in">CurrentSizeEstimate</span>();</span><br><span class="line"><span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用 BlockBuilder 中的 Add 方法，将键值对添加到 DataBlock 中，关于 BlockBuilder 的实现，后面单独文章来描述。哈哈，<strong>这里 LevelDB 分层抽象是做的真好，搞的我们的文章也只能分层了</strong>。每次添加键值对后，都会检查当前 DataBlock 的大小是否超过了 block_size，如果超过了，则调用 Flush 方法将 DataBlock 写入磁盘文件。这里 block_size 是在 options 中设置的，默认是 4KB。这个是键值压缩前的大小，如果开启了压缩，实际写入文件的大小会小于 block_size。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approximate size of user data packed per block.  Note that the</span></span><br><span class="line"><span class="comment">// block size specified here corresponds to uncompressed data.  The</span></span><br><span class="line"><span class="comment">// actual size of the unit read from disk may be smaller if</span></span><br><span class="line"><span class="comment">// compression is enabled.  This parameter can be changed dynamically.</span></span><br><span class="line"><span class="type">size_t</span> block_size = <span class="number">4</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>这里 Flush 怎么写磁盘呢，我们接着往下看。</p><h3 id="Flush-写数据块"><a href="#Flush-写数据块" class="headerlink" title="Flush 写数据块"></a>Flush 写数据块</h3><p>在前面的 Add 方法中，如果一个块的大小凑够 4KB，就会调用 Flush 方法写磁盘文件。Flush 的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;pending_index_entry);</span><br><span class="line">  <span class="built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(r-&gt;offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始部分也就是一些前置校验，注意 Flush 只是用来刷 DataBlock 部分，如果 data_block 为空，就直接返回。接着调用 WriteBlock 方法(后面详解)将 DataBlock 写入文件，然后<strong>更新 pending_index_entry 为 true，表示下次添加 key 时，需要更新索引块</strong>。</p><p>最后调用 file-&gt;Flush() 将目前内存中的数据调用系统 write 写磁盘，注意这里不保证数据已被同步到物理磁盘。数据可能还在系统缓存中，如果操作系统宕机，那有可能丢失没写入成功的数据。这里写文件刷磁盘，可以参考本系列<a href="/2024/08/02/leveldb_source_env_posixfile/">LevelDB 源码阅读：Posix 文件操作接口实现细节</a>中关于文件操作的更多细节。如果有 filter_block，还需要调用 StartBlock 方法，这个方法也比较有意思，等后面我们专门来写 filter block 的时候再详细说明。</p><h2 id="WriteBlock-写文件"><a href="#WriteBlock-写文件" class="headerlink" title="WriteBlock 写文件"></a>WriteBlock 写文件</h2><p>上面提到 Flush 中会调用 WriteBlock 方法将 DataBlock 写入文件，该方法在下面要提到的 Finish 中也会被调用，用来在最后写索引块，过滤块等内容。WriteBlock 的实现比较简单，主要用来处理压缩逻辑，然后调用真正的写文件函数 WriteRawBlock 来把块内容写入文件。</p><p>压缩并不是必须的，如果调用 leveldb 时设置了需要压缩，并且链接了压缩库，就会选择对应的压缩算法对 Block 进行压缩。LevelDB 这里也做了一点<strong>压缩性能和效果的平衡，如果压缩比 (compression_ratio) 小于等于 0.85，就会将压缩后的数据写入文件，否则直接写入原始数据</strong>。真正写文件部分，调用 WriteRawBlock 方法，主要代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="type">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 CompressionType type, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  handle-&gt;<span class="built_in">set_offset</span>(r-&gt;offset);</span><br><span class="line">  handle-&gt;<span class="built_in">set_size</span>(block_contents.<span class="built_in">size</span>());</span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(block_contents);</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="type">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;</span><br><span class="line">    <span class="type">uint32_t</span> crc = crc32c::<span class="built_in">Value</span>(block_contents.<span class="built_in">data</span>(), block_contents.<span class="built_in">size</span>());</span><br><span class="line">    crc = crc32c::<span class="built_in">Extend</span>(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></span><br><span class="line">    <span class="built_in">EncodeFixed32</span>(trailer + <span class="number">1</span>, crc32c::<span class="built_in">Mask</span>(crc));</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      r-&gt;offset += block_contents.<span class="built_in">size</span>() + kBlockTrailerSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在每个块的尾部放了 5 个字节的 trailer 部分，来对数据准确性进行校验。第一个字节是压缩类型，目前支持的压缩算法有 snappy 和 zstd。后面 4 字节是 crc32 校验和，这里用 crc32c::Value 计算数据块的校验和，然后把压缩类型一起计算进去校验和。这里 crc32 部分，可以参考本系列 <a href="/2024/08/29/leveldb_source_utils/">LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码</a> 了解更多细节。</p><h2 id="Finish-主动触发落盘"><a href="#Finish-主动触发落盘" class="headerlink" title="Finish 主动触发落盘"></a>Finish 主动触发落盘</h2><p>上面的所有操作，主要用来将键值对不断添加到数据块中，这个过程如果达到 DataBlock 的大小限制，会触发 DataBlock 的落盘。但整个 SSTable 文件还有索引块，过滤块等，<strong>需要主动触发落盘</strong>。那在什么时机触发，又是怎么落盘呢？</p><p>LevelDB 中产生 SSTable 文件的时机有很多，这里以保存 immetable 时候触发的落盘时机为例。将 immemtable 保存为 SSTable 文件时，过程如下：首先迭代 immemtable 中的键值对，然后调用上面的 Add 方法来添加。Add 中会更新相关 block 的内容，每当 DataBlock 超过 block_size 时，会调用 Flush 方法将 DataBlock 写入文件。</p><p>等所有键值对写完，会主动调用 Finish 方法，来进行一些<strong>收尾工作</strong>，比如将最后一个 Datablock 的数据写入文件，写入 IndexBlock，FilterBlock 等。</p><p>Finish 的实现如下，开始之前先用 Flush 把剩余的 DataBlock 部分刷到磁盘文件中，接着会处理其他块，并且在文件尾部添加一个固定大小的 footer 部分，用来记录索引信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">  r-&gt;closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write filter block</span></span><br><span class="line">  <span class="comment">// Write metaindex block</span></span><br><span class="line">  <span class="comment">// Write index block</span></span><br><span class="line">  <span class="comment">// Write footer</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里构建各个块也比较有意思，都是用一个 builder 来处理内容，同时用一个 handler 来记录块的偏移和大小。我们分别来看下。</p><h3 id="BlockBuilder-构建块"><a href="#BlockBuilder-构建块" class="headerlink" title="BlockBuilder 构建块"></a>BlockBuilder 构建块</h3><p>先思考一个问题，<strong>这里有这么多类型的块，每个块都要一个自己的 Builder 来拼装数据吗</strong>？</p><p>这里要从每个块的数据结构来看，Data&#x2F;Index&#x2F;MetaIndex Block 这三种块都具有以下共同特征：</p><ul><li>键值对结构：都存储键值对形式的数据，虽然这里每个块里面的键值含义不一样，但都是键值对形式;</li><li>有序性要求：键必须按顺序排列，因为后面查找的时候，需要支持二分查找或顺序扫描;</li></ul><p>所以这 3 类块的构建逻辑是类似的，LevelDB 中共用同一个 BlockBuilder 来处理。这里实现在 <a href="https://github.com/google/leveldb/blob/main/table/block_builder.h">table&#x2F;block_builder.h</a> 中，也有不少优化细节。比如前缀压缩优化，对于相似的键只存储差异部分，节省空间。重启点机制，每隔几个条目设置一个重启点，支持二分查找。后面我会专门用一篇文章来详细说明。封装后用起来比较简单，以 MetaIndex Block 为例，用 Add 添加键值，然后 WriteBlock 落磁盘就好。代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// Add mapping from &quot;filter.Name&quot; to location of filter data</span></span><br><span class="line">      std::string key = <span class="string">&quot;filter.&quot;</span>;</span><br><span class="line">      key.<span class="built_in">append</span>(r-&gt;options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">      std::string handle_encoding;</span><br><span class="line">      filter_block_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">      meta_index_block.<span class="built_in">Add</span>(key, handle_encoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 filter block 的数据结构和其他的都不一样，它存储的是布隆过滤器的二进制数据，按文件偏移分组，每 2KB 文件范围对应一个过滤器。所以 filter block 的构建逻辑和其他的都不一样，需要单独处理。这里的实现在 <a href="https://github.com/google/leveldb/blob/main/table/filter_block.cc">table&#x2F;filter_block.cc</a> 中，后面我单独再展开分析。这里使用倒是很简单，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write filter block</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="built_in">WriteRawBlock</span>(r-&gt;filter_block-&gt;<span class="built_in">Finish</span>(), kNoCompression,</span><br><span class="line">                &amp;filter_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 Finish 方法会返回 filter block 的二进制数据，然后调用 WriteRawBlock 方法将数据写入文件。</p><h3 id="BlockHandle-记录偏移和大小"><a href="#BlockHandle-记录偏移和大小" class="headerlink" title="BlockHandle 记录偏移和大小"></a>BlockHandle 记录偏移和大小</h3><p>上面用两个 builder 来构建块，但是用同一个 handler 类来记录块的偏移和大小。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里 BlockHandle 的实现在 <a href="https://github.com/google/leveldb/blob/main/table/format.h#L23">table&#x2F;format.h</a> 中，主要告诉系统在文件的第 X 字节位置，有一个大小为 Y 字节的块，仅此而已。不过配合不同块的 handle 信息，就能方便存储不同块的偏移和大小。</p><p>至此，我们用两个 builder 来构建各种索引块，同时用一个 handler 来辅助记录块的偏移和大小。就完成了整个块的构建。</p><h2 id="创建-SSTable-文件完整步骤"><a href="#创建-SSTable-文件完整步骤" class="headerlink" title="创建 SSTable 文件完整步骤"></a>创建 SSTable 文件完整步骤</h2><p>最后我们可以来看看上层调用方，是如何用 TableBuilder 来构造 SSTable 文件的。</p><p>在 <a href="https://github.com/google/leveldb/blob/main/db/builder.cc#L17">db&#x2F;builder.cc</a> 中封装了一个函数 BuildTable 来创建 SSTable 文件，它就是调用 TableBuilder 类的接口来实现的。省略其他无关代码，核心代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BuildTable</span><span class="params">(<span class="type">const</span> std::string&amp; dbname, Env* env, <span class="type">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    TableBuilder* builder = <span class="keyword">new</span> <span class="built_in">TableBuilder</span>(options, file);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Slice key;</span><br><span class="line">    <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">      key = iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      builder-&gt;<span class="built_in">Add</span>(key, iter-&gt;<span class="built_in">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Finish and check for builder errors</span></span><br><span class="line">    s = builder-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用迭代器 iter 来遍历 immemtable 中的键值对，然后调用 TableBuilder 的 Add 方法将键值对添加到 SSTable 文件中。Memtable 的大小限制默认是 4MB(write_buffer_size &#x3D; <code>4*1024*1024</code>)，在用 TableBuilder 添加键值对时，会根据 block_size(4*1024) 来划分数据块。每当凑够一个 DataBlock，就会拼装相应 block 的数据，然后用 flush 追增内容到磁盘 SSTable 文件中。最后调用 TableBuilder 的 Finish 方法写入其他 Block，完成整个SSTable 文件的写入。</p><p>除了这里 BuildTable 将 immemtable 中的数据写入 level0 的 SSTable 文件外，还有一个场景是在 Compact 过程中，将多个 SSTable 文件合并成一个 SSTable 文件。这个过程在 <a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L897">db&#x2F;db_impl.cc</a> 中的 DoCompactionWork 函数中实现，整体流程稍微复杂，调用比较深入，等后面我们讲 Compact 的时候再详细分析。</p><p>不过这里只讲一个点，在 Compact 过程中，会在某些失败场景调用 TableBuilder 的 Abandon 方法，用来放弃当前的 TableBuilder 写入文件过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compact-&gt;builder-&gt;<span class="built_in">Abandon</span>();</span><br></pre></td></tr></table></figure><p>Abandon 主要就是把 TableBuilder 的 Rep 中的 closed 设置为 true，调用方之后就会丢掉这个 TableBuilder 实例，不会用它执行任何写入操作了(写入中一堆断言来检查这个状态)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到开头我们提出的问题，文件格式该如何设计，才能兼顾高效写入和快速读取？通过深入分析 LevelDB 的 SSTable 文件创建过程，我们可以看到作者是如何一步步解决这个问题的。首先SSTable 数据格式设计有几个重要的设计思想：</p><ol><li><strong>分块存储</strong>：将大文件切分成 4KB 的 DataBlock，既便于管理，又能减少无效的磁盘 I&#x2F;O，还方便缓存热点数据。</li><li><strong>索引加速</strong>：通过 IndexBlock 将”全文扫描”变成”查目录 + 精准读取”，减少磁盘 I&#x2F;O 次数。</li><li><strong>过滤优化</strong>：用 FilterBlock 在源头减少不必要的磁盘读取，提高读取性能。</li><li><strong>元信息集中管理</strong>：Footer + Meta-IndexBlock 的设计保证了扩展性，方便后续添加更多元数据块。</li></ol><p>在 TableBuilder 的实现中，我们也看到了不少值得学习的工程细节，比如：</p><ul><li><strong>索引键优化</strong>：延迟到下一个块开始时才更新索引，通过 FindShortestSeparator 算法生成最短分割键，大幅减少索引块大小。这个优化看似微小，但在大规模数据下效果显著。</li><li><strong>错误处理</strong>：代码中大量的 assert 断言体现了”早崩溃早发现”的理念，对于底层存储系统来说至关重要。</li><li><strong>分层抽象</strong>：TableBuilder → BlockBuilder → FilterBlockBuilder 的分层设计，让复杂的文件格式构建变得井井有条。每一层都有明确的职责边界。</li><li><strong>性能平衡</strong>：压缩策略中的 0.85 压缩比阈值，体现了对性能与效果的权衡考量。</li></ul><p>其实 SSTable 的设计回答了存储系统中的几个根本问题。用顺序写入，来保证写入吞吐，用索引结构来保证读取性能。用分块和按需加载以及缓存，在有限内存下处理海量数据。同时用压缩和过滤器来平衡存储空间与查询效率，用元信息分层来保证系统的可扩展性。这些都是计算机软件系统中沉淀多年的经典设计，值得我们学习。</p><p>理解了 SSTable 的创建过程后，你可能会产生一些新的疑问：DataBlock 内部是如何组织数据的？读取 SSTable 时的流程是怎样的？多个 SSTable 文件如何协同工作？</p><p>这些问题的答案，构成了 LevelDB 这个精巧存储引擎的完整图景。我会在后面的文章中继续深入分析，敬请期待。</p>]]></content>
    
    
    <summary type="html">深入解析 LevelDB 中 SSTable 文件的创建过程和内部结构设计。本文从问题驱动的角度，详细分析了 SSTable 如何通过分块存储、索引优化、过滤器等机制实现高效的读写性能。重点剖析 TableBuilder 类的实现细节，包括 DataBlock、IndexBlock、FilterBlock 的构建过程，以及索引键优化、压缩策略等工程技巧。通过源码分析展示了 LevelDB 如何解决大规模数据存储中的关键问题：快速定位数据块、减少无效磁盘 I/O、平衡存储空间与查询效率。文章结合具体代码示例和流程图，让读者深入理解 SSTable 文件格式设计的精妙之处，以及 LevelDB 作为高性能键值存储引擎的核心实现原理。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：LRU Cache 高性能缓存实现细节</title>
    <link href="https://selfboot.cn/2025/06/13/leveldb_source_LRU_cache/"/>
    <id>https://selfboot.cn/2025/06/13/leveldb_source_LRU_cache/</id>
    <published>2025-06-13T21:00:00.000Z</published>
    <updated>2025-07-15T13:42:45.602Z</updated>
    
    <content type="html"><![CDATA[<p>计算机系统中，缓存无处不在。从 CPU 缓存到内存缓存，从磁盘缓存到网络缓存，缓存无处不在。缓存的核心思想就是空间换时间，通过将热点数据缓存到高性能的存储中，从而提高性能。因为缓存设备比较贵，所以存储大小有限，就需要淘汰掉一些缓存数据。这里淘汰的策略就非常重要了，因为如果淘汰的策略不合理，把接下来要访问的数据淘汰掉了，那么缓存命中率就会非常低。</p><p>缓存淘汰策略有很多种，比如 LRU、LFU、FIFO 等。其中 LRU(Least Recently Used) 就是一种很经典的缓存淘汰策略，它的核心思想是：<strong>当缓存满了的时候，淘汰掉最近最少使用的数据</strong>。这里基于的一个经验假设就是”<strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong>“。只要这个假设成立，那么 LRU 就可以显著提高缓存命中率。</p><p>在 LevelDB 中，实现了内存中的 LRU Cache，用于缓存热点数据，提高读写性能。默认情况下，LevelDB 会对 sstable 的索引 和 data block 进行缓存，其中 sstable 默认是支持缓存 990 (1000-10) 个，data block 则默认分配了 8MB 的缓存。</p><p>LevelDB 实现的 LRU 缓存是一个分片的 LRU，在细节上做了很多优化，非常值得学习。本文将从经典的 LRU 实现思路出发，然后一步步解析 LevelDB 中 <a href="https://github.com/google/leveldb/blob/main/util/cache.cc">LRU Cache</a> 的实现细节。</p><span id="more"></span><h2 id="经典的-LRU-实现思路"><a href="#经典的-LRU-实现思路" class="headerlink" title="经典的 LRU 实现思路"></a>经典的 LRU 实现思路</h2><p>一个实现良好的 LRU 需要支持 O(1) 时间复杂度的插入、查找、删除操作。经典的实现思路是使用<strong>一个双向链表和一个哈希表</strong>，其中：</p><ul><li><strong>双向链表用于存储缓存中的数据项，并保持缓存项的使用顺序</strong>。最近被访问的数据项被移动到链表的头部，而最久未被访问的数据项则逐渐移向链表的尾部。当缓存达到容量限制而需要淘汰数据时，链表尾部的数据项（即最少被访问的数据项）会被移除。</li><li><strong>哈希表用于存储键与双向链表中相应节点的对应关系</strong>，这样任何数据项都可以在常数时间内被快速访问和定位。哈希表的键是数据项的键，值则是指向双向链表中对应节点的指针。</li></ul><p><strong>双向链表保证在常数时间内添加和删除节点，哈希表则提供常数时间的数据访问能力</strong>。对于 Get 操作，通过哈希表快速定位到链表中的节点，如果存在则将其移动到链表头部，更新为最近使用。对于插入 Insert 操作，如果数据已存在，更新数据并移动到链表头部；如果数据不存在，则在链表头部插入新节点，并在哈希表中添加映射，如果超出容量则移除链表尾部节点，并从哈希表中删除相应的映射。</p><p>上面的实现思路相信每个学过算法的人都知道，Leetcode 上也有 LRU 实现的题目，比如 <a href="https://leetcode.com/problems/lru-cache/">146. LRU 缓存</a>，需要实现的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过想实现一个工业界可用的高性能 LRU 缓存，还是有点难度的。接下来，我们来看看 LevelDB 是如何实现的。</p><h2 id="缓存设计：依赖倒置"><a href="#缓存设计：依赖倒置" class="headerlink" title="缓存设计：依赖倒置"></a>缓存设计：依赖倒置</h2><p>在开始看 LevelDB 的 LRU Cache 实现之前，先看下 LevelDB 中如何使用这里的缓存。比如在 <a href="https://github.com/google/leveldb/blob/main/db/table_cache.cc">db&#x2F;table_cache.cc</a> 中，为了缓存 SST table 的元数据信息，TableCache 类定义了一个 Cache 类型的成员变量，然后通过该成员来对缓存进行各种操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cache* <span class="title">cache_</span><span class="params">(NewLRUCache(entries))</span></span>;</span><br><span class="line"></span><br><span class="line">*handle = cache_-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">*handle = cache_-&gt;<span class="built_in">Insert</span>(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">cache_-&gt;<span class="built_in">Release</span>(handle);</span><br><span class="line">cache_-&gt;<span class="built_in">Erase</span>(<span class="built_in">Slice</span>(buf, <span class="built_in">sizeof</span>(buf)));</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里 Cache 是一个抽象类，定义了缓存操作的各种接口，具体定义在 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/cache.h">include&#x2F;leveldb&#x2F;cache.h</a> 中。它定义了缓存应该具有的基本操作，如 Insert、Lookup、Release、Erase 等。它还定义了 Cache::Handle 这个类型，作为缓存条目。用户代码只与这个抽象接口交互，不需要知道具体实现。</p><p>然后有个 LRUCache 类，是具体的缓存实现类，它实现了一个完整的 LRU 缓存。这个类不直接对外暴露，也不直接继承 Cache。然后还有个 ShardedLRUCache 类，它继承 Cache 类实现了缓存各种接口。它内部包含 16 个 LRUCache “分片”（shards），每个分片负责缓存一部分数据。</p><p>这样的设计允许调用方在<strong>不修改使用缓存部分的代码的情况下，轻松替换不同的缓存实现</strong>。哈哈，这不就是八股文经常说的，<strong>面向对象编程 SOLID 中的依赖倒置</strong>嘛，应用层依赖于抽象接口(Cache)而不是具体实现(LRUCache)。这样可以降低代码耦合度，提高系统的可扩展性和可维护性。</p><p>使用 Cache 的时候，通过这里的工厂函数来创建具体的缓存实现 <a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L339">ShardedLRUCache</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cache* <span class="title">NewLRUCache</span><span class="params">(<span class="type">size_t</span> capacity)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ShardedLRUCache</span>(capacity); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以随时增加新的缓存实现</span></span><br><span class="line"><span class="comment">// Cache* NewClockCache(size_t capacity);</span></span><br></pre></td></tr></table></figure><p>LRUCache 是缓存的核心部分，不过现在我们先不管怎么实现 LRUCache，先来看看<strong>缓存项 Hanle 的设计</strong>。</p><h2 id="LRUHandle-类的实现"><a href="#LRUHandle-类的实现" class="headerlink" title="LRUHandle 类的实现"></a>LRUHandle 类的实现</h2><p>在 LevelDB 中，缓存的数据项是一个 LRUHandle 类，定义在 <a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L43">util&#x2F;cache.cc</a> 中。这里的注释也说明了，LRUHandle 是一个支持堆分配内存的变长结构体，它会被保存在一个双向链表中，按访问时间排序。我们来看看这个结构体的成员有哪些吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LRUHandle</span> &#123;</span><br><span class="line">  <span class="type">void</span>* value;</span><br><span class="line">  <span class="built_in">void</span> (*deleter)(<span class="type">const</span> Slice&amp;, <span class="type">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;</span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="type">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="type">size_t</span> key_length;</span><br><span class="line">  <span class="type">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="type">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present.</span></span><br><span class="line">  <span class="type">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="type">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还稍微有点复杂，每个字段都还挺重要的，我们一个个来看吧。</p><ul><li>value：存储缓存的实际 value 值，这里是一个 void* 的指针，说明缓存这层不关心具体值的结构，只用知道对象的地址就好；</li><li>deleter：一个函数指针，指向用于删除缓存值的回调函数，当缓存项被移除时，用它来释放缓存值的内存空间；</li><li>next_hash：LRU 缓存实现需要用到哈希表。这里 LevelDB 自己实现了一个高性能的哈希表，在 <a href="/2024/12/25/leveldb_source_hashtable/">LevelDB 源码阅读：如何设计一个高性能哈希表</a> 中，我们介绍了 LevelDB 中哈希表的实现细节，里面有介绍过 LRUHandle 的 next_hash 字段就是用来解决哈希表的冲突的。</li><li>prev&#x2F;next：双向链表的前一个&#x2F;下一个指针，用来维持双向链表，方便快速从双向链表中插入或者删除节点；</li><li>charge：表示该缓存项占用的成本（通常是内存大小），用于计算总缓存使用量，判断是否需要淘汰；</li><li>key_length：键的长度，用于构造 Slice 对象表示键；</li><li>in_cache：标记该项是否在缓存中，如果为 true，表示缓存拥有对该项的引用；</li><li>refs：引用计数，包括缓存本身的引用（如果在缓存中）和使用方的引用，当计数为0时，可以释放该项；</li><li>hash：键的哈希值，用于快速查找和分片；这里同一个 key 也把 hash 值保存下来，避免重复计算；</li><li>key_data：柔性数组成员，存储键的实际数据，使用 malloc 分配足够空间来存储整个键。柔性数组我们在 <a href="/2024/08/13/leveldb_source_unstand_c++/">LevelDB 源码阅读：理解其中的 C++ 高级技巧</a> 中也有介绍过，这里就不展开了。</li></ul><p>这里 LRUHandle 的设计允许缓存高效地管理数据项，跟踪缓存项的引用，并实现 LRU 淘汰策略。特别是 in_cache 和 refs 字段的结合使用，使得我们可以区分”<strong>被缓存但未被客户端引用</strong>“和”<strong>被客户端引用</strong>“的项，从而用两个链表来支持高效淘汰缓存。</p><p>下面我们详细看看 LRUCache 类的实现细节，就更容易理解上面各个字段的用途了。</p><h2 id="LRUCache-类的实现细节"><a href="#LRUCache-类的实现细节" class="headerlink" title="LRUCache 类的实现细节"></a>LRUCache 类的实现细节</h2><p>前面看完了缓存的数据项的设计，接着可以来看看这里 LevelDB LRUCache 的具体实现细节了。核心的缓存逻辑实现在 <a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L151">util&#x2F;cache.cc</a> 的 LRUCache 类中。该类包含了缓存的核心逻辑，如插入、查找、删除、淘汰等操作。</p><p>这里注释(LevelDB 的注释感觉都值得好好品读)中提到，用了两个双向链表来维护缓存项，这又是为什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The cache keeps two linked lists of items in the cache.  All items in the</span></span><br><span class="line"><span class="comment">// cache are in one list or the other, and never both.  Items still referenced</span></span><br><span class="line"><span class="comment">// by clients but erased from the cache are in neither list.  The lists are:</span></span><br><span class="line"><span class="comment">// - in-use:  contains the items currently referenced by clients, in no</span></span><br><span class="line"><span class="comment">//   particular order.  (This list is used for invariant checking.  If we</span></span><br><span class="line"><span class="comment">//   removed the check, elements that would otherwise be on this list could be</span></span><br><span class="line"><span class="comment">//   left as disconnected singleton lists.)</span></span><br><span class="line"><span class="comment">// - LRU:  contains the items not currently referenced by clients, in LRU order</span></span><br><span class="line"><span class="comment">// Elements are moved between these lists by the Ref() and Unref() methods,</span></span><br><span class="line"><span class="comment">// when they detect an element in the cache acquiring or losing its only</span></span><br><span class="line"><span class="comment">// external reference.</span></span><br></pre></td></tr></table></figure><h3 id="为什么用两个双向链表？"><a href="#为什么用两个双向链表？" class="headerlink" title="为什么用两个双向链表？"></a>为什么用两个双向链表？</h3><p>我们前面也提到，一般的 LRU Cache 实现中用一个双向链表。每次使用一个缓存项时，会将其移动到链表的头部，这样链表的尾部就是最近最少使用的缓存项。淘汰的时候，直接移除链表尾部的节点即可。比如开始提到的 Leetcode 中的题目就可以这样实现来解决，实现中每个缓存项就是一个 int，取的时候直接复制出来就好。<strong>如果要缓存的项是简单的值类型，读的时候直接复制值，不需要引用，那单链表的实现足够了</strong>。</p><p>但在 LevelDB 中，缓存的数据项是 LRUHandle 对象，它是一个动态分配内存的变长结构体。在使用的时候，为了高并发和性能考虑，不能通过简单的值复制，而要通过引用计数来管理缓存项。如果还是简单的使用单链表的话，我们考虑下这样的场景。</p><p>我们依次访问 A, C, D 项，最后访问了 B, B 项被客户端引用(refs&#x3D;1)，位于链表头部，如下图中的开始状态。一段时间内，A、C、D都被访问了，但 B 没有被访问。根据 LRU 规则，A、C、D被移到链表头部。<strong>B 虽然仍被引用，但因为长时间未被访问，相对位置逐渐后移</strong>。A 和 D 被访问后，很快使用完，这时候没有引用了。当需要淘汰时，从尾部开始，会发现B项(refs&#x3D;1)不能淘汰，需要跳过继续往前遍历检查其他项。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250611_leveldb_source_lru_cache.webp" alt="LRUCache 中节点双向链表的状态"></p><p>也就是说在这种引用场景下，淘汰节点的时候，如果链表尾部的节点正在被外部引用（refs &gt; 1），则不能淘汰它。这时候需要<strong>遍历链表寻找可淘汰的节点，效率较低</strong>。在最坏情况下，如果所有节点都被引用，可能需要遍历整个链表却无法淘汰任何节点。</p><p>为了解决这个问题，在 LRUCache 实现中，用了两个双向链表。一个是<strong>in_use_</strong>，用来存储被引用的缓存项。另一个是<strong>lru_</strong>，用来存储未被引用的缓存项。每个缓存项只能在其中的一个链表中，不能同时在两个链表中。但是可以根据当前是否被引用，在两个链表中互相移动。这样在需要淘汰节点的时候，就可以直接从 lru_ 链表中淘汰，而不用遍历 in_use_ 链表。</p><p>双链表介绍就先到这里，后面可以结合 LRUCache 的核心实现继续理解双链表具体怎么实现。</p><h3 id="缓存插入，删除，查找节点"><a href="#缓存插入，删除，查找节点" class="headerlink" title="缓存插入，删除，查找节点"></a>缓存插入，删除，查找节点</h3><p>先来看插入节点，实现在 <a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L267">util&#x2F;cache.cc</a> 中。简单说，这里先创建 LRUHandle 对象，然后把它放到 in_use_ 双向链表中，同时更新哈希表。如果插入节点后，缓存容量达到上限，则需要淘汰节点。但是实现中，还是有不少细节部分，LevelDB 的代码也确实精简。</p><p>可以看下这里的入参，key 和 value 是客户端传入的，hash 是 key 的哈希值，charge 是缓存项占用的成本，deleter 是删除缓存项的回调函数。这里因为 LRUHandle 最后成员是柔性数组，所以我们先手动计算 LRUHandle 对象的大小，然后分配内存，之后开始初始化各种成员。这里 refs 初始化为 1，因为返回了一个 Handle 指针对象。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash, <span class="type">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">void</span> (*deleter)(<span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  LRUHandle* e =</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;deleter = deleter;</span><br><span class="line">  e-&gt;charge = charge;</span><br><span class="line">  e-&gt;key_length = key.<span class="built_in">size</span>();</span><br><span class="line">  e-&gt;hash = hash;</span><br><span class="line">  e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure><p>接着这里也比较有意思，LevelDB 中的 LRUCache 实现，支持缓存容量设为 0，这时候就不缓存任何数据。要缓存的时候，更新 in_cache 为 true，增加 refs 计数，因为把 Handle 对象放到了 in_use_ 链表中。接着当然还要把 Handle 插入到哈希表中，注意这里有个 FinishErase 调用，值得好好聊聊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  e-&gt;refs++;  <span class="comment">// for the cache&#x27;s reference.</span></span><br><span class="line">  e-&gt;in_cache = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">  usage_ += charge;</span><br><span class="line">  <span class="built_in">FinishErase</span>(table_.<span class="built_in">Insert</span>(e));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// don&#x27;t cache. (capacity_==0 is supported and turns off caching.)</span></span><br><span class="line">  <span class="comment">// next is read by key() in an assert, so it must be initialized</span></span><br><span class="line">  e-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们前面将哈希表实现的时候，这里插入哈希表，如果已经有同样的 key，则返回旧的 Handle 对象。这里 FinishErase 函数就是用来清理这个旧的 Handle 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If e != nullptr, finish removing *e from the cache; it has already been</span></span><br><span class="line"><span class="comment">// removed from the hash table.  Return whether e != nullptr.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUCache::FinishErase</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    usage_ -= e-&gt;charge;</span><br><span class="line">    <span class="built_in">Unref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清理操作有几个吧，首先从 in_use_ 或者 lru_ 链表中移除，这里其实不确定旧的 Handle 对象具体在哪个链表中，不过没关系，<strong>LRU_Remove 不用知道在哪个链表也能处理</strong>。LRU_Remove 函数实现很简单，也就两行代码，大家不理解的话可以画个图来理解下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUCache::LRU_Remove</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着更新 in_cache 为 false，表示已经不在缓存中了。后面还要更新缓存容量，减少 usage_。最后调用 Unref 减少这个 Handle 对象的引用计数，这时候这个 Handle 对象可能在其他地方还有引用。等到所有引用都释放了，这时候才会真正清理这个 Handle 对象。<a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L226">Unref 函数</a> 其实也有点意思，我把代码也贴出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUCache::Unref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(e-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">  e-&gt;refs--;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">0</span>) &#123;  <span class="comment">// Deallocate.</span></span><br><span class="line">    <span class="built_in">assert</span>(!e-&gt;in_cache);</span><br><span class="line">    (*e-&gt;deleter)(e-&gt;<span class="built_in">key</span>(), e-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(e);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;in_cache &amp;&amp; e-&gt;refs == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// No longer in use; move to lru_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;lru_, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先减少计数，如果计数为 0，则表示<strong>完全没有外部引用，这时候可以大胆释放内存</strong>。释放也分两部分，先用回调函数 deleter 来清理 value 部分的内存空间。接着用 free 来释放 LRUHandle 指针的内存空间。如果计数为 1 并且还在缓存中，表示只有来自缓存自身的引用，这时候<strong>需要把 Handle 对象从 in_use_ 链表中移除，并放到 lru_ 链表中</strong>。如果后面要淘汰节点，这个节点在 lru_ 链表中，就可以直接淘汰了。</p><p>接下来就是插入节点操作的最后一步了，判断缓存是否还有剩余空间，没有的话，要开始淘汰节点了。这里只要空间还是不够，然后就会从 lru_ 链表中取出队首节点，然后从<strong>哈希表中移除，接着调用 FinishErase 清理节点</strong>。这里判断双向链表是否为空也比较有意思，用到了哑元节点，后面再介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;</span><br><span class="line">  LRUHandle* old = lru_.next;</span><br><span class="line">  <span class="built_in">assert</span>(old-&gt;refs == <span class="number">1</span>);</span><br><span class="line">  <span class="type">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(old-&gt;<span class="built_in">key</span>(), old-&gt;hash));</span><br><span class="line">  <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">    <span class="built_in">assert</span>(erased);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个插入节点函数，包括这里的淘汰逻辑，甚至是整个 LevelDB 代码中，都有大量的 assert 断言，用来做一些检查，保证有问题进程立马挂掉，避免错误传播。</p><p>看完插入节点，其实删除节点就不用看了，代码实现很简单，从哈希表中移除节点，然后调用 FinishErase 清理节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUCache::Erase</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(key, hash));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找节点也相对简单些，直接从哈希表中查找，如果找到，则增加引用计数，并返回 Handle 对象。这里其实和插入一样，只要返回了 Handle 对象，就会增加引用计数。所以如果外面如果没有用到的话，要记得调用 Release 方法手动释放引用，不然内存就容易泄露了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Lookup</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  LRUHandle* e = table_.<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">Ref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUCache::Release</span><span class="params">(Cache::Handle* handle)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">Unref</span>(<span class="built_in">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，这里的 Cache 还实现了 Prune 接口，用来主动清理缓存。方法和插入里面的清理逻辑类似，不过这里会把 lru_ 链表中所有节点都清理掉。这个清理在 LevelDB 中也没地方用到过。</p><h3 id="双向链表的操作"><a href="#双向链表的操作" class="headerlink" title="双向链表的操作"></a>双向链表的操作</h3><p>我们再补充讨论下这里双向链表相关的操作吧。前面我们其实已经知道了分了两个链表，一个 lru_ 链表，一个 in_use_ 链表。这里结合注释看更清晰：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dummy head of LRU list.</span></span><br><span class="line"><span class="comment">// lru.prev is newest entry, lru.next is oldest entry.</span></span><br><span class="line"><span class="comment">// Entries have refs==1 and in_cache==true.</span></span><br><span class="line"><span class="function">LRUHandle lru_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy head of in-use list.</span></span><br><span class="line"><span class="comment">// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.</span></span><br><span class="line"><span class="function">LRUHandle in_use_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br></pre></td></tr></table></figure><p>lru_ 成员是链表的哑元节点，next 成员指向 lru_ 链表中最老的缓存项，prev 成员指向 lru_ 链表中最新的缓存项。在 LRUCache 的构造函数中，lru_ 的 next 和 prev 都指向它自己，表示链表为空。还记得前面插入节点的时候，怎么判定还有可以淘汰的节点的吧，就是用 <code>lru_.next != &amp;lru_</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LRUCache::<span class="built_in">LRUCache</span>() : <span class="built_in">capacity_</span>(<span class="number">0</span>), <span class="built_in">usage_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Make empty circular linked lists.</span></span><br><span class="line">  lru_.next = &amp;lru_;</span><br><span class="line">  lru_.prev = &amp;lru_;</span><br><span class="line">  in_use_.next = &amp;in_use_;</span><br><span class="line">  in_use_.prev = &amp;in_use_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>哑元（dummy node）</code>在很多数据结构的实现中被用作简化边界条件处理的技巧。在 LRU 缓存的上下文中，哑元主要是用来作为链表的头部，这样链表的头部始终存在，即使链表为空时也是如此。这种方法可以简化插入和删除操作，因为在插入和删除操作时<strong>不需要对空链表做特殊处理</strong>。</p><p>例如，当向链表中添加一个新的元素时，可以直接在哑元和当前的第一个元素之间插入它，而不需要检查链表是否为空。同样，当从链表中删除元素时，你不需要担心删除最后一个元素后如何更新链表头部的问题，因为哑元始终在那里。</p><p>删除链表中节点 LRU_Remove 我们前面看过，两行代码就行了。往链表添加节点的实现，我整理了一张图，配合代码就好理解了：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250613_leveldb_source_lru_cache_linkedlist.webp" alt="LRUCache 双向链表操作"></p><p>这里 e 是新插入的节点，list 是链表的哑元节点。list 的 pre 和 next 我这里用圆形，表示它可以是自己，比如初始空链表的时候。这里插入是在哑元的前面，所以 list-&gt;prev 永远是链表最新的节点，list-&gt;next 永远是链表最老的节点。这种链表操作，最好画个图，就一目了然了。</p><h3 id="reinterpret-cast-转换"><a href="#reinterpret-cast-转换" class="headerlink" title="reinterpret_cast 转换"></a>reinterpret_cast 转换</h3><p>最后再补充说下，上面代码中有不少地方用到了 reinterpret_cast 来在 LRUHandle* 和 Cache::Handle* 之间转换类型。<strong>reinterpret_cast 将一种类型的指针强制转换为另一种类型的指针，而不进行任何类型检查</strong>。它不进行任何底层数据的调整，只是告诉编译器：”请把这个内存地址当作另一种类型来看待”。其实这种操作比较危险，一般不推荐这样用。</p><p>但 LevelDB 这样做其实是为了将接口和实现分析。这里将具体的内部数据结构 LRUHandle* 以一个抽象、不透明的句柄 Cache::Handle* 形式暴露给外部用户，同时又能在内部将这个不透明的句柄转换回具体的数据结构进行操作。</p><p><strong>在这种特定的、受控的设计模式下，它是完全安全的</strong>。因为只有 LRUCache 内部代码可以创建 LRUHandle。任何返回给外部的 Cache::Handle* 总是指向一个合法的 LRUHandle 对象。任何传递给 LRUCache 的 Cache::Handle* 必须是之前由同一个 LRUCache 实例返回的。</p><p>只要遵守这些约定，reinterpret_cast 就只是在指针的”视图”之间切换，指针本身始终指向一个有效的、类型正确的对象。如果用户试图伪造一个 Cache::Handle* 或者将一个不相关的指针传进来，程序就会发生未定义行为，但这属于 API 的误用。</p><h2 id="ShardedLRUCache-分片实现"><a href="#ShardedLRUCache-分片实现" class="headerlink" title="ShardedLRUCache 分片实现"></a>ShardedLRUCache 分片实现</h2><p>前面 LRUCache 的实现中，插入缓存、查找缓存、删除缓存操作都必须通过一个互斥锁来保护。在多线程环境下，如果只有一个大的缓存，<strong>这个锁就会成为一个全局瓶颈</strong>。当多个线程同时访问缓存时，只有一个线程能获得锁，其他线程都必须等待，这会严重影响并发性能。</p><p>为了提高性能，ShardedLRUCache 将缓存分成多个分片（shard_ 数组），每个分片都有自己独立的锁。当一个请求到来时，它会根据 key 的哈希值被路由到特定的分片。这样，不同线程访问不同分片时就可以并行进行，因为它们获取的是不同的锁，从而减少了锁的竞争，提高了整体的吞吐量。画个图可能更清晰些，mermaid 代码在<a href="/downloads/mermaid_leveldb_lru_cache_shard.txt">这里</a>。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250613_leveldb_source_lru_cache_shard.webp" alt="ShardedLRUCache 分片实现优点对比"></p><p>那么需要分多少片呢？LevelDB 这里硬编码了一个 $ kNumShards &#x3D; 1 &lt;&lt; kNumShardBits $，计算出来是 16，算是一个经验选择吧。如果分片数量太少，比如2、4个，在核心数很多的服务器上，锁竞争依然可能很激烈。分片太多的话，每个分片的容量就会很小。这可能导致一个”热”分片频繁淘汰数据，而另一个”冷”分片有很多空闲空间的情况，从而降低了整个缓存的命中率。</p><p>选择 16 的话，对于典型的 8 核或 16 核服务器，已经能提供足够好的并发度，同时又不会带来过大的额外开销。同时选择 2 的幂次方，还能通过位运算 $ hash &gt;&gt; (32 - kNumShardBits)$ 快速计算分片索引。</p><p>加入分片后，包装了下原始的 LRUCache 类，构造的时候需要指定分片数，每个分片容量等，<a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L352">实现</a>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">ShardedLRUCache</span><span class="params">(<span class="type">size_t</span> capacity)</span> : last_id_(<span class="number">0</span>) &#123;</span></span><br><span class="line">   <span class="type">const</span> <span class="type">size_t</span> per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">     shard_[s].<span class="built_in">SetCapacity</span>(per_shard);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后其他相关缓存操作，比如插入、查找、删除等，都是通过 Shard 函数来决定操作哪个分片。这里以插入为例，<a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L359">实现</a>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Handle* <span class="title">Insert</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">void</span>* value, <span class="type">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">void</span> (*deleter)(<span class="type">const</span> Slice&amp; key, <span class="type">void</span>* value))</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> hash = <span class="built_in">HashSlice</span>(key);</span><br><span class="line">  <span class="keyword">return</span> shard_[<span class="built_in">Shard</span>(hash)].<span class="built_in">Insert</span>(key, hash, value, charge, deleter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求 Hash 和计算分片的 Shard 函数没什么难点，这里就忽略了。这里也提下，ShardLRUCache 这里还要继承 Cache 抽象类，实现 Cache 中的各种接口。这样才能被其他调用 Cache 接口的地方使用。</p><p>最后这里还有一个小细节，也值得说下，那就是 Cache 接口还有个 NewId 函数。在其他的 LRU 缓存实现中，没见过有支持 Cache 生成一个 Id。<strong>LevelDB 为啥这么做呢？</strong></p><h3 id="Cache-的-Id-生成"><a href="#Cache-的-Id-生成" class="headerlink" title="Cache 的 Id 生成"></a>Cache 的 Id 生成</h3><p>LevelDB 其实提供了注释，但是只看注释似乎也不好明白，我们结合使用场景来分析下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a new numeric id.  May be used by multiple clients who are</span></span><br><span class="line"><span class="comment">// sharing the same cache to partition the key space.  Typically the</span></span><br><span class="line"><span class="comment">// client will allocate a new id at startup and prepend the id to</span></span><br><span class="line"><span class="comment">// its cache keys.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里补充些背景，我们在打开 LevelDB 数据库时，可以创建一个 Cache 对象，并传入 options.block_cache，用来缓存 SSTTable 文件中的数据块和过滤块。当然如果不传的话，LevelDB 默认也会创建一个 8 MB 的 SharedLRUCache 对象。这里 <strong>Cache 对象是全局共享的，数据库中所有的 Table 对象都会使用这同一个 BlockCache 实例来缓存它们的数据块</strong>。</p><p>在 <a href="https://github.com/google/leveldb/blob/main/table/table.cc#L72">table&#x2F;table.cc</a> 的 Table::Open 中，我们看到每次打开 SSTTable 文件的时候，就会用 NewId 生成一个 cache_id。这里底层用互斥锁保证，每次生成的 Id 是全局递增的。后面我们要读取 SSTTable 文件中偏移量为 offset 的数据块 block 时，会用 <code>&lt;cache_id, offset&gt;</code> 作为缓存的 key 来进行读写。这样不同 SSTTable 文件的 cache_id 不同，即使他们的 offset 一样，这里缓存 key 也不同，不会冲突。</p><p>说白了，SharedLRUCache 提供全局递增的 Id 主要是用来区分不同 SSTTable 文件，免得每个文件还要自己维护一个唯一 Id 来做缓存的 key。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，LevelDB 的 LRU Cache 分析完了，我们可以看到一个工业级高性能缓存的设计思路和实现细节。最后总结下几个关键点：</p><ol><li><strong>接口与实现分离</strong>：通过抽象的 Cache 接口，将缓存的使用方与具体实现解耦，体现了面向对象设计中的依赖倒置原则。用户代码只需要跟 Cache 接口打交道，不用关心具体实现。</li><li><strong>精心设计的缓存项</strong>：LRUHandle 结构体包含了引用计数、缓存标志等元数据，通过柔性数组成员存储变长的 key，减少内存分配次数，提高性能。</li><li><strong>双链表优化</strong>：通过两个双向链表（in_use_ 和 lru_）分别管理”正在使用”和”可以淘汰”的缓存项，避免了在淘汰时遍历整个链表，提高了淘汰效率。</li><li><strong>哑元节点技巧</strong>：使用哑元节点简化了链表操作，不需要处理空链表的特殊情况，代码更简洁。</li><li><strong>分片减少锁竞争</strong>：ShardedLRUCache 将缓存分成多个分片，每个分片有独立的锁，大幅提高了多线程环境下的并发性能。</li><li><strong>引用计数管理内存</strong>：通过精确的引用计数，确保缓存项在仍被外部引用时不会被释放，同时在不再需要时及时回收内存。</li><li><strong>断言保证正确性</strong>：大量使用断言来检查代码的前置条件和不变量，确保错误能够及早被发现。</li></ol><p>这些设计思路和实现技巧都值得我们在自己的项目中借鉴。特别是在需要高并发、高性能的场景中，LevelDB 的这些优化手段可以帮助我们设计出更高效的缓存系统。</p>]]></content>
    
    
    <summary type="html">本文深入剖析LevelDB中高性能LRU缓存的实现细节，包括缓存接口设计、LRUHandle数据结构、双向链表优化和分片机制。通过分析其巧妙的引用计数管理、哑元节点技巧和锁分片减少竞争等核心设计，展示了工业级缓存系统的优化思路。文章结合代码和图解，帮助读者理解LevelDB如何实现高并发、高性能的缓存，以及这些设计技巧如何应用到自己的项目中。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：MemTable 内存表的实现细节</title>
    <link href="https://selfboot.cn/2025/06/11/leveldb_source_memtable/"/>
    <id>https://selfboot.cn/2025/06/11/leveldb_source_memtable/</id>
    <published>2025-06-11T19:47:42.000Z</published>
    <updated>2025-07-15T13:42:45.601Z</updated>
    
    <content type="html"><![CDATA[<p>在 LevelDB 中，所有的写操作首先都会被记录到一个 <a href="https://selfboot.cn/2024/08/14/leveldb_source_wal_log/">Write-Ahead Log（WAL，预写日志）</a>中，以确保持久性。接着数据会被存储在 MemTable 中，MemTable 的主要作用是<strong>在内存中有序存储最近写入的数据</strong>，到达一定条件后批量落磁盘。</p><p>LevelDB 在内存中维护两种 MemTable，一个是可写的，接受新的写入请求。当达到一定的大小阈值后，会被转换为一个不可变的 Immutable MemTable，接着会触发一个后台过程将其写入磁盘形成 SSTable。这个过程中，会创建一个新的 MemTable 来接受新的写入操作。这样可以保证写入操作的连续性，不受到影响。</p><p>在读取数据时，LevelDB 首先查询 MemTable。如果在 MemTable 中找不到，然后会依次查询不可变的 Immutable MemTable，最后是磁盘上的 SSTable 文件。在 LevelDB 的实现中，不管是 MemTable 还是 Immutable MemTable，内部其实都是用 class MemTable 来实现的。这篇文章我们来看看 memtable 的实现细节。</p><span id="more"></span><h2 id="Memtable-使用方法"><a href="#Memtable-使用方法" class="headerlink" title="Memtable 使用方法"></a>Memtable 使用方法</h2><p>先来看看 LevelDB 中哪里用到了 MemTable 类。在库的核心 DB <a href="https://github.com/google/leveldb/blob/main/db/db_impl.h#L177">实现类 DBImpl</a> 中，可以看到有两个成员指针，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBImpl</span> : <span class="keyword">public</span> DB &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DBImpl</span>(<span class="type">const</span> Options&amp; options, <span class="type">const</span> std::string&amp; dbname);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  MemTable* mem_;</span><br><span class="line">  <span class="function">MemTable* imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// Memtable being compacted</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mem_ 是可写的 memtable，imm_ 是不可变的 memtable。这两个是数据库实例中唯一的两个 memtable 对象，用来存储最近写入的数据，在读取和写入键值的时候，都会用到这两个 memtable。</p><p>我们先来看写入过程，我之前写过<a href="https://selfboot.cn/2025/01/24/leveldb_source_writedb/">LevelDB 源码阅读：写入键值的工程实现和优化细节</a>，里面有写入键值的全部过程。写入过程中，写入 WAL 日志成功后，会调用 <a href="https://github.com/google/leveldb/blob/main/db/write_batch.cc#L121">db&#x2F;write_batch.cc</a> 中的 MemTableInserter 类来写入 memtable，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/write_batch.cc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemTableInserter</span> : <span class="keyword">public</span> WriteBatch::Handler &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SequenceNumber sequence_;</span><br><span class="line">  MemTable* mem_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    mem_-&gt;<span class="built_in">Add</span>(sequence_, kTypeValue, key, value);</span><br><span class="line">    sequence_++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里调用了 Add 接口往 memtable 中写入键值对，sequence_ 是写入的序列号，kTypeValue 是写入的类型，key 和 value 是用户传入的键值对。 </p><p>除了写入过程，在读取键值对的时候，也会需要 Memtable 类。具体在 <a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1147">db&#x2F;db_impl.cc</a> 中 DBImpl 类的 Get 方法中，会调用 memtable 的 Get 方法来查询键值对。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::string* value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里会先创建本地指针 mem 和 imm 来引用成员变量 mem_ 和 imm_，之后用本地指针来进行读取。这里有个问题是，<strong><span style="color:red">为什么不直接使用成员变量 mem_ 和 imm_ 来读取呢</span></strong>？这个问题留到<a href="#%E8%A7%A3%E7%AD%94%E7%96%91%E9%97%AE">后面解读疑问</a>我们再回答。</p><p>好了，至此我们已经看到了 Memtable 的主要使用方法了，那它们内部是怎么实现的呢，我们接着看吧。</p><h2 id="Memtable-实现"><a href="#Memtable-实现" class="headerlink" title="Memtable 实现"></a>Memtable 实现</h2><p>在开始讨论 MemTable 对外方法的实现之前，先要知道 Memtable 中的数据其实是存储在跳表中的。跳表提供了平衡树的大部分优点（如有序性、插入和查找的对数时间复杂性），但是实现起来更为简单。关于跳表的详细实现，可以参考<a href="https://selfboot.cn/2024/09/09/leveldb_source_skiplist/">LevelDB 源码阅读：跳表的原理、实现以及可视化</a>。</p><p>MemTable 类内部来声明了一个跳表对象 table_ 成员变量，跳表是个模板类，初始化需要提供 key 和 Comparator 比较器。这里 memtable 中跳表的 key 是 <code>const char*</code> 类型，比较器是 KeyComparator 类型。KeyComparator 就是这样一个自定义的比较器，用来给跳表中键值进行排序。</p><p>KeyComparator 包含了一个 InternalKeyComparator 类型的成员变量 comparator，用来比较 internal key 的大小。KeyComparator 比较器的 <code>operator()</code> 重载了函数调用操作符，先从 const char* 中解码出 internal key，然后然后调用 InternalKeyComparator 的 Compare 方法来比较 internal key 的大小。具体实现在 <a href="https://github.com/google/leveldb/blob/main/db/memtable.cc#L28">db&#x2F;memtable.cc</a> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> MemTable::KeyComparator::<span class="built_in">operator</span>()(<span class="type">const</span> <span class="type">char</span>* aptr,</span><br><span class="line">                                        <span class="type">const</span> <span class="type">char</span>* bptr) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="comment">// Internal keys are encoded as length-prefixed strings.</span></span><br><span class="line">  Slice a = <span class="built_in">GetLengthPrefixedSlice</span>(aptr);</span><br><span class="line">  Slice b = <span class="built_in">GetLengthPrefixedSlice</span>(bptr);</span><br><span class="line">  <span class="keyword">return</span> comparator.<span class="built_in">Compare</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再补充说下这里 levelDB 的 <strong>internal key</strong> 其实是拼接了用户传入的 key 和内部的 sequence number，然后再加上一个类型标识。这样可以保证相同 key 的不同版本是有序的，从而实现 MVCC 并发读写。存储到 Memtable 的时候又在 internal key 前面编码了长度信息，叫 <code>memtable key</code>，这样后面读取的时候，我们就能从 const char* 的 memtable key 中根据长度信息解出 internal key 来。这部分我在另一篇文章：<a href="https://selfboot.cn/2025/06/10/leveldb_mvcc_intro/">LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)</a> 有详细分析，感兴趣的可以看看。</p><p>Memtable 用跳表做存储，然后对外主要支持 Add 和 Get 方法，下面来看看这两个函数的实现细节。</p><h3 id="Add-添加键值对"><a href="#Add-添加键值对" class="headerlink" title="Add 添加键值对"></a>Add 添加键值对</h3><p>Add 方法用于往 MemTable 中添加一个键值对，其中 key 和 value 是用户传入的键值对，SequenceNumber 是写入时的序列号，ValueType 是写入的类型，有两种类型：kTypeValue 和 kTypeDeletion。kTypeValue 表示插入操作，kTypeDeletion 表示删除操作。LevelDB 中的删除操作，内部其实是插入一个标记为删除的键值对。</p><p>Add 实现在 <a href="https://github.com/google/leveldb/blob/main/db/memtable.cc#L76">db&#x2F;memtable.cc</a> 中，函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  tag          : uint64((sequence &lt;&lt; 8) | type)</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>这里的注释十分清楚，Memtable 中存储了格式化后的键值对，先是 internal key 的长度，然后是 internal key 字节串(就是下面的 tag 部分，包含 User Key + Sequence Number + Value Type)，接着是 value 的长度，然后是 value 字节串。整体由 5 部分组成，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-----------+----------------------+----------+--------+</span><br><span class="line">| Key Size  | User Key  |          tag         | Val Size | Value  |</span><br><span class="line">+-----------+-----------+----------------------+----------+--------+</span><br><span class="line">| varint32  | key bytes | <span class="number">64</span> 位，后 <span class="number">8</span> 位为 type  | varint32 | value  |</span><br></pre></td></tr></table></figure><p>这里第一部分的 keysize 是用 Varint 编码的用户 key 长度加上 8 字节 tag，tag 是序列号和 value type 的组合，高 56 位存储序列号，低 8 位存储 value type。其他部分比较简单，这里不再赘述。</p><p>插入过程会先计算出需要分配的内存大小，然后分配内存，接着写入各个部分的值，最后插入到跳表中。具体写入过程代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/memtable.cc</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">size_t</span> key_size = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> val_size = value.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> encoded_len = <span class="built_in">VarintLength</span>(internal_key_size) +</span><br><span class="line">                             internal_key_size + <span class="built_in">VarintLength</span>(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">  <span class="type">char</span>* buf = arena_.<span class="built_in">Allocate</span>(encoded_len);</span><br><span class="line">  <span class="type">char</span>* p = <span class="built_in">EncodeVarint32</span>(buf, internal_key_size);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(p, key.<span class="built_in">data</span>(), key_size);</span><br><span class="line">  p += key_size;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>;</span><br><span class="line">  p = <span class="built_in">EncodeVarint32</span>(p, val_size);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(p, value.<span class="built_in">data</span>(), val_size);</span><br><span class="line">  <span class="built_in">assert</span>(p + val_size == buf + encoded_len);</span><br><span class="line">  table_.<span class="built_in">Insert</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>EncodeVarint32</code> 和 <code>EncodeFixed64</code> 是一些编码函数，用来将整数编码到字节流中。具体可以参考<a href="https://selfboot.cn/2024/08/29/leveldb_source_utils/">LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码</a>。接下来看看查询键的实现。</p><h3 id="Get-查询键值"><a href="#Get-查询键值" class="headerlink" title="Get 查询键值"></a>Get 查询键值</h3><p>查询方法的定义也比较简单，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line"><span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line"><span class="comment">// in *status and return true.</span></span><br><span class="line"><span class="comment">// Else, return false.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(<span class="type">const</span> LookupKey&amp; key, std::string* value, Status* s)</span></span>;</span><br></pre></td></tr></table></figure><p>这里接口传入的 key 并不是用户输入 key，而是一个 LookupKey 对象，在 <a href="https://github.com/google/leveldb/blob/main/db/dbformat.h#L184">db&#x2F;dbformat.h</a> 中有定义。这是因为 levelDB 中同一个用户键可能有不同版本，查询的时候必须指定快照(也就是序列号)，才能拿到对应的版本。所以这里抽象出了一个 LookupKey 类，可以根据用户输入的 key 和 sequence number 来初始化，然后就可以拿到需要的键值格式。</p><p>具体到查找过程，先用 LookupKey 对象的 memtable_key 方法拿到前面提到的 memtable key，然后调用跳表的 Seek 方法来查找。<a href="https://github.com/google/leveldb/blob/main/db/memtable.cc#L102">db&#x2F;memtable.cc</a> 中 Get 方法的完整实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MemTable::Get</span><span class="params">(<span class="type">const</span> LookupKey&amp; key, std::string* value, Status* s)</span> </span>&#123;</span><br><span class="line">  Slice memkey = key.<span class="built_in">memtable_key</span>();</span><br><span class="line">  <span class="function">Table::Iterator <span class="title">iter</span><span class="params">(&amp;table_)</span></span>;</span><br><span class="line">  iter.<span class="built_in">Seek</span>(memkey.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">if</span> (iter.<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// Check that it belongs to same user key.  We do not check the</span></span><br><span class="line">    <span class="comment">// sequence number since the Seek() call above should have skipped</span></span><br><span class="line">    <span class="comment">// all entries with overly large sequence numbers.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* entry = iter.<span class="built_in">key</span>();</span><br><span class="line">    <span class="type">uint32_t</span> key_length;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* key_ptr = <span class="built_in">GetVarint32Ptr</span>(entry, entry + <span class="number">5</span>, &amp;key_length);</span><br><span class="line">    <span class="keyword">if</span> (comparator_.comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Compare</span>(</span><br><span class="line">            <span class="built_in">Slice</span>(key_ptr, key_length - <span class="number">8</span>), key.<span class="built_in">user_key</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Correct user key</span></span><br><span class="line">      <span class="type">const</span> <span class="type">uint64_t</span> tag = <span class="built_in">DecodeFixed64</span>(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">switch</span> (<span class="built_in">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> kTypeValue: &#123;</span><br><span class="line">          Slice v = <span class="built_in">GetLengthPrefixedSlice</span>(key_ptr + key_length);</span><br><span class="line">          value-&gt;<span class="built_in">assign</span>(v.<span class="built_in">data</span>(), v.<span class="built_in">size</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">          *s = Status::<span class="built_in">NotFound</span>(<span class="built_in">Slice</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，跳表的 Seek 方法将迭代器定位到链表中<strong>第一个大于等于目标内部键的位置</strong>，所以我们还需要额外验证该键的 key 与用户查询的 key 是否一致。这是因为可能存在多个具有相同前缀的键，Seek 可能会返回与查询键具有相同前缀的不同键。例如，查询 “app” 可能返回 “apple” 的记录。</p><p>这里注释还特别说明了下，我们<strong>并没有检查 internal key 中的序列号，这是为什么呢</strong>？前面也提到在跳表中，键的排序是基于内部键比较器 (InternalKeyComparator) 来进行的，这里的排序要看键值和序列号。首先<strong>会使用用户定义的比较函数（默认是字典顺序）比较用户键</strong>，键值小的靠前。如果用户键相同，则比较序列号，<strong>序列号大的记录在跳表中位置更前</strong>。这是因为我们通常希望对于相同的用户键，更新的更改（即具有更大序列号的记录）应该被优先访问。</p><p>比如有两个内部键，Key1 &#x3D; “user_key1”, Seq &#x3D; 1002 和 Key1 &#x3D; “user_key1”, Seq &#x3D; 1001。在跳表中，第一个记录（Seq &#x3D; 1002）将位于第二个记录（Seq &#x3D; 1001）之前，因为1002 &gt; 1001。当用 Seek 查找 &lt;Key &#x3D; user_key1, Seq &#x3D; 1001&gt; 时，自然会跳过 Seq &#x3D; 1002 的记录。</p><p>所以拿到 internal key 后，不用再检查序列号。只用确认用户 key 相等后，再拿到 64 位的 tag，用 0xff 取出低 8 位的操作类型。对于删除操作会返回”未找到”的状态，说明该键值已经被删除了。对于值操作，则接着从 memtable key 后面解出 value 字节串，然后赋值给 value 指针。</p><h2 id="友元类声明"><a href="#友元类声明" class="headerlink" title="友元类声明"></a>友元类声明</h2><p>除了前面的 Add 和 Get 方法，MemTable 类还声明了一个友元类 <code>friend class MemTableBackwardIterator;</code>，看名字是逆向的迭代器。不过在整个代码仓库，并没有找到这个类的定义。可能是开发的时候预留的一个功能，最后没有实现，这里忘记删除无效代码了。这里编译器没有报错是因为C++ 编译器在<strong>处理友元声明时不要求友元类必须已经定义</strong>。编译器仅检查该声明的语法正确性，只有当实际上需要使用那个类（例如创建实例或访问其成员）时，缺少定义才会成为问题。</p><p>此外还有一个友元 <code>friend class MemTableIterator;</code>，该类实现了 Iterator 接口，用于遍历 memTable 中的键值对。MemTableIterator 的方法如 key() 和 value() 依赖于对内部迭代器 iter_ 的操作，这个迭代器直接工作在 memTable 的 SkipList 上。这些都是 memTable 的私有成员，所以需要声明为友元类。</p><p>在 db_impl.cc 中，当需要将 immemtable 落地到 Level0 的 SST文件时，就会用到 MemTableIterator 来遍历 memTable 中的键值对。使用部分的代码如下，BuildTable 中会遍历 memTable，将键值对写入到 SST 文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/db_impl.cc</span></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Version* base)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Iterator* iter = mem-&gt;<span class="built_in">NewIterator</span>();</span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Level-0 table #%llu: started&quot;</span>,</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)meta.number);</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    s = <span class="built_in">BuildTable</span>(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里遍历 memtable 时，用到一个友元类，<strong>为啥不直接提供一些 public 的接口来遍历呢</strong>？使用友元类的一个好处是，类的职责划分比较清晰。MemTableIterator 负责遍历 memTable 的数据，而 memTable 负责管理数据的存储。这种分离有助于清晰地定义类的职责，遵循单一职责原则，每个类只处理一组特定的任务，使得系统的设计更加模块化。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>最后来看看 MemTable 的内存管理。MemTable 类有一个 Arena 类的成员变量 arena_，用来管理跳表的内存分配。在插入键值对的时候，编码后的信息就存在 arena_ 分配的内存中。关于内存管理 Arena 类，可以参考<a href="https://selfboot.cn/2024/08/29/leveldb_source_utils/#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Arena-%E7%B1%BB">LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码</a>。</p><p>为了能够在不使用 MemTable 的时候，及时释放内存，这里引入了<strong>引用计数</strong>机制来管理内存。引用计数允许共享对 MemTable 的访问权，而不需要担心资源释放的问题。对外也提供了 Ref 和 Unref 两个方法来增加和减少引用计数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increase reference count.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ref</span><span class="params">()</span> </span>&#123; ++refs_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop reference count.  Delete if no more references exist.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Unref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  --refs_;</span><br><span class="line">  <span class="built_in">assert</span>(refs_ &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (refs_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当引用计数减至零时，MemTable 自动删除自己，这时候就会调用析构函数 <code>~MemTable()</code> 来释放内存。对象析构时，对于自定义的成员变量，<strong>会调用各自的析构函数来释放资源</strong>。在 MemTable 中，用跳表来存储 key，跳表的内存则是通过 <code>Arena arena_;</code> 来管理的。MemTable 析构过程，会调用 area_ 的析构函数来释放之前分配的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arena::~<span class="built_in">Arena</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] blocks_[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里值得注意的是，MemTable 将析构函数 <code>~MemTable();</code> 设置为 private，强制外部代码通过 <code>Unref()</code> 方法来管理 MemTable 的生命周期。这保证了引用计数逻辑能够正确执行，防止了由于不当的删除操作导致的内存错误。</p><h3 id="解答疑问"><a href="#解答疑问" class="headerlink" title="解答疑问"></a>解答疑问</h3><p>好了，这时候还有最后一个问题了，就是前面留的一个疑问，在 LevelDB Get 方法中，为啥不直接使用成员变量 mem_ 和 imm_ 来读取，而是创建了两个本地指针来引用呢？</p><p><strong>如果直接使用 mem_ 和 imm_ 的话，会有什么问题</strong>？先考虑不加锁的情况，比如一个读线程正在读 mem_，这时候另一个写线程刚好写满了 mem_，触发了 mem_ 转到 imm_ 的逻辑，会重新创建一个空的 mem_，这时候读线程读到的内存地址就无效了。当然，你可以加锁，来把读写 mem_ 和 imm_ 都保护起来，但是这样并发性能就很差，同一时间，只允许一个读操作或者写操作。</p><p>为了支持并发，LevelDB 这里的做法比较复杂。读取的时候，先加线程锁，复制 mem_ 和 imm_ 用 Ref() 增加引用计数。之后就可以释放线程锁，在复制的 mem 和 imm 上进行查找操作，这里的查找操作不用线程锁，支持多个读线程并发。读取完成后，再调用 Unref() 减少引用计数，如果引用计数变为零，对象被销毁。</p><p><strong>考虑多个读线程在读 mem_，同时有 1 个写线程在写入 mem_</strong>。每个读线程都会先拿到自己的 mem_ 的引用，然后释放锁开始查找操作。写线程可以往里面继续写入内容，或者写满后创建新的 mem_ 内存。只要有任何一个读线程还在查找，这里最开始的 mem_ 的引用计数就不会为零，内存地址就一直有效。直到所有读线程读完，并且写线程把 mem_ 写满，将它转为 imm_ 并写入 SST 文件后，最开始的 mem_ 的引用计数为零，这时候就触发析构操作，可以回收地址了。</p><p>看文字有点绕，我让 AI 整理一个 mermaid 的流程图来帮助理解吧：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250611_leveldb_source_memtable_life_mermaid.webp" alt="LevelDB 内存表的生命周期图"></p><p>mermaid 的源码可以在<a href="/downloads/mermaid_leveldb_source_memtable.txt">这里</a>找到。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在整个 LevelDB 架构中，MemTable 扮演着承上启下的角色。它接收来自上层的写入请求，在内存中积累到一定量后，转变为不可变的 Immutable MemTable，最终由后台线程写入磁盘形成 SST 文件。同时，它也是读取路径中优先级最高的组件，确保最新写入的数据能够立即被读取到。</p><p>本文我们详细分析了 LevelDB 中 MemTable 的实现原理与工作机制，最后再简单总结下MemTable 的核心设计：</p><ol><li><strong>基于跳表的实现</strong>：MemTable 内部使用跳表（SkipList）来存储数据，这种数据结构提供了平衡树的大部分优点，同时实现更为简单，能够高效地支持查找和插入操作。</li><li><strong>内存管理机制</strong>：MemTable 通过 Arena 内存分配器来管理内存，统一分配和释放，避免内存碎片和提高内存利用率。</li><li><strong>引用计数机制</strong>：通过 Ref() 和 Unref() 方法实现引用计数，支持并发访问，同时保证资源能在不再使用时及时释放。</li><li><strong>特定键值编码格式</strong>：MemTable 中存储的键值对采用了特定的编码格式，包含键长度、用户键、序列号和类型标识、值长度以及值本身，支持了 LevelDB 的多版本并发控制（MVCC）。</li><li><strong>友元类协作</strong>：通过友元类 MemTableIterator 来遍历 MemTable 中的数据，实现了关注点分离的设计原则。</li></ol><p>MemTable 通过细致的内存管理和引用计数机制，解决了并发访问问题；通过跳表数据结构，实现了高效的查询和插入；通过特定的键值编码格式，支持了多版本并发控制。这些设计共同构成了 LevelDB 高性能、高可靠性的基础。</p>]]></content>
    
    
    <summary type="html">本文深入解析LevelDB中MemTable内存表的实现细节，包括其在内存中管理最近写入数据的核心作用。文章详细介绍了MemTable的内部构造、基于跳表的数据结构、键值对的编码格式以及内存管理机制。通过分析Add和Get方法的实现，展示了键值对如何被编码存储和高效查询。同时解释了引用计数机制如何实现并发访问控制，以及MemTable如何与友元类协作完成数据遍历。对理解LevelDB读写流程和性能优化具有重要参考价值。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源码阅读：结合代码理解多版本并发控制(MVCC)</title>
    <link href="https://selfboot.cn/2025/06/10/leveldb_mvcc_intro/"/>
    <id>https://selfboot.cn/2025/06/10/leveldb_mvcc_intro/</id>
    <published>2025-06-10T17:47:42.000Z</published>
    <updated>2025-07-15T13:42:45.601Z</updated>
    
    <content type="html"><![CDATA[<p>在数据库系统中，并发访问是一个常见的场景。多个用户同时读写数据库，如何保证每个人的读写结果都是正确的，这就是并发控制要解决的问题。</p><p>考虑一个简单的转账场景，开始的时候 A 账户有 1000 元，要转 800 元给 B 账户。转账过程包括两步：从 A 扣钱，给 B 加钱。恰好在这两步中间，有人查询了 A 和 B 的余额。</p><p>如果没有任何并发控制，查询者会看到一个异常现象：A 账户已经被扣除了 800 元，只剩 200 元，B 账户还没收到转账，还是原来的金额！这就是典型的数据不一致问题。为了解决这个问题，数据库系统<strong>需要某种并发控制机制</strong>。</p><p>最直观的解决方案是加锁，当有人在进行写操作（如转账）时，其他人的读操作必须等待。回到前面的问题，只有在转账的两步都完成之后，才能查到正确的账户余额。但是锁机制存在明显的问题，每次只要写相关 key，所有读该 key 的操作都要排队等待，导致并发上不去，性能会比较差。</p><p>现代数据库系统普遍采用 MVCC 来控制并发，LevelDB 也不例外，接下来我们结合源码来理解 LevelDB 的 MVCC 实现。</p><span id="more"></span><h2 id="通过-MVCC-控制并发"><a href="#通过-MVCC-控制并发" class="headerlink" title="通过 MVCC 控制并发"></a>通过 MVCC 控制并发</h2><p>MVCC(<a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multi-Version Concurrency Control</a>) 是一种并发控制机制，它通过维护数据的多个版本来实现并发访问。简单来说，LevelDB 的 MVCC 实现关键点有下面几个：</p><ul><li>每个 key 可以有多个版本，每个版本都有自己的序列号(sequence number)；</li><li>写操作创建新版本而不是直接修改现有数据。不同的写入需要加锁互斥，保证每个写入获得递增的版本号。</li><li>不同的读操作之间可以并发，不用加锁。多个读操作也可以和写操作并发，不需要加锁。</li><li>通过 snapshot 来实现读和写、读和读之间的隔离，读取操作看到的总是某个时间点之前的数据版本。</li></ul><p>这就是 MVCC 的核心思想了。我们通过一个具体的时间操作序列，来理解下 MVCC 是怎么工作的。假设有以下操作序列：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间点 T1: <span class="attribute">sequence</span>=100, 写入 <span class="attribute">key</span>=A, <span class="attribute">value</span>=1</span><br><span class="line">时间点 T2: <span class="attribute">sequence</span>=101, 写入 <span class="attribute">key</span>=A, <span class="attribute">value</span>=2</span><br><span class="line">时间点 T3: Reader1 获取 <span class="attribute">snapshot</span>=101</span><br><span class="line">时间点 T4: <span class="attribute">sequence</span>=102, 写入 <span class="attribute">key</span>=A, <span class="attribute">value</span>=3</span><br><span class="line">时间点 T5: Reader2 获取 <span class="attribute">snapshot</span>=102</span><br></pre></td></tr></table></figure><p>那么不管 Reader1 和 Reader2 谁先读取，Reader1 读取 key&#x3D;A 总会得到 value&#x3D;2（sequence&#x3D;101），Reader2 读取 key&#x3D;A 会得到 value&#x3D;3（sequence&#x3D;102）。后续如果有新的读取，不带 snapshot 的读取会得到最新的数据。通过下面的时序图更容易理解，mermaid 源码在<a href="/downloads/mermaid_leveldb_mvcc.txt">这里</a>：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250610_leveldb_mvcc_intro_r_w.webp" alt="LevelDB 读写 MVCC 操作时序图"></p><p>MVCC 的整体效果就如上了，还是比较容易理解的。下面看看 LevelDB 中是怎么实现 MVCC 的。</p><h2 id="LevelDB-键带版本格式"><a href="#LevelDB-键带版本格式" class="headerlink" title="LevelDB 键带版本格式"></a>LevelDB 键带版本格式</h2><p>实现 MVCC 的前提是，<strong>每个键都保存多个版本</strong>。所以要设计一个数据结构，把键和版本号关联起来。LevelDB 设计的 key 格式如下：</p><blockquote><p>[key][sequence&lt;&lt;8|type]</p></blockquote><p>LevelDB 的做法也比较容易理解，在原来的 key 后面拼上版本信息。这里版本信息是一个 64 位的 uint，其中高 56 位存储的是 sequence，低 8 位存储的是操作类型。这里操作类型目前只有两种，对应的分别是写入和删除操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value types encoded as the last component of internal keys.</span></span><br><span class="line"><span class="comment">// DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk</span></span><br><span class="line"><span class="comment">// data structures.</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ValueType</span> &#123; kTypeDeletion = <span class="number">0x0</span>, kTypeValue = <span class="number">0x1</span> &#125;;</span><br></pre></td></tr></table></figure><p>这里序列号只有 56 位，所以最多可以支持 $ 2^{56} $ 次写入。这样实现会不会有问题？如果我想<span style="color:red">写入更多的 key 那岂不是不支持了</span>？理论上是的，但是咱们从实际使用场景来分析下。假设每秒写入 100W 次，这个已经是很高的写入 QPS 了，那么可以持续写入的时间是：</p><p>$$ 2^{56} &#x2F; 1000000 &#x2F; 3600 &#x2F; 24 &#x2F; 365 &#x3D; 2284 $$ </p><p>嗯。。。能写 2000 多年，所以这个序列号是够用的，不用担心耗尽问题了。这里的数据格式设计虽然很简单，但还是有不少好处的：</p><ol><li><strong>同一个 key 支持不同版本</strong>，同一个 key 多次写入，最新写入的会有更高的序列号。在写入的同时，支持并发读这个 key 的更老版本。</li><li>类型字段(type)区分普通写入还是删除，这样删除并不是真正删除数据，而是写入一个删除标记，只有等待 compaction 时被真正删除。</li></ol><p>我们知道 LevelDB 中键是顺序存储的，当要查询单个键时，可以用二分查找快速定位。当需要获取一系列连续键时，可以使用二分查找快速定位范围起点，然后顺序扫描即可。但现在我们给键增加了版本号，那么问题来了，<strong>带版本号的键要怎么排序呢</strong>？</p><h3 id="内部键排序方法"><a href="#内部键排序方法" class="headerlink" title="内部键排序方法"></a>内部键排序方法</h3><p>LevelDB 的做法也是比较简单有效，排序规则如下：</p><ol><li>首先按键升序排列，这里是按照字符串的字典序排序；</li><li>然后按序列号降序排列，序列号越大越靠前；</li><li>最后按类型降序排列，写入类型靠前，删除类型靠后；</li></ol><p>为了实现这里的排序规则，LevelDB 实现了自己的比较器，在 <a href="https://github.com/google/leveldb/blob/main/db/dbformat.cc#L47">db&#x2F;dbformat.cc</a> 中，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="type">const</span> Slice&amp; akey, <span class="type">const</span> Slice&amp; bkey)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Order by:</span></span><br><span class="line">  <span class="comment">//    increasing user key (according to user-supplied comparator)</span></span><br><span class="line">  <span class="comment">//    decreasing sequence number</span></span><br><span class="line">  <span class="comment">//    decreasing type (though sequence# should be enough to disambiguate)</span></span><br><span class="line">  <span class="type">int</span> r = user_comparator_-&gt;<span class="built_in">Compare</span>(<span class="built_in">ExtractUserKey</span>(akey), <span class="built_in">ExtractUserKey</span>(bkey));</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> anum = <span class="built_in">DecodeFixed64</span>(akey.<span class="built_in">data</span>() + akey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> bnum = <span class="built_in">DecodeFixed64</span>(bkey.<span class="built_in">data</span>() + bkey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line">      r = <span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先从带版本号的 key 中去掉后 8 位，拿到真实的用户键，之后按照用户键的排序规则进行比较。这里再多说一句，LevelDB 提供了一个默认的用户键比较器 <code>leveldb.BytewiseComparator</code>，这里是完全按照键值的字节序进行比较。比较器的实现代码在 <a href="https://github.com/google/leveldb/blob/main/util/comparator.cc#L21">util&#x2F;comparator.cc</a> 中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BytewiseComparatorImpl</span> : <span class="keyword">public</span> Comparator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BytewiseComparatorImpl</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;leveldb.BytewiseComparator&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Compare</span><span class="params">(<span class="type">const</span> Slice&amp; a, <span class="type">const</span> Slice&amp; b)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">compare</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... </span></span><br></pre></td></tr></table></figure><p>这里 Slice 是 LevelDB 中定义的一个字符串类，用于表示一个字符串，它的 compare 就是字节码比较。其实 LevelDB 也支持用户自定义比较器，只需要实现 Comparator 接口即可。这里多说一点，在使用比较器的时候，用 BytewiseComparator 封装了一个单例，代码有点难理解，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我之前专门写了一篇文章来解释 NoDestructor 模板类，感兴趣的可以看下：<a href="https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/">LevelDB 源码阅读：禁止对象被析构</a>。</p><p>这种排序规则的好处也是显而易见的，首先按照用户键升序排列，这样范围查询非常高效。当用户需要获取一系列连续键时，可以使用二分查找快速定位范围起点，然后顺序扫描即可。另外，同一个用户键的多个版本按序列号降序排列，这意味着最新版本在前，便于快速找到当前值。查询时，只需找到第一个序列号小于等于当前快照的版本，<strong>不需要完整扫描所有版本</strong>。</p><p>好了，关于排序就说到这。下面咱们结合代码来看看写入和读取的时候，是怎么拼接 key 的。</p><h2 id="写入带版本键"><a href="#写入带版本键" class="headerlink" title="写入带版本键"></a>写入带版本键</h2><p>LevelDB 写入键值对的步骤比较复杂，可以看我之前的文章：<a href="https://selfboot.cn/2025/01/24/leveldb_source_writedb/">LevelDB 源码阅读：写入键值的工程实现和优化细节</a>。简单说就是先写入 memtable，然后是 immutable memtable，最后不断沉淀(compaction)到不同层次的 SST 文件。整个过程的第一步就是写入 memtable，所以在最开始写入 memtable 的时候，就会给 key 带上版本和类型，组装成前面我们说的带版本的内部 key 格式。</p><p>这里组装 Key 的代码在 <a href="https://github.com/google/leveldb/blob/main/db/memtable.cc#L76">db&#x2F;memtable.c</a> 的 <code>MemTable::Add</code> 函数中。这里除了组装 key，还拼接了 value 部分。实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  tag          : uint64((sequence &lt;&lt; 8) | type)</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">  <span class="type">size_t</span> key_size = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> val_size = value.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> encoded_len = <span class="built_in">VarintLength</span>(internal_key_size) +</span><br><span class="line">                             internal_key_size + <span class="built_in">VarintLength</span>(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">  <span class="type">char</span>* buf = arena_.<span class="built_in">Allocate</span>(encoded_len);</span><br><span class="line">  <span class="type">char</span>* p = <span class="built_in">EncodeVarint32</span>(buf, internal_key_size);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(p, key.<span class="built_in">data</span>(), key_size);</span><br><span class="line">  p += key_size;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>;</span><br><span class="line">  p = <span class="built_in">EncodeVarint32</span>(p, val_size);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(p, value.<span class="built_in">data</span>(), val_size);</span><br><span class="line">  <span class="built_in">assert</span>(p + val_size == buf + encoded_len);</span><br><span class="line">  table_.<span class="built_in">Insert</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里同一个用户键的多次写入会产生多个版本，每个版本都有唯一的 sequence number。用户键一旦被转换为内部键，后续所有处理过程都基于这个内部键进行。包括 MemTable 转为 Immutable MemTable，SST 文件写入，SST 文件合并等。</p><p>这里 Add 函数中，在 internal_key 内部键的前面其实也保存了整个内部键的长度，然后把长度和内部键拼接起来，一起插入到了 MemTable 中。这样的 key 其实是 memtable_key，后续在读取的时候，也是用 memtable_key 来在 memtable 中查找的。</p><p><strong>这里为什么要保存长度呢</strong>？我们知道 Memtable 中的 SkipList 使用 const char* 指针作为键类型，但这些指针只是指向内存中某个位置的裸指针。当跳表的比较器需要比较两个键时，它需要知道每个键的确切范围，也就是起始位置和结束位置。如果直接使用 internal key，就没有明确的方法知道一个 internal key 在内存中的确切边界。加上长度信息后，就可以快速定位到每个键的边界，从而进行正确的比较。</p><h2 id="读取键值过程"><a href="#读取键值过程" class="headerlink" title="读取键值过程"></a>读取键值过程</h2><p>接下来看看读取键值的过程。在读取键值的时候，会先把用户键转为内部键，然后进行查找。不过这里首先面临一个问题是，序列号要用哪个呢。回答这个问题前，我们先来看读取键常用的的方法，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string newValue;</span><br><span class="line">status = db-&gt;<span class="built_in">Get</span>(leveldb::<span class="built_in">ReadOptions</span>(), <span class="string">&quot;key500&quot;</span>, &amp;newValue);</span><br></pre></td></tr></table></figure><p>这里有个 ReadOptions 参数，里面会封装一个 Snapshot 快照对象。这里的快照你可以理解为数据库在某个时间点的状态，里面有这个时间点之前所有的数据，但不会包含这个时间点之后的写入。</p><p>其实这里快照的核心实现就是保存某个时间点的最大序列号，读取的时候，会用这个序列号来组装内部键。读的时候，分两种情况，如果没有指定 snapshot，使用当前最新的 sequence number。如果使用了之前保存下来的 snapshot，则会使用 snapshot 的序列号。</p><p>之后会根据快照序列号和用户键组装，这里先定义了一个 LookupKey 对象，用来封装查找时候使用内部键的一些常用操作。代码在 <a href="https://github.com/google/leveldb/blob/main/db/dbformat.h#L184">db&#x2F;dbformat.h</a> 中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A helper class useful for DBImpl::Get()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LookupKey</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize *this for looking up user_key at a snapshot with</span></span><br><span class="line">  <span class="comment">// the specified sequence number.</span></span><br><span class="line">  <span class="built_in">LookupKey</span>(<span class="type">const</span> Slice&amp; user_key, SequenceNumber sequence);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LookupKey</span>(<span class="type">const</span> LookupKey&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  LookupKey&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LookupKey&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">LookupKey</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a key suitable for lookup in a MemTable.</span></span><br><span class="line">  <span class="function">Slice <span class="title">memtable_key</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Slice</span>(start_, end_ - start_); &#125;</span><br><span class="line">  <span class="comment">// Return an internal key (suitable for passing to an internal iterator)</span></span><br><span class="line">  <span class="function">Slice <span class="title">internal_key</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Slice</span>(kstart_, end_ - kstart_); &#125;</span><br><span class="line">  <span class="comment">// Return the user key</span></span><br><span class="line">  <span class="function">Slice <span class="title">user_key</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Slice</span>(kstart_, end_ - kstart_ - <span class="number">8</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 LookupKey 的构造函数中，会根据传入的 user_key 和 sequence 来组装内部键，具体代码在 <a href="https://github.com/google/leveldb/blob/main/db/dbformat.cc#L117">db&#x2F;dbformat.cc</a> 中。后续在 memtable 中搜索的时候，用的 memtable_key，然后在 SST 中查找的时候，用的 internal_key。这里 memtable_key 就是我们前面说的，在 internal_key 的前面加上了长度信息，方便在 SkipList 中快速定位到每个键的边界。</p><p>这里在 memtable 和 immutable memtable 中找不到的话，会去 SST 中查找。SST 的查找就相当复杂一些，涉及多版本数据的管理，后续我会专门写文章来介绍这里的读取过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇对 MVCC 的讲解还比较浅显，介绍了大概的概念，以及重点讲了下读取和写入过程中如何对序列号进行处理的过程。并没有深入数据多版本管理，以及旧版本数据回收清理的过程。后面文章再深入这些话题。</p><p>总的来说，LevelDB 通过在键值中引入版本号，实现了多版本并发控制。通过 snapshot 来实现读取隔离，写入永远创建新版本。对于读操作来说，不需要加锁，可以并发读取。对于写操作来说，需要加锁，保证写入的顺序。</p><p>这种设计提供了很好的并发性能，保证了读取的一致性，同时减少了锁冲突。不过代价是存储空间的额外开销，以及需要保存多个版本带来的代码复杂度。</p>]]></content>
    
    
    <summary type="html">本文深入剖析LevelDB如何通过MVCC实现并发控制，详细解读了带版本键的数据结构设计、排序规则以及读写过程的实现细节。文章介绍了LevelDB如何通过在键中嵌入序列号和类型信息，实现多版本数据管理，使读操作无需加锁即可获取一致性视图，同时写操作创建新版本而非覆盖现有数据。通过实际代码分析，展示了内部键的排序方法、Snapshot机制的工作原理，以及键值读写过程中的版本控制逻辑，帮助读者理解现代数据库系统并发控制的实际工程实现。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  
  
  <entry>
    <title>使用 Cursor 深度体验 3 个 MCP Server，惊艳但并不实用?</title>
    <link href="https://selfboot.cn/2025/05/23/mcp_user_report/"/>
    <id>https://selfboot.cn/2025/05/23/mcp_user_report/</id>
    <published>2025-05-23T11:39:14.000Z</published>
    <updated>2025-07-15T13:42:45.601Z</updated>
    
    <content type="html"><![CDATA[<p>大语言模型刚出来的时候，只是通过预训练的模型来生成回答内容。这个时候的模型有两个主要的缺点：</p><ol><li>有些数据它不知道，比如 2024 年 3 月训练的模型，就不知道 2024 年 5 月的事情；</li><li>没法使用外部工具。这里的工具我们可以等效理解为函数调用，比如我有个发表文章的工具函数，我没法用自然语言让大模型来帮我调用这个函数。</li></ol><p>为了解决这两个问题，OpenAI 最先在模型中支持了 <code>function calling</code> 功能，他们在这篇博客: <a href="https://openai.com/index/function-calling-and-other-api-updates/">Function calling and other API updates</a> 有介绍。</p><h2 id="背景：理解-Function-Calling"><a href="#背景：理解-Function-Calling" class="headerlink" title="背景：理解 Function Calling"></a>背景：理解 Function Calling</h2><p>这时候，我们就可以告诉模型，我有这么几个工具，每个工具需要什么参数，然后能做什么事情，输出什么内容。当模型收到具体任务的时候，会帮我们选择合适的工具，并解析出参数。之后我们可以执行相应的工具，拿到结果。并可以接着循环这个过程，让 AI 根据工具结果继续决定往下做什么事情。</p><p>我在网上找了个动图，可以来理解下有了 function calling 后，做事情的流程：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250522_mcp_user_report_functioncalling.webp" alt="理解 function calling过程"></p><span id="more"></span><p>当然这里大模型只是根据我们给的工具列表，选择合适的工具，并解析出参数。它不能直接去调用工具，我们需要<strong>编程实现工具调用部分</strong>，可以参考 OpenAI 的 <a href="https://platform.openai.com/docs/guides/function-calling?api-mode=responses">Function calling 文档</a>。</p><h2 id="为什么又引入了-MCP"><a href="#为什么又引入了-MCP" class="headerlink" title="为什么又引入了 MCP"></a>为什么又引入了 MCP</h2><p>只有 function calling 已经能做很多事了，派生了不少有意思的项目，比如 <a href="https://github.com/Significant-Gravitas/AutoGPT">AutoGPT</a>，可以说是最早的 Agent 智能体了。</p><p>但是有个问题，就是不同厂商 function calling 实现各不相同，开发者需要为每个平台单独适配。另外开发者还需要编写代码来解析 function calling 的输出，并调用相应的工具。这里面有不少工程的工作，比如失败重试、超时处理、结果解析等。</p><p>计算机领域，<strong>没有什么是不能通过加个中间层来解决的</strong>。过了一年多，随着模型能力提升，各种外部工具的丰富，<a href="https://www.anthropic.com/news/model-context-protocol">Anthropic 在2024年11月25日推出了 MCP 协议</a>，引入了 MCP Client 和 MCP Server 这个中间层，来解决解决 LLM 应用与外部数据源和工具之间通信的问题。</p><p>当然其实这中间也有一些其他方案，来赋予模型调用外部工具的能力，比如 OpenAI 推出的 <a href="https://openai.com/index/introducing-the-gpt-store/">ChatGPT Store</a>，曾经也火了一阵子的 <a href="https://chatgpt.com/gpts">GTPs</a>，不过目前似乎很少看到人用了。</p><p>目前比较流行的就是 MCP 了，这里有个图，可以帮助你理解：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250522_mcp_user_report_whatismcp.webp" alt="理解什么是 MCP"></p><p>咱们这篇文章主要是介绍实用体验，所以关于背景的交代就到这里。如果对 MCP 的开发感兴趣，可以看<a href="https://modelcontextprotocol.io/introduction">官方文档</a>，介绍的还是十分详细的。</p><h2 id="Cursor-MCP-使用方法"><a href="#Cursor-MCP-使用方法" class="headerlink" title="Cursor MCP 使用方法"></a>Cursor MCP 使用方法</h2><p>在使用之前，我先简单介绍下 Cursor 使用 MCP 的方法。Cursor 接入 MCP 还是挺方便的，对于大部分不需要密钥的 MCP Server，基本一个配置就能接入。现在 MCP 发展还挺快，所以建议大家直接去看 <a href="https://docs.cursor.com/context/model-context-protocol">Cursor 的官方文档</a>，获取最新信息。网上不少教你如何配置的文章，其实都过时了。</p><p>这里我给大家介绍下配置的整体思想，方便你理解文档。Cursor 在这里相当于 AI 应用，它内置了 MCP Client，所以你不用管 Client 部分了。你只需要告诉他你有哪些 MCP Server，然后在会话聊天中 Cursor 会自动调用工具并使用它的结果。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250522_mcp_user_report_understand.webp" alt="MCP 整体理解图"></p><p>先祭出上面这张图，方便你理解。目前大部分 AI 应用都是用 json 文件来配置 MCP Server 的，比如 Claude Desktop。Cursor 也是如此，它支持全局配置(<code>~/cursor/mcp.json</code>)，也可以在项目中(<code>.cursor/mcp.json</code>) 配置。</p><p>目前 Cursor 支持本地 MCP CLI Stdio Server 和远程 MCP SSE Server 两种方式，关于 SSE 可以参考我之前的文章<a href="https://selfboot.cn/2024/05/19/stream_sse_chunk/">结合实例理解流式输出的几种实现方法</a>。本地的 CLI 方式，其实就是在本地机器启动一个 Server 进程，然后 Cursor 通过标准输入输出来和这个本地进程交互。</p><p>这里本地的 Server 支持 Python，Node 服务，也支持 Docker 容器。不过前提是<strong>本地机器已经安装了对应的语言环境，能跑起来相应的启动命令</strong>。这 3 种方式，我都给了一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx @browsermcp/mcp@latest</span><br><span class="line">uvx mcp-server-browser-use@latest</span><br><span class="line">docker run -i --<span class="built_in">rm</span> -e GITHUB_PERSONAL_ACCESS_TOKEN ghcr.io/github/github-mcp-server</span><br></pre></td></tr></table></figure><p>有时候 MCP Server 里面还需要一些配置，比如 Github 的 API 密钥，这时候就需要你手动配置了。提醒下你要把密钥配置到环境变量中，<strong>千万不要把密钥上传到代码仓库</strong>哦。</p><p>具体到某个 MCP Server，你可以参考它的文档，看如何配置，应该没什么难度。配置好 json 后，Cursor 会自动识别，你可以打开这个 MCP Server，过一会看到绿色标记和列出来的工具，就说明配置成功了。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250522_mcp_user_report_configsucc.webp" alt="Cursor 配置 MCP Server 成功"></p><p>接下来终于到重头戏了，咱们来体验下 MCP 的实际效果。</p><h2 id="MCP-体验一：网页自动操作"><a href="#MCP-体验一：网页自动操作" class="headerlink" title="MCP 体验一：网页自动操作"></a>MCP 体验一：网页自动操作</h2><p>之前就经常想着让 AI 来自动化执行一些网页任务。比如自动去某个站点搜索、浏览指定主题的内容，进行回复，或者导出一些有意义的内容。于是试了下微软的无头 playwright MCP Server，给了它一个比较复杂的任务:</p><blockquote><p>帮我打开淘宝，搜索苹果手机，找到最新款的苹果手机，给出店铺销量最高的几家，并导出每家店铺的销量和价格。</p></blockquote><p>确实如期打开了淘宝，并真的找到了搜索框，输入了苹果手机，如图:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250522_mcp_user_report_taobaocase.webp" alt="MCP 体验一：网页自动操作"></p><p>但是后面弹了一个登录框，Claude 3.7 在这里卡了很久，也没解决。跑了一阵子，最后的输出是这样的：</p><blockquote><p>我注意到我们看到了一个登录弹窗，这可能是因为淘宝网站要求用户登录才能查看详细搜索结果。这是淘宝网站的常见安全措施，特别是对于非登录用户通过自动化工具访问时。<br>让我尝试取消登录弹窗，点击关闭按钮：<br>我们看到点击关闭按钮后，淘宝网站依然要求登录才能查看搜索结果。淘宝网站对非登录用户有严格的安全限制，特别是使用自动化工具访问时。<br>由于需要登录才能查看详细的苹果手机信息，我可以尝试使用其他方式获取有关苹果手机的信息。例如，我可以使用网络搜索查找有关最新款苹果手机及其销量和价格信息的公开数据：</p></blockquote><p>最后开始联网搜索，和我本意差的有点远。这里登录态确实不好处理，我找了另一个 <a href="https://browsermcp.io/">MCP Server</a>，它支持在本地浏览器中运行，这样可以登录后再让 AI 来操作。这个工具的原理是，在本地浏览器安装一个插件，然后 MCP Server 来控制本地浏览器。</p><p>使用下来，目前登录态是没问题了，但有些网站有部分防爬的功能，页面元素做了些保护，这个 MCP Server 还没法完美的操控，比如没法成功点击按钮，另外滚动起来也是很卡顿。</p><p>其实目前 LLM 操控浏览器还是有不少难度的，最近一个比较火的 <a href="https://browser-use.com/">Browser Use</a> 项目，它除了用 HTML 元素，还尝试用视觉元素来操控浏览器。整体前景会好一些，等我有 Token 了再来深度体验下这个。</p><h2 id="MCP-体验二：Github-仓库信息分析"><a href="#MCP-体验二：Github-仓库信息分析" class="headerlink" title="MCP 体验二：Github 仓库信息分析"></a>MCP 体验二：Github 仓库信息分析</h2><p>再来试试 Cursor 官方例子中的 <a href="https://github.com/github/github-mcp-server">Github MCP Server</a>，它支持搜索仓库、代码、issue，创建 PR 等。我想到一个场景就是，遇到一个火的项目，可以先让 AI 总结下目前比较火的 PR 或者 Issue，然后看看有没有可以贡献的地方。当然了，如果 AI 找到有价值的 Issue，然后再分析代码，给出解决方案，并自动提交代码，那这个价值就更大了。</p><p>当然，咱先拆分问题，来个低难度的信息收集：</p><blockquote><p>LevelDB 这个项目中，有哪些讨论比较多，还没合并的 pull request 啊</p></blockquote><p>这里用的 Claude3.7，竟然有点死循环了，一直在 Call list_pull_requests 这个工具，参数也基本一样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;google&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;leveldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;open&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;updated&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;perPage&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>查了 10 多遍，也没自动终止。PR 查不成功，我换了下查 Issue，这次还可以，用 list_issues 工具，查了 3 页，参数类似下面:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;google&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;leveldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;open&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;comments&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;perPage&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;page&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后也给出了一些结论，如图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250522_mcp_user_report_leveldbcase.webp" alt="Github MCP Issue 信息分析"></p><p>检查了几个，没什么大问题，这个我还是挺满意的。遇到一个大的项目，能够快速找到大家讨论多的 Issue，然后分析下，确实能帮上忙。不过我怀疑这里没找完，只有 3 页，其实一共 200 多个 Issue 呢。</p><p>然后继续聚焦其中一个 <a href="https://github.com/google/leveldb/pull/917">PR #917</a>，让他给我分析下。刚好今天 Claude 推出了 Sonnet 4 模型，用这个新的模型让他分析下。不得不说，针对这种拆解开的小的问题，AI 分析还是很强的。</p><p>先是收集了这个 PR 的评论，PR 的代码改动，然后还拉了这个 PR 提到的另外 2 个 Issue，<strong>综合了这么多信息后，给出了一个详细的分析</strong>。分析也十分给力，先是问题描述，问题背景和表现，接着是提议的解决方案，社区针对这个方案的讨论焦点，比如性能影响，作者回应等。最后还给出这个 PR 的当前状态，从 2021 年 6 月提交至今，还没合并进去。这里的分析太惊艳了，看来后面遇到一些开源项目的问题，还是可以来用下的。</p><p>这里是截图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250523_mcp_user_report_githubissue.webp" alt="Github MCP PR 信息分析"></p><p>当然看了下 Github MCP Server 的文档，这里不止是提供了读仓库，读 Issue 的能力，还有修改仓库的能力。包括提交 PR，创建 Issue，创建评论，创建标签，新建分支等。我还没来得及深入使用下这些会改动仓库的功能，等后面有机会再接着体验。</p><h2 id="MCP-体验三：图表生成"><a href="#MCP-体验三：图表生成" class="headerlink" title="MCP 体验三：图表生成"></a>MCP 体验三：图表生成</h2><p>有时候会经常根据数据生成一些好看的报表，之前还有 AI 写了一个工具，来<a href="https://gallery.selfboot.cn/zh/tools/chartrace">生成动态柱状图</a>。现在有了 MCP 后，可以试试让 AI 来生成图表。其实有不少很酷的生成图表的库，比如 echarts 这些。看了下现在没有官方的图表库，不过找到了一个 <a href="https://github.com/antvis/mcp-server-chart?tab=readme-ov-file">mcp-server-chart</a>，它支持生成 echarts 的图表。</p><p>这里有<a href="https://gallery.selfboot.cn/zh/tools/chartrace/dynamic/china_population">最近 10 年中国各省份人口变化的动态竞速图</a>，导了一份数据出来，然后试试 MCP Server 生成图表效果如何。</p><p>直接给它一份文件，然后提示：</p><blockquote><p>@china_population.csv 结合这份中国人口变化数据，生成一个 2022 年和2023 年各省份人口的柱状图</p></blockquote><p>这里用的 Claude 4 Sonnet 模型，成功调用了 mcp-server-chart 的 generate_column_chart 工具，生成了图表。不过这个工具返回的是图片 URL，需要去输出里复制出来打开才能看。其实 Cursor 支持输出图片的 Base64 编码，这样聊天里也能加载出来。工具返回的图片地址<a href="https://mdn.alipayobjects.com/one_clip/afts/img/w099SKFp0AMAAAAAAAAAAAAAoEACAQFr/original">在这</a>，效果如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250523_mcp_user_report_echart.webp" alt="MCP 生成柱状图"></p><p>然后我发现这个工具支持其他类型的图表，比如折线图，散点图，饼图等。有个图我不知道啥图，但效果还挺好的，我就截了个图给 Claude，提示：</p><blockquote><p>参考这张图，生成一个 2023 年各省人口的图</p></blockquote><p>它先分析这是一个树状图，然后帮我生成了结果，还解释了下。解释超大矩形块是广东省，占据最大面积，提现了人口第一大省的地位。生成图<a href="https://mdn.alipayobjects.com/one_clip/afts/img/6CQ6TKSrI_sAAAAAAAAAAAAAoEACAQFr/original">地址在这</a>，我这里也放出来吧：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250523_mcp_user_report_echart_treemap.webp" alt="MCP 生成人口树状图"></p><p>效果还是可以的。目前这个工具每个图表一个 Tool，支持的图表类型还是有限的。</p><h2 id="MCP-使用限制"><a href="#MCP-使用限制" class="headerlink" title="MCP 使用限制"></a>MCP 使用限制</h2><p>目前的 MCP 还是存在一些限制的，首先咱们要明确一点，MCP 协议只是加了个 Server 和 Client 的中间层，它<strong>还是要依赖 LLM 的 function calling 能力</strong>。而 function calling 会受到 LLM 的上下文长度限制，工具的描述信息，参数等都会占用 Token。</p><p>当工具数量太多或者描述复杂的时候，可能会导致 Token 不够用。另外，就算 Token 够用，如果提供的工具描述过多，也会导致模型效果下降。<a href="https://platform.openai.com/docs/guides/function-calling?api-mode=responses#token-usage">OpenAI 的文档</a>也有提到：</p><blockquote><p>Under the hood, functions are injected into the system message in a syntax the model has been trained on. This means functions count against the model’s context limit and are billed as input tokens. If you run into token limits, we suggest limiting the number of functions or the length of the descriptions you provide for function parameters.</p></blockquote><p>MCP 基于 function calling 能力，所以也有同样的限制。MCP server 如果提供了过多的工具，或者工具描述太复杂，都会影响到实际效果。</p><p>比如拿 Cursor 来说，它推荐打开的 MCP Servers 最多提供 40 个工具，太多工具的话，模型效果不好。并且有的模型也不支持超过 40 个工具。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250522_mcp_user_report_cursor_limit.webp" alt="Cursor MCP 工具限制"></p><h2 id="MCP-的实用价值？"><a href="#MCP-的实用价值？" class="headerlink" title="MCP 的实用价值？"></a>MCP 的实用价值？</h2><p>好了，咱们介绍完 MCP 背景以及使用方法以及限制了，最后来聊下 MCP 的实用价值。目前市面上有太多 MCP Server 了，Cursor 有个 <a href="https://cursor.directory/mcp">MCP Server 列表页</a>，有需求的话可以在这找找看。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250522_mcp_user_report_cursor_allmcps.webp" alt="MCP Server 列表"></p><p>大致看了下，觉得有些 MCP Servers 后面可能会继续尝试用一用。</p><ul><li><a href="https://github.com/mendableai/firecrawl-mcp-server">firecrawl-mcp-server</a>: 这个工具可以搜索网页，并导出网页内容。还支持搜索，深度研究以及批量爬取。感觉后面写一些文章的时候，可以用来收集参考资料。爬网页这个需求还是会有的，也有不少类似的 MCP Server，后面都可以玩玩看了。</li><li><a href="https://github.com/MiniMax-AI/MiniMax-MCP">MiniMax-MCP</a>: 最近 MiniMax 的语言合成冲到了榜首，体验了下确实很不错。有几十款音色，每个都很有特色，听起来几乎就是真人的了。这款 MCP Server 支持调用 MiniMax 的合成接口，可以用来生成一些语音内容，来尝尝鲜也是可以的。</li><li><a href="https://github.com/ClickHouse/mcp-clickhouse">mcp-clickhouse</a>: 这类 DB 操作类的 MCP Server 如果足够强大的话也不错，可以聊着天就把数据查出来了，对普通人来说足够了。再配合图表类的 MCP Server，真的就能一句话把数据可视化出来。这里不止 Clickhouse 有，Mysql，Sqlite，Redis 这些都有 MCP Server，后面可以试试。</li></ul><p>就目前试过的几款，确实有些不错的亮点功能，但还不能让我觉得有特别大的价值。尝鲜之后，也就就束之高阁了。也就 Github MCP Server 让我觉得后面可能会用得到。</p><p>不过文章还没写好 Claude Sonnet 4 模型就发布了，号称世界上最强编程模型。推理能力也有很大提升，等后面多用一段时间，才能有一个真实的体感。或许随着模型能力提升，各个 MCP Server 的持续优化，有一天终会变成大家每天都离不开的工具吧。</p><p>不知道各位有什么好的 MCP Server 使用场景吗？欢迎留言讨论。</p>]]></content>
    
    
    <summary type="html">文章详细介绍了MCP的背景起源、与OpenAI Function Calling的关系，以及如何在Cursor中配置使用MCP Server。分别体验了网页自动化操作、Github仓库信息分析、图表生成等实用场景，发现MCP在Github代码分析方面表现惊艳，但网页操作仍有局限。文章同时指出MCP的核心限制：依然依赖大模型的function calling能力，受Token数量限制影响。虽然MCP为AI工具调用提供了标准化解决方案，但目前实用价值有限，更多是技术尝鲜阶段，期待未来随着模型能力提升带来更大突破。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="LLM" scheme="https://selfboot.cn/tags/LLM/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：写入键值的工程实现和优化细节</title>
    <link href="https://selfboot.cn/2025/01/24/leveldb_source_writedb/"/>
    <id>https://selfboot.cn/2025/01/24/leveldb_source_writedb/</id>
    <published>2025-01-24T18:00:00.000Z</published>
    <updated>2025-07-15T13:42:45.601Z</updated>
    
    <content type="html"><![CDATA[<p>读、写键值是 KV 数据库中最重要的两个操作，LevelDB 中提供了一个 Put 接口，用于写入键值对。使用方法很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;./db&quot;</span>, &amp;db);</span><br><span class="line">status = db-&gt;<span class="built_in">Put</span>(leveldb::<span class="built_in">WriteOptions</span>(), key, value);</span><br></pre></td></tr></table></figure><p>LevelDB 最大的优点就是<strong>写入速度也非常快，可以支持很高的并发随机写</strong>。官方给过一个<a href="https://github.com/google/leveldb/tree/main?tab=readme-ov-file#write-performance">写入压力测试结果</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fillseq      :       1.765 micros/op;   62.7 MB/s</span><br><span class="line">fillsync     :     268.409 micros/op;    0.4 MB/s (10000 ops)</span><br><span class="line">fillrandom   :       2.460 micros/op;   45.0 MB/s</span><br><span class="line">overwrite    :       2.380 micros/op;   46.5 MB/s</span><br></pre></td></tr></table></figure><p>可以看到这里不强制要求刷磁盘的话，随机写入的速度达到 45.0 MB&#x2F;s，每秒支持写入 40 万次。如果强制要求刷磁盘，写入速度会下降不少，也能够到 0.4 MB&#x2F;s, 每秒支持写入 3700 次左右。</p><p>这里 Put 接口具体做了什么？数据的写入又是如何进行的？LevelDB 又有哪些优化？本文一起来看看。开始之前，先看一个大致的流程图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250124_leveldb_source_writedb_flow_zh.png" alt="LevelDB 写入整体流程图"></p><span id="more"></span><h2 id="LevelDB-写入-key-的-2-种方式"><a href="#LevelDB-写入-key-的-2-种方式" class="headerlink" title="LevelDB 写入 key 的 2 种方式"></a>LevelDB 写入 key 的 2 种方式</h2><p>LevelDB 支持一次写入一个键值对，也支持一次写入多个键值对。不论是单个写入，还是批量写内部都是通过 <a href="https://selfboot.cn/2025/01/13/leveldb_source_write_batch/">WriteBatch</a> 来处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DB::Put</span><span class="params">(<span class="type">const</span> WriteOptions&amp; opt, <span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  batch.<span class="built_in">Put</span>(key, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以选择在调用 LevelDB 接口的应用层聚合写入操作，从而实现批量写入，提高写入吞吐。例如，在应用层可以设计一个缓冲机制，收集一定时间内的写入请求，然后将它们打包在一个 WriteBatch 中提交。这种方式可以减少磁盘的写入次数和上下文切换，从而提高性能。</p><p>当然也可以每次都写入单个键值，这时候 LevelDB 内部会通过 WriteBatch 来处理。如果在高并发情况下，可能会在内部合并多个写操作，然后将这批键值对写入 WAL 并更新到 memtable。</p><p>这里整体写入还是比较复杂的，本篇文章只先关注写入到 WAL 和 memtable 的过程。</p><h2 id="LevelDB-写入详细步骤"><a href="#LevelDB-写入详细步骤" class="headerlink" title="LevelDB 写入详细步骤"></a>LevelDB 写入详细步骤</h2><p>完整的写入部分代码在 <a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1205">leveldb&#x2F;db&#x2F;db_impl.cc 的 DBImpl::Write</a> 方法中，咱们一点点拆开看吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  writers_.<span class="built_in">push_back</span>(&amp;w);</span><br><span class="line">  <span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.<span class="built_in">front</span>()) &#123;</span><br><span class="line">    w.cv.<span class="built_in">Wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (w.done) &#123;</span><br><span class="line">    <span class="keyword">return</span> w.status;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始部分把 WriteBatch 和 sync 参数赋值给 Writer 结构体，然后通过一个 writers_ 队列来管理多个 Writer 结构体。这两个结构体和队列在整个写入过程中还是挺重要的，先来看看。</p><h3 id="Writer-结构和处理队列"><a href="#Writer-结构和处理队列" class="headerlink" title="Writer 结构和处理队列"></a>Writer 结构和处理队列</h3><p>这里 <a href="https://github.com/google/leveldb/blob/main/db/db_impl.h#L186">writers_</a> 是一个 <code>std::deque&lt;Writer*&gt;</code> 类型的队列，用于管理多个 Writer 结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::deque&lt;Writer*&gt; writers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br></pre></td></tr></table></figure><p>这里队列用 <code>GUARDED_BY(mutex_)</code> 装饰，表示队列的访问需要通过 <code>mutex_</code> 互斥锁来保护。这个用到了 Clang 的静态线程安全分析功能，可以参考我之前的文章 <a href="https://selfboot.cn/2025/01/02/leveldb_source_thread_anno/">LevelDB 源码阅读：利用 Clang 的静态线程安全分析</a></p><p>这里 Writer 结构体定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DBImpl</span>::Writer &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(port::Mutex* mu)</span></span></span><br><span class="line"><span class="function">      : batch(nullptr), sync(false), done(false), cv(mu) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  Status status;</span><br><span class="line">  WriteBatch* batch;</span><br><span class="line">  <span class="type">bool</span> sync;</span><br><span class="line">  <span class="type">bool</span> done;</span><br><span class="line">  port::CondVar cv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 Writer 结构体封装了不少参数，其中最重要是一个 WriteBatch 指针，记录了每个 WriteBatch 写请求的数据。然后用一个 status 用来记录每个 WriteBatch 写请求的错误状态。</p><p>此外，用一个 sync <strong>来标记每个 WriteBatch 写请求是否需要立马刷到磁盘中</strong>。默认是 false，不强制刷磁盘，如果系统崩溃，可能会丢掉部分还没来得及写进磁盘的数据。如果打开了 sync 选项，每次写入都会立马刷到磁盘，整体写入耗时会上涨，但是可以保证只要写入成功，数据就不会丢失。关于刷磁盘文件的更多细节，可以参考我之前的文章<a href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/">LevelDB 源码阅读：Posix 文件操作接口实现细节</a>。</p><p>还有一个 **done 则用来标记每个 WriteBatch 的写请求是否完成。**这里因为内部可能会合并写入多个 WriteBatch，当本次写入请求被合并到其他批次写入后，本次请求标记完成，就不需要再处理了。从而避免重复执行，提高并发的写入效率。</p><p>为了<strong>实现等待和通知，这里还有一个条件变量 cv，用于支持多个写请求的批量处理，并实现多个写请求的同步</strong>。写入的时候，多个线程可以同时提交写入请求，每个写请求都会先被放入写入队列。<strong>实际写入过程，则是串行化写入，同一时刻只有一批写入过程在执行</strong>。每次会从队列中取出队首的写请求，如果此时队列中还有其他等待的写任务，则会被合并为一个批次一起处理。在当前批次的写入请求处理过程中，后续来的请求进入队列后都需要等待。当前批次的请求处理完成后，会通知后面进入队列在等待中的写请求。</p><p>结合这里的介绍，应该能看懂前面 Write 方法开始部分代码的含义了。对于每个写入请求，都会先创建一个 Writer 结构体，然后将其放入 writers_ 队列中。接下来在 while 循环中，判断当前写入请求是否完成，如果完成就会直接返回当前写入的状态结果。如果当前写入请求没在队首，则需要等待在 cv 条件变量上。</p><p>如果当前写入请求在队首，那么就需要执行实际的写入操作了，这里具体写入流程是什么样呢？</p><h3 id="预先分配空间"><a href="#预先分配空间" class="headerlink" title="预先分配空间"></a>预先分配空间</h3><p>接下来在正式写入前，要先确保有足够的空间来写入数据。这里会调用 <a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1330">MakeRoomForWrite</a> 方法，确保在进行写入操作之前，有足够的资源和空间来处理新的写入请求。它负责管理内存表（memtable）的使用情况、控制 Level 0 文件的数量，并在需要时触发后台压缩。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REQUIRES: this thread is currently at the front of the writer queue</span></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::MakeRoomForWrite</span><span class="params">(<span class="type">bool</span> force)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!writers_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="type">bool</span> allow_delay = !force;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="comment">// Yield previous error</span></span><br><span class="line">      s = bg_error_;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里开始部分是一些验证部分，用 AssertHeld 验证当前线程必须持有 mutex_ 互斥锁，并且 writers_ 队列不能为空。接着会判断 bg_error_ 是否为空，如果不为空，则直接返回 bg_error_ 状态。在下文中会看到，如果写入 WAL 刷磁盘失败，就会设置 bg_error_ ，这样会让后续的写入都直接返回失败。</p><p>在 while 循环中，接着是一系列 if 分支检查，处理不同情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;<span class="built_in">NumLevelFiles</span>(<span class="number">0</span>) &gt;=</span><br><span class="line">                                  config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line">      <span class="comment">// We are getting close to hitting a hard limit on the number of</span></span><br><span class="line">      <span class="comment">// L0 files.  Rather than delaying a single write by several</span></span><br><span class="line">      <span class="comment">// seconds when we hit the hard limit, start delaying each</span></span><br><span class="line">      <span class="comment">// individual write by 1ms to reduce latency variance.  Also,</span></span><br><span class="line">      <span class="comment">// this delay hands over some CPU to the compaction thread in</span></span><br><span class="line">      <span class="comment">// case it is sharing the same core as the writer.</span></span><br><span class="line">      mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">      env_-&gt;<span class="built_in">SleepForMicroseconds</span>(<span class="number">1000</span>);</span><br><span class="line">      allow_delay = <span class="literal">false</span>;  <span class="comment">// Do not delay a single write more than once</span></span><br><span class="line">      mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先当 Level 0 文件数量接近 kL0_SlowdownWritesTrigger&#x3D;8 阈值时，<strong>暂时释放锁，延迟 1 毫秒，以减缓写入速度</strong>。当然这里只允许延迟一次，避免长时间阻塞单个写入。这里之所以设置一个小的 Level 0 文件数量阈值，是为了防止 Level 0 文件太多后，到达系统瓶颈后，后续写入卡太长时间。在没到瓶颈前，就开始把延迟平摊到每个请求上，从而减缓压力。这里的注释也写的很清楚，上面也都贴出来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line">           (mem_-&gt;<span class="built_in">ApproximateMemoryUsage</span>() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line">  <span class="comment">// There is room in current memtable</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>接着这里判断如果当前 memtable 的使用量没超过最大容量，就直接返回了。这里 write_buffer_size 是 memtable 的最大容量，默认是 4MB。这里可以调整配置，如果大一点的话，会在内存缓存更多数据，提高写入的性能，但是会占用更多内存，并且下次打开 db 的时候，恢复时间也会更长些。</p><p>接下来有两种情况，是当前没有地方可以写入，因此需要等待了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// We have filled up the current memtable, but the previous</span></span><br><span class="line">  <span class="comment">// one is still being compacted, so we wait.</span></span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Current memtable full; waiting...\n&quot;</span>);</span><br><span class="line">  background_work_finished_signal_.<span class="built_in">Wait</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;<span class="built_in">NumLevelFiles</span>(<span class="number">0</span>) &gt;= config::kL0_StopWritesTrigger) &#123;</span><br><span class="line">  <span class="comment">// There are too many level-0 files.</span></span><br><span class="line">  <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Too many L0 files; waiting...\n&quot;</span>);</span><br><span class="line">  background_work_finished_signal_.<span class="built_in">Wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种情况是不可变的 memtable 还在写入中，因此需要等待它写入完成。LevelDB 会维护两个 memtable，一个是当前可以写入的 memtable mem_，一个是不可变的 memtable imm_。每次写满一个 mem_ 后，就会把它转为 imm_ 然后刷数据到磁盘。如果 imm_ 还没完成刷磁盘，那么就必须等待刷完后才能把现有的 mem_ 转为新的 imm_。</p><p>第二种情况是 Level 0 文件数量太多，需要等待压缩完成。LevelDB 配置了 Level 0 文件数量的阈值 kL0_StopWritesTrigger，默认是 12，当 Level 0 文件数量超过这个阈值时，那么当前写入请求就需要等待。因为 Level 0 层的文件之间没有全局排序的保证，多个 Level 0 文件可能包含重叠的键范围。对于读来说，查询操作需要在所有 L0 文件中查找，文件数量过多会增加读取延迟。对于写来说，文件数量多，后台压缩的工作量也会增加，影响整体系统性能。所以这里强制控制 Level 0 的文件数量，达到阈值后就直接不给写入。</p><p>接下来的情况就是不可变的 imm_ 为空，同时 mem_ 也没足够空间，这时候要做的事情比较多：</p><ol><li><strong>创建新日志文件</strong>：生成新的日志文件号，并尝试创建新的 writable file 作为 WAL（Write-Ahead Log）。如果失败，重用文件号并退出循环，返回错误状态。</li><li><strong>关闭旧日志文件</strong>：关闭当前日志文件。如果关闭失败，记录后台错误，阻止后续写入操作。</li><li><strong>更新日志文件指针</strong>：设置新的日志文件指针，更新日志编号，创建新的 log::Writer 进行写入。</li><li><strong>转换 memtable</strong>：将当前 memtable 转换为不可变 memtable（imm_），并创建新的 memtable 进行写入。通过 has_imm_.store(true, std::memory_order_release) 标记有不可变 memtable 存在。</li><li>触发后台压缩：调用 MaybeScheduleCompaction()，触发后台压缩任务，处理不可变 memtable。</li></ol><p>这里可以看到 <strong>memtable 和 WAL 文件一一对应的，每个 memtable 对应一个 WAL 文件，WAL 文件记录写入 memtable 的所有操作，当 memtable 满时，同时切换 WAL 文件</strong>。同一时刻，前台 memtable 和新的 WAL 日志文件处理新的请求，同时后台的 imm_ 和旧的 WAL 文件处理压缩任务。等压缩完成，就可以删除旧的 WAL 文件了。</p><h3 id="合并写入任务"><a href="#合并写入任务" class="headerlink" title="合并写入任务"></a>合并写入任务</h3><p>接着是合并写入的逻辑，<a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1224">核心代码</a>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> last_sequence = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">Writer* last_writer = &amp;w;</span><br><span class="line"><span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; updates != <span class="literal">nullptr</span>) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">  WriteBatch* write_batch = <span class="built_in">BuildBatchGroup</span>(&amp;last_writer);</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">  last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">// ... 具体写入到 WAL 和 memtable </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">  versions_-&gt;<span class="built_in">SetLastSequence</span>(last_sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是获取当前全局的 sequence 值，这里 <strong>sequence 用来记录写入键值对的版本号，全局单调递增</strong>。每个写入请求都会被分配一个唯一的 sequence 值，通过版本号机制来实现 MVCC 等特性。在写入当前批次键值对的时候，会先设置 sequence 值，写入成功后，还会更新 last_sequence 值。</p><p>为了<strong>提高写入并发性能，每次写入的时候，不止需要写队首的任务，还会尝试合并队列中后续的写入任务</strong>。这里合并的逻辑放在 <a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1280">BuildBatchGroup</a> 中，主要是遍历整个写入队列，<strong>在控制整体批次的大小，以及保证刷磁盘的级别情况下，不断把队列后面的写入任务合并到队首的写入任务</strong>中。整体构建好的写入批次，会放到一个临时的对象 tmp_batch_ 中，在完整的写入操作完成后，会清空 tmp_batch_ 对象。</p><p>我们提到的每个写入任务其实封装为了一个 WriteBatch 对象，该类的实现支持了不同写入任务合并，以及获取任务的大小等。相关细节实现可以参考我前面的文章 <a href="https://selfboot.cn/2025/01/13/leveldb_source_write_batch/">LevelDB 源码阅读：如何优雅地合并写入和删除操作</a>。</p><p>上面代码其实忽略了核心的写入到 WAL 和 memtable 的逻辑，下面来看看这部分的实现。</p><h3 id="写入到-WAL-和-memtable"><a href="#写入到-WAL-和-memtable" class="headerlink" title="写入到 WAL 和 memtable"></a>写入到 WAL 和 memtable</h3><p>LevelDB 中写入键值对，会先写 WAL 日志，然后写入到 memtable 中。WAL 日志是 LevelDB 中实现数据恢复的关键，memtable 则是 LevelDB 中实现内存缓存和快速查询的关键。写入关键代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line"><span class="comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line"><span class="comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line"><span class="comment">// into mem_.</span></span><br><span class="line">&#123;</span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">  status = log_-&gt;<span class="built_in">AddRecord</span>(WriteBatchInternal::<span class="built_in">Contents</span>(write_batch));</span><br><span class="line">  <span class="type">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; options.sync) &#123;</span><br><span class="line">    status = logfile_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      sync_error = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    status = WriteBatchInternal::<span class="built_in">InsertInto</span>(write_batch, mem_);</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  <span class="keyword">if</span> (sync_error) &#123;</span><br><span class="line">    <span class="comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">    <span class="comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">    <span class="comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">    <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<strong>在写入到 WAL 和 memtable 的时候，会先释放 mutex_ 互斥锁，写入完成后，再重新加锁</strong>。注释也专门解释了下，因为当前队首 <code>&amp;w</code> 正在负责写入 WAL 和 memtable，后续的写入调用，可以拿到 mutex_ 互斥锁，因此可以完成入队操作。但是因为不是队首，需要等在条件变量上，只有当前任务处理完成，才有机会执行。所以<strong>写入 WAL 和 memtable 的过程，虽然释放了锁，但整体还是串行化写入的</strong>。WAL 和 memtable 本身也不需要保证线程安全。</p><p>不过因为写 WAL 和 memtable 相对耗时，释放锁之后，其他需要用到 mutex_ 的地方，都可以拿到锁继续执行了，整体提高了系统的并发。</p><p>WAL（Write-Ahead Logging）是一种日志记录机制，它允许在数据写入磁盘之前，先记录日志。<strong>WAL 日志是追加写入，磁盘的顺序 IO 性能优于随机 IO 性能，因此追加写入一般效率比较高</strong>。写入 WAL 成功后，再把数据放到 memtable 中，memtable 是内存结构，写入效率也很高，等在内存积累到一定量级，再写入磁盘。如果系统崩溃重启，内存中 memtable 的数据可能会丢失，但是通过 WAL 日志，可以重放写入操作，从而恢复数据状态，确保数据的完整性。</p><p>这里具体写入，只是简单的调用 log::Writer 对象 log_ 的 AddRecord 方法来写入 WriteBatch 数据。log::Writer 会把这里的数据进行组织，然后在适当的时机写入磁盘，详细实现可以参考我前面的文章<a href="https://selfboot.cn/2024/08/14/leveldb_source_wal_log/">LevelDB 源码阅读：读写 WAL 日志保证持久性</a>。</p><p>当然，如果写入的时候带了 sync&#x3D;true，那么这里写入 WAL 成功后，会调用 logfile_-&gt;Sync() 方法，强制刷磁盘。这里稍微补充说明下，这里<strong>往文件里写内容是会通过系统调用 <code>write</code> 来完成，这个系统调用返回成功，并不保证数据一定被写入磁盘。文件系统一般会把数据先放到缓冲区，然后根据情况，选择合适的时机刷到磁盘中</strong>。要保证一定刷到磁盘中去，则需要另外的系统调用，不同平台有不同的接口，具体可以参考我之前的文章<a href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/">LevelDB 源码阅读：Posix 文件操作接口实现细节</a>。</p><p>如果强制刷磁盘过程发生错误，那么这里会调用 RecordBackgroundError 方法，记录错误状态到 bg_error_ 中，这样后续所有的写入操作都会返回失败。</p><p>在写入 WAL 成功后，就可以写入 memtable 了。这里调用 WriteBatchInternal::InsertInto 方法，把 WriteBatch 数据插入到 memtable 中。关于 memtable 的实现，我后面文章会详细介绍。</p><h3 id="更新批次写任务的状态"><a href="#更新批次写任务的状态" class="headerlink" title="更新批次写任务的状态"></a>更新批次写任务的状态</h3><p>写入批次完成后，就需要更新批次写任务的状态，从 writers_ 队列的前端取出最先入队的 Writer 对象，然后开始遍历，直到批次中的最后一个写入任务。这里更新所有已经完成任务的状态，然后唤醒所有等待的写入任务。<a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1259">核心实现</a>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  Writer* ready = writers_.<span class="built_in">front</span>();</span><br><span class="line">  writers_.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="keyword">if</span> (ready != &amp;w) &#123;</span><br><span class="line">    ready-&gt;status = status;</span><br><span class="line">    ready-&gt;done = <span class="literal">true</span>;</span><br><span class="line">    ready-&gt;cv.<span class="built_in">Signal</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ready == last_writer) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify new head of write queue</span></span><br><span class="line"><span class="keyword">if</span> (!writers_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  writers_.<span class="built_in">front</span>()-&gt;cv.<span class="built_in">Signal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后如果队列中还有写入任务，则需要唤醒队首的写入任务，继续处理。至此整个写入处理完毕，可以返回给调用方写入的结果了。</p><h2 id="其他工程实现细节"><a href="#其他工程实现细节" class="headerlink" title="其他工程实现细节"></a>其他工程实现细节</h2><p>整个写入过程到此分析完了，不过还有些工程实现细节，值得一起看看。</p><h3 id="混合-sync-和非-sync-写入"><a href="#混合-sync-和非-sync-写入" class="headerlink" title="混合 sync 和非 sync 写入"></a>混合 sync 和非 sync 写入</h3><p>如果有一批写入请求，其中既有 sync 又有非 sync 的写入，那么 LevelDB 内部会怎么处理呢？</p><p>前面分析可以看到每次取出队首的写入任务后，会尝试合并队列中后续的写入任务。因为每个写入任务可以强制 sync 刷磁盘，也可以不刷，合并的时候，怎么处理这种混合不同 sync 配置的写入任务呢？</p><p>这里配置 <strong>sync&#x3D;true 的时候写入会强制刷磁盘，对于合并后的批次写入，取得是队首的 sync</strong>。<a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1237">核心代码</a>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; updates != <span class="literal">nullptr</span>) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">      mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">      status = log_-&gt;<span class="built_in">AddRecord</span>(WriteBatchInternal::<span class="built_in">Contents</span>(write_batch));</span><br><span class="line">      <span class="type">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; options.sync) &#123;</span><br><span class="line">        status = logfile_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          sync_error = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，如果队首是的任务是不需要刷磁盘，那么合并的时候，就不能合并 sync&#x3D;true 的写入任务。<a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1302">核心实现代码</a>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; iter != writers_.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">  Writer* w = *iter;</span><br><span class="line">  <span class="keyword">if</span> (w-&gt;sync &amp;&amp; !first-&gt;sync) &#123;</span><br><span class="line">    <span class="comment">// Do not include a sync write into a batch handled by a non-sync write.</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过如果队首是 sync&#x3D;true 的写入任务，那么合并的时候，就不需要考虑被合并的写入任务的 sync 设置。因为整个合并后的批次，都会被强制刷磁盘。这样就<strong>可以保证不会降低写入的持久化保证级别，但是可以适当提升写入的持久化保证级别</strong>。当然这里提升写入的持久化级别保证，其实也并不会导致整体耗时上涨，因为这里队首一定要刷磁盘，顺带着多一点不需要刷磁盘的写入任务，也不会导致耗时上涨。</p><h3 id="优化大批量小-key-写入延迟"><a href="#优化大批量小-key-写入延迟" class="headerlink" title="优化大批量小 key 写入延迟"></a>优化大批量小 key 写入延迟</h3><p>上面实现可以看到，如果大批量并发写入的时候，写入请求会先被放入队列中，然后串行化写入。如果写入的 key 都比较小，那么从队首取出一个写入任务，然后和当前队列中的其他写入合并为一个批次。合并的时候，需要设置一个 max_size 来限制合并的 key 数量，那么这里 max_size 要设置多少合理呢？</p><p>这里 LevelDB 给了一个经验值，默认是 1 &lt;&lt; 20 个字节。但是考虑一个场景，如果写入的 key 都比较小，合并的时候，可能会合并很多 key，从而导致写入耗时变长。<strong>由于是小 key 的写入，写入耗时长的话，体验上来并不好</strong>。</p><p>所以这里加了个小优化，如果当前队首写入任务的整体 size 小于 128 &lt;&lt; 10 个字节，那么这里 max_size 就会小很多。当然，这个值应该也只是经验值，我也没找到官方具体的说明。相关代码在<br> <a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1289">BuildBatchGroup</a> 中：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allow the group to grow up to a maximum size, but if the</span></span><br><span class="line"><span class="comment">// original write is small, limit the growth so we do not slow</span></span><br><span class="line"><span class="comment">// down the small write too much.</span></span><br><span class="line"><span class="type">size_t</span> max_size = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= (<span class="number">128</span> &lt;&lt; <span class="number">10</span>)) &#123;</span><br><span class="line">  max_size = size + (<span class="number">128</span> &lt;&lt; <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入-WAL-成功，但是-memtable-失败"><a href="#写入-WAL-成功，但是-memtable-失败" class="headerlink" title="写入 WAL 成功，但是 memtable 失败"></a>写入 WAL 成功，但是 memtable 失败</h3><p>写入过程，会先写入 WAL 日志，写成功后，才写 memtable。但这两个写入并不是原子的，如果写 WAL 失败，不回写 memtable，并且会阻塞后续所有的写入，这样是合理的，也不会有问题。</p><p>但是如果写入 WAL 日志成功，但是写入 memtable 失败的话，返回给调用方的状态是写入失败，调用可能认为写失败。但是 WAL 成功写入，并且其他流程都是正常执行，也更新了全局的 sequence。<strong>万一这时候故障，从 WAL 恢复数据的时候，会把写 memtable 失败的也恢复，这样就导致调用方认为写失败的数据，其实成功写入了</strong>。</p><p>这里自己暂时还没彻底搞明白，可能是 LevelDB 的潜在 bug，也可能是自己对整体代码还没理解透。这里尝试用 GPT O1 和 Deepseek 的 R1 深度思考分析了下，都倾向这里是 bug。Deepseek 给的思考过程也比较有意思：</p><blockquote><p>我需要确认在LevelDB的实际运行中，这种情况发生的概率有多大。MemTable的写入失败通常可能由什么原因引起？比如内存不足，或者其他不可恢复的错误？如果是暂时性的错误，LevelDB是否有重试机制？</p><p>另外，查看LevelDB的官方文档或相关讨论，是否有提到这种情况的处理方式。比如，是否在写入MemTable失败时，LevelDB会主动删除或无效化对应的WAL记录？</p><p>可能还需要考虑数据库恢复流程。当LevelDB重启时，会读取WAL并重新构建MemTable。如果某个WAL记录对应的写入在MemTable失败，但WAL存在，恢复时会再次尝试写入MemTable。如果此时条件允许（比如内存足够），写入可能成功，导致不一致。但如果原来的失败是持久性的（如数据结构错误），恢复时可能再次失败，导致数据库无法打开，从而避免不一致。</p><p>此外，用户的问题是否假设了某些特定场景？例如，MemTable写入失败但数据库没有崩溃，之后正常关闭，这时候WAL未被清除，恢复时重新应用。这种情况是否可能？</p></blockquote><p>AI 现在的深度思考能力，逻辑推理的能力还是非常强的，考虑问题比较全面。这里也欢迎读者留言讨论这个问题哈。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章有点长，这里简单总结下吧。LevelDB 的写入操作设计充分考虑了高并发和性能优化，通过一系列精巧的机制实现了高效的键值对写入。下面是一些值得借鉴的设计：</p><ol><li><p><strong>批量合并写入</strong>: LevelDB 通过 Writer 队列将多个写入请求合并处理，避免了频繁的磁盘 IO。每个写入请求会被放入队列，队列头部的写入请求负责合并后续请求，形成一个大的 WriteBatch。这种设计显著提高了吞吐量，尤其适合高并发的小键值对写入场景。</p></li><li><p><strong>WAL 日志处理崩溃恢复</strong>: WAL（Write-Ahead Log）：所有写入操作首先顺序写入 WAL 日志，确保数据持久性。写入 WAL 后才更新内存中的 MemTable，这种 “先日志后内存” 的设计是 LevelDB 崩溃恢复的基石。</p></li><li><p><strong>内存双缓冲机制</strong>: 当 MemTable 写满后，会转换为 Immutable MemTable 并触发后台压缩，同时创建新的 MemTable 和 WAL 文件。这<strong>种双缓冲机制避免了写入阻塞，实现了平滑的内存-磁盘数据流转</strong>。</p></li><li><p><strong>写入限流与自适应延迟</strong>: 通过 kL0_SlowdownWritesTrigger 和 kL0_StopWritesTrigger 阈值，在 Level 0 文件过多时主动引入写入延迟或暂停写入。这种 “软限流” 策略避免了系统过载后的雪崩效应。</p></li><li><p><strong>动态批次合并</strong>: 根据当前队列头部请求的大小，动态调整合并批次的最大尺寸（如小请求合并 128KB，大请求合并 1MB），在吞吐量和延迟之间取得平衡。</p></li><li><p><strong>条件变量唤醒机制</strong>: 通过 CondVar 实现高效的线程等待-通知，确保合并写入时不会长时间阻塞后续请求。</p></li><li><p><strong>混合 Sync 处理</strong>: 支持同时处理需要强制刷盘（sync&#x3D;true）和非强制刷盘的请求，优先保证队首请求的持久化级别，避免降低数据安全性。</p></li><li><p><strong>错误隔离</strong>: WAL 写入失败会标记全局错误状态 bg_error_，直接拒绝掉所有后续写请求，防止数据不一致。</p></li></ol><p>最后，欢迎大家留言讨论，一起学习 LevelDB 的实现细节。</p>]]></content>
    
    
    <summary type="html">本文深入剖析LevelDB的写入机制，详解从Put接口到WAL日志、MemTable落盘的全流程。通过源码解析揭示LevelDB实现40万次/秒高吞吐写入的奥秘：WriteBatch批量合并策略、双MemTable内存管理、WAL顺序写优化、Level0文件数动态限流等核心技术。探讨混合sync写入处理、小键值合并优化、异常场景数据一致性等工程细节，带你掌握LevelDB高性能写入的设计精髓与实现策略。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：如何优雅地合并写入和删除操作</title>
    <link href="https://selfboot.cn/2025/01/13/leveldb_source_write_batch/"/>
    <id>https://selfboot.cn/2025/01/13/leveldb_source_write_batch/</id>
    <published>2025-01-13T22:00:00.000Z</published>
    <updated>2025-07-15T13:42:45.600Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 支持写入单个键值对和批量写入多个键值对，这两种操作的处理流程本质上是相同的，都会被封装进一个 WriteBatch 对象中，这样就可以提高写操作的效率。</p><p>在 LevelDB 中，WriteBatch 是通过一个简单的数据结构实现的，其中包含了一系列的写入操作。这些操作被序列化（转换为字节流）并存储在内部的一个字符串中。每个操作都包括操作类型（如插入或删除），键和值（对于插入操作）。</p><p>当 WriteBatch 被提交给数据库时，其内容被解析并应用到 WAL 日志和 memtable 中。不管 WriteBatch 中包含多少操作，它们都将作为一个整体进行处理和日志记录。</p><span id="more"></span><p>WriteBatch 的实现主要涉及到 4 个文件，接下来一起看看。</p><ol><li><a href="https://github.com/google/leveldb/blob/main/include/leveldb/write_batch.h">include&#x2F;leveldb&#x2F;write_batch.h</a>：对外暴露的接口文件，定义了 WriteBatch 类的接口。</li><li><a href="https://github.com/google/leveldb/blob/main/db/write_batch_internal.h">db&#x2F;write_batch_internal.h</a>：内部实现文件，定义了 WriteBatchInternal 类，提供了一些操作 WriteBatch 的方法。</li><li><a href="https://github.com/google/leveldb/blob/main/db/write_batch.cc">db&#x2F;write_batch.cc</a>：WriteBatch 类的实现文件，实现了 WriteBatch 类。</li><li><a href="https://github.com/google/leveldb/blob/main/db/write_batch_test.cc">db&#x2F;write_batch_test.cc</a>：WriteBatch 类的测试文件，用于测试 WriteBatch 的功能。</li></ol><h2 id="WriteBatch-接口设计"><a href="#WriteBatch-接口设计" class="headerlink" title="WriteBatch 接口设计"></a>WriteBatch 接口设计</h2><p>我们先来看 write_batch.h 文件，这里定义了 WriteBatch 类对外暴露的一些接口。 LevelDB 代码中的注释十分清晰，不过这里先省略注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> WriteBatch &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> Handler &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Handler</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WriteBatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Intentionally copyable.</span></span><br><span class="line">  <span class="built_in">WriteBatch</span>(<span class="type">const</span> WriteBatch&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  WriteBatch&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WriteBatch&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">WriteBatch</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">ApproximateSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> WriteBatch&amp; source)</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">Iterate</span><span class="params">(Handler* handler)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteBatchInternal</span>;</span><br><span class="line"></span><br><span class="line">  std::string rep_;  <span class="comment">// See comment in write_batch.cc for the format of rep_</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/write_batch.h#L35">WriteBatch::Handler</a> 是一个抽象基类，定义了处理键值对操作的接口，只包括 Put 和 Delete 方法。这样的设计允许 WriteBatch 类实现与<strong>具体存储操作</strong>解耦，使得 WriteBatch 不必直接知道如何将操作应用到底层存储（如 MemTable）。</p><p><strong>通过继承 Handler 类，可以创建多种处理器，它们可以以不同的方式实现这些方法</strong>。比如：</p><ol><li>MemTableInserter： 定义在 db&#x2F;write_batch.cc 中，将键值操作存储到 MemTable 中。</li><li>WriteBatchItemPrinter：定义在 db&#x2F;dumpfile.cc 中，将键值操作打印到文件中，可以用来测试。</li></ol><p>另外还有一个 <code>friend class WriteBatchInternal</code> 作为 WriteBatch 的友元类，能够访问其私有和受保护成员。<strong>WriteBatchInternal 主要用来封装一些内部操作，这些方法不需要对外暴露，只在内部用到。通过将内部操作方法隐藏在 WriteBatchInternal 中，保持了对象的接口清晰，可以自由地修改内部实现而不影响到使用这些对象的代码</strong>。</p><h3 id="WriteBatch-使用方法"><a href="#WriteBatch-使用方法" class="headerlink" title="WriteBatch 使用方法"></a>WriteBatch 使用方法</h3><p>在应用层，我们可以通过 WriteBatch 来批量写入多个键值对，然后通过 <code>DB::Write</code> 方法将 WriteBatch 写入到数据库中。</p><p>这里 WriteBatch 支持 Put 和 Delete 操作，可以合并多个 WriteBatch。如下使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WriteBatch batch;</span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">batch.<span class="built_in">Delete</span>(<span class="string">&quot;key3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并另一个批次</span></span><br><span class="line">WriteBatch another_batch;</span><br><span class="line">another_batch.<span class="built_in">Put</span>(<span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>);</span><br><span class="line">batch.<span class="built_in">Append</span>(another_batch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据库</span></span><br><span class="line">db-&gt;<span class="built_in">Write</span>(writeOptions, &amp;batch);</span><br></pre></td></tr></table></figure><h2 id="WriteBatch-实现细节"><a href="#WriteBatch-实现细节" class="headerlink" title="WriteBatch 实现细节"></a>WriteBatch 实现细节</h2><p>那么 WriteBatch 是怎么实现的呢？关键在 <a href="https://github.com/google/leveldb/blob/main/db/write_batch.cc">db&#x2F;write_batch.cc</a>，该类中有一个 private 成员 <code>std::string rep_</code> 来存储序列化后的键值操作。我们先来看看这里的存储数据协议：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------------+----------------------------------------+</span><br><span class="line">|<span class="string">   Sequence    </span>|<span class="string">     Count     </span>|<span class="string">                Data                    </span>|</span><br><span class="line">|<span class="string">  (8 bytes)    </span>|<span class="string">   (4 bytes)   </span>|<span class="string">                                        </span>|</span><br><span class="line">+---------------+---------------+----------------------------------------+</span><br><span class="line">                                   |<span class="string">                 </span>|<span class="string">                   </span>|</span><br><span class="line">                                   v                 v                   v</span><br><span class="line">                               +-------+         +-------+          +-------+</span><br><span class="line">                               |<span class="string">Record1</span>|<span class="string">         </span>|<span class="string">Record2</span>|<span class="string">   ...    </span>|<span class="string">RecordN</span>|</span><br><span class="line">                               +-------+         +-------+          +-------+</span><br><span class="line">                                  |<span class="string">                 </span>|</span><br><span class="line">                                  v                 v</span><br><span class="line">                        +-----------------+ +-----------------+</span><br><span class="line">                        |<span class="string"> kTypeValue      </span>|<span class="string"> </span>|<span class="string"> kTypeDeletion   </span>|</span><br><span class="line">                        |<span class="string"> Varstring Key   </span>|<span class="string"> </span>|<span class="string"> Varstring Key   </span>|</span><br><span class="line">                        |<span class="string"> Varstring Value </span>|<span class="string"> </span>|<span class="string">                 </span>|</span><br><span class="line">                        +-----------------+ +-----------------+</span><br><span class="line">                        </span><br><span class="line">Varstring (可变长度字符串):</span><br><span class="line">+-------------+-----------------------+</span><br><span class="line">|<span class="string"> Length (varint32) </span>|<span class="string"> Data (uint8[])  </span>|</span><br><span class="line">+-------------+-----------------------+</span><br></pre></td></tr></table></figure><p>该字符串前 12 个字节是头部元数据部分，包括 8 个字节的序列号和 4 个字节的 count 数。接下来是一个或多个操作记录，每个记录包含一个操作类型和键值对。操作类型是一个字节，可以是 Put 或者 Delete 操作。键和值都是可变长度的字符串，格式为 varstring。</p><h3 id="LevelDB-的序列号机制"><a href="#LevelDB-的序列号机制" class="headerlink" title="LevelDB 的序列号机制"></a>LevelDB 的序列号机制</h3><p>rep_ 头部 8 个字节代表64位的数字 sequence（序列号），WriteBatchInternal 友元类提供了两个方法来获取和设置 sequence number，内部是用 <a href="https://selfboot.cn/2024/08/29/leveldb_source_utils/#%E6%95%B4%E6%95%B0%E7%BC%96%E3%80%81%E8%A7%A3%E7%A0%81">EncodeFixed64 和 DecodeFixed64</a> 方法来编解码 64 位的序列号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SequenceNumber <span class="title">WriteBatchInternal::Sequence</span><span class="params">(<span class="type">const</span> WriteBatch* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SequenceNumber</span>(<span class="built_in">DecodeFixed64</span>(b-&gt;rep_.<span class="built_in">data</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::SetSequence</span><span class="params">(WriteBatch* b, SequenceNumber seq)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(&amp;b-&gt;rep_[<span class="number">0</span>], seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>序列号是 LevelDB 中的全局递增标识符，用于实现版本控制和操作排序</strong>。每个 WriteBatch 在执行时会获得一段连续的序列号，批次内的每个操作（Put&#x2F;Delete）都会分配到其中的一个序列号。序列号在 LevelDB 中有三个核心作用：</p><ol><li><strong>版本控制</strong>：LevelDB 中的每个 key 可以有多个版本，每个版本都对应一个序列号。在读取时，通过比较序列号来确定应该返回哪个版本的值。较大的序列号表示更新的版本。</li><li><strong>多版本并发控制（MVCC）</strong>：写操作获取新的序列号，创建 key 的新版本。读操作可以指定序列号，访问该序列号时间点的数据快照。这种机制使得读写操作可以并发执行，无需互相阻塞。</li><li><strong>故障恢复</strong>：WAL（预写日志）中记录了操作的序列号。系统重启时，通过序列号可以准确重建崩溃时的数据状态，避免重复应用已持久化的操作。</li></ol><p>这种设计让 LevelDB 既保证了数据一致性，又实现了高效的并发控制。</p><p>设置序列号的逻辑在 <a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L1222">DBImpl::Write</a> 方法中，首先获取当前最大序列号，然后为 WriteBatch 分配一个新的序列号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">uint64_t</span> last_sequence = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; updates != <span class="literal">nullptr</span>) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">    WriteBatch* write_batch = <span class="built_in">BuildBatchGroup</span>(&amp;last_writer);</span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">    last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 WriteBatch 包含多个操作，那么这些操作会<strong>连续地分配序列号</strong>。在写入 WAL 日志时，会将 WriteBatch 的序列号写入到日志中，这样在恢复时可以根据序列号来恢复操作的顺序。写入 memtable 之后，会更新当前最大序列号，以便下次分配。</p><h3 id="count-记录操作数"><a href="#count-记录操作数" class="headerlink" title="count 记录操作数"></a>count 记录操作数</h3><p>头部还有 4 个字节的 count，用于记录 WriteBatch 中包含的操作数。这里每次 put 或者 delete 操作都会增加 count 的值。如下示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WriteBatch batch;</span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);  <span class="comment">// count = 1</span></span><br><span class="line">batch.<span class="built_in">Put</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);  <span class="comment">// count = 2</span></span><br><span class="line">batch.<span class="built_in">Delete</span>(<span class="string">&quot;key3&quot;</span>);         <span class="comment">// count = 3</span></span><br><span class="line"><span class="type">int</span> num_ops = WriteBatchInternal::<span class="built_in">Count</span>(&amp;batch);  <span class="comment">// = 3</span></span><br></pre></td></tr></table></figure><p>在合并两个 WriteBatch 的时候，也会累计两部分的 count 的值，如下 <a href="https://github.com/google/leveldb/blob/main/db/write_batch.cc#L144">WriteBatchInternal::Append</a> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::Append</span><span class="params">(WriteBatch* dst, <span class="type">const</span> WriteBatch* src)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetCount</span>(dst, <span class="built_in">Count</span>(dst) + <span class="built_in">Count</span>(src));</span><br><span class="line">  <span class="built_in">assert</span>(src-&gt;rep_.<span class="built_in">size</span>() &gt;= kHeader);</span><br><span class="line">  dst-&gt;rep_.<span class="built_in">append</span>(src-&gt;rep_.<span class="built_in">data</span>() + kHeader, src-&gt;rep_.<span class="built_in">size</span>() - kHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 count 的地方主要有两个，一个是在迭代这里每个记录的时候，会用 <a href="https://github.com/google/leveldb/blob/main/db/write_batch.cc#L75">count 来做完整性检查</a>，确保没有遗漏操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatch::Iterate</span><span class="params">(Handler* handler)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">Slice <span class="title">input</span><span class="params">(rep_)</span></span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (found != WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;WriteBatch has wrong count&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个是在 db 写入的时候，根据 count 可以预先知道需要分配多少序列号，保证序列号连续性。如下 <a href="https://github.com/google/leveldb/blob/main/db/db_impl.cc#L449">DBImpl::Write</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch);</span><br></pre></td></tr></table></figure><h3 id="支持的各种操作"><a href="#支持的各种操作" class="headerlink" title="支持的各种操作"></a>支持的各种操作</h3><p>在头部的 sequence 和 count 之后，rep_ 紧跟着的是一系列的记录，每个记录包含一个操作类型和键值。这里记录可以通过 Put 和 Delete 方法来添加，其中 Put 方法的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeValue));</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新了 count，然后添加了 kTypeValue 操作类型，接着是添加 key 和 value。Delete 操作类似，count 计数也是要加 1，然后操作类型是 kTypeDeletion，最后只用添加 key 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatch::Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeDeletion));</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是往 rep_ 中添加记录，那么如何从 rep_ 中解析出这些记录呢？这里 WriteBatch 类中提供了一个 <a href="https://github.com/google/leveldb/blob/main/db/write_batch.cc#L42">Iterate</a> 方法，该方法遍历 rep_ 中的每条记录，然后通过传入的 Handler 接口来灵活处理这些记录。 </p><p>此外该方法的实现中还有<strong>数据格式验证，会检查头部大小、操作类型、操作数量是否匹配</strong>。可以返回 Corruption 错误，表示数据格式不正确等。Iterate 核心代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatch::Iterate</span><span class="params">(Handler* handler)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">Slice <span class="title">input</span><span class="params">(rep_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (input.<span class="built_in">size</span>() &lt; kHeader) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;malformed WriteBatch (too small)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  input.<span class="built_in">remove_prefix</span>(kHeader);</span><br><span class="line">  Slice key, value;</span><br><span class="line">  <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!input.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    found++;</span><br><span class="line">    <span class="type">char</span> tag = input[<span class="number">0</span>];</span><br><span class="line">    input.<span class="built_in">remove_prefix</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> kTypeValue:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key) &amp;&amp;</span><br><span class="line">            <span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;value)) &#123;</span><br><span class="line">          handler-&gt;<span class="built_in">Put</span>(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad WriteBatch Put&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key)) &#123;</span><br><span class="line">          handler-&gt;<span class="built_in">Delete</span>(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad WriteBatch Delete&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;unknown WriteBatch tag&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面提过 Handler 是 WriteBatch 的抽象基类，可以传入不同的实现。在 LevelDB 写数据的时候，这里传入的是 MemTableInserter 类，该类将操作数据存储到 MemTable 中。具体可以调用这里的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatchInternal::InsertInto</span><span class="params">(<span class="type">const</span> WriteBatch* b, MemTable* memtable)</span> </span>&#123;</span><br><span class="line">  MemTableInserter inserter;</span><br><span class="line">  inserter.sequence_ = WriteBatchInternal::<span class="built_in">Sequence</span>(b);</span><br><span class="line">  inserter.mem_ = memtable;</span><br><span class="line">  <span class="keyword">return</span> b-&gt;<span class="built_in">Iterate</span>(&amp;inserter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体上看 WriteBatch 负责存储键值操作的数据，进行编码解码等，而 Handler 负责具体处理里面的每条数据。这样 WriteBatch 的操作就可以被灵活地应用到不同场景中，方便扩展。</p><h2 id="测试用例分析"><a href="#测试用例分析" class="headerlink" title="测试用例分析"></a>测试用例分析</h2><p>最后再来看看 <a href="https://github.com/google/leveldb/blob/main/db/write_batch_test.cc">write_batch_test.cc</a>，这里提供了一些测试用例，用于测试 WriteBatch 的功能。</p><p>首先定义了一个 PrintContents 函数，用来输出 WriteBatch 中的所有操作记录。这里用 MemTableInserter 将 WriteBatch 中的操作记录存储到 MemTable 中，然后通过 MemTable 的迭代器遍历所有记录，并保存到字符串中。</p><p>这里测试用例覆盖了下面这些情况：</p><ol><li>Empty：测试空的 WriteBatch 是否正常；</li><li>Multiple：测试多个 Put 和 Delete 操作，验证总的 count 数目和每个操作的序列号是否正确；</li><li>Corruption：先写进去数据，然后故意截断部分记录，测试能读取尽量多的正常数据；</li><li>Append：测试合并两个 WriteBatch，验证合并后序列号的正确性，以及合并空 WriteBatch；</li><li>ApproximateSize：测试 ApproximateSize 方法，计算 WriteBatch 的近似大小；</li></ol><p>这里通过测试用例，基本就能知道怎么使用 WriteBatch 了。比较有意思的是，前面在看 Append 代码的时候，没太留意到合并后这里序列号是用谁的。这里结合测试用例，才发现取的目标 WriteBatch 的序列号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(WriteBatchTest, Append) &#123;</span><br><span class="line">  WriteBatch b1, b2;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetSequence</span>(&amp;b1, <span class="number">200</span>);</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetSequence</span>(&amp;b2, <span class="number">300</span>);</span><br><span class="line">  b<span class="number">1.</span><span class="built_in">Append</span>(b2);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;&quot;</span>, <span class="built_in">PrintContents</span>(&amp;b1));</span><br><span class="line">  b<span class="number">2.</span><span class="built_in">Put</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;va&quot;</span>);</span><br><span class="line">  b<span class="number">1.</span><span class="built_in">Append</span>(b2);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;Put(a, va)@200&quot;</span>, <span class="built_in">PrintContents</span>(&amp;b1));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过深入分析 LevelDB 的 WriteBatch 实现，我们可以清晰地看到其设计精妙之处。WriteBatch 通过将多个写入和删除操作封装在一起，不仅提高了写操作的效率，还简化了并发控制和故障恢复的实现。有几个亮点值得借鉴：</p><ol><li><strong>批量操作</strong>：WriteBatch 允许将多个 Put 和 Delete 操作合并为一个批次，减少了频繁的 I&#x2F;O 操作，提升了写入性能。</li><li><strong>序列号机制</strong>：通过全局递增的序列号，LevelDB 实现了多版本并发控制（MVCC），确保了读写操作的一致性。</li><li><strong>Handler 抽象</strong>：通过 Handler 接口，WriteBatch 将操作的具体实现与存储逻辑解耦，使得代码更加灵活和可扩展。</li><li><strong>数据格式验证</strong>：在解析 WriteBatch 时，LevelDB 会进行严格的数据格式验证，确保数据的完整性和正确性。</li></ol><p>当然本篇只是分析 WriteBatch 的实现，并没有串起 LevelDB 的整个写入流程，后续文章我们会继续分析，写入一个 key 的完整流程。</p>]]></content>
    
    
    <summary type="html">本文深入剖析了 LevelDB 中 WriteBatch 的设计与实现，详细介绍了其如何通过批量写入和删除操作提升性能。文章从 WriteBatch 的接口设计、序列号机制、操作记录存储格式等方面展开，结合源码分析了其核心功能，如序列号的全局递增、操作计数、数据格式验证等。此外，文章还通过测试用例展示了 WriteBatch 的实际使用场景，适合对 LevelDB 或存储系统设计感兴趣的开发者阅读。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  <entry>
    <title>5 个导致 C++ 进程 Crash 的真实业务案例</title>
    <link href="https://selfboot.cn/2025/01/10/c++_crash_cases/"/>
    <id>https://selfboot.cn/2025/01/10/c++_crash_cases/</id>
    <published>2025-01-10T21:00:00.000Z</published>
    <updated>2025-07-15T13:42:45.600Z</updated>
    
    <content type="html"><![CDATA[<p>只要你写过比较复杂的 C++ 项目，应该都或多或少遇见过进程 Coredump 的问题。Coredump 是程序运行过程中发生严重错误时，操作系统将程序当前的内存状态记录下来的一种机制。</p><p>C++ 中导致进程 Coredump 的原因有很多，比如：</p><ol><li><strong>访问非法内存地址</strong>：包括空指针解引用、访问已释放的内存、数组越界访问等；</li><li><strong>栈溢出</strong>：无限递归、大数组分配在栈上；</li><li><strong>段错误</strong>（Segmentation Fault）：试图写入只读内存、访问未映射的内存区域；</li><li><strong>异常未捕获</strong>：未处理的异常导致程序终止；</li></ol><p>遇到 Coredump 问题时，一般需要打开 core 文件，然后根据 core 文件来进行问题分析和调试。分析 core 文件有时候还是比较难的，需要对 C++ 的内存模型、异常处理机制、系统调用等有深入的理解。</p><p>本文不会过多介绍分析 core 文件的方法，而是通过几个真实项目中的案例，来让大家在写代码时候，能够有意识地避免这些错误。</p><span id="more"></span><h2 id="抛异常没有捕获"><a href="#抛异常没有捕获" class="headerlink" title="抛异常没有捕获"></a>抛异常没有捕获</h2><p>业务代码中最常见的导致进程 crash 的原因，就是不小心抛出异常却没有捕获。比如一个字符串转整数的函数中，用了 <a href="https://cplusplus.com/reference/string/stoi/">std::stoi</a> 来转换。但是这里万一字符串没法转成数字，就会抛出 <code>std::invalid_argument</code> 异常。如果框架层或者调用方没有捕获异常，就会导致进程 crash 掉。</p><p>就拿标准库来说，可能抛出异常的函数还是挺多的，常见的有：</p><ul><li>std::vector::at()：如果访问越界，会抛出 <code>std::out_of_range</code> 异常。</li><li>std::vector::push_back()：如果内存分配失败，会抛出 <code>std::bad_alloc</code> 异常。</li><li>std::map::at()：如果访问不存在的 key，会抛出 <code>std::out_of_range</code> 异常。</li></ul><p>在使用这些可能抛出异常的标准库函数的时候，一定要妥善处理好异常。<strong>另外如果是自定义类，不建议抛出异常，可以用错误码来处理。当然对使用异常还是错误码这里一直有争论，可以按照自己比较熟悉或者项目中的惯例来处理就好</strong>。如果是明确不抛出异常的函数，可以加上 noexcept 来告诉编译器和使用方。</p><p>这里再补充说下，有时候有些函数调用不会抛异常，但是会导致<a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">未定义行为</a>，也是可能导致进程 crash 的。比如 <a href="https://cplusplus.com/reference/cstdlib/atoi/?kw=atoi">atoi 函数</a>，如果字符串没法转成数字，这里会导致未定义行为。未定义行为在某些场景下，会导致进程 crash。</p><p>平常在使用一些基础函数的时候，如果对该函数不清楚的话，可以查看 <a href="https://cplusplus.com/">cplusplus</a> 的文档，来确定该函数是否会在某些场景抛异常，是否会导致未定义行为。比如对于 vector ：</p><blockquote><p>std::vector::front()<br> Calling this function on an empty container causes undefined behavior.</p><p>std::vector::push_back()<br> If a reallocation happens, the storage is allocated using the container’s allocator, which may throw exceptions on failure (for the default allocator, bad_alloc is thrown if the allocation request does not succeed).</p></blockquote><h2 id="数组下标访问越界"><a href="#数组下标访问越界" class="headerlink" title="数组下标访问越界"></a>数组下标访问越界</h2><p>除了抛出异常，还有一类问题也比较常见，那就是数组下标访问越界。我们都知道在 C++ 中<strong>访问数组的时候如果下标越界，会导致访问非法内存地址，可能导致进程 crash</strong>。你可能会觉得，怎么会数组访问越界？我遍历的时候限制长度就行了呀。</p><p>别急，看下面来自业务中的真实例子。当然为了演示，这里简化了很多实际业务逻辑，只保留核心部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; src.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 可能是后面加的业务过滤逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(src[i] == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dest.<span class="built_in">push_back</span>(src[i] * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 继续根据 src 的内容进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; src.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 其他对 src 的处理</span></span><br><span class="line">        <span class="comment">// 这种用法虽然有问题，但这里内存在堆上，可能还没被回收，也不会 core</span></span><br><span class="line">        <span class="comment">// dest[i] -= 5; </span></span><br><span class="line">        dest.<span class="built_in">at</span>(i) -= <span class="number">5</span>; <span class="comment">// 这种用法会 core</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里刚开始实现的时候，第一次遍历 src 用来初始化 dest。然后中间有一些其他代码，接着后面又遍历 src，根据 src 的内容对初始化后的 dest 再进行某些处理。</p><p>刚开始实现的时候，这样没什么问题，然后某天可能加了个需求，需要过滤掉 src 中某些数据，于是就加了 if 判断来跳过某些内容。改动的人，可能没注意到后面对 src 和 dest 的遍历，没意识到过滤会导致 dest 的长度已经变了。</p><p>这个场景有时候比较难触发 coredump，可能只有极少场景才会有过滤导致长度不一样。并且这里就算第二轮访问了越界下标，用 [] 访问的话，也可能不会 core。上面示例代码为了必现 core，故意改成用 at 访问，这样下标越界就会抛异常。</p><h2 id="访问失效的迭代器"><a href="#访问失效的迭代器" class="headerlink" title="访问失效的迭代器"></a>访问失效的迭代器</h2><p>除了下标访问越界，还有一类问题比较常见，那就是访问失效的迭代器。迭代器是一种设计模式，它提供了一种方法来访问容器对象中的元素，而无需暴露该对象的内部表示。在 C++ 中，迭代器是一个非常重要的概念，它是容器和算法之间的桥梁。</p><p>C++ 标准库中，很多容器都提供了迭代器，比如 vector、list、map 等。<strong>访问这些容器的迭代器时候，如果迭代器已经失效，就会导致未定义行为，可能导致进程 coredump</strong>。</p><p>导致迭代器失效的原因有很多，比如 vector 扩容，导致之前的迭代器失效。最常见的一个例子就是删除 vector 中偶数位置的元素，很多新手可能像下面这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        numbers.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里当调用 <code>erase</code> 删除元素时，会<strong>导致删除位置和它之后的所有迭代器都失效</strong>。所以循环中接着访问 <code>it</code> 就会导致未定义行为。正确做法是使用 erase 的返回值，来更新迭代器，或者使用 remove_if 和 erase 来删除元素。</p><p>当然这个示例比较简单，在实际业务中，我们遇见过一些比较隐蔽的迭代器失效问题。背景是这样，我们有个批处理任务，会用协程池来处理一批 IO 密集的任务，并且把结果写回到一个 vector 中。为了示例，这里代码简化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟异步任务处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncProcess</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    value += <span class="number">1</span>;  <span class="comment">// 可能访问已经失效的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        values.<span class="built_in">push_back</span>(i);</span><br><span class="line">        results.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span>&amp; result = results.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;result]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            AsyncProcess(result);  <span class="comment">// 在异步任务中使用引用</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待一段时间让任务执行</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们保存了 <code>results.back()</code> 的引用，并在异步任务中使用它。在异步任务执行期间，<code>results</code> vector 继续添加新元素。当 vector 需要扩容时，原有的内存会被释放，新的内存会被分配。此时异步任务中持有的引用就变成了悬空引用，访问它会导致未定义行为。</p><p>正确的做法应该是使用 <code>reserve</code> 预分配空间，避免扩容。或者保存索引，使用索引值而不是引用。</p><h2 id="并发导致的数据竞争"><a href="#并发导致的数据竞争" class="headerlink" title="并发导致的数据竞争"></a>并发导致的数据竞争</h2><p>还有一类 crash 问题，是因为并发导致的数据竞争。经常有这么一个场景，就是服务中有一个后台线程，会从某个配置中心拉取配置更新到本地。然后有多个业务线程，会并发读取这里的配置。</p><p>因为是经典的读多写少场景，所以一般会用读写锁来实现。多个读线程可以同时持有读锁，写线程必须独占，写的过程需要保证无其他读或写操作。写操作期间，新的读操作需要等待。一个可能的执行序列如下：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Time ──────────────────────────────────────────────────────▶</span></span><br><span class="line"><span class="attribute">Reader 1</span><span class="punctuation">:</span> <span class="string">     RRRR      RRRR      </span></span><br><span class="line"><span class="attribute">Reader 2</span><span class="punctuation">:</span> <span class="string">        RRRR        RRRR</span></span><br><span class="line"><span class="attribute">Reader 3</span><span class="punctuation">:</span> <span class="string">           RRRR         RRRR</span></span><br><span class="line"><span class="attribute">Writer A</span><span class="punctuation">:</span> <span class="string"> W                 W</span></span><br></pre></td></tr></table></figure><p>这里 W 代表一次写入，R 代表一次读取。可以看到，写操作期间，新的读操作需要等待。我们在实际场景中，有遇见过一个 crash 就是错误的使用读写锁。整体比较复杂，下面简化下逻辑，给出核心代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_mutex mutex_;</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num_keys = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;std::string, std::string&gt; localdata;</span><br><span class="line">        std::vector&lt;std::string&gt; keys;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">            keys.<span class="built_in">push_back</span>(<span class="string">&quot;test&quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">            localdata[keys[i]] = <span class="string">&quot;test&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            m_data.<span class="built_in">swap</span>(localdata);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">readData</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> m_data[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整的演示代码在 <a href="https://gist.github.com/selfboot/dc0d9450ded391bc28a43aecd1045694">core_share.cpp</a> 中，感兴趣的可以看下。这里 loadData 中，先准备好配置数据，然后用写锁来更新配置。在 readData 中，则用读锁来读取配置。</p><p>看起来没啥问题呀？因为当时是很偶发的 crash，这里业务代码也很久没动过了，只能开了 core 文件来分析。结果 core 的堆栈很奇怪，在 loadData 方法里，localdata 的<strong>析构过程发生的 crash</strong>。这里 localdata 是局部变量，最后析构前交换了 m_data 和 localdata 的值。那就是 m_data 的数据内存布局有问题了，<strong>m_data 只有这里会写，其他地方全部是“读“</strong>。</p><p>又仔细翻了下业务代码，发现 m_data 读的时候，用了 [] 来拿 unordered_map 的值。<strong>对于 unordered_map 来说，如果 key 不存在，[] 会导致插入一个默认值</strong>。啊！！这里本来意图是用读锁保护只读操作，结果不小心还执行了写操作。我们知道，并发写 unordered_map 会有数据竞争，怪不得导致 crash。</p><p>当然这里 core 的堆栈其实不一定是析构时候，比如示例的代码，堆栈就是在读线程 readData 的时候，如下图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250110_c++_crash_cases_mapread.png" alt="读线程 crash 堆栈"></p><h2 id="灾难性回溯导致的栈溢出"><a href="#灾难性回溯导致的栈溢出" class="headerlink" title="灾难性回溯导致的栈溢出"></a>灾难性回溯导致的栈溢出</h2><p>上面的示例其实平时多注意的话，还是能避免的。但下面这个，一般人还是很少知道，很容易踩坑。</p><p>我们有个地方需要判断字符串中是否有一对括号，于是用了 C++ 的正则表达式。相关代码简化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string problematic = <span class="string">&quot;((((&quot;</span>;</span><br><span class="line">    problematic += std::<span class="built_in">string</span>(<span class="number">100000</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    problematic += <span class="string">&quot;))))&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">re</span><span class="params">(<span class="string">R&quot;(\([^\)]+\))&quot;</span>)</span></span>;</span><br><span class="line">    std::smatch matches;</span><br><span class="line">    <span class="type">bool</span> found = std::<span class="built_in">regex_search</span>(problematic, matches, re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，我构造了一个很长的字符串，然后使用正则表达式来匹配。用 g++ 编译后，运行程序，程序就会 coredump 掉。如果用 gdb 看堆栈的话，如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250107_c++_crash_cases_regex.png" alt="灾难性回溯导致的栈溢出"></p><p>这是因为正则引擎进行了大量的回溯，每次回溯都会在调用栈上创建新的栈帧。导致这里栈的深度特别长，最终超出栈大小限制，进程 coredump 了。</p><p>这个就是所谓的<strong>灾难性回溯（Catastrophic Backtracking）</strong>，实际开发中，对于复杂的文本处理，最好对输入长度进行限制。如果能用循环或者其他非递归的方案解决，就尽量不用正则表达式。如果一定要用正则表达式，可以限制重复次数（使用 {n,m} 而不是 + 或 *），另外也要注意避免嵌套的重复（如 (.+)+）。</p><p>上面的正则表达式，可以改成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">re</span><span class="params">(<span class="string">R&quot;(\([^\)]&#123;1,100&#125;\))&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>当然除了这里递归回溯导致的栈溢出，还有其他一些场景，比如无限递归、大数组分配在栈上，都可能导致栈溢出。好在栈溢出的话，有 core 文件还是能比较好定位到原因的。</p><h2 id="coredump-问题分析"><a href="#coredump-问题分析" class="headerlink" title="coredump 问题分析"></a>coredump 问题分析</h2><p>遇到 crash 问题，一般需要打开 core 文件。真实业务环境中，业务进程如果占内存比较大，crash 后保存 core 文件可能会持续比较久的时间。而真实业务中，一般会有守护进程定时拨测业务进程，如果发现业务进程没回应，有的会用 <code>kill -9</code> 来杀死进程并重启。<strong>这时候，业务进程的 core 文件可能只写了一半，我们拿到的是不完整的 core 文件</strong>。这时候就要修改守护进程，等 core 文件写完再重启进程。</p><p>拿到 core 文件后，用 gdb 来分析，如果堆栈比较明确，一般就能很快定位到问题。但很多时候，可能看到的堆栈不完整，是一堆 ??。比如上面访问失效的迭代器，用 gdb 来运行，crash 之后看到堆栈如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_gdb_iter.png" alt="访问失效的迭代器堆栈"></p><p>这里堆栈没有什么有用的信息，比较难分析。对于示例这种能稳定复现的问题，使用 <a href="https://en.wikipedia.org/wiki/Valgrind">Valgrind</a> 来辅助分析，会更容易定位。上面代码分析结果如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20250109_c++_crash_cases_valgrind.png" alt="访问失效的迭代器用 Valgrind 分析"></p><p>从这里分析结果可以看到，主要有两个问题，无效读取（Invalid read）和无效写入（Invalid write）。发生问题的代码行数这里也有，所以可以很快定位到问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 5 个自己遇到过的导致进程 Coredump 的经典案例：</p><ol><li><strong>抛异常没有捕获</strong>：使用标准库函数时，要注意其是否会抛出异常。对于可能抛出异常的函数，需要妥善处理异常。对于自定义类，建议使用错误码而不是异常来处理错误。</li><li><strong>数组下标访问越界</strong>：在使用数组或容器时，要特别注意下标访问的合法性。尤其是在多处遍历同一容器时，要确保容器的大小没有发生变化。可以使用 <code>at()</code> 方法来进行带边界检查的访问。</li><li><strong>访问失效的迭代器</strong>：在使用迭代器时，要注意容器的操作（如删除、插入等）可能会导致迭代器失效。对于 vector 来说，扩容会导致所有迭代器失效；对于其他容器，也要了解其迭代器失效的规则。</li><li><strong>并发导致的数据竞争</strong>：在多线程环境下，要特别注意数据的并发访问。即使是看似只读的操作（如 map 的 [] 操作符），也可能会修改容器的内容。使用合适的同步机制（如互斥锁、读写锁等）来保护共享数据。</li><li><strong>灾难性回溯导致的栈溢出</strong>：在使用正则表达式等可能导致大量递归的场景下，要注意输入的限制。对于复杂的文本处理，最好使用非递归的方案，或者限制递归深度。</li></ol><p>当然还有些不常见的 core，比如我之前遇到的：<a href="https://selfboot.cn/2024/03/15/object_memory_coredump/">Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析</a>。大家有遇见过什么印象深刻的 crash 案例，欢迎留言分享。</p>]]></content>
    
    
    <summary type="html">本文深入分析了 C++ 开发中常见的 5 种导致进程 Crash 的典型案例：未捕获的异常处理、数组越界访问、迭代器失效、并发数据竞争以及栈溢出问题。通过真实的代码示例，详细讲解了每种问题的成因、排查方法和解决方案。文章还介绍了如何使用 GDB、Valgrind 等工具来分析 Coredump 问题，是一篇实用的 C++ 参考指南。</summary>
    
    
    
    <category term="计算机基础" scheme="https://selfboot.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
  
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：利用 Clang 的静态线程安全分析</title>
    <link href="https://selfboot.cn/2025/01/02/leveldb_source_thread_anno/"/>
    <id>https://selfboot.cn/2025/01/02/leveldb_source_thread_anno/</id>
    <published>2025-01-02T22:00:00.000Z</published>
    <updated>2025-07-15T13:42:45.600Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 中有一些宏比较有意思，平时自己写代码的时候，还基本没用过。这些宏在 <a href="https://github.com/google/leveldb/blob/main/port/thread_annotations.h">thread_annotations.h</a> 中定义，可以在编译时<strong>使用 Clang 编译器的线程安全分析工具，来检测潜在的线程安全问题</strong>。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20241227_leveldb_source_thread_anno_code.png" alt="Clang 编译器的线程安全分析工具"></p><span id="more"></span><p>比如下面这些宏，到底有什么作用呢？本文就一起来看看吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GUARDED_BY</span>(x)          <span class="comment">// 表示变量必须在持有锁x时才能访问</span></span><br><span class="line"><span class="built_in">PT_GUARDED_BY</span>(x)       <span class="comment">// 指针类型的 GUARDED_BY</span></span><br><span class="line"><span class="built_in">ACQUIRED_AFTER</span>(...)    <span class="comment">// 指定锁的获取顺序，防止死锁</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="GUARDED-BY-锁保护"><a href="#GUARDED-BY-锁保护" class="headerlink" title="GUARDED_BY 锁保护"></a>GUARDED_BY 锁保护</h2><p>在很多类的成员变量定义中，都有 <code>GUARDED_BY(mutex_)</code> 这样的注解，有什么作用呢？比如 LRU Cache 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">mutable</span> port::Mutex mutex_;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> usage_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function">HandleTable table_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实这就是 Clang 的线程安全注解，编译的时候，Clang 会检查所有对 <code>usage_</code> 和 <code>table_</code> 的访问是否都在持有 <code>mutex_</code> 锁的情况下进行。另外，在函数或代码块结束时，编译器还会检查所有应该释放的锁是否都已经释放，可以防止遗漏锁释放导致的资源泄露或死锁。</p><p>反观我们平时在写业务代码的时候，几乎没用过这些线程安全注解。顶多注释下这里不是线程安全的，要加锁访问，全靠开发的自觉。可想而知，业务中肯定会遇见各种奇怪的多线程数据竞争问题。</p><p>LevelDB 实现的时候，加了很多类似的线程安全注解，<strong>不仅可以明确告诉其他开发者这个变量需要锁保护，还可以在编译期就发现潜在的线程安全问题，从而减少多线程环境下可能出现的竞态条件、死锁等问题</strong>。</p><h3 id="锁保护线程注解示例"><a href="#锁保护线程注解示例" class="headerlink" title="锁保护线程注解示例"></a>锁保护线程注解示例</h3><p>下面通过一个完整的例子来看看 Clang 的线程安全注解作用。这里 SharedData 类中，<code>counter_</code> 变量需要锁保护，<code>mutex_</code> 是我们封装的一个锁实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guard.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__attribute__</span>((<span class="built_in">capability</span>(<span class="string">&quot;mutex&quot;</span>))) Mutex &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; mutex_.<span class="built_in">lock</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; mutex_.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedData</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mutex_.<span class="built_in">lock</span>();</span><br><span class="line">        counter_++;</span><br><span class="line">        mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wrong case: Accessing shared variable without holding the lock</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UnsafeIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter_++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UnsafeIncrement2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mutex_.<span class="built_in">lock</span>();</span><br><span class="line">        counter_++;</span><br><span class="line">        <span class="comment">// Forgot to unlock, will trigger warning</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex_;</span><br><span class="line">    <span class="type">int</span> counter_ __attribute__((<span class="built_in">guarded_by</span>(mutex_)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SharedData data;</span><br><span class="line">    data.<span class="built_in">Increment</span>();</span><br><span class="line">    data.<span class="built_in">UnsafeIncrement</span>();</span><br><span class="line">    data.<span class="built_in">UnsafeIncrement2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这里的测试代码为了直接能运行，就没有依赖 LevelDB 中的宏定义 GUARDED_BY。下面的 <code>__attribute__((guarded_by(mutex_)))</code> 和宏展开的结果是一样的。</p><p>用 Clang 编译上面的代码，就能看到告警信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang++ -pthread -Wthread-safety -std=c++17 guard.cpp -o guard</span></span><br><span class="line">guard.cpp:16:9: warning: writing variable &#x27;counter_&#x27; requires holding mutex &#x27;mutex_&#x27; exclusively [-Wthread-safety-analysis]</span><br><span class="line">        counter_++;</span><br><span class="line">        ^</span><br><span class="line">guard.cpp:22:9: warning: writing variable &#x27;counter_&#x27; requires holding mutex &#x27;mutex_&#x27; exclusively [-Wthread-safety-analysis]</span><br><span class="line">        counter_++;</span><br><span class="line">        ^</span><br><span class="line">guard.cpp:27:9: warning: writing variable &#x27;counter_&#x27; requires holding mutex &#x27;mutex_&#x27; exclusively [-Wthread-safety-analysis]</span><br><span class="line">        counter_++;</span><br><span class="line">        ^</span><br><span class="line">3 warnings generated</span><br></pre></td></tr></table></figure><p>可以看到，编译器在编译的时候，就发现了 <code>counter_</code> 变量在未持有 <code>mutex_</code> 锁的情况下被访问，从而告警。</p><h3 id="PT-GUARDED-BY-指针保护"><a href="#PT-GUARDED-BY-指针保护" class="headerlink" title="PT_GUARDED_BY 指针保护"></a>PT_GUARDED_BY 指针保护</h3><p>这里 GUARDED_BY 通常用在对象的非指针成员上，用来保护成员变量自身。而 <strong>PT_GUARDED_BY 则是用在指针和智能指针成员上，用来保护指针指向的数据</strong>。注意这里 PT_GUARDED_BY <strong>只保护指针指向的数据，指针本身并没有约束的</strong>。可以看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Mutex mu;</span><br><span class="line"><span class="function"><span class="type">int</span> *p1             <span class="title">GUARDED_BY</span><span class="params">(mu)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> *p2             <span class="title">PT_GUARDED_BY</span><span class="params">(mu)</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; p3  <span class="title">PT_GUARDED_BY</span><span class="params">(mu)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  p1 = <span class="number">0</span>;             <span class="comment">// Warning!</span></span><br><span class="line"></span><br><span class="line">  *p2 = <span class="number">42</span>;           <span class="comment">// Warning!</span></span><br><span class="line">  p2 = <span class="keyword">new</span> <span class="type">int</span>;       <span class="comment">// OK.</span></span><br><span class="line"></span><br><span class="line">  *p3 = <span class="number">42</span>;           <span class="comment">// Warning!</span></span><br><span class="line">  p<span class="number">3.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">int</span>);  <span class="comment">// OK.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="capability-属性注解"><a href="#capability-属性注解" class="headerlink" title="capability 属性注解"></a>capability 属性注解</h2><p>上面的例子中，我们没有直接用标准库的 mutex 互斥锁，而是简单封装了一个 <code>Mutex</code> 类。在类定义那里，用了 <code>__attribute__((capability(&quot;mutex&quot;)))</code> 注解。</p><p>这是因为 Clang 的线程安全分析需要<strong>知道哪些类型是锁，需要去追踪锁的获取和释放状态</strong>。而标准库的类型没有这些注解，不能直接用于 Clang 的线程安全分析。这里用到了 clang 的 <code>capability(&quot;mutex&quot;)</code> 属性，用来指定该类具有锁的特性。</p><p>LevelDB 中定义锁的代码也用到了注解，不过稍微不同，用的是 <code>LOCKABLE</code>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LOCKABLE</span> Mutex &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Mutex</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">Mutex</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Mutex</span>(<span class="type">const</span> Mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>这是因为早期版本的 Clang 使用 lockable 属性，后来引入了更通用的 capability 属性。为了向后兼容，lockable 被保留为 capability(“mutex”) 的别名。所以，这两者是等效的。</p><h2 id="线程安全分析的能力"><a href="#线程安全分析的能力" class="headerlink" title="线程安全分析的能力"></a>线程安全分析的能力</h2><p>上面例子有点简单，其实从本质上来看，这里 clang 静态线程安全分析想做的事情，<strong>就是在编译器提供一种保护资源的能力</strong>。这里资源可以是数据成员，比如前面的 <code>counter_</code>，也可以是提供对某些底层资源访问的函数&#x2F;方法。clang 可以在编译期确保，除非某个线程有访问资源的能力，否则它无法访问资源。</p><p>这里线程安全分析<strong>使用属性来声明这里的资源约束</strong>，属性可以附加到类、方法和数据成员前面。Clang 官方也提供了一系列属性定义宏，可以直接拿来用。LevelDB 中定义了自己的宏，也可以参考。</p><p>前面给的例子中，注解主要用在数据成员上，其实也可以用在函数上。比如 LevelDB 中定义的锁对象 Mutex，在成员函数上用到了这些注解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LOCKABLE</span> Mutex &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Lock</span><span class="params">()</span> <span class="title">EXCLUSIVE_LOCK_FUNCTION</span><span class="params">()</span> </span>&#123; mu_.<span class="built_in">lock</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Unlock</span><span class="params">()</span> <span class="title">UNLOCK_FUNCTION</span><span class="params">()</span> </span>&#123; mu_.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AssertHeld</span><span class="params">()</span> <span class="title">ASSERT_EXCLUSIVE_LOCK</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些注解主要用于标记锁对象的成员函数，告诉编译器这些函数会如何改变锁的状态：</p><ul><li><strong>EXCLUSIVE_LOCK_FUNCTION</strong>: 表示函数会获取互斥锁的独占访问权，调用前锁必须是未持有状态，调用后锁会被当前线程独占；</li><li><strong>UNLOCK_FUNCTION</strong>: 表示函数会释放锁，调用前锁必须是被持有状态（可以是独占或共享），调用后锁会被释放；</li><li><strong>ASSERT_EXCLUSIVE_LOCK</strong>: 用于断言当前线程持有锁的独占权，通常用在调试代码中，确保代码运行在正确的加锁状态下。</li></ul><p>当然这些是 clang 早期的线程安全注解，主要为了锁来命名。上面这几个现在可以用 <a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#acquire-acquire-shared-release-release-shared-release-generic">ACQUIRE(…), ACQUIRE_SHARED(…), RELEASE(…), RELEASE_SHARED(…)</a> 来替代。</p><p>此外，还有其他一些注解，可以参考 Clang 官方的文档 <a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html">Thread Safety Analysis</a> 了解更多细节。</p>]]></content>
    
    
    <summary type="html">本文介绍 LevelDB 中使用 Clang 的静态线程安全分析工具，通过在代码中添加宏注解，支持在编译期检测潜在的线程安全问题。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：如何设计一个高性能哈希表</title>
    <link href="https://selfboot.cn/2024/12/25/leveldb_source_hashtable/"/>
    <id>https://selfboot.cn/2024/12/25/leveldb_source_hashtable/</id>
    <published>2024-12-25T21:00:00.000Z</published>
    <updated>2025-07-15T13:42:45.600Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表(HashTable) 是一个经典的数据结构，只要写点过代码，应该都有用过哈希表。每种语言都有自己的哈希表实现，基本都是开箱即用。以至于虽然用过哈希表的人很多，但自己动手写过哈希表的人估计没多少吧。</p><p>要设计一个高性能的哈希表，其实还是有不少细节需要考虑的。比如如何处理哈希冲突，如何处理哈希表扩容等。一些成熟的哈希表实现，比如 C++ 标准库中的哈希表，<a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/tr1/hashtable.h">代码量</a>比较大，也比较难理解。</p><p>好在 LevelDB 在实现 LRU Cache 的时候，顺便实现了一个<a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L70">简单高效的哈希表</a>，整体代码写的很精简，麻雀虽小五脏俱全，非常值得学习。本文以 LevelDB 的哈希表实现为例，分析下如何设计一个高性能的哈希表。</p><span id="more"></span><h2 id="LevelDB-实现哈希表的原因"><a href="#LevelDB-实现哈希表的原因" class="headerlink" title="LevelDB 实现哈希表的原因"></a>LevelDB 实现哈希表的原因</h2><p>C++ 标准库已经有了哈希表实现，为什么 LevelDB 还要实现一个自己的哈希表呢？官方是这样说的：</p><blockquote><p>We provide our own simple hash table since it removes a whole bunch<br>of porting hacks and is also faster than some of the built-in hash<br>table implementations in some of the compiler&#x2F;runtime combinations<br>we have tested.  E.g., readrandom speeds up by ~5% over the g++<br>4.4.3’s builtin hashtable.</p></blockquote><p>这里简单总结就是，其他实现有些冗杂，这里自己实现不依赖第三方库，代码精简的同时，也能保证实现的性能。</p><h2 id="LevelDB-哈希表实现原理"><a href="#LevelDB-哈希表实现原理" class="headerlink" title="LevelDB 哈希表实现原理"></a>LevelDB 哈希表实现原理</h2><p>这里 HashTable 实现的思想其实和 C++ 标准库中的哈希表实现差不多，用数组来存储哈希桶。<strong>插入、查找、删除操作的平均时间复杂度都是 O(1)，首先根据 key 的 hash 值定位到具体某个哈希桶，然后在冲突链表上执行相应的操作</strong>。同时，如果插入的时候发现哈希表的负载因子过高，则进行扩容。</p><p>这里补充一点，因为 LevelDB 的哈希表是用来实现 LRU Cache 的，所以这里哈希表的元素类型是 <code>LRUHandle</code>，除了有 key 和 value 两个字段外，还有一个 next_hash 指针，用链地址法来处理哈希冲突。另外，这里也存储了 hash 值，一般是调用方生成后保存下来。这样在后续的查找、插入和删除操作中，可以直接使用这个 hash 值来定位到具体的哈希桶。LRUHandle 的其他字段主要是在 LRU Cache 中使用，这里就不展开了。</p><h3 id="FindPointer-查找位置"><a href="#FindPointer-查找位置" class="headerlink" title="FindPointer 查找位置"></a>FindPointer 查找位置</h3><p>接着我们先看看查找指定 key 的操作，LevelDB 封装了一个基础的 <code>FindPointer()</code> 方法，返回了一个指向 key 的二级指针。<a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L115">具体实现</a>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a pointer to slot that points to a cache entry that</span></span><br><span class="line"><span class="comment">// matches key/hash.  If there is no such cache entry, return a</span></span><br><span class="line"><span class="comment">// pointer to the trailing slot in the corresponding linked list.</span></span><br><span class="line"><span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">  <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;<span class="built_in">key</span>())) &#123;</span><br><span class="line">    ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里根据 key 的 hash 值定位到具体的哈希桶，如果桶为空，则直接返回指向桶头指针 nullptr 的地址。如果桶不为空，<strong>则用经典的链地址法处理哈希冲突</strong>。遍历哈希桶上的冲突链表，如果找到对应的 key，则返回指向该节点的二级指针。如果遍历完链表都没有找到，则返回链表的尾指针地址。</p><p>这里比较巧妙的是<strong>返回了一个二级指针，这样就能在查找、插入和删除操作中都复用该方法</strong>。在查找时，直接解引用返回的指针就能获得目标节点。在插入时，通过这个指针可以既能检查是否存在相同key的节点，又能直接在正确的位置插入新节点。在删除时，可以直接通过修改这个指针指向的值来完成节点的移除，而不需要额外记录前驱节点。</p><h3 id="Remove-删除节点"><a href="#Remove-删除节点" class="headerlink" title="Remove 删除节点"></a>Remove 删除节点</h3><p>查找节点就是直接调前面的 <code>FindPointer</code> 方法，然后解引用即可，这里不再赘述。我们来看看删除 key 的 <a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L95">Remove 方法</a>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = <span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">  LRUHandle* result = *ptr;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *ptr = result-&gt;next_hash;</span><br><span class="line">    --elems_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单吧！为了在一个链表中删除指定节点，这里先用 FindPointer 找到指向链表节点指针的地址，然后<strong>将要删除节点的下一个节点地址(result-&gt;next_hash)赋值给原指针位置</strong>，就完成了删除操作。本方法返回了被删除的节点指针，方便调用者进行后续处理（如内存释放等）。这里的实现方式，<strong>不需要额外记录前驱节点，操作简单高效，也能够正确处理链表头节点的删除情况</strong>。</p><p>这里的删除方法可以优雅下面的所有情况：</p><table><thead><tr><th>情况</th><th>描述</th><th>初始状态</th><th>删除后状态</th></tr></thead><tbody><tr><td>1</td><td>删除链表第一个节点 A</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; [C] –&gt; nullptr</td><td>list_[i] –&gt; [B] –&gt; [C] –&gt; nullptr</td></tr><tr><td>2</td><td>删除链表中间节点 B</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; [C] –&gt; nullptr</td><td>list_[i] –&gt; [A] –&gt; [C] –&gt; nullptr</td></tr><tr><td>3</td><td>删除链表最后节点 C</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; [C] –&gt; nullptr</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td></tr><tr><td>4</td><td>删除链表唯一节点 A</td><td>list_[i] –&gt; [A] –&gt; nullptr</td><td>list_[i] –&gt; nullptr</td></tr><tr><td>5</td><td>要删除的key不存在</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td></tr><tr><td>6</td><td>hash桶为空</td><td>list_[i] –&gt; nullptr</td><td>list_[i] –&gt; nullptr</td></tr></tbody></table><h3 id="Insert-插入节点"><a href="#Insert-插入节点" class="headerlink" title="Insert 插入节点"></a>Insert 插入节点</h3><p>插入节点的方法 <a href="https://github.com/google/leveldb/blob/main/util/cache.cc#L79">Insert</a> 和删除节点有点类似，也是先找到插入位置，然后进行插入操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = <span class="built_in">FindPointer</span>(h-&gt;<span class="built_in">key</span>(), h-&gt;hash);</span><br><span class="line">  LRUHandle* old = *ptr;</span><br><span class="line">  h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">  *ptr = h;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第 4 行，用二级指针一次性处理了下面所有情况，文章后面会再详细介绍这里的二级指针。</p><table><thead><tr><th>情况</th><th>描述</th><th>初始状态</th><th>插入后状态</th><th>返回值</th></tr></thead><tbody><tr><td>1</td><td>插入到空桶</td><td>list_[i] –&gt; nullptr</td><td>list_[i] –&gt; [H] –&gt; nullptr</td><td>nullptr</td></tr><tr><td>2</td><td>插入时key已存在(第一个节点)</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td><td>list_[i] –&gt; [H] –&gt; [B] –&gt; nullptr</td><td>A</td></tr><tr><td>3</td><td>插入时key已存在(中间节点)</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; [C] –&gt; nullptr</td><td>list_[i] –&gt; [A] –&gt; [H] –&gt; [C] –&gt; nullptr</td><td>B</td></tr><tr><td>4</td><td>插入时key已存在(最后节点)</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td><td>list_[i] –&gt; [A] –&gt; [H] –&gt; nullptr</td><td>B</td></tr><tr><td>5</td><td>插入新key(非空桶)</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; nullptr</td><td>list_[i] –&gt; [A] –&gt; [B] –&gt; [H] –&gt; nullptr</td><td>nullptr</td></tr></tbody></table><p>这里插入后，还会根据 old 判断是否是新增节点，如果是新增节点，则更新哈希表的元素数量，并且要判断是否需要动态扩容，接下来看看这里扩容逻辑。</p><h2 id="高负载因子动态扩容"><a href="#高负载因子动态扩容" class="headerlink" title="高负载因子动态扩容"></a>高负载因子动态扩容</h2><p>对于某个固定桶数量的哈希表，<strong>随着插入元素的变多，哈希冲突的概率会变大</strong>。极端情况下，可能每个 key 都有很长的冲突链表，导致 hashtable 的查找和删除性能退化。为了<strong>衡量这里哈希冲突的严重程度</strong>，我们可以定义<strong>负载因子 &#x3D; 哈希表的元素数量 &#x2F; 哈希桶数量</strong>，一旦这个值超过某个阈值，则需要进行扩容。</p><p>前面 Insert 方法在插入元素的时候，会统计当前 hashtable 的元素数量。一旦负载因子超过阈值 1，则调用 <code>Resize()</code> 进行扩容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ++elems_;</span><br><span class="line">    <span class="keyword">if</span> (elems_ &gt; length_) &#123;</span><br><span class="line">    <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">    <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">    <span class="built_in">Resize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<strong>扩容第一个要解决的问题就是决定新的哈希桶数量</strong>。LevelDB 的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (new_length &lt; elems_) &#123;</span><br><span class="line">      new_length *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在标准库的 vector 扩容时候，也是选择按照 2 的整数倍进行扩容。这里<strong>扩容系数如果选择的太大，可能浪费比较多空间，选择倍数太小，可能导致频繁扩容</strong>。工程实践中，一般会选择 2 作为扩容倍数。</p><p>决定好新的桶大小后，就先创建这个更大容量的哈希桶，然后<strong>遍历所有旧的哈希桶，对于每个桶，还要遍历冲突链表上的每个 key，然后将每个 key 插入到新的链表上</strong>。核心的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">    <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="built_in">sizeof</span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">      LRUHandle* h = list_[i];</span><br><span class="line">      <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        LRUHandle* next = h-&gt;next_hash;</span><br><span class="line">        <span class="comment">// 头插法插入到新哈希表</span></span><br><span class="line">        h = next;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(elems_ == count);</span><br><span class="line">    <span class="keyword">delete</span>[] list_;</span><br><span class="line">    list_ = new_list;</span><br><span class="line">    length_ = new_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在 Resize 的时候，每次成功一个 key 到新的哈希表中，都会更新哈希表的元素数量。之后会用 assert 断言来检查扩容后，哈希表的元素数量是否正确。所有 key 都插入到新哈希表后，就可以回收旧哈希表的内存，然后替换 list_ 为新哈希表，并更新哈希表容量。</p><p>前面省略了关键的插入部分逻辑，这里<strong>在 while 循环中会遍历旧哈希表冲突链表中的每个 key，然后用头插法插入到新哈希表中</strong>，下面看看头插法的详细实现。</p><h2 id="头插法优化链表插入"><a href="#头插法优化链表插入" class="headerlink" title="头插法优化链表插入"></a>头插法优化链表插入</h2><p>这里前面 Resize 省略的头插法的核心代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">      LRUHandle* h = list_[i];</span><br><span class="line">      <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        <span class="type">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line">        LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">        h-&gt;next_hash = *ptr;</span><br><span class="line">        *ptr = h;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>头插法的核心思想是：<strong>将新节点插入到链表的头部</strong>。假设原始链表中如下：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">list_</span><span class="title">[</span><span class="comment">i</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">A</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">B</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">C</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="comment">nullptr</span></span><br></pre></td></tr></table></figure><p><strong>重哈希过程会依次处理 A、B、C 三个节点，将其插入到新哈希表中</strong>。如果在新的哈希表中，A、B 个节点依旧在同一个桶中，则重哈希后的链表状态如下：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">new_list</span><span class="title">[</span><span class="comment">hash_a</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">B</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">A</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="comment">nullptr</span></span><br><span class="line"><span class="comment">new_list</span><span class="title">[</span><span class="comment">hash_c</span><span class="title">]</span> <span class="literal">--</span>&gt; <span class="title">[</span><span class="comment">C</span><span class="title">]</span> <span class="literal">--</span>&gt;<span class="comment">nullptr</span></span><br></pre></td></tr></table></figure><p>这里 A 和 B 在新的链表中依旧在同一个桶中，但是 A 和 B 的顺序反过来了。相比传统的遍历到链表尾部进行插入，<strong>头插法的实现比较简单，只用在头部插入，不需要遍历到链表尾部，所以操作时间复杂度是O(1)</strong>。并且使用头插法也不需要维护尾指针，<strong>空间效率更高</strong>。此外，<strong>头插法还有缓存局部性，最近插入的节点在链表头部，对于某些访问模式下查找效率更高</strong>。   </p><h2 id="C-二级指针详解"><a href="#C-二级指针详解" class="headerlink" title="C++ 二级指针详解"></a>C++ 二级指针详解</h2><p>前面链表的操作代码十分简介，没有各种复杂的条件判断，正是因为用好了二级指针，那么要怎么理解 C++ 中的二级指针呢？<strong>C++ 中的对象有值和对应内存地址，指针存储的是对象的内存地址，而二级指针存储的是指针的地址</strong>。</p><p>举个例子来看更清晰些，比如某个 bucket 上有 <code>bucket-&gt;A-&gt;B-&gt;nullptr</code> 这样一个冲突链表，对应可以用下面 C++ 代码表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle *node_a;    <span class="comment">// 地址：0x100，数据：&#123;value: &quot;A&quot;, next_hash: 0x200&#125;</span></span><br><span class="line">LRUHandle *node_b;    <span class="comment">// 地址：0x200，数据：&#123;value: &quot;B&quot;, next_hash: nullptr&#125;</span></span><br><span class="line">node_a-&gt;next_hash = node_b;</span><br><span class="line">LRUHandle* bucket = node_a;   <span class="comment">// 地址：0x300，数据：0x100</span></span><br></pre></td></tr></table></figure><p>当然这里内存地址的具体值只是为了方便理解，实际运行的内存地址位置会不一样。现在有一个新的节点 node_h，地址是 0x500，如果要在上面链表中用头插法插入该节点，核心代码只有 3 行，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">h-&gt;next_hash = *ptr;    </span><br><span class="line">*ptr = h;</span><br></pre></td></tr></table></figure><p>我们来看这里每一行带来的变化。第一行执行完，这里整体内存布局如下：</p><table><thead><tr><th>变量名</th><th>内存地址</th><th>存储的值</th></tr></thead><tbody><tr><td>ptr</td><td>0x400</td><td>0x300</td></tr><tr><td>bucket</td><td>0x300</td><td>0x100</td></tr><tr><td>node_a</td><td>0x100</td><td>{value: “A”, next_hash: 0x200}</td></tr><tr><td>node_b</td><td>0x200</td><td>{value: “B”, next_hash: nullptr}</td></tr></tbody></table><p>接着执行 <code>h-&gt;next_hash = *ptr</code> 把 node_h 的 next_hash 指向 *ptr，这里 *ptr 拿到的就是 A 的地址，整体内存布局如下：</p><table><thead><tr><th>变量名</th><th>内存地址</th><th>存储的值</th></tr></thead><tbody><tr><td>ptr</td><td>0x400</td><td>0x300</td></tr><tr><td>bucket</td><td>0x300</td><td>0x100 (*ptr)</td></tr><tr><td>node_h</td><td>0x500</td><td>{value: “H”, next_hash: <strong>0x100</strong>}</td></tr><tr><td>node_a</td><td><strong>0x100</strong></td><td>{value: “A”, next_hash: <strong>0x200</strong>}</td></tr><tr><td>node_b</td><td><strong>0x200</strong></td><td>{value: “B”, next_hash: nullptr}</td></tr></tbody></table><p>这时候我们已经建好了 <strong>H-&gt;A-&gt;B-&gt;nullptr</strong> 链。只是 bucket 还是指向了 A，所以要接着执行 <code>*ptr = h</code> 让 bucket 指向 node_h 的地址，这一步完成后整体内存布局如下：</p><table><thead><tr><th>变量名</th><th>内存地址</th><th>存储的值</th></tr></thead><tbody><tr><td>ptr</td><td>0x400</td><td>0x300</td></tr><tr><td>bucket</td><td>0x300</td><td><strong>0x500</strong></td></tr><tr><td>node_h</td><td><strong>0x500</strong></td><td>{value: “H”, next_hash: <strong>0x100</strong>}</td></tr><tr><td>node_a</td><td><strong>0x100</strong></td><td>{value: “A”, next_hash: <strong>0x200</strong>}</td></tr><tr><td>node_b</td><td><strong>0x200</strong></td><td>{value: “B”, next_hash: nullptr}</td></tr></tbody></table><p>至此，我们就完成了 <code>p-&gt;bucket-&gt;H-&gt;A-&gt;B-&gt;nullptr</code> 的构建。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们详细分析了 LevelDB 的哈希表实现，看完应该能设计一个高性能的哈希表了吧，哈哈。最后总结下 LevelDB 哈希表实现的关键点：</p><ol><li><strong>巧妙运用二级指针</strong>：通过返回指向节点指针的指针，使得 FindPointer 方法能够在查找、插入和删除操作中复用，大大简化了链表操作的代码实现。</li><li><strong>高效的冲突处理</strong>：采用链地址法处理哈希冲突，并通过头插法优化链表插入操作，避免了遍历到链表尾部的开销。</li><li><strong>动态扩容机制</strong>：通过监控负载因子，在合适的时机进行 2 倍扩容，在空间利用和性能之间取得平衡。</li><li><strong>简洁优雅的实现</strong>：整个实现代码量很小，但包含了哈希表的所有核心功能，是一个非常好的学习范例。</li></ol><p>虽然这里哈希表主要用于 LevelDB 的 LRU Cache，但其中的很多设计思想对于实现其他高性能数据结构都很有参考价值。</p>]]></content>
    
    
    <summary type="html">以 LevelDB 的哈希表实现为例，分析了如何设计一个高性能的哈希表。通过二级指针，实现了链表的插入、删除和查找操作，并且通过头插法优化了链表插入操作，并分析了链表扩容的实现。最后，通过一个例子详细介绍了 C++ 中的二级指针。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
</feed>
