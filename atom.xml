<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just For Fun</title>
  <icon>https://www.gravatar.com/avatar/0de0c23d97c75300e32f8494b1485fb8</icon>
  <subtitle>知其然，知其所以然。知识广度是深度的副产品！</subtitle>
  <link href="https://selfboot.cn/atom.xml" rel="self"/>
  
  <link href="https://selfboot.cn/"/>
  <updated>2023-05-25T05:02:00.965Z</updated>
  <id>https://selfboot.cn/</id>
  
  <author>
    <name>FeiZhao</name>
    <email>xuezaigds@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GPT4 教我什么是期权</title>
    <link href="https://selfboot.cn/2023/05/24/gpt4_teach_option/"/>
    <id>https://selfboot.cn/2023/05/24/gpt4_teach_option/</id>
    <published>2023-05-24T13:45:15.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p><b>Question:</b><br>什么是期权</p><p><b>ChatGPT:</b><br>期权是一种金融衍生品，它给予买方（期权持有人）购买或出售某种资产（如股票、债券、商品等）的权利，但不承担义务。买方可以选择在未来的某个日期（即行权日期），或在到期日期之前的任何时间，以预定的价格（即行权价格）执行购买或出售的权利。</p><p>期权有两种主要类型：看涨期权和看跌期权。看涨期权授予持有者以特定价格购买特定资产的权利，而看跌期权则授予以特定价格出售资产的权利。</p><hr><p><b>Question:</b><br>可以给我举一个具体的例子吗</p><p><b>ChatGPT:</b><br>当然可以。假设你买了一份ABC公司股票的看涨期权，行权价格是$50，这意味着你有权（但不是义务）以$50的价格购买ABC公司的股票。</p><p>假设在期权到期日，ABC公司的股票价格升到了$60。由于你有权以$50的价格购买股票，所以你可以行权购买股票，然后立刻以市场价$60出售，从中赚取$10的利润（这还未扣除购买期权的成本）。</p><p>然而，如果ABC公司的股票价格在期权到期日是$40，那么你就不会选择行权，因为市场上的价格比你的行权价格还低。在这种情况下，你购买的期权就会“作废”，你的损失就是你购买期权的成本。</p><p>这就是期权的基本工作原理。希望这个例子有助于你理解期权。</p><hr><p><b>Question:</b><br>上面的例子，如果购买期权的成本，是 $50 一股吗</p><p><b>ChatGPT:</b><br>不，购买期权的成本（也被称为期权的”溢价”）通常要低得多。实际上，期权的价格取决于许多因素，包括潜在资产的价格、行权价格、期权到期日与当前日期的距离（也就是期权的”期限”）以及市场对潜在资产价格波动性的预期等。</p><p>比如，你可能只需要支付$5来购买一份行权价格为$50的ABC公司股票的看涨期权。这意味着你实际上为每股股票支付了$5，以换取在期权有效期内以$50的价格购买股票的权利。</p><p>这样，如果股票价格上升到$60，你行权后的利润就是$60（股票市场价格）减去$50（行权价格）再减去$5（期权溢价），即$5。如果股票价格低于$50，你的损失就是你为期权支付的$5溢价。</p><hr><p><b>Question:</b><br>如果价格是 48，我可以买入吗，这样我的损失会不会少一些</p><p><b>ChatGPT:</b><br>如果ABC公司的股票价格在期权到期时是$48，并且你持有的是行权价格为$50的看涨期权，那么你通常不会选择行权。因为在开放市场上，你可以以$48的价格直接购买股票，而不需要以更高的$50的价格通过行权购买。所以，即使股票价格低于行权价格，你也可以选择不行权，而是在开放市场上直接购买股票。<br>你购买期权的溢价（在这个例子中是$5）是你的最大损失。无论潜在资产的价格是多少，你的损失都不会超过这个溢价。所以，如果股票价格在期权到期时低于行权价格，你的损失就是你支付的期权溢价。</p><hr><p><b>Question:</b><br>所以无论行权不行权，我前期付出的5$每股，在期权到期的时候都是要支付的？</p><p><b>ChatGPT:</b><br>是的，你正确地理解了。期权的溢价，即你购买期权时所支付的费用，在任何情况下都不会退还给你。无论你是否行权，这个成本都是不可避免的。</p><p>在你的例子中，$5就是购买期权的费用，也就是你为获得在未来某一时间以$50的价格购买股票的权利而支付的价格。如果股票的价格在期权到期时超过$50，你可能会选择行权，从中获利。但如果股票价格低于$50，你则可能会选择放弃行权，这时你的损失就是这个$5的期权溢价。</p><p>因此，购买期权的决策应该基于你对未来价格走势的预测，你需要权衡潜在的收益和可能的损失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;b&gt;Question:&lt;/b&gt;&lt;br&gt;什么是期权&lt;/p&gt;
&lt;p&gt;&lt;b&gt;ChatGPT:&lt;/b&gt;&lt;br&gt;期权是一种金融衍生品，它给予买方（期权持有人）购买或出售某种资产（如股票、债券、商品等）的权利，但不承担义务。买方可以选择在未来的某个日期（即行权日期），或在到期日期之前</summary>
      
    
    
    
    <category term="金融" scheme="https://selfboot.cn/categories/%E9%87%91%E8%9E%8D/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
  </entry>
  
  <entry>
    <title>Postman 高级用法指南</title>
    <link href="https://selfboot.cn/2017/11/12/postman_read_doc/"/>
    <id>https://selfboot.cn/2017/11/12/postman_read_doc/</id>
    <published>2017-11-12T12:18:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>Postman是一款强大的API接口测试工具，有许多不容易发现的好用的功能，下面简单介绍其中一部分功能。详细内容可以参考<a href="https://www.getpostman.com/docs/">文档</a>，官方还有视频教程，非常方便入手。后续本博客会持续提供一些Postman使用的细节技巧，方便大家用Postman进行接口调试。</p><p><img src="https://s3.amazonaws.com/postman-static-getpostman-com/postman-docs/statusBar.png" alt="Navigating Postman"> </p><span id="more"></span><p>作为一个跨平台的API测试工具，Postman有Win&#x2F;Mac&#x2F;Linux客户端，还有浏览器扩展程序。不过官方建议使用客户端，主要有以下优点：</p><ul><li>自带cookie支持：请求可以使用同一域名下的cookie；</li><li>内置代理支持：可以用来转发请求，分析请求流量；</li><li>自定义请求头：不必受限于Chrome中对于请求头的限制；</li><li>内置控制台：在控制台可以查看请求的详细信息</li></ul><p>简单来说，postman 做的事情就是模拟浏览器发送请求，接受响应。使用Postman可以模拟任何浏览器发出的请求，可以自由地构造请求地址，请求方法，请求内容，Cookies等。Postman的响应内容包括完整的响应头，响应时间，响应大小，cookie等内容。</p><p>此外，postman还提供如下方便功能：</p><ul><li><a href="https://www.getpostman.com/docs/postman/sending_api_requests/debugging_and_logs">Debugging and logs</a>：可以在控制台对postman的请求进行调试，特别是如果有pre-request或者test script时，使用控制台可以方便debug。原生postman可以通过<code>CMD/CTRL + ALT + C</code>打开控制台。</li><li><a href="https://www.getpostman.com/docs/postman/sending_api_requests/generate_code_snippets">Generate code snippets</a>：将当前请求导出为各种版本的请求代码，比如python，js，curl等，方便用命令行测试；</li><li><a href="https://www.getpostman.com/docs/postman/sending_api_requests/proxy">Proxy</a>：如果本机不能直接访问服务端，可以在<code>Settings-Proxy-Using custom/system proxy</code>设置代理；</li><li><a href="https://www.getpostman.com/docs/postman/sending_api_requests/capturing_http_requests">Capturing HTTP requests</a>：有时候用手机访问服务端时，我们可能需要借助fiddler来查看HTTP请求。postman也可以做相同的工作，只需要将postman作为代理转发HTTP请求即可。</li><li><a href="https://www.getpostman.com/docs/postman/sending_api_requests/certificates">Certificates</a>： 如果服务端要验证客户端证书，可以在<code>Settings-Certificates-Add Certificate</code>配置证书；</li></ul><h1 id="Environments-and-globals"><a href="#Environments-and-globals" class="headerlink" title="Environments and globals"></a>Environments and globals</h1><p>我们在构造API请求时，经常会在多个地方使用相同的值，比如相同的请求域名，一些固定的参数值。这时候如果使用<strong>变量</strong>来保存相应的值，然后在需要使用该值的地方用变量来代替会带来不少好处，比如要改变这些值，只用在变量的定义地方作出改动即可。</p><p><img src="https://s3.amazonaws.com/postman-static-getpostman-com/postman-docs/59165135.png" alt="Quick Look for variables"></p><p>Postman定义了4类变量，极大地方便了构造请求以及对结果进行测试：</p><ul><li>Global: 全局变量，postman中所有请求都可以访问或者修改；</li><li>Environment: 构造请求时可以选择使用某个Environment，这样就可以访问或者修改该Environment下的所有变量；</li><li>Local: 脚本中定义的变量，只对脚本的当前作用域有用；</li><li>Data: 只有在使用 <code>Collection Runner</code> 的时候，可以通过导入 Data Files 来构造当前测试集中用到的数据。</li></ul><p>就像程序中的变量一样，这里的变量也是有优先级，如果在Environment中有和Global重名的变量，会优先使用Environment中变量。上面4个变量的优先级由上到下依次减弱。 </p><p>在postman中使用变量有着很多意想不到的好处，比如：</p><ol><li>Collection Runner中通过Data file来构造不同的测试数据，方便快速进行大量不同请求数据的测试；</li><li>可以在不同请求中传递值，比如在一个请求中产生流水号，将其设置为某个变量的值，下一个请求即可使用该变量值。</li></ol><h1 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h1><p>Postman 内置了Node.js的运行时环境，可以执行JS脚本。这样就带来了很多激动人心的好处，比如构建动态请求参数，编写强大的测试用例等。Postman中的Scripts分为2类：</p><ul><li><a href="https://www.getpostman.com/docs/postman/scripts/pre_request_scripts">pre-request script</a>: 在发送请求之前执行的脚本，一般用来构建请求参数；</li><li><a href="https://www.getpostman.com/docs/postman/scripts/test_scripts">test script</a>: 在获取相应之后执行的脚本，一般用来做测试。不过需要注意，测试脚本运行在Sandbox环境，内置了许多JS库支持，方便进行测试。</li></ul><p><img src="https://s3.amazonaws.com/postman-static-getpostman-com/postman-docs/59184189.png" alt="Request Execution Flow"></p><p>Postman的<a href="https://www.getpostman.com/docs/postman/scripts/postman_sandbox">Sandbox</a>环境十分强大，比如：</p><ol><li>通过提供 <code>postman.setNextRequest(&quot;request_name&quot;)</code> 实现，可以很方便地在 Collection 中控制请求的执行路径；</li><li>提供了一系列<a href="https://www.getpostman.com/docs/postman/scripts/postman_sandbox_api_reference">内置接口</a>，方便对环境变量，请求或者相应内容进行访问；</li><li>提供了 CryptoJS 库，可以方便地进行加解密操作；</li><li>提供了 tv4 库，可以对 Json Scheme进行测试；JSON Schema 定义了如何基于 JSON 格式描述 JSON 数据结构的规范，进而提供数据校验、文档生成和接口数据交互控制等一系列能力。</li></ol><h1 id="Collections-runs"><a href="#Collections-runs" class="headerlink" title="Collections runs"></a>Collections runs</h1><p>Collections 是一系列请求的集合，postman通过collection来支持构建请求工作流，自动化测试，请求的导入导出，持续集成等功能。Collection 支持以下功能：</p><ul><li><a href="https://www.getpostman.com/docs/postman/collections/sharing_collections">Sharing collections</a>：可以将Collection中的请求导出分享给其他人；</li><li><a href="https://www.getpostman.com/docs/postman/collections/data_formats">Data formats</a>：Postman可以导出环境变量，甚至可以将请求和环境变量等一起打包为一个Json，方便迁移所有的请求数据。</li></ul><p>Collection的一大用处就是一次执行其中所有的请求，这就是所谓的 <a href="https://www.getpostman.com/docs/postman/collection_runs/starting_a_collection_run">collection run</a>。</p><p><img src="https://s3.amazonaws.com/postman-static-getpostman-com/postman-docs/58793861.png" alt="collection runner"></p><p>在执行collection run时，有很多配置选项，主要如下：</p><ul><li><a href="https://www.getpostman.com/docs/postman/collection_runs/using_environments_in_collection_runs">Using environments in collection runs</a>: 可以指定一个 Environment，这样collection中的请求可以使用其中的变量；</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/working_with_data_files">Working with data files</a>: 可以导入一个Data File，里面存放测试中用到的Data变量。可以存放很多不同的Data变量，这样迭代跑多次Collection时，每次使用不同的数据；</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/running_multiple_iterations">Running multiple iterations</a>: 可以配置迭代的运行Collection中的请求，对接口的稳定性进行测试。此外配合Data files，也可以对接口的正确性进行测试；</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/building_workflows">Building workflows</a>：默认情况下会顺序执行Collection中的请求，不过可以通过<code>setNextRequest()</code>来更改请求的执行流程。</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/debugging_a_collection_run">Debugging a collection run</a>: Collection中的请求执行后，会有可视化的执行结果展示，可以方便进行调试，此外，也可以通过控制台来进行调试。</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/sharing_a_collection_run">Sharing a collection run</a>: 整个Collection Run也是可以导出，可以在其他平台进行运行；</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/command_line_integration_with_newman">Command line integration with Newman</a>: 导出Collection Run后，可以在命令行使用 newman 运行。</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/integration_with_travis">Integration with Travis CI</a>: 可以将 newman 和 Travis CI集成，配置好持续性集成，指定自动运行测试用例的时机。</li></ul><h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><p><strong>1. 文件上传</strong></p><p>图形界面端，Collection 中的请求不支持POST文件上传，不过在导出Collection后，可以在json文件中配置文件路径，然后使用 newman 进行文件上传。详细可以参考Postman官方博客：<a href="http://blog.getpostman.com/2014/11/15/using-newman-to-run-collections-with-file-post-requests/">Using Newman to run collections with file-post requests</a></p><p>不过文件上传时必须指定文件路径，不能用变量代替，也不能通过Data Files来设置不同的文件，不是很方便。所以我给官方提了 <a href="https://github.com/postmanlabs/postman-app-support/issues/3779">Issue</a>，目前该功能已经纳入 Feature，有望在后续版本中实现该功能。这里就不得不赞一下Postman的社区支持了，基本上有任何问题，只要在官方Issue上提出，基本很快就会有Postman的工作人员提供支持。</p><p>（备注：本文所有图片均来自Postman Doc）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Postman是一款强大的API接口测试工具，有许多不容易发现的好用的功能，下面简单介绍其中一部分功能。详细内容可以参考&lt;a href=&quot;https://www.getpostman.com/docs/&quot;&gt;文档&lt;/a&gt;，官方还有视频教程，非常方便入手。后续本博客会持续提供一些Postman使用的细节技巧，方便大家用Postman进行接口调试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.amazonaws.com/postman-static-getpostman-com/postman-docs/statusBar.png&quot; alt=&quot;Navigating Postman&quot;&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="工具介绍" scheme="https://selfboot.cn/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="教程" scheme="https://selfboot.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="总结" scheme="https://selfboot.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python2.x 字符编码终极指南</title>
    <link href="https://selfboot.cn/2016/12/28/py_encode_decode/"/>
    <id>https://selfboot.cn/2016/12/28/py_encode_decode/</id>
    <published>2016-12-28T22:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://selfboot.cn/2014/08/28/character_encoding/">人机交互之字符编码</a> 一文中对字符编码进行了详细的讨论，并通过一些简单的小程序验证了我们对于字符编码的认识。但仅了解这篇文章的内容，并不能帮我们在日常编程中躲过一些字符编码相关的坑，Stackoverflow 上就有大量编码相关的问题，比如 <a href="http://stackoverflow.com/questions/9942594/unicodeencodeerror-ascii-codec-cant-encode-character-u-xa0-in-position-20">1</a>，<a href="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161228_encode_decode_2.png">2</a>(Python: Convert Unicode to ASCII without errors)，<a href="http://stackoverflow.com/questions/2688020/how-to-print-chinese-word-in-my-code-using-python">3</a>。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161228_encode_decode_1.png" alt="图1. 错误的编解码"></p><p>本文首先尝试对编码、解码进行一个<strong>宏观、直观</strong>的解读，然后详细来解释 python2 中的str和unicode，并对常见的UnicodeEncodeError 和 UnicodeDecodeError 异常进行剖析。</p><span id="more"></span><h1 id="如何理解编、解码？"><a href="#如何理解编、解码？" class="headerlink" title="如何理解编、解码？"></a>如何理解编、解码？</h1><p>如何去理解编码、解码？举个例子，Alice同学刚加入了机器学习这门课，想给同班的Bob同学打个招呼。但是作为人，Alice不能通过意念和Bob交流，必须通过某种方式，比如手语、声音、文字等来表达自己的想法。如果Alice选择用文字，那么他可能会写下这么一段文字：<code>My name is： boot …… 来学机器学习喽</code>，写文字这个过程其实就是<strong>编码</strong>，经过编码后的文字才能给Bob看。Bob收到Alice的文字后，就会用自己对文字的认知来解读Alice传达的含义，这个过程其实就是<strong>解码</strong>。当然，如果Bob不懂中文，那么就无法理解Alice的最后一句了，如果Bob不识字，就完全不知道Alice想表达什么了。</p><p>上面的例子只是为了方便我们理解编码、解码这个抽象的概念，现在来看看对于计算机程序来说，如何去理解字符的编码、解码过程。我们知道绝大多数程序都是读取数据，做一些操作，然后输出数据。比如当我们打开一个文本文件时，就会从硬盘读取文件中的数据，接着我们输入了新的数据，点击保存后，文本程序会将更新后的内容输出到硬盘。程序读取数据就相当于Bob读文字，必须进行一个解码的过程，解码后的数据才能让我们进行各种操作。同理，保存到硬盘时，也需要对数据进行编码。</p><p>下图方框 A 代表一个输出数据的程序，方框 B 代表一个读取数据的程序。当然这里的程序只是一个概念，表示一个处理数据的逻辑单元，可以是一个进程、一个函数甚至一个语句等。A 和 B 也可以是同一个程序，先解码外部获取的数据，内部操作后，再进行某种编码。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161228_encode_decode_2.png" alt="图2. 编码、解码的过程"></p><p>值得注意的是，有的编码方案不一定能表示某些信息，这时编码就会失败，比如 ASCII 就不能用来表示中文。当然，如果以错误的方式去解读某段内容，解码也会失败，比如用 ASCII 来解读包含 UTF-8的信息。至于什么是 ASCII，UTF-8等，在<a href="http://selfboot.cn/2014/08/28/character_encoding/">人机交互之字符编码</a> 中有详细的说明，这里不再赘述。下面结合具体的例子，来看看编码、解码的细节问题。</p><h1 id="python2-x-中的字符串"><a href="#python2-x-中的字符串" class="headerlink" title="python2.x 中的字符串"></a>python2.x 中的字符串</h1><p>在程序设计中，字符串一般是指一连串的<a href="https://docs.python.org/2/howto/unicode.html#definitions">字符</a>，比如<code>hello world!</code>、<code>你好</code>或者<code>もしもし</code>（日语）等等。各种语言对于字符串的支持各不相同，Python 2 中字符串的设计颇不合理，导致新手经常会出现各种问题，类似下面的提示信息相信很多人都遇到过（<code>UnicodeEncodeError</code> 或者 <code>UnicodeDecodeError</code>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 0-1: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>下面我们一起来解决这个疑难杂症。首先需要搞清楚python中的两个类型：<code>&lt;type &#39;str&#39;&gt;</code> 和 <code>&lt;type &#39;unicode&#39;&gt;</code>，<a href="https://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange">文档</a>中关于这两个类型的说明其实挺含糊的：</p><blockquote><p>There are seven sequence types: strings, Unicode strings, lists, …</p><p>String literals are written in single or double quotes: ‘xyzzy’, “frobozz”. Unicode strings are much like strings, but are specified in the syntax using a preceding ‘u’ character: u’abc’, u”def”.</p></blockquote><p>上面并没有给出什么有用的信息，不过好在<a href="https://www.azavea.com/blog/2014/03/24/solving-unicode-problems-in-python-2-7/">这篇文章</a>讲的特别好，简单来说：</p><ul><li>str：是<code>字节串（container for bytes）</code>，由 Unicode 经过编码(encode)后的字节组成的。</li><li>unicode：真正意义上的<code>字符串</code>，其中的每个字符用 Unicode 中对应的 <a href="https://en.wikipedia.org/wiki/Code_point">Code Point</a> 表示。</li></ul><p>翻译成<strong>人话</strong>就是，unicode 有点类似于前面 Alice 打招呼传递的想法，而 str 则是写下来的文字（或者是说出来的声音，甚至可以是手语）。我们可以用 GBK，UTF-8 等编码方案将 Unicode 类型转换为 str 类型，类似于用语言、文字或者手语来表达想法。</p><h2 id="repr-与终端交互"><a href="#repr-与终端交互" class="headerlink" title="repr 与终端交互"></a>repr 与终端交互</h2><p>为了彻底理解字符编码、解码，下面要用 python 交互界面进行一些小实验来加深我们的理解（下面所有的交互代码均在 Linux 平台下）。在这之前，我们先来看下面交互代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo = <span class="string">&#x27;Test 试试&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo</span><br><span class="line"><span class="string">&#x27;Test \xe8\xaf\x95\xe8\xaf\x95&#x27;</span></span><br></pre></td></tr></table></figure><p>当我们只输入标识符 demo 时，终端返回了 demo 的内容。这里返回的内容是怎么得到呢？答案是通过 <a href="https://docs.python.org/2/library/functions.html#repr">repr() 函数</a> 获得。文档中对于 repr 函数解释如下：</p><blockquote><p>Return a string containing a printable representation of an object.</p></blockquote><p>所以，我们可以在源文件中用下面的代码，来获取和上面终端一样的输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">demo = <span class="string">&#x27;Test 试试&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">repr</span>(demo)</span><br><span class="line"><span class="comment"># &#x27;Test \xe8\xaf\x95\xe8\xaf\x95&#x27;</span></span><br></pre></td></tr></table></figure><p>对于字符串来说，<code>repr()</code> 的返回值很好地说明了其在python内部的表示方式。通过 repr 的返回值，我们可以真切体会到前面提到的两点：</p><ul><li><strong>str：实际上是字节串</strong></li><li><strong>unicode：真正意义上的字符串</strong></li></ul><p>下面分别来看看这两个类型。</p><h2 id="unicode-类型"><a href="#unicode-类型" class="headerlink" title="unicode 类型"></a>unicode 类型</h2><p><strong>unicode 是真正意义上的字符串</strong>，为了理解这句话，先看下面的一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode_str = <span class="string">u&#x27;Welcome to 广州&#x27;</span> <span class="comment"># &#x27;&#x27;前面的 u 表示这是一个 unicode 字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode_str, <span class="built_in">type</span>(unicode_str)  <span class="comment"># repr(unicode_str)</span></span><br><span class="line">(<span class="string">u&#x27;Welcome to \u5e7f\u5dde&#x27;</span>, &lt;<span class="built_in">type</span> <span class="string">&#x27;unicode&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><p>repr 返回的 <code>Welcome to \u5e7f\u5dde</code> 说明了unicode_str存储的内容，其中两个<code>\u</code>后面的数字分别对应了<code>广、州</code>在unicode中的code point：</p><ul><li><code>5e7f</code> 对应<code>广</code>字；</li><li><code>5dde</code> 对应<code>州</code>字；</li></ul><p>英文字母也有对应的code point，它的值等于ASCII值，不过repr并没有直接输出。我们可以在<a href="http://tool.chinaz.com/tools/unicode.aspx">站长工具</a>中查看所有字符对应的code point。也可以用 python 的内置函数 <code>ord</code> 查看字符的 code point，如下所示（调用了 format 将code point转换为十六进制）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:04x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">ord</span>(<span class="string">u&#x27;广&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;5e7f&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:04x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">ord</span>(<span class="string">u&#x27;W&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0057&#x27;</span></span><br></pre></td></tr></table></figure><p>总结一下，我们可以将 <code>&lt;type &#39;unicode&#39;&gt;</code> 看作是<strong>一系列字符组成的数组</strong>，数组的每一项是一个code point，用来表示相应位置的字符。所以对于 unicode 来说，其长度等于它包含的字符（<code>a</code> 和 <code>广</code> 都是一个字符）的数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(unicode_str)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode_str[<span class="number">0</span>], unicode_str[<span class="number">12</span>], unicode_str[-<span class="number">1</span>]</span><br><span class="line">(<span class="string">u&#x27;W&#x27;</span>, <span class="string">u&#x27;\u5dde&#x27;</span>, <span class="string">u&#x27;\u5dde&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="str-类型"><a href="#str-类型" class="headerlink" title="str 类型"></a>str 类型</h2><p><strong>str 是字节串（container for bytes）</strong>，为了理解这句话，先来看下面的一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_str = <span class="string">&#x27;Welcome to 广州&#x27;</span>       <span class="comment"># 这是一个 str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_str, <span class="built_in">type</span>(str_str)</span><br><span class="line">(<span class="string">&#x27;Welcome to \xe5\xb9\xbf\xe5\xb7\x9e&#x27;</span>, &lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><p>python中 <code>\xhh</code>（h为16进制数字）表示一个字节，输出中的<code>\xe5\xb9\xbf\xe5\xb7\x9e</code> 就是所谓的字节串，它对应了<code>广州</code>。实际上 str_str 中的英文字母也是保存为字节串的，不过 repr 并没有以 <code>\x</code> 的形式返回。为了验证上面输出内容确实是<strong>字节串</strong>，我们用python提供的 <a href="https://docs.python.org/2.7/library/functions.html#bytearray">bytearray 函数</a>将相同内容的 unicode字符串用 UTF-8 编码为字节数组，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode_str = <span class="string">u&#x27;Welcome to 广州&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytearray</span>(unicode_str, <span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;Welcome to \xe5\xb9\xbf\xe5\xb7\x9e&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">bytearray</span>(unicode_str, <span class="string">&#x27;UTF-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 字节数组，每一项为一个字节；</span></span><br><span class="line">[<span class="number">87</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">116</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">229</span>, <span class="number">185</span>, <span class="number">191</span>, <span class="number">229</span>, <span class="number">183</span>, <span class="number">158</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">r&quot;\x&quot;</span> + <span class="string">r&quot;\x&quot;</span>.join([<span class="string">&quot;%02x&quot;</span> % c <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">bytearray</span>(unicode_str, <span class="string">&#x27;UTF-8&#x27;</span>))])</span><br><span class="line"><span class="comment"># 转换为 \xhh 的形式</span></span><br><span class="line">\x57\x65\x6c\x63\x6f\x6d\x65\x20\x74\x6f\x20\xe5\xb9\xbf\xe5\xb7\x9e</span><br></pre></td></tr></table></figure><p>可见，上面的 str_str 是 unicode_str 经过 <a href="http://selfboot.cn/2014/08/28/character_encoding/#%E5%8F%91%E6%89%AC%E5%85%89%E5%A4%A7-UTF-8%E7%BC%96%E7%A0%81">UTF-8 编码</a> 后的字节串。这里透漏了一个十分重要的信息，<strong>str类型隐含有某种编码方式</strong>，正是这种隐式编码（<em>implicit encoding</em>）的存在导致了许多问题的出现（后面详细说明）。值得注意的是，str类型字节串的隐式编码不一定都是’UTF-8’，前面示例程序都是在 OS X 平台下的终端，所以隐式编码是 UTF-8。对于 Windows 而言，如果语言设置为简体中文，那么交互界面输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Win 平台下，系统语言为简体中文</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_str = <span class="string">&#x27;Welcome to 广州&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_str, <span class="built_in">type</span>(str_str)</span><br><span class="line">(<span class="string">&#x27;Welcome to \xb9\xe3\xd6\xdd&#x27;</span>, &lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><p>这里str_str的隐式编码是<strong>cp936</strong>，可以用 <code>bytearray(unicode_str, &#39;cp936&#39;)</code> 来验证这点。终端下，str类型的隐式编码由系统 locale 决定，可以采用下面方式查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Unix or Linux</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> locale</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locale.getdefaultlocale()</span><br><span class="line">(<span class="string">&#x27;zh_CN&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 简体中文 Windows</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locale.getdefaultlocale()</span><br><span class="line">(<span class="string">&#x27;zh_CN&#x27;</span>, <span class="string">&#x27;cp936&#x27;</span>)</span><br></pre></td></tr></table></figure><p>总结一下，我们可以将 <code>&lt;type &#39;str&#39;&gt;</code> 看作是<strong>unicode字符串经过某种编码后的字节组成的数组</strong>。数组的每一项是一个字节，用 <code>\xhh</code> 来表示。所以对于 str 字符串来说，其长度等于编码后字节的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(str_str)</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_str[<span class="number">0</span>], str_str[-<span class="number">1</span>]</span><br><span class="line">(<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;\x9e&#x27;</span>)       <span class="comment"># 实际上是(&#x27;\x57&#x27;, &#x27;\x9e&#x27;)</span></span><br></pre></td></tr></table></figure><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Python 2.x 中为上面两种类型的字符串都提供了 <a href="https://docs.python.org/2/library/stdtypes.html#string-methods">encode 和 decode</a> 方法，原型如下：</p><blockquote><p>str.decode([encoding[, errors]])<br>str.encode([encoding[, errors]])</p></blockquote><p>利用上面的两个函数，可以实现 str 和 unicode 类型之间的相互转换，如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161228_encode_decode_3.png" alt="图3. 类型间相互转换"></p><p>上图中绿色线段标示的即为我们常用的转换方法，红色标示的转换在 python 2.x 中是合法的，不过没有什么意义，通常会抛出错误（可以参见 <a href="http://stackoverflow.com/questions/447107/what-is-the-difference-between-encode-decode">What is the difference between encode&#x2F;decode?</a>）。下面是两种类型之间的转换示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># decode： &lt;type &#x27;str&#x27;&gt; 到 &lt;type &#x27;unicode&#x27;&gt;的转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>enc = str_str.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>enc, <span class="built_in">type</span>(enc)</span><br><span class="line">(<span class="string">u&#x27;Welcome to \u5e7f\u5dde&#x27;</span>, &lt;<span class="built_in">type</span> <span class="string">&#x27;unicode&#x27;</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># encode： &lt;type &#x27;unicode&#x27;&gt; 到 &lt;type &#x27;str&#x27;&gt; 的转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dec = unicode_str.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dec, <span class="built_in">type</span>(dec)</span><br><span class="line">(<span class="string">&#x27;Welcome to \xe5\xb9\xbf\xe5\xb7\x9e&#x27;</span>, &lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><p>上面代码中通过encode将unicode类型<strong>编码</strong>为str类型，通过 decode 将str类型<strong>解码</strong>为unicode类型。当然，编码、解码的过程并不总是一帆风顺的，通常会出现各种错误。</p><h2 id="编、解码错误"><a href="#编、解码错误" class="headerlink" title="编、解码错误"></a>编、解码错误</h2><p>Python 中经常会遇到 UnicodeEncodeError 和 UnicodeDecodeError，怎么产生的呢？ 如下代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; u<span class="string">&#x27;Hello 广州&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 6-7: ordinal not in range(128)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;Hello 广州&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: &#x27;ascii&#x27; codec can&#x27;t decode byte 0xe5 in position 6: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>当我们用 ascii 去编码带有中文的unicode字符串时，发生了UnicodeEncodeError，当我们用 ascii 去解码有中文的str字节串时，发生了UnicodeDecodeError。我们知道，ascii 只包含 127 个字符，根本无法表示中文。所以，让 ascii 来编码、解码中文，就超出了其能力范围。这就像你对一个不懂中文的老外说中文，他根本没法听懂。简单来说，<strong>所有的编码、解码错误都是由于所选的编码、解码方式无法表示某些字符造成的</strong>。</p><p>有时候我们就是想用 ascii 去编码一段夹杂中文的str字节串，并不希望抛出异常。那么可以通过 errors 参数来指定当无法编码某个字符时的处理方式，常用的处理方式有 “strict”，”ignore”和”replace”。改动后的程序如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; u<span class="string">&#x27;Hello 广州&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>)</span></span><br><span class="line">&#x27;Hello ??&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; u<span class="string">&#x27;Hello 广州&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>)</span></span><br><span class="line">&#x27;Hello &#x27;</span><br></pre></td></tr></table></figure><h2 id="隐藏的解码"><a href="#隐藏的解码" class="headerlink" title="隐藏的解码"></a>隐藏的解码</h2><p>str和unicode类型都可以用来表示字符串，为了方便它们之间进行操作，python并不要求在操作之前统一类型，所以下面的代码是合法的，并且能得到正确的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; new_str = u<span class="string">&#x27;Welcome to &#x27;</span> + <span class="string">&#x27;GuangZhou&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; new_str, <span class="built_in">type</span>(new_str)</span></span><br><span class="line">(u&#x27;Welcome to GuangZhou&#x27;, &lt;type &#x27;unicode&#x27;&gt;)</span><br></pre></td></tr></table></figure><p>因为str类型是隐含有某种编码方式的字节码，所以python内部将其<strong>解码</strong>为unicode后，再和unicode类型进行 <code>+ 操作</code>，最后返回的结果也是unicode类型。</p><p>第2步的解码过程是在幕后悄悄发生的，<strong>默认采用ascii来进行解码</strong>，可以通过 <code>sys.getdefaultencoding()</code> 来获取默认编码方式。Python 之所以采用 ascii，是因为 ascii 是最早的编码方式，是许多编码方式的子集。</p><p>不过正是这个不可见的解码过程，有时候会导致出乎意料的解码错误，考虑下面的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; u<span class="string">&#x27;Welcome to&#x27;</span> + <span class="string">&#x27;广州&#x27;</span></span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: &#x27;ascii&#x27; codec can&#x27;t decode byte 0xe5 in position 0: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>上面在字符串的+操作时，python 偷偷对’广州’用 ascii 做解码操作，所以抛出了UnicodeDecodeError异常。其实上面操作等同于 <code>u&#39;Welcome to&#39; + &#39;广州&#39;.decode(&#39;ascii&#39;)</code> ，你会发现这句代码抛出的异常和上面的一模一样。</p><h2 id="隐藏的编码"><a href="#隐藏的编码" class="headerlink" title="隐藏的编码"></a>隐藏的编码</h2><p>Python 不只偷偷地用 ascii 来解码str类型的字节串，有时还会偷偷用ascii来编码unicode类型。如果函数或类等对象接收的是 str 类型的字符串，但传进去的是unicode，python2 就会使用 ascii 将其编码成str类型再做运算。</p><p>以raw_input为例，我们可以给 <a href="https://docs.python.org/2/library/functions.html#raw_input">raw_input</a> 函数提供 prompt 参数，作为输入提示内容。这里如果 prompt 是 unicode 类型，python会先用ascii对其进行编码，所以下面代码会抛出UnicodeEncodeError异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = raw_input(u<span class="string">&#x27;请输入内容: &#x27;</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 0-4: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>上面操作完全等同于 <code>a = raw_input(u&#39;请输入内容: &#39;.encode(&#39;ascii&#39;))</code>，你会发现它们抛出的异常完全一样。此外，如果尝试将unicode字符串重定向输出到文本中，也可能会抛出UnicodeEncodeError异常。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> a.py</span></span><br><span class="line">demo = u&#x27;Test 试试&#x27;</span><br><span class="line">print demo</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python a.py &gt; output</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;a.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    print demo</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 5-6: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>当然，如果直接在终端进行输出，则不会抛出异常。因为python会使用控制台的默认编码，而不是 ascii。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结下本文的内容：</p><ul><li>str可以看作是unicode字符串经过某种编码后的字节组成的数组</li><li>unicode是真正意义上的字符串</li><li>通过 encode 可以将unicode类型<strong>编码</strong>为str类型</li><li>通过 decode 可以将str类型<strong>解码</strong>为unicode类型</li><li>python 会隐式地进行编码、解码，默认采用 ascii</li><li>所有的编码、解码错误都是由于所选的编码、解码方式无法表示某些字符造成的</li></ul><p>如果你明白了上面每句话的含义，那么应该能解决大部分编、解码引起的问题了。当然，本篇文章其实并不能帮你完全避免python编码中的坑（坑太多）。还有许多问题在这里并没有说明：</p><ul><li>读取、写入文件时的编码问题：</li><li>数据库的读写</li><li>网络数据操作</li><li>源文件编码格式的指定</li></ul><p>有空再详细谈谈上面列出的坑。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://nedbatchelder.com/text/unipain.html">Pragmatic Unicode</a><br><a href="http://farmdev.com/talks/unicode/">Unicode In Python, Completely Demystified</a><br><a href="https://www.azavea.com/blog/2014/03/24/solving-unicode-problems-in-python-2-7/">Solving Unicode Problems in Python 2.7</a><br><a href="https://docs.python.org/2.7/howto/unicode.html">Unicode HOWTO</a><br><a href="https://wiki.python.org/moin/PrintFails">Wiki：PrintFails</a><br><a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">Unicode and Character Sets</a><br><a href="http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python">What is the purpose of __str__ and __repr__ in Python?</a><br><a href="http://stackoverflow.com/questions/2672326/what-does-a-leading-x-mean-in-a-python-string-xaa">What does a leading \x mean in a Python string \xaa</a></p><p><a href="https://funhacks.net/2016/11/25/character_encoding/">Python: 熟悉又陌生的字符编码</a><br><a href="http://wklken.me/posts/2013/08/31/python-extra-coding-intro.html">PYTHON-进阶-编码处理小结</a><br><a href="http://python.jobbole.com/85482/">五分钟战胜 Python 字符编码</a><br><a href="http://blog.csdn.net/trochiluses/article/details/16825269">python 字符编码与解码</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;http://selfboot.cn/2014/08/28/character_encoding/&quot;&gt;人机交互之字符编码&lt;/a&gt; 一文中对字符编码进行了详细的讨论，并通过一些简单的小程序验证了我们对于字符编码的认识。但仅了解这篇文章的内容，并不能帮我们在日常编程中躲过一些字符编码相关的坑，Stackoverflow 上就有大量编码相关的问题，比如 &lt;a href=&quot;http://stackoverflow.com/questions/9942594/unicodeencodeerror-ascii-codec-cant-encode-character-u-xa0-in-position-20&quot;&gt;1&lt;/a&gt;，&lt;a href=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161228_encode_decode_2.png&quot;&gt;2&lt;/a&gt;(Python: Convert Unicode to ASCII without errors)，&lt;a href=&quot;http://stackoverflow.com/questions/2688020/how-to-print-chinese-word-in-my-code-using-python&quot;&gt;3&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161228_encode_decode_1.png&quot; alt=&quot;图1. 错误的编解码&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文首先尝试对编码、解码进行一个&lt;strong&gt;宏观、直观&lt;/strong&gt;的解读，然后详细来解释 python2 中的str和unicode，并对常见的UnicodeEncodeError 和 UnicodeDecodeError 异常进行剖析。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://selfboot.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="方法" scheme="https://selfboot.cn/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Python中的ThreadLocal变量（下）</title>
    <link href="https://selfboot.cn/2016/11/03/threadlocal_enhance/"/>
    <id>https://selfboot.cn/2016/11/03/threadlocal_enhance/</id>
    <published>2016-11-03T22:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://selfboot.cn/2016/08/22/threadlocal_overview/">上篇</a>我们看到了 ThreadLocal 变量的简单使用，<a href="http://selfboot.cn/2016/08/26/threadlocal_implement/">中篇</a>对python中 ThreadLocal 的实现进行了分析，但故事还没有结束。本篇我们一起来看下<a href="http://werkzeug.pocoo.org/">Werkzeug</a>中ThreadLocal的设计。</p><p>Werkzeug 作为一个 WSGI 工具库，由于一些方面的考虑，并没有直接使用python内置的ThreadLocal类，而是自己实现了一系列Local类。包括简单的Local，以及在此基础上实现的LocalStack，LocalManager 和 LocalProxy。接下来我们一起来看看这些类的使用方式，设计的初衷，以及具体的实现技巧。</p><span id="more"></span><h1 id="Local-类的设计"><a href="#Local-类的设计" class="headerlink" title="Local 类的设计"></a>Local 类的设计</h1><p>Werkzeug 的设计者认为python自带的ThreadLocal并不能满足需求，主要因为下面两个原因：</p><ol><li>Werkzeug 主要用“ThreadLocal”来满足并发的要求，python 自带的ThreadLocal只能实现基于线程的并发。而python中还有其他许多并发方式，比如常见的<a href="https://github.com/xuelangZF/CS_Offer/blob/4ab9bed1a0b11b34f1761ba2ead3bf8387350d60/Python/Coroutine.md">协程</a>（greenlet），因此需要实现一种能够支持协程的Local对象。</li><li><a href="http://selfboot.cn/2016/08/07/forum_design_wsgi/">WSGI</a>不保证每次都会产生一个新的线程来处理请求，也就是说线程是可以复用的（可以维护一个线程池来处理请求）。这样如果werkzeug 使用python自带的ThreadLocal，一个“不干净（存有之前处理过的请求的相关数据）”的线程会被用来处理新的请求。</li></ol><p>为了解决这两个问题，werkzeug 中实现了Local类。Local对象可以做到线程和协程之间数据的隔离，此外，还要支持清理某个线程或者协程下的数据（这样就可以在处理一个请求之后，清理相应的数据，然后等待下一个请求的到来）。</p><p>具体怎么实现的呢，思想其实特别简单，我们在<a href="http://selfboot.cn/2016/08/22/threadlocal_overview/">深入理解Python中的ThreadLocal变量（上）</a> 一文的最后有提起过，就是创建一个全局字典，然后将线程（或者协程）标识符作为key，相应线程（或协程）的局部数据作为 value。这里 werkzeug 就是按照上面思路进行实现，不过利用了python的一些黑魔法，最后提供给用户一个清晰、简单的接口。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>Local 类的实现在 <a href="https://github.com/pallets/werkzeug/blob/master/werkzeug/local.py">werkzeug.local</a> 中，以 <a href="https://github.com/pallets/werkzeug/commit/8a84b62b3dd89fe7d720d7948954e20ada690c40">8a84b62</a> 版本的代码进行分析。通过前两篇对ThreadLocal的了解，我们已经知道了Local对象的特点和使用方法。所以这里不再给出Local对象的使用例子，我们直接看代码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="constructor">Local(<span class="params">object</span>)</span>:</span><br><span class="line">    __slots__ = (&#x27;__storage__&#x27;, &#x27;__ident_func__&#x27;)</span><br><span class="line"></span><br><span class="line">    def <span class="constructor">__init__(<span class="params">self</span>)</span>:</span><br><span class="line">        <span class="keyword">object</span>.<span class="constructor">__setattr__(<span class="params">self</span>, &#x27;<span class="params">__storage__</span>&#x27;, &#123;&#125;)</span></span><br><span class="line">        <span class="keyword">object</span>.<span class="constructor">__setattr__(<span class="params">self</span>, &#x27;<span class="params">__ident_func__</span>&#x27;, <span class="params">get_ident</span>)</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>由于可能有大量的Local对象，为了节省Local对象占用的空间，这里使用 <code>__slots__</code> 写死了Local可以拥有的属性：</p><ul><li>__storage__： 值为一个字典，用来保存实际的数据，初始化为空；</li><li>__ident_func__：值为一个函数，用来找到当前线程或者协程的标志符。</li></ul><p>由于Local对象实际的数据保存在__storage__中，所以对Local属性的操作其实是对__storage__的操作。对于获取属性而言，这里用魔术方法<code>__getattr__</code>拦截__storage__ 和 __ident_func__以外的属性获取，将其导向__storage__存储的当前线程或协程的数据。而对于属性值的set或者del，则分别用__setattr__和__setattr__来实现（这些魔术方法的介绍见<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python/Class.md#%E5%B1%9E%E6%80%A7%E6%8E%A7%E5%88%B6">属性控制</a>）。关键代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">    ident = self.__ident_func__()</span><br><span class="line">    storage = self.__storage__</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        storage[ident][name] = value</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__delattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(name)</span><br></pre></td></tr></table></figure><p>假设我们有ID为1，2， … ， N 的N个线程或者协程，每个都用Local对象保存有自己的一些局部数据，那么Local对象的内容如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161103_threadlocal_enhance_1.png"></p><p>此外，Local类还提供了<code>__release_local__</code>方法，用来释放当前线程或者协程保存的数据。</p><h1 id="Local-扩展接口"><a href="#Local-扩展接口" class="headerlink" title="Local 扩展接口"></a>Local 扩展接口</h1><p>Werkzeug 在 Local 的基础上实现了 LocalStack 和 LocalManager，用来提供更加友好的接口支持。</p><h2 id="LocalStack"><a href="#LocalStack" class="headerlink" title="LocalStack"></a>LocalStack</h2><p>LocalStack通过封装Local从而实现了一个线程（或者协程）独立的栈结构，注释里面有具体的使用方法，一个简单的使用例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls = LocalStack()</span><br><span class="line">ls.push(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span> ls.top    <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span> ls._local.__storage__</span><br><span class="line"><span class="comment"># &#123;140735190843392: &#123;&#x27;stack&#x27;: [12]&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>LocalStack 的实现比较有意思，它将一个Local对象作为自己的属性<code>_local</code>，然后定义接口push, pop 和 top 方法进行相应的栈操作。这里用 <strong>_local.__storage__.[_local.__ident_func__()][‘stack’]</strong> 这个list来模拟栈结构。在接口push, pop和top中，通过操作这个list来模拟栈的操作，需要注意的是在接口函数内部获取这个list时，不用像上面黑体那么复杂，可以直接用_local的getattr()方法即可。以 push 函数为例，实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, obj</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Pushes a new item to the stack&quot;&quot;&quot;</span></span><br><span class="line">    rv = <span class="built_in">getattr</span>(self._local, <span class="string">&#x27;stack&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._local.stack = rv = []</span><br><span class="line">    rv.append(obj)</span><br><span class="line">    <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure><p>pop 和 top 的实现和一般栈类似，都是对 <code>stack = getattr(self._local, &#39;stack&#39;, None)</code> 这个列表进行相应的操作。此外，LocalStack还允许我们自定义<code>__ident_func__</code>，这里用 <a href="https://docs.python.org/2/library/functions.html#property">内置函数 property</a> 生成了<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python/Descriptor.md">描述器</a>，封装了__ident_func__的get和set操作，提供了一个属性值__ident_func__作为接口，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get__ident_func__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self._local.__ident_func__</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_set__ident_func__</span>(<span class="params">self, value</span>):</span><br><span class="line">    <span class="built_in">object</span>.__setattr__(self._local, <span class="string">&#x27;__ident_func__&#x27;</span>, value)</span><br><span class="line">__ident_func__ = <span class="built_in">property</span>(_get__ident_func__, _set__ident_func__)</span><br><span class="line"><span class="keyword">del</span> _get__ident_func__, _set__ident_func__</span><br></pre></td></tr></table></figure><h1 id="LocalManager"><a href="#LocalManager" class="headerlink" title="LocalManager"></a>LocalManager</h1><p>Local 和 LocalStack 都是线程或者协程独立的单个对象，很多时候我们需要一个线程或者协程独立的容器，来组织多个Local或者LocalStack对象（就像我们用一个list来组织多个int或者string类型一样）。</p><p>Werkzeug实现了LocalManager，它通过一个list类型的属性locals来存储所管理的Local或者LocalStack对象，还提供cleanup方法来释放所有的Local对象。Werkzeug中LocalManager最主要的接口就是<a href="http://selfboot.cn/2014/08/10/python_decorator/">装饰器</a>方法<code>make_middleware</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_middleware</span>(<span class="params">self, app</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Wrap a WSGI application so that cleaning up happens after</span></span><br><span class="line"><span class="string">    request end.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">        <span class="keyword">return</span> ClosingIterator(app(environ, start_response), self.cleanup)</span><br><span class="line">    <span class="keyword">return</span> application</span><br></pre></td></tr></table></figure><p>这个装饰器注册了回调函数cleanup，当一个线程（或者协程）处理完请求之后，就会调用cleanup清理它所管理的Local或者LocalStack 对象（ClosingIterator 的实现在 <a href="https://github.com/pallets/werkzeug/blob/master/werkzeug/wsgi.py">werkzeug.wsgi</a>中）。下面是一个使用 LocalManager 的简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local, LocalManager</span><br><span class="line"></span><br><span class="line">local = Local()</span><br><span class="line">local_2 = Local()</span><br><span class="line">local_manager = LocalManager([local, local2])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">    local.request = request = Request(environ)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># application 处理完毕后，会自动清理local_manager 的内容</span></span><br><span class="line">application = local_manager.make_middleware(application)</span><br></pre></td></tr></table></figure><p>通过LocalManager的make_middleware我们可以在某个线程（协程）处理完一个请求后，清空所有的Local或者LocalStack对象，这样这个线程又可以处理另一个请求了。至此，文章开始时提到的第二个问题就可以解决了。Werkzeug.local 里面还实现了一个 LocalProxy 用来作为Local对象的代理，也非常值得去学习。</p><p>通过这三篇文章，相信对 ThreadLocal 有了一个初步的了解。Python标准库和Werkzeug在实现中都用到了很多python的黑魔法，不过最终提供给用户的都是非常友好的接口。Werkzeug作为WSGI 工具集，为了解决Web开发中的特定使用问题，提供了一个改进版本，并且进行了一系列封装，便于使用。不得不说，werkzeug的代码可读性非常好，注释也是写的非常棒，建议去阅读源码。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://werkzeug.pocoo.org/docs/0.11/local/">Context Locals</a><br><a href="https://docs.python.org/2/tutorial/classes.html#private-variables-and-class-local-references">Private Variables and Class-local References</a><br><a href="http://stackoverflow.com/questions/17330160/how-does-the-property-decorator-work">How does the @property decorator work?</a><br><a href="http://stackoverflow.com/questions/350404/how-do-the-proxy-decorator-adapter-and-bridge-patterns-differ/350471#350471">How do the Proxy, Decorator, Adapter, and Bridge Patterns differ?</a></p><p><a href="http://mingxinglai.com/cn/2016/08/flask-source-code/">Flask源码剖析</a><br><a href="https://www.15yan.com/story/j7BfM4NHEI9/">Werkzeug.locals 模块解读</a><br><a href="http://www.zlovezl.cn/articles/charming-python-start-from-flask-request/">Charming Python: 从Flask的request说起</a><br><a href="http://stackoverflow.com/questions/11277432/how-to-remove-a-key-from-a-python-dictionary">How to remove a key from a python dictionary?</a><br><a href="https://www.ficapy.com/2016/08/03/werkzeug_local_note/">werkzeug源码分析(local.py)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;http://selfboot.cn/2016/08/22/threadlocal_overview/&quot;&gt;上篇&lt;/a&gt;我们看到了 ThreadLocal 变量的简单使用，&lt;a href=&quot;http://selfboot.cn/2016/08/26/threadlocal_implement/&quot;&gt;中篇&lt;/a&gt;对python中 ThreadLocal 的实现进行了分析，但故事还没有结束。本篇我们一起来看下&lt;a href=&quot;http://werkzeug.pocoo.org/&quot;&gt;Werkzeug&lt;/a&gt;中ThreadLocal的设计。&lt;/p&gt;
&lt;p&gt;Werkzeug 作为一个 WSGI 工具库，由于一些方面的考虑，并没有直接使用python内置的ThreadLocal类，而是自己实现了一系列Local类。包括简单的Local，以及在此基础上实现的LocalStack，LocalManager 和 LocalProxy。接下来我们一起来看看这些类的使用方式，设计的初衷，以及具体的实现技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Flask" scheme="https://selfboot.cn/tags/Flask/"/>
    
    <category term="Thread" scheme="https://selfboot.cn/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建论坛（三）：Flask框架简单介绍</title>
    <link href="https://selfboot.cn/2016/10/30/forum_design_flask/"/>
    <id>https://selfboot.cn/2016/10/30/forum_design_flask/</id>
    <published>2016-10-30T22:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>前面两篇文章中我们已经了解 Web(HTTP)服务器，Web应用程序，Web框架，WSGI这些 Python Web 开发中的概念。我们知道，Web框架通过将不同Web应用程序中的共性部分给抽象出来，提供一系列通用的接口，从而避免开发者做重复性工作，让其将精力放在业务相关的实现。</p><p>接下来一起来看一个具体的 Web 框架，这里选择 Flask，因为它是一个年轻充满活力的微框架，有着众多的拥护者，文档齐全，社区活跃度高。我们的<a href="https://github.com/xuelangZF/NaHan">论坛项目</a> 就使用了该框架。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161030_forum_design_flask_1.png"></p><span id="more"></span><h1 id="Flask-框架"><a href="#Flask-框架" class="headerlink" title="Flask 框架"></a>Flask 框架</h1><p>为了理解 Flask 框架是如何抽象出Web开发中的共同部分，我们先来看看Web应用程序的一般流程。对于Web应用来说，当客户端想要获取<strong>动态资源</strong>时，就会发起一个HTTP请求（比如用浏览器访问一个 URL），Web应用程序会在后台进行相应的业务处理，（从数据库或者进行一些计算操作等）取出用户需要的数据，生成相应的HTTP响应（当然，如果访问静态资源，则直接返回资源即可，不需要进行业务处理）。整个处理过程如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161030_forum_design_flask_2.png"></p><p>实际应用中，<strong>不同的请求可能会调用相同的处理逻辑</strong>。这里有着相同业务处理逻辑的 HTTP 请求可以用一类 URL 来标识。比如论坛站点中，对于所有的获取Topic内容的请求而言，可以用 <code>topic/&lt;topic_id&gt;/</code> 这类URL来表示，这里的 topic_id 用以区分不同的topic。接着在后台定义一个 <code>get_topic(topic_id)</code> 的函数，用来获取topic相应的数据，此外还需要建立URL和函数之间的一一对应关系。这就是Web开发中所谓的<strong>路由分发</strong>，如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161030_forum_design_flask_3.png"></p><p>Flask底层使用<a href="https://github.com/pallets/werkzeug">werkzeug</a>来做路由分发，代码写起来十分简单，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/topic/&lt;int:topic_id&gt;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_topic</span>(<span class="params">topic_id</span>):</span><br><span class="line">    <span class="comment"># Do some cal or read from database</span></span><br><span class="line">    <span class="comment"># Get the data we need.</span></span><br></pre></td></tr></table></figure><p>通过业务逻辑函数拿到数据后，接下来需要根据这些数据生成HTTP响应（对于Web应用来说，HTTP响应一般是一个HTML文件）。Web开发中的一般做法是提供一个HTML模板文件，然后将数据传入模板，经过渲染后得到最终需要的HTML响应文件。</p><p>一种比较常见的场景是，<strong>请求虽然不同，但响应中数据的展示方式是相同的</strong>。仍以论坛为例，对不同topic而言，其具体topic content虽然不同，但页面展示的方式是一样的，都有标题拦，内容栏等。也就是说，对于 topic 来说，我们只需提供一个HTML模板，然后传入不同topic数据，即得到不同的HTTP响应。这就是所谓的<strong>模板渲染</strong>，如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161030_forum_design_flask_4.png"></p><p>Flask 使用 <a href="https://github.com/pallets/jinja">Jinja2</a> 模板渲染引擎来做模板渲染，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/topic/&lt;int:topic_id&gt;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_topic</span>(<span class="params">topic_id</span>):</span><br><span class="line">    <span class="comment"># Do some cal or read from database</span></span><br><span class="line">    <span class="comment"># Get the data we need.</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;path/to/template.html&#x27;</span>, data_needed)</span><br></pre></td></tr></table></figure><p>总结一下，Flask处理一个请求的流程就是，首先根据 URL 决定由那个函数来处理，然后在函数中进行操作，取得所需的数据。再将数据传给相应的模板文件中，由Jinja2 负责渲染得到 HTTP 响应内容，然后由Flask返回响应内容。</p><h1 id="Flask-入门"><a href="#Flask-入门" class="headerlink" title="Flask 入门"></a>Flask 入门</h1><p>关于 Flask 框架的学习，不建议直接读<a href="http://flask.pocoo.org/docs/0.11/">官网文档</a>，虽然这是一手的权威资料，但并不适合初学者入手。这里推荐几个学习资料，可以帮助新手很快的入门：</p><p>汇智网<a href="http://www.hubwiz.com/course/562427361bc20c980538e26f/">flask框架</a>教程：一个非常适合入门的精简教程，主要分为七部分：</p><ul><li>快速入门</li><li>路由：URL 规则与视图函数</li><li>请求、应答与会话</li><li>上下文对象：Flask 核心机制</li><li>模版：分离数据与视图</li><li>访问数据库：SQLAlchemy简介</li><li>蓝图：Flask应用组件化</li></ul><p>教程简练地总结了 Flask 最核心的内容，并且还提供了一个简单的在线练习环境，方便一边学习理论一边动手实践。</p><p>此外，麦子学院也有一个 <a href="http://www.maiziedu.com/course/313/">Flask入门</a> 视频教程，一共8小时的视频教程，涵盖flask web 开发的方方面面，包括环境的搭建，flask 语法介绍，项目结构的组织，flask 全球化，单元测试等内容。视频作者有 17 年软件开发经验，曾任微软深圳技术经理及多家海外机构担任技术顾问，够牛！视频讲的也确实不错。</p><p>如果上面两个不能满足你，那么还可以看 <a href="https://book.douban.com/subject/26274202/">Flask Web开发：基于Python的Web应用开发实战</a> 这本有着 8.6 评分的书，相信没看完就跃跃欲试想写点什么了。这么优秀的框架，Github 上当然也有 <a href="https://github.com/humiaozuzu/awesome-flask">awesome-flask</a>了，想深入学习flask的话，这里不失为一个好的资源帖。</p><p>本篇大概谈了下 Flask 的路由分发和模版渲染，下篇我们会继续讲Flask使用中的一些问题。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks">What is the purpose of Flask’s context stacks?</a><br><a href="https://blog.tonyseek.com/post/the-context-mechanism-of-flask/">Flask 的 Context 机制</a><br><a href="http://python.jobbole.com/81396/">Flask、Django、Pyramid三个框架的对比</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面两篇文章中我们已经了解 Web(HTTP)服务器，Web应用程序，Web框架，WSGI这些 Python Web 开发中的概念。我们知道，Web框架通过将不同Web应用程序中的共性部分给抽象出来，提供一系列通用的接口，从而避免开发者做重复性工作，让其将精力放在业务相关的实现。&lt;/p&gt;
&lt;p&gt;接下来一起来看一个具体的 Web 框架，这里选择 Flask，因为它是一个年轻充满活力的微框架，有着众多的拥护者，文档齐全，社区活跃度高。我们的&lt;a href=&quot;https://github.com/xuelangZF/NaHan&quot;&gt;论坛项目&lt;/a&gt; 就使用了该框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161030_forum_design_flask_1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="项目实践" scheme="https://selfboot.cn/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Flask" scheme="https://selfboot.cn/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的未定义行为</title>
    <link href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/"/>
    <id>https://selfboot.cn/2016/09/18/c++_undefined_behaviours/</id>
    <published>2016-09-18T22:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们需要一个程序从控制台读入一个 INT 型整数（输入确保是INT），然后输出其绝对值，你可能闭着眼睛就会写出下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">abs</span>(n) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等下，好好思考两分钟，然后写几个测试例子跑一下程序。那么你找出程序存在的问题了吗？好了，欢迎走进未定义行为 (Undefined Behavior) 的世界。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160918_ub.png"></p><span id="more"></span><h1 id="什么是未定义行为"><a href="#什么是未定义行为" class="headerlink" title="什么是未定义行为"></a>什么是未定义行为</h1><p>文章一开始的程序中用到了 abs 求绝对值函数，当n为 INT_MIN 时，函数返回什么呢？<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf">C++ 标准</a>中有这么一条：</p><blockquote><p>If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.</p></blockquote><p>在一个2进制系统中，当 n 是 INT_MIN 时，<code>int abs(int n)</code> 返回的值超出了 int 的范围，所以这将导致一个未定义行为。很多时候，标准过于精炼，不便于我们快速查找，因此我们可以在 <a href="http://en.cppreference.com/w/cpp">cppreference</a> 找到需要的信息，以 abs函数为例，cppreference 明确指出可能导致未定义行为：</p><blockquote><p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.</p></blockquote><p>那么到底什么是未定义行为呢？简单来说，就是某个操作逻辑上是不合法的，比如越界访问数组等，但是C++ 标准并没有告诉我们遇到这种情况该如何去处理。</p><p>我们知道在大部分语言（比如 Python 和 Java）中，一个语句要么按照我们的预期正确执行，要么立即抛出异常。但是在 C++ 中，还有一种情况就是，某条语句并没有按照预期执行（逻辑上已经出错了），但是程序还是可以继续执行（C++标准没有告诉怎么继续执行）。只不过程序的行为已经不可预测了，也就是说程序可能发生运行时错误，也可能给出错误的结果，甚至还可能给出正确的结果。</p><p>有一点需要注意的是，对于有的未定义行为，现代编译器有时候可以给出警告，或者是编译失败的提示信息。此外，不同编译器对于未定义行为的处理方式也不同。</p><h1 id="常见的未定义行为"><a href="#常见的未定义行为" class="headerlink" title="常见的未定义行为"></a>常见的未定义行为</h1><p>C++ 标准中有大量的未定义行为，如果在标准中查找 <code>undefined behavior</code>，将会看到几十条相关内容。如此众多的未定义行为，无疑给我们带来了许多麻烦，下面我们将列出一些常见的未定义行为，写程序时应该尽量避免。</p><p>指针相关的常见未定义行为有如下内容：</p><ul><li>解引用 nullptr 指针；</li><li>解引用一个未初始化的指针；</li><li>解引用 new 操作失败返回的指针；</li><li>指针访问越界（解引用一个超出数组边界的指针）；</li><li>解引用一个指向已销毁对象的指针；</li></ul><p>解引用一个指向已销毁对象的指针，有时候很容易就会犯这个错误，例如在<a href="https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Function.md#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">函数中返回局部指针地址</a>。 一些简单的错误代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">get</span><span class="params">(<span class="type">int</span> tmp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *foo = <span class="built_in">get</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; *foo &lt;&lt; std::endl; <span class="comment">// Undefined Behavior;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; *(arr+<span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// Undefined Behavior;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *bar=<span class="number">0</span>;</span><br><span class="line">    *bar = <span class="number">2</span>;                       <span class="comment">// Undefined Behavior;</span></span><br><span class="line">    std::cout &lt;&lt; *bar &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他常见未定义行为如下：</p><ul><li>有符号整数溢出（文章开头的例子）；</li><li>整数做左移操作时，移动的位数为负数；</li><li>整数做移位操作时，移动的位数超出整型占的位数。（int64_t i &#x3D; 1; i &lt;&lt;&#x3D; 72）；</li><li>尝试修改字符串字面值或者常量的内容；</li><li>对自动初始化且没有赋初值的变量进行操作；（int i; i++; cout &lt;&lt; i;）</li><li>在有返回值的函数结束时不返回内容；</li></ul><p>更完整的未定义行为列表可以在<a href="http://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviours-that-a-c-programmer-should-know-a">这里</a>找到。</p><h1 id="为什么存在未定义行为"><a href="#为什么存在未定义行为" class="headerlink" title="为什么存在未定义行为"></a>为什么存在未定义行为</h1><p>C++ 程序经常因为未定义行为而出现各种千奇百怪的 Bug，调试起来也十分困难。相反，其他很多语言中并没有未定义行为，比如 python，当访问 list 越界时会抛出 <code>list index out of range</code>，这些语言中不会因为未定义行为出现各种奇怪的错误。那么为什么 C++ 标准为什么要搞这么多未定义行为呢？</p><p>原因是这样可以<strong>简化编译器的工作，有时候还可以产生更加高效的代码</strong>。举个例子来说，如果我们想让解引用指针的操作行为变的明确起来（成功或者抛出异常），就需要在编译期知道指针使用是否合法，那么编译器至少需要做下面这些工作：</p><ul><li>检查指针是否为 nullptr；</li><li>通过某种机制检查指针保存的地址是否合法；</li><li>通过某种机制抛出错误</li></ul><p>这样的话编译器的实现会复杂很多。此外，如果我们有一个循环需要对大量的指针进行操作，那么编译生成的代码就会因为做各种附加检查而导致效率低下。</p><p>实际上，很多未定义行为，都是因为程序违反了某一先决条件而导致的，比如赋给指针的地址值必须是可访问的，数组访问时下标在正确的范围内。对 C++来说，语言设计者认为这是程序员（大家都是成年人了）需要保证的内容，语言层面并不会去做相应的检查。</p><p>不过，好消息是现在很多编译器已经可以诊断出一些可能导致未定义行为的操作，可以帮我们写出更加健壮的程序。</p><h1 id="其他一些行为"><a href="#其他一些行为" class="headerlink" title="其他一些行为"></a>其他一些行为</h1><p>C++ 标准还规定了一些 <strong>Unspecified Behavior</strong>，一个简单的例子（一个大公司曾经的笔试题目）如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Cal</span>(<span class="built_in">get</span>(<span class="number">0</span>), <span class="built_in">get</span>(<span class="number">10</span>)) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出多少？答案是视编译器而定，可能是0 10 12，也可能是 10 0 12。这是因为<strong>函数参数的执行顺序是 Unspecified Behavior</strong>，引用C++标准对 Unspecified Behavior 的说明：</p><blockquote><p>Unspecified behavior use of an unspecified value, or other behavior where this International Standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance.</p></blockquote><p>此外，C++标准中还有所谓的 <code>implementation-defined behavior</code>，比如C++标准说需要一个数据类型，然后具体的编译器去选择该类型占用的字节数，或者是存储方式（大端还是小端）。</p><p>一般情况下，我们需要关心的只有未定义行为，因为它通常会导致程序出错。而其他的两种行为，不需要我们去关心。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://en.cppreference.com/w/cpp/language/ub">Cppreference：Undefined behavior</a><br><a href="http://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviours-that-a-c-programmer-should-know-a">What are all the common undefined behaviors that a C++ programmer should know about? </a><br><a href="http://stackoverflow.com/questions/98340/what-are-the-common-undefined-unspecified-behavior-for-c-that-you-run-into">What are the common undefined&#x2F;unspecified behavior for C that you run into?</a><br><a href="http://stackoverflow.com/questions/9566187/function-parameter-evaluation-order">function parameter evaluation order</a><br><a href="http://blog.regehr.org/archives/213">A Guide to Undefined Behavior in C and C++, Part 1</a><br><a href="http://blog.regehr.org/archives/213">A Guide to Undefined Behavior in C and C++, Part 2</a><br><a href="https://www.quora.com/Why-is-there-so-much-undefined-behaviour-in-C++-Wouldnt-it-be-better-if-some-of-them-were-pre-defined-in-the-standard">Why is there so much undefined behavior in C++? </a><br><a href="http://www.cplusplus.com/reference/cstdlib/abs/?kw=abs">Cplusplus: abs</a><br><a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">What Every C Programmer Should Know About Undefined Behavior</a><br><a href="http://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points">Undefined behavior and sequence points</a><br><a href="http://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior">Undefined, unspecified and implementation-defined behavior</a><br><a href="http://stackoverflow.com/questions/81656/where-do-i-find-the-current-c-or-c-standard-documents">Where do I find the current C or C++ standard documents?</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们需要一个程序从控制台读入一个 INT 型整数（输入确保是INT），然后输出其绝对值，你可能闭着眼睛就会写出下面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cin &amp;gt;&amp;gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;abs&lt;/span&gt;(n) &amp;lt;&amp;lt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;等下，好好思考两分钟，然后写几个测试例子跑一下程序。那么你找出程序存在的问题了吗？好了，欢迎走进未定义行为 (Undefined Behavior) 的世界。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160918_ub.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>被忽视的 partition 算法</title>
    <link href="https://selfboot.cn/2016/09/01/lost_partition/"/>
    <id>https://selfboot.cn/2016/09/01/lost_partition/</id>
    <published>2016-09-01T12:02:08.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>如果你学习过算法，那么肯定听说过快速排序的大名，但是对于快速排序中用到的 partition 算法，你了解的够多吗？或许是快速排序太过于光芒四射，使得我们往往会忽视掉同样重要的 partition 算法。</p><p>Partition 可不只用在快速排序中，还可以用于 <a href="https://en.wikipedia.org/wiki/Selection_algorithm">Selection algorithm</a>（在无序数组中寻找第K大的值）中。甚至有可能正是这种<strong>通过一趟扫描来进行分类的思想</strong>激发 Edsger Dijkstra 想出了 Three-way Partitioning，高效地解决了 <a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">Dutch national flag problem</a> 问题。接下来我们一起来探索 partition 算法。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160901_lost_partition_1.png" alt="Partition 一次扫描进行划分"></p><span id="more"></span><h1 id="Partition-实现"><a href="#Partition-实现" class="headerlink" title="Partition 实现"></a>Partition 实现</h1><p>快速排序中用到的 partition 算法思想很简单，首先从无序数组中选出枢轴点 pivot，然后通过一趟扫描，以 pivot 为分界线将数组中其他元素分为两部分，使得左边部分的数小于等于枢轴，右边部分的数大于等于枢轴（左部分或者右部分都可能为空），最后返回枢轴在新的数组中的位置。</p><p>Partition 的一个直观简单实现如下（这里取数组的第一个元素为pivot）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do partition in arr[begin, end), with the first element as the pivot.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[begin];</span><br><span class="line">    <span class="comment">// Last position where puts the no_larger element.</span></span><br><span class="line">    <span class="type">int</span> pos = begin;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=begin+<span class="number">1</span>; i!=end; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= pivot)&#123;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">if</span>(i!=pos)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[pos], arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[begin], arr[pos]);</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果原始数组为[5,9,2,1,4,7,5,8,3,6]，那么整个处理的过程如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160901_lost_partition_2.png" alt="Partition 简单实现"></p><p>这种实现思路比较直观，但是其实并不高效。从直观上来分析一下，每个小于pivot的值<strong>基本上</strong>（除非到现在为止还没有遇见大于pivot的值）都需要一次交换，大于pivot的值（例如上图中的数字9）有可能需要被交换多次才能到达最终的位置。</p><p>如果我们考虑用 <a href="https://github.com/xuelangZF/LeetCode/tree/master/TwoPointers">Two Pointers</a> 的思想，保持头尾两个指针向中间扫描，每次在头部找到大于pivot的值，同时在尾部找到小于pivot的值，然后将它们做一个交换，就可以一次把这两个数字放到最终的位置。一种比较明智的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[begin];</span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end &amp;&amp; arr[--end] &gt;= pivot);</span><br><span class="line">        arr[begin] = arr[end];</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end &amp;&amp; arr[++begin] &lt;= pivot);</span><br><span class="line">        arr[end] = arr[begin];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[begin] = pivot;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是第一次看到上面的代码，那么停下来，好好品味一下。这里没有用到 swap 函数，但其实也相当于做了 swap 操作。以前面的数组为例，看看以这种方法来做的话，整个处理的流程。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160901_lost_partition_3.png" alt="Partition 高效实现"></p><p>直观上来看，赋值操作的次数不多，比前面单向扫描的swap次数都少，效率应该会更高。<a href="http://cs.stackexchange.com/questions/11458/quicksort-partitioning-hoare-vs-lomuto/11550">这里</a>从理论上对这两种方法进行了分析，有兴趣可以看看。</p><h1 id="Partition-应用"><a href="#Partition-应用" class="headerlink" title="Partition 应用"></a>Partition 应用</h1><p>我们都知道经典的快速排序就是首先用 partition 将数组分为两部分，然后分别对左右两部分递归进行快速排序，过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt;= end - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">partition</span>(arr, begin, end);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, begin, pos);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, pos+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然快排用到了经典的<strong>分而治之</strong>的思想，但是快排实现的前提还是在于 partition 函数。正是有了 partition 的存在，才使得可以将整个大问题进行划分，进而分别进行处理。</p><p>除了用来进行快速排序，partition 还可以用 O(N) 的平均时间复杂度<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">从无序数组中寻找第K大的值</a>。和快排一样，这里也用到了分而治之的思想。首先用 partition 将数组分为两部分，得到分界点下标 pos，然后分三种情况：</p><ul><li>pos &#x3D;&#x3D; k-1，则找到第 K 大的值，arr[pos]；</li><li>pos &gt; k-1，则第 K 大的值在左边部分的数组。</li><li>pos &lt; k-1，则第 K 大的值在右边部分的数组。</li></ul><p>下面给出基于迭代的实现（这里寻找第 k 小的数字）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_kth_number</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> begin = <span class="number">0</span>, end = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">assert</span>(k&gt;<span class="number">0</span> &amp;&amp; k&lt;=end);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end)&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">partition</span>(arr, begin, end);</span><br><span class="line">        <span class="keyword">if</span>(pos == k<span class="number">-1</span>)&#123;</span><br><span class="line">            target_num = arr[pos];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; k<span class="number">-1</span>)&#123;</span><br><span class="line">            end = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            begin = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的时间复杂度是多少呢？考虑最坏情况下，每次 partition 将数组分为长度为 N-1 和 1 的两部分，然后在长的一边继续寻找第 K 大，此时时间复杂度为 O(N^2 )。不过如果在开始之前将数组进行随机打乱，那么可以尽量避免最坏情况的出现。而在最好情况下，每次将数组均分为长度相同的两半，运行时间 T(N) &#x3D; N + T(N&#x2F;2)，时间复杂度是 O(N)。</p><h1 id="Partition-进阶"><a href="#Partition-进阶" class="headerlink" title="Partition 进阶"></a>Partition 进阶</h1><p>接下来先考虑这样一个<a href="https://leetcode.com/problems/sort-colors/">问题</a>，给定红、白、蓝三种颜色的小球若干个，将其排成一列，使相同颜色的小球相邻，三种颜色先后顺序为红，白，蓝。这就是经典的 <a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">Dutch national flag problem</a>。</p><p>我们可以针对红，蓝，白三种颜色的球分别计数，然后根据计数结果来重新放球。不过如果我们将问题进一步抽象，也就是说将一个数组按照某个target值分为三部分，使得左边部分的值小于 target，中间部分等于 target，右边部分大于 target，这样就不能再用简单的计数来确定排序后的结果。这时候，就可以用到另一种 partition 算法：three-way-partition。它的思路稍微复杂一点，用<strong>三个指针</strong>将数组分为四个部分，通过一次扫描最终将数组分为 &lt;，&#x3D;，&gt; 的三部分，如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160901_lost_partition_4.png" alt="三分划分"></p><p>可以结合下面代码来理解具体的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume target is in the arr.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">three_way_partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> next_less_pos = <span class="number">0</span>, next_bigger_pos = arr.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> next_scan_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (next_scan_pos &lt;= next_bigger_pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[next_scan_pos] &lt; target)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[next_scan_pos++], arr[next_less_pos++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[next_scan_pos] &gt; target)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[next_scan_pos], arr[next_bigger_pos--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            next_scan_pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的主要思想就是在一遍扫描中，通过交换不同位置的数字，使得数组最终可以维持一定的顺序，和前面快排中用到的 partition 思想一致。区别在于快排按照 pivot 将数组分为两部分，左右部分中的值都可能等于 pivot，而 three-way-partition 将数组分为 &lt;, &#x3D;, &gt;的三部分。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://algs4.cs.princeton.edu/lectures/23DemoPartitioning.pdf">Algorithms 4.0: DemoPartitioning</a><br><a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">Dutch national flag problem</a><br><a href="https://www.cise.ufl.edu/class/cot3100fa07/quicksort_analysis.pdf">Time complexity of quick-sort in detail</a><br><a href="http://cs.stackexchange.com/questions/11458/quicksort-partitioning-hoare-vs-lomuto/11550">Quicksort Partitioning: Hoare vs. Lomuto</a><br><a href="http://blog.csdn.net/pongba/article/details/2544933">数学之美番外篇：快排为什么那样快</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你学习过算法，那么肯定听说过快速排序的大名，但是对于快速排序中用到的 partition 算法，你了解的够多吗？或许是快速排序太过于光芒四射，使得我们往往会忽视掉同样重要的 partition 算法。&lt;/p&gt;
&lt;p&gt;Partition 可不只用在快速排序中，还可以用于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Selection_algorithm&quot;&gt;Selection algorithm&lt;/a&gt;（在无序数组中寻找第K大的值）中。甚至有可能正是这种&lt;strong&gt;通过一趟扫描来进行分类的思想&lt;/strong&gt;激发 Edsger Dijkstra 想出了 Three-way Partitioning，高效地解决了 &lt;a href=&quot;https://en.wikipedia.org/wiki/Dutch_national_flag_problem&quot;&gt;Dutch national flag problem&lt;/a&gt; 问题。接下来我们一起来探索 partition 算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160901_lost_partition_1.png&quot; alt=&quot;Partition 一次扫描进行划分&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Python中的ThreadLocal变量（中）</title>
    <link href="https://selfboot.cn/2016/08/26/threadlocal_implement/"/>
    <id>https://selfboot.cn/2016/08/26/threadlocal_implement/</id>
    <published>2016-08-26T00:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="http://selfboot.cn/2016/08/22/threadlocal_overview/">深入理解Python中的ThreadLocal变量（上）</a> 中我们看到 ThreadLocal 的引入，使得可以很方便地在多线程环境中使用局部变量。如此美妙的功能到底是怎样实现的？如果你对它的实现原理没有好奇心或一探究竟的冲动，那么接下来的内容估计会让你后悔自己的浅尝辄止了。</p><p>简单来说，Python 中 ThreadLocal 就是通过<a name="img_1"></a>下图中的方法，将全局变量伪装成线程局部变量，相信读完本篇文章你会理解图中内容的。（对这张图不眼熟的话，可以回顾下<a href="(http://selfboot.cn/2016/08/22/threadlocal_overview/)">上篇</a>）。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160826_threadlocal_implement_1.png" alt="ThreadLocal 实现机制"></p><span id="more"></span><h1 id="在哪里找到源码？"><a href="#在哪里找到源码？" class="headerlink" title="在哪里找到源码？"></a>在哪里找到源码？</h1><p>好了，终于要来分析 ThreadLocal 是如何实现的啦，不过，等等，怎么找到它的源码呢？上一篇中我们只是用过它（<code>from threading import local</code>），从这里只能看出它是在 threading 模块实现的，那么如何找到 threading 模块的源码呢。</p><p>如果你在使用 PyCharm，恭喜你，你可以用 <code>View source</code>（OS X 快捷键是 ⌘↓）找到 local 定义的地方。现在许多 IDE 都有这个功能，可以查看 IDE 的帮助来找到该功能。接着我们就会发现 local 是这样子的（这里以 python 2.7 为例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get thread-local implementation, either from the thread</span></span><br><span class="line"><span class="comment"># module, or from the python fallback</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> thread <span class="keyword">import</span> _local <span class="keyword">as</span> local</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> _threading_local <span class="keyword">import</span> local</span><br></pre></td></tr></table></figure><p>嗯，自带解释，非常好。我们要做的是继续往下深挖具体实现，用同样的方法（⌘↓）找 _local 的实现，好像不太妙，没有找到纯 python 实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_local</span>(object):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot; Thread-local data &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    def __delattr__(self, name): <span class="meta"># real signature unknown; restored from __doc__</span></span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot; x.__delattr__(&#x27;name&#x27;) &lt;==&gt; del x.name &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        pass</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>没关系，继续来看下_threading_local吧，这下子终于找到了local的纯 python 实现。开始就是很长的一段注释文档，告诉我们这个模块是什么，如何用。这个文档的质量非常高，值得我们去学习。所以，再次后悔自己的浅尝辄止了吧，差点错过了这么优秀的文档范文！</p><h2 id="将源码私有化"><a href="#将源码私有化" class="headerlink" title="将源码私有化"></a>将源码私有化</h2><p>在具体动手分析这个模块之前，我们先把它拷出来放在一个单独的文件 <code>thread_local.py</code> 中，这样可以方便我们随意肢解它（比如在适当的地方加上log），并用修改后的实现验证我们的一些想法。此外，如果你真的理解了_threading_local.py最开始的一段，你就会发现这样做是多么的有必要。因为python的threading.local不一定是用的_threading_local（还记得class _local(object) 吗？）。</p><p>所以如果你用 threading.local 来验证自己对_threading_local.py的理解，你很可能会一头雾水的。不幸的是，我开始就这样干的，所以被下面的代码坑了好久：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> local, current_thread</span><br><span class="line">data = local()</span><br><span class="line">key = <span class="built_in">object</span>.__getattribute__(data, <span class="string">&#x27;_local__key&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> current_thread().__dict__.get(key)</span><br><span class="line"><span class="comment"># AttributeError: &#x27;thread._local&#x27; object has no attribute &#x27;_local__key&#x27;</span></span><br></pre></td></tr></table></figure><p>当然，你可能不理解这里是什么意思，没关系，我只是想强调在 threading.local 没有用到_threading_local.py，你必须要创建一个模块（我将它命名为 thread_local.py）来保存_threading_local里面的内容，然后像下面这样验证自己的想法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"><span class="keyword">from</span> thread_local <span class="keyword">import</span> local</span><br><span class="line"></span><br><span class="line">data = local()</span><br><span class="line">key = <span class="built_in">object</span>.__getattribute__(data, <span class="string">&#x27;_local__key&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> current_thread().__dict__.get(key)</span><br></pre></td></tr></table></figure><h1 id="如何去理解源码"><a href="#如何去理解源码" class="headerlink" title="如何去理解源码"></a>如何去理解源码</h1><p>现在可以静下心来读读这不到两百行的代码了，不过，等等，好像有许多奇怪的内容（黑魔法）：</p><ul><li><a href="https://docs.python.org/2/reference/datamodel.html#slots">__slots__</a></li><li><a href="https://docs.python.org/2.7/reference/datamodel.html#basic-customization">__new__</a></li><li><a href="https://docs.python.org/2.7/reference/datamodel.html#customizing-attribute-access">__getattribute__／__setattr__／__delattr__</a></li><li><a href="https://docs.python.org/2/library/threading.html#rlock-objects">Rlock</a></li></ul><p>这些是什么？如果你不知道，没关系，千万不要被这些纸老虎吓到，我们有丰富的文档，查文档就对了（这里不建议直接去网上搜相关关键字，最好是先读文档，读完了有疑问再去搜）。</p><h2 id="python-黑魔法"><a href="#python-黑魔法" class="headerlink" title="python 黑魔法"></a>python 黑魔法</h2><p>下面是我对上面提到的内容的一点总结，如果觉得读的明白，那么可以继续往下分析源码了。如果还有不理解的，再读几遍文档（或者我错了，欢迎指出来）。</p><ul><li>简单来说，python 中创建一个<strong>新式类</strong>的实例时，首先会调用<code>__new__(cls[, ...])</code>创建实例，如果它成功返回cls类型的对象，然后才会调用__init__来对对象进行初始化。</li><li>新式类中我们可以用__slots__指定该类可以拥有的属性名称，这样每个对象就不会再创建__dict__，从而节省对象占用的空间。特别需要注意的是，基类的__slots__并不会屏蔽派生类中__dict__的创建。</li><li>可以通过重载<code>__setattr__，__delattr__和__getattribute__</code>这些方法，来控制自定义类的属性访问（x.name），它们分别对应属性的赋值，删除，读取。</li><li>锁是操作系统中为了保证操作原子性而引入的概念，python 中 RLock是一种可重入锁（reentrant lock，也可以叫作递归锁），Rlock.acquire()可以不被阻塞地多次进入同一个线程。</li><li><code>__dict__</code>用来保存对象的（可写）属性，可以是一个字典，或者其他映射对象。</li></ul><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>对这些相关的知识有了大概的了解后，再读源码就亲切了很多。为了彻底理解，我们首先回想下<strong>平时是如何使用local对象的，然后分析源码在背后的调用流程</strong>。这里从定义一个最简单的thread-local对象开始，也就是说当我们写下下面这句时，发生了什么？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> = local()</span></span><br></pre></td></tr></table></figure><p>上面这句会调用 <code>_localbase.__new__</code> 来为data对象设置一些属性（还不知道有些属性是做什么的，不要怕，后面遇见再说），然后将data的属性字典(<code>__dict__</code>)作为当前线程的一个属性值（这个属性的 key 是根据 id(data) 生成的身份识别码）。</p><p>这里很值得玩味：在创建ThreadLocal对象时，同时在线程（也是一个对象，没错万物皆对象）的属性字典<code>__dict__</code>里面保存了ThreadLocal对象的属性字典。还记得文章开始的<a href="#img_1">图片</a>吗，红色虚线就表示这个操作。</p><p>接着我们考虑在线程 Thread-1 中对ThreadLocal变量进行一些常用的操作，比如下面的一个操作序列：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">data</span>.name = <span class="string">&quot;Thread 1(main)&quot;</span> <span class="comment"># 调用 __setattr__</span></span><br><span class="line"><span class="built_in">print</span> <span class="title">data</span>.name     <span class="comment"># 调用 __getattribute__</span></span><br><span class="line">del <span class="title">data</span>.name       <span class="comment"># 调用 __delattr__</span></span><br><span class="line"><span class="built_in">print</span> <span class="title">data</span>.__dict__</span><br><span class="line"><span class="comment"># Thread 1(main)</span></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>那么背后又是如何操作的呢？上面的操作包括了给属性赋值，读属性值，删除属性。这里我们以__getattribute__的实现为例（读取值）进行分析，属性的__setattr__和__delattr__和前者差不多，区别在于禁止了对__dict__属性的更改以及删除操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">    lock = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;_local__lock&#x27;</span>)</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        _patch(self)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, name)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        lock.release()</span><br></pre></td></tr></table></figure><p>函数中首先获得了ThreadLocal变量的<code>_local__lock</code>属性值（知道这个变量从哪里来的吗，回顾下_localbase吧），然后用它来保证 <code>_patch(self)</code> 操作的原子性，还用 <strong>try-finally 保证即使抛出了异常也会释放锁资源，避免了线程意外情况下永久持有锁而导致死锁</strong>。现在问题是_patch究竟做了什么？答案还是在源码中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_patch</span>(<span class="params">self</span>):</span><br><span class="line">    key = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;_local__key&#x27;</span>)  <span class="comment"># ThreadLocal变量 的标识符</span></span><br><span class="line">    d = current_thread().__dict__.get(key)  <span class="comment"># ThreadLocal变量在该线程下的数据</span></span><br><span class="line">    <span class="keyword">if</span> d <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        current_thread().__dict__[key] = d</span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__dict__&#x27;</span>, d)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we have a new instance dict, so call out __init__ if we have one</span></span><br><span class="line">        cls = <span class="built_in">type</span>(self)</span><br><span class="line">        <span class="keyword">if</span> cls.__init__ <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">object</span>.__init__:</span><br><span class="line">            args, kw = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;_local__args&#x27;</span>)</span><br><span class="line">            cls.__init__(self, *args, **kw)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__dict__&#x27;</span>, d)</span><br></pre></td></tr></table></figure><p>_patch做的正是整个ThreadLocal实现中最核心的部分，<strong>从当前正在执行的线程对象那里拿到该线程的私有数据，然后将其交给ThreadLocal变量</strong>，就是本文开始<a href="#img_1">图片</a>中的虚线2。这里需要补充说明以下几点：</p><ul><li>这里说的线程的私有数据，其实就是指通过x.name可以拿到的数据（其中 x 为ThreadLocal变量）</li><li>主线程中在创建ThreadLocal对象后，就有了对应的数据（还记得红色虚线的意义吗？）</li><li>对于那些第一次访问ThreadLocal变量的线程来说，需要创建一个空的字典来保存私有数据，然后还要调用该变量的初始化函数。</li><li>还记得_localbase基类里__new__函数设置的属性   _local__args 吗？在这里被用来进行初始化。</li></ul><p>到此，整个源码核心部分已经理解的差不多了，只剩下<code>local.__del__</code>用来执行清除工作。因为每次创建一个ThreadLocal 变量，都会在进程对象的__dict__中添加相应的数据，当该变量被回收时，我们需要在相应的线程中删除保存的对应数据。</p><h1 id="从源码中学到了什么？"><a href="#从源码中学到了什么？" class="headerlink" title="从源码中学到了什么？"></a>从源码中学到了什么？</h1><p>经过一番努力，终于揭开了 ThreadLocal 的神秘面纱，整个过程可以说是收获颇丰，下面一一说来。</p><p>不得不承认，计算机基础知识很重要。你得知道进程、线程是什么，CPU 的工作机制，什么是操作的原子性，锁是什么，为什么锁使用不当会导致死锁等等。</p><p>其次就是语言层面的知识也必不可少，就ThreadLocal的实现来说，如果对__new__，__slots__等不了解，根本不知道如何去做。所以，学语言还是要有深度，不然下面的代码都看不懂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">dict_test</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = dict_test()</span><br><span class="line"><span class="built_in">print</span> d.__dict__</span><br><span class="line">d.__dict__ = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;value&#x27;</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="built_in">print</span> d.name</span><br></pre></td></tr></table></figure><p>还有就是高质量的功能实现需要考虑各方各面的因素，以ThreadLocal 为例，在基类_localbase中用__slots__节省空间，用try…finally保证异常环境也能正常释放锁，最后还用__del__来及时的清除无效的信息。</p><p>最后不得不说，好的文档和注释简直就是画龙点睛，不过<strong>写文档和注释是门技术活，绝对需要不断学习的</strong>。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init">Python’s use of __new__ and __init__?</a><br><a href="http://spyhce.com/blog/understanding-new-and-init">Understanding __new__ and __init__</a><br><a href="http://stackoverflow.com/questions/472000/usage-of-slots">Usage of __slots__?</a><br><a href="https://pymotw.com/2/weakref/">weakref – Garbage-collectable references to objects</a><br><a href="https://www.quora.com/How-do-I-find-the-source-code-of-a-function-in-Python">How do I find the source code of a function in Python?</a><br><a href="http://stackoverflow.com/questions/269795/how-do-i-find-the-location-of-python-module-sources">How do I find the location of Python module sources?</a><br><a href="http://stackoverflow.com/questions/9728243/is-self-dict-updatekwargs-good-or-poor-style">Is self.__dict__.update(**kwargs) good or poor style?</a><br><a href="https://docs.python.org/2/library/weakref.html">Doc: weakref — Weak references</a><br><a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python/Class.md#%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84">python class 全面分析</a></p><p><a href="http://vincestyling.com/posts/2014/how-am-i-read-open-source-projects-code.html">我是如何阅读开源项目的源代码的</a><br><a href="http://blog.a0z.me/2016/04/28/how-to-read-open-project/">高效阅读源代码指南</a><br><a href="https://www.zhihu.com/question/19625320">如何阅读程序源代码？</a><br><a href="http://www.cnblogs.com/ToDoToTry/archive/2009/06/21/1507760.html">如何看懂源代码–(分析源代码方法)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;a href=&quot;http://selfboot.cn/2016/08/22/threadlocal_overview/&quot;&gt;深入理解Python中的ThreadLocal变量（上）&lt;/a&gt; 中我们看到 ThreadLocal 的引入，使得可以很方便地在多线程环境中使用局部变量。如此美妙的功能到底是怎样实现的？如果你对它的实现原理没有好奇心或一探究竟的冲动，那么接下来的内容估计会让你后悔自己的浅尝辄止了。&lt;/p&gt;
&lt;p&gt;简单来说，Python 中 ThreadLocal 就是通过&lt;a name=&quot;img_1&quot;&gt;&lt;/a&gt;下图中的方法，将全局变量伪装成线程局部变量，相信读完本篇文章你会理解图中内容的。（对这张图不眼熟的话，可以回顾下&lt;a href=&quot;(http://selfboot.cn/2016/08/22/threadlocal_overview/)&quot;&gt;上篇&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160826_threadlocal_implement_1.png&quot; alt=&quot;ThreadLocal 实现机制&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Thread" scheme="https://selfboot.cn/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Python中的ThreadLocal变量（上）</title>
    <link href="https://selfboot.cn/2016/08/22/threadlocal_overview/"/>
    <id>https://selfboot.cn/2016/08/22/threadlocal_overview/</id>
    <published>2016-08-22T22:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道多线程环境下，每一个线程均可以使用所属进程的全局变量。如果一个线程对全局变量进行了修改，将会影响到其他所有的线程。为了避免多个线程同时对变量进行修改，引入了线程同步机制，通过互斥锁，条件变量或者读写锁来控制对全局变量的访问。</p><p>只用全局变量并不能满足多线程环境的需求，很多时候线程还需要拥有自己的私有数据，这些数据对于其他线程来说不可见。因此线程中也可以使用局部变量，局部变量只有线程自身可以访问，同一个进程下的其他线程不可访问。</p><p>有时候使用局部变量不太方便，因此 python 还提供了 ThreadLocal 变量，它本身是一个全局变量，但是每个线程却可以利用它来保存属于自己的私有数据，这些私有数据对其他线程也是不可见的。下图给出了线程中这几种变量的存在情况：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160822_threadlocal_overview_1.png" alt="线程变量"></p><span id="more"></span><h1 id="全局-VS-局部变量"><a href="#全局-VS-局部变量" class="headerlink" title="全局 VS 局部变量"></a>全局 VS 局部变量</h1><p>首先借助一个小程序来看看多线程环境下全局变量的同步问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">global_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_cal</span>():</span><br><span class="line">    <span class="keyword">global</span> global_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        global_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get 10 threads, run them and wait them all finished.</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    threads.append(threading.Thread(target=thread_cal))</span><br><span class="line">    threads[i].start()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    threads[i].join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Value of global variable can be confused.</span></span><br><span class="line"><span class="built_in">print</span> global_num</span><br></pre></td></tr></table></figure><p>这里我们创建了10个线程，每个线程均对全局变量 global_num 进行1000次的加1操作（循环1000次加1是为了延长单个线程执行时间，使线程执行时被中断切换），当10个线程执行完毕时，全局变量的值是多少呢？答案是不确定。简单来说是因为 <code>global_num += 1</code> 并不是一个原子操作，因此执行过程可能被其他线程中断，导致其他线程读到一个脏值。以两个线程执行 +1 为例，其中一个可能的执行序列如下（此情况下最后结果为1）：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160822_threadlocal_overview_2.png" alt="多线程全局变量同步"></p><p>多线程中使用全局变量时普遍存在这个问题，解决办法也很简单，可以使用互斥锁、条件变量或者是读写锁。下面考虑用互斥锁来解决上面代码的问题，只需要在进行 +1 运算前加锁，运算完毕释放锁即可，这样就可以保证运算的原子性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = threading.Lock()</span><br><span class="line">...</span><br><span class="line">    l.acquire()</span><br><span class="line">    global_num += <span class="number">1</span></span><br><span class="line">    l.release()</span><br></pre></td></tr></table></figure><p>在线程中使用局部变量则不存在这个问题，因为每个线程的局部变量不能被其他线程访问。下面我们用10个线程分别对各自的局部变量进行1000次加1操作，每个线程结束时打印一共执行的操作次数（每个线程均为1000）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span> threading.current_thread().getName(), num</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_cal</span>():</span><br><span class="line">    local_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        local_num += <span class="number">1</span></span><br><span class="line">    show(local_num)</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    threads.append(threading.Thread(target=thread_cal))</span><br><span class="line">    threads[i].start()</span><br></pre></td></tr></table></figure><p>可以看出这里每个线程都有自己的 local_num，各个线程之间互不干涉。</p><h1 id="Thread-local-对象"><a href="#Thread-local-对象" class="headerlink" title="Thread-local 对象"></a>Thread-local 对象</h1><p>上面程序中我们需要给 show 函数传递 local_num 局部变量，并没有什么不妥。不过考虑在实际生产环境中，我们可能会调用很多函数，每个函数都需要很多局部变量，这时候用传递参数的方法会很不友好。</p><p>为了解决这个问题，一个直观的的方法就是建立一个全局字典，保存进程 ID 到该进程局部变量的映射关系，运行中的线程可以根据自己的 ID 来获取本身拥有的数据。这样，就可以避免在函数调用中传递参数，如下示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">global_data = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    cur_thread = threading.current_thread()</span><br><span class="line">    <span class="built_in">print</span> cur_thread.getName(), global_data[cur_thread]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_cal</span>():</span><br><span class="line">    cur_thread = threading.current_thread()</span><br><span class="line">    global_data[cur_thread] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        global_data[cur_thread] += <span class="number">1</span></span><br><span class="line">    show()  <span class="comment"># Need no local variable.  Looks good.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>保存一个全局字典，然后将线程标识符作为key，相应线程的局部数据作为 value，这种做法并不完美。首先，每个函数在需要线程局部数据时，都需要先取得自己的线程ID，略显繁琐。更糟糕的是，这里并没有真正做到线程之间数据的隔离，因为每个线程都可以读取到全局的字典，每个线程都可以对字典内容进行更改。</p><p>为了更好解决这个问题，python 线程库实现了 ThreadLocal 变量（很多语言都有类似的实现，比如Java）。ThreadLocal 真正做到了线程之间的数据隔离，并且使用时不需要手动获取自己的线程 ID，如下示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">global_data = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    <span class="built_in">print</span> threading.current_thread().getName(), global_data.num</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_cal</span>():</span><br><span class="line">    global_data.num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        global_data.num += <span class="number">1</span></span><br><span class="line">    show()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Main thread: &quot;</span>, global_data.__dict__ <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>上面示例中每个线程都可以通过 global_data.num 获得自己独有的数据，并且每个线程读取到的 global_data 都不同，真正做到线程之间的隔离。</p><p>Python通过 local 类来实现 ThreadLocal 变量，代码量不多（只有100多行），但是比较难理解，涉及很多 Python 黑魔法，<a href="http://selfboot.cn/2016/08/26/threadlocal_implement/">下一篇</a>再来详细分析。那么 ThreadLocal 很完美了？不！Python 的 WSGI 工具库 werkzeug 中有一个更好的 <a href="https://github.com/pallets/werkzeug/blob/8a84b62b3dd89fe7d720d7948954e20ada690c40/werkzeug/local.py">ThreadLocal 实现</a>，甚至支持协程之间的私有数据，实现更加复杂，有机会再分析。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://stackoverflow.com/questions/1408171/thread-local-storage-in-python">Thread local storage in Python</a><br><a href="https://pymotw.com/2/threading/">threading – Manage concurrent threads</a><br><a href="https://harveyqing.gitbooks.io/python-read-and-write/content/python_advance/python_thread_sync.html">Python线程同步机制</a><br><a href="http://www.cnblogs.com/vamei/archive/2012/10/09/2715393.html">Linux多线程与同步</a><br><a href="https://www.quora.com/Are-local-variables-in-a-python-function-thread-safe">Are local variables in a python function thread safe?</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道多线程环境下，每一个线程均可以使用所属进程的全局变量。如果一个线程对全局变量进行了修改，将会影响到其他所有的线程。为了避免多个线程同时对变量进行修改，引入了线程同步机制，通过互斥锁，条件变量或者读写锁来控制对全局变量的访问。&lt;/p&gt;
&lt;p&gt;只用全局变量并不能满足多线程环境的需求，很多时候线程还需要拥有自己的私有数据，这些数据对于其他线程来说不可见。因此线程中也可以使用局部变量，局部变量只有线程自身可以访问，同一个进程下的其他线程不可访问。&lt;/p&gt;
&lt;p&gt;有时候使用局部变量不太方便，因此 python 还提供了 ThreadLocal 变量，它本身是一个全局变量，但是每个线程却可以利用它来保存属于自己的私有数据，这些私有数据对其他线程也是不可见的。下图给出了线程中这几种变量的存在情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160822_threadlocal_overview_1.png&quot; alt=&quot;线程变量&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Thread" scheme="https://selfboot.cn/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建论坛（二）：Web服务器网关接口</title>
    <link href="https://selfboot.cn/2016/08/07/forum_design_wsgi/"/>
    <id>https://selfboot.cn/2016/08/07/forum_design_wsgi/</id>
    <published>2016-08-07T22:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="http://selfboot.cn/2016/07/28/forum_design_framework/">从零开始搭建论坛（一）：Web服务器与Web框架</a> 中我们弄清楚了Web 服务器、Web 应用程序、Web框架的概念。对于 Python 来说，越来越多的 Web 框架面世，在给我们更多选择机会的同时，也限制了我们对于 Web Server 的选择。同样是有着很多 Web 框架的Java，因为有着 servlet API 的存在，任何Java Web框架写的应用程序都可以运行在任意一个 Web Server 上。</p><p>Python 社区当然也需要这样一套 API，来适配Web服务器和应用程序，这套 API 就是 WSGI（Python Web Server Gateway Interface），在 <a href="https://www.python.org/dev/peps/pep-3333/">PEP 3333</a> 里有详细的说明。简单来说，WSGI是连接Web服务器和Web应用程序的桥梁，一方面从Web server 拿到原始 HTTP 数据，处理成统一格式后交给 Web 应用程序，另一方面从应用程序／框架这边进行业务逻辑处理，生成响应内容后交给服务器。</p><p>Web服务器和框架通过 WSGI 来进行耦合的详细过程如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160807_forum_design_WSGI_1.png" alt="WSGI Server 适配"></p><span id="more"></span><p>具体解释如下：</p><ul><li>应用程序（网络框架）提供一个命名为application的可调用对象（WSGI协议并没有指定如何实现这个对象）。</li><li>服务器每次从HTTP客户端接收请求之后，调用可调用对象application，调用时传递一个名叫environ的字典作为参数，以及一个名为start_response的可调用对象。</li><li>框架&#x2F;应用生成HTTP状态码以及HTTP响应报头，然后将二者传递至start_response，等待服务器保存。此外，框架&#x2F;应用还将返回响应的正文。</li><li>服务器将状态码、响应报头和响应正文组合成HTTP响应，并返回给客户端（这一步并不属于WSGI协议）。</li></ul><p>下面分别从服务器端和应用程序端来看看 WSGI 是如何做适配的。</p><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>我们知道客户端（通常是浏览器）发出的每个HTTP请求由请求行、消息报头、请求正文三部分组成，里面包含了本次请求的相关细节内容。比如：</p><ul><li>Method：指出在由Request-URI标识的资源上所执行的方法，包括GET，POST 等</li><li>User-Agent：允许客户端将它的操作系统、浏览器和其它属性告诉服务器；</li></ul><p>服务器从客户端接收HTTP请求之后，WSGI 接口必须要对这些请求字段进行统一化处理，方便传给应用服务器接口（其实就是给框架）。Web服务器具体传递哪些数据给应用程序，早在<a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>（Common Gateway Interface，通用网关接口）里就有详细规定，这些数据被叫做 CGI 环境变量。WSGI 沿用了 CGI 环境变量的内容，要求 Web 服务器必须创建一个字典用来保存这些环境变量（一般将其命名为 <code>environ</code>）。除了 CGI 定义的变量，environ 还必须保存一些WSGI定义的变量，此外还可以保存一些客户端系统的环境变量，可以参考 <a href="https://www.python.org/dev/peps/pep-3333/#environ-variables">environ Variables</a> 来看看具体有哪些变量。</p><p>接着 WSGI 接口必须将 environ 交给应用程序去处理，这里 WSGI 规定应用程序提供一个可调用对象 application，然后服务器去调用 application，获得返回值为HTTP响应正文。服务器在调用 application 的时候，需要提供两个变量，一个是前面提到的变量字典environ，另一个是可调用对象 start_response，它产生状态码和响应头，这样我们就得到了一个完整的HTTP响应。Web 服务器将响应返回给客户端，一次完整的<code>HTTP请求－响应</code>过程就完成了。</p><h2 id="wsgiref-分析"><a href="#wsgiref-分析" class="headerlink" title="wsgiref 分析"></a>wsgiref 分析</h2><p>Python 中内置了一个实现了WSGI接口的 Web 服务器，在模块<a href="https://docs.python.org/2.7/library/wsgiref.html">wsgiref</a>中，它是用纯Python编写的WSGI服务器的参考实现，我们一起来简单分析一下它的实现。首先假设我们用下面代码启动一个 Web 服务器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Instantiate the server</span></span><br><span class="line">httpd = make_server(</span><br><span class="line">    <span class="string">&#x27;localhost&#x27;</span>,    <span class="comment"># The host name</span></span><br><span class="line">    <span class="number">8051</span>,           <span class="comment"># A port number where to wait for the request</span></span><br><span class="line">    application     <span class="comment"># The application object name, in this case a function</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for a single request, serve it and quit</span></span><br><span class="line">httpd.handle_request()</span><br></pre></td></tr></table></figure><p>然后我们以Web服务器接收一个请求、生成 environ，然后调用 application 来处理请求这条主线来分析源码的调用过程，简化如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160807_forum_design_WSGI_2.png" alt="WSGI Server 调用流程"></p><p>这里主要有三个类，WSGIServer，WSGIRequestHandler，ServerHandle。WSGIServer 是Web服务器类，可以提供server_address（IP:Port）和 WSGIRequestHandler 类来进行初始化获得一个server对象。该对象监听响应的端口，收到HTTP请求后通过 finish_request 创建一个RequestHandler 类的实例，在该实例的初始化过程中会生成一个 Handle 类实例，然后调用其 run(application) 函数，在该函数里面再调用应用程序提供的 application对象来生成响应。</p><p>这三个类的继承关系如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160807_forum_design_WSGI_3.png" alt="WSGI 类继承关系图"></p><p>其中 TCPServer 使用 socket 来完成 TCP 通信，HTTPServer 则是用来做 HTTP 层面的处理。同样的，StreamRequestHandler 来处理 stream socket，BaseHTTPRequestHandler 则是用来处理 HTTP 层面的内容，这部分和 WSGI 接口关系不大，更多的是 Web 服务器的具体实现，可以忽略。</p><h2 id="微服务器实例"><a href="#微服务器实例" class="headerlink" title="微服务器实例"></a>微服务器实例</h2><p>如果上面的 wsgiref 过于复杂的话，下面一起来实现一个微小的 Web 服务器，便于我们理解 Web 服务器端 WSGI 接口的实现。代码摘自 <a href="http://codingpy.com/article/build-a-simple-web-server-part-two/">自己动手开发网络服务器（二）</a>，放在 <a href="https://gist.github.com/xuelangZF/217b1b6ab34ec33c3ca155ce681f72ad">gist</a> 上，主要结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WSGIServer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 套接字参数</span></span><br><span class="line">    address_family, socket_type = socket.AF_INET, socket.SOCK_STREAM</span><br><span class="line">    request_queue_size = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, server_address</span>):</span><br><span class="line">        <span class="comment"># TCP 服务端初始化：创建套接字，绑定地址，监听端口</span></span><br><span class="line">        <span class="comment"># 获取服务器地址，端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_app</span>(<span class="params">self, application</span>):</span><br><span class="line">        <span class="comment"># 获取框架提供的 application</span></span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serve_forever</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 处理 TCP 连接：获取请求内容，调用处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_request</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 解析 HTTP 请求，获取 environ，处理请求内容，返回HTTP响应结果</span></span><br><span class="line">        env = self.get_environ()</span><br><span class="line">        result = self.application(env, self.start_response)</span><br><span class="line">        self.finish_response(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_request</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="comment"># 解析 HTTP 请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_environ</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 分析 environ 参数，这里只是示例，实际情况有很多参数。</span></span><br><span class="line">        env[<span class="string">&#x27;wsgi.url_scheme&#x27;</span>]   = <span class="string">&#x27;http&#x27;</span></span><br><span class="line">        ...</span><br><span class="line">        env[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>]    =  self.request_method    <span class="comment"># GET</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> env</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_response</span>(<span class="params">self, status, response_headers, exc_info=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># 添加响应头，状态码</span></span><br><span class="line">        self.headers_set = [status, response_headers + server_headers]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finish_response</span>(<span class="params">self, result</span>):</span><br><span class="line">        <span class="comment"># 返回 HTTP 响应信息</span></span><br><span class="line"></span><br><span class="line">SERVER_ADDRESS = (HOST, PORT) = <span class="string">&#x27;&#x27;</span>, <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个服务器实例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_server</span>(<span class="params">server_address, application</span>):</span><br><span class="line">    server = WSGIServer(server_address)</span><br><span class="line">    server.set_app(application)</span><br><span class="line">    <span class="keyword">return</span> server</span><br></pre></td></tr></table></figure><p>目前支持 WSGI 的成熟Web服务器有很多，<a href="http://gunicorn.org/">Gunicorn</a>是相当不错的一个。它脱胎于ruby社区的Unicorn，成功移植到python上，成为一个WSGI HTTP Server。有以下优点：</p><ul><li>容易配置</li><li>可以自动管理多个worker进程</li><li>选择不同的后台扩展接口（sync, gevent, tornado等）</li></ul><h1 id="应用程序端（框架）"><a href="#应用程序端（框架）" class="headerlink" title="应用程序端（框架）"></a>应用程序端（框架）</h1><p>和服务器端相比，应用程序端（也可以认为框架）要做的事情就简单很多，它只需要提供一个可调用对象（一般习惯将其命名为application），这个对象接收服务器端传递的两个参数 environ 和 start_response。这里的可调用对象不仅可以是函数，还可以是类（下面第二个示例）或者拥有 <code>__call__</code> 方法的实例，总之只要<strong>可以接受前面说的两个参数，并且返回值可以被服务器进行迭代即可</strong>。</p><p>Application 具体要做的就是根据 environ 里面提供的关于 HTTP 请求的信息，进行一定的业务处理，返回一个可迭代对象，服务器端通过迭代这个对象，来获得 HTTP 响应的正文。如果没有响应正文，那么可以返回None。</p><p>同时，application 还会调用服务器提供的 start_response，产生HTTP响应的状态码和响应头，原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_response</span>(<span class="params">self, status, headers,exc_info=<span class="literal">None</span></span>):</span><br></pre></td></tr></table></figure><p>Application 需要提供 status：一个字符串，表示HTTP响应状态字符串，还有 response_headers: 一个列表，包含有如下形式的元组：(header_name, header_value)，用来表示HTTP响应的headers。同时 exc_info 是可选的，用于出错时，server需要返回给浏览器的信息。</p><p>到这里为止，我们就可以实现一个简单的 application 了，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_app</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Simplest possible application function&quot;&quot;&quot;</span></span><br><span class="line">    HELLO_WORLD = <span class="string">&quot;Hello world!\n&quot;</span></span><br><span class="line">    status = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line">    response_headers = [(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [HELLO_WORLD]</span><br></pre></td></tr></table></figure><p>或者用类实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppClass</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Produce the same output, but using a class&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.start = start_response</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        HELLO_WORLD = <span class="string">&quot;Hello world!\n&quot;</span></span><br><span class="line">        <span class="keyword">yield</span> HELLO_WORLD</span><br></pre></td></tr></table></figure><p>注意这里 <code>AppClass</code> 类本身就是 application，用 environ 和 start_response 调用（实例化）它返回一个实例对象，这个实例对象本身是可迭代的，符合 WSGI 对 application 的要求。</p><p>如果想使用 AppClass 类的对象作为 application，那么必须给类添加一个 <code>__call__</code> 方法，接受 environ 和 start_response 为参数，返回可迭代对象，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppClass</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Produce the same output, but using an object&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这部分涉及到python的一些高级特性，比如 yield 和 magic method，可以参考我总结的<a href="https://github.com/xuelangZF/CS_Offer/tree/master/Python">python语言要点</a>来理解。</p><h2 id="Flask-中的-WSGI"><a href="#Flask-中的-WSGI" class="headerlink" title="Flask 中的 WSGI"></a>Flask 中的 WSGI</h2><p>flask 是一个轻量级的Python Web框架，符合 WSGI 的规范要求。它的最初版本只有 600 多行，相对便于理解。下面我们来看下它最初版本中关于 WSGI 接口的部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wsgi_app</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;The actual WSGI application.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is not implemented in `__call__` so that middlewares can be applied:</span></span><br><span class="line"><span class="string">        app.wsgi_app = MyMiddleware(app.wsgi_app)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> self.request_context(environ):</span><br><span class="line">        rv = self.preprocess_request()</span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            rv = self.dispatch_request()</span><br><span class="line">        response = self.make_response(rv)</span><br><span class="line">        response = self.process_response(response)</span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Shortcut for :attr:`wsgi_app`&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> self.wsgi_app(environ, start_response)</span><br></pre></td></tr></table></figure><p>这里的 wsgi_app 实现了我们说的 application 功能，rv 是 对请求的封装，response 是框架用来处理业务逻辑的具体函数。这里对 flask 源码不做过多解释，感兴趣的可以去github下载，然后check 到最初版本去查看。</p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>前面 flask 代码 wsgi_app 函数的注释中提到不直接在 <code>__call__</code> 中实现 application 部分，是为了可以使用<code>中间件</code>。 那么为什么要使用中间件，中间件又是什么呢？</p><p>回顾前面的 application&#x2F;server 端接口，对于一个 HTTP 请求，server 端总是会调用一个 application 来进行处理，并返回 application 处理后的结果。这足够应付一般的场景了，不过并不完善，考虑下面的几种应用场景：</p><ul><li>对于不同的请求（比如不同的 URL），server 需要调用不同的 application，那么如何选择调用哪个呢；</li><li>为了做负载均衡或者是远程处理，需要使用网络上其他主机上运行的 application 来做处理；</li><li>需要对 application 返回的内容做一定处理后才能作为 HTTP 响应；</li></ul><p>上面这些场景有一个共同点就是，有一些必需的操作不管放在服务端还是应用（框架）端都不合适。对应用端来说，这些操作应该由服务器端来做，对服务器端来说，这些操作应该由应用端来做。为了处理这种情况，引入了<code>中间件</code>。</p><p>中间件就像是应用端和服务端的桥梁，来沟通两边。对服务器端来说，中间件表现的像是应用端，对应用端来说，它表现的像是服务器端。如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160807_forum_design_WSGI_4.png" alt="中间件"></p><h2 id="中间件的实现"><a href="#中间件的实现" class="headerlink" title="中间件的实现"></a>中间件的实现</h2><p>flask 框架在 Flask 类的初始化代码中就使用了中间件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.wsgi_app = SharedDataMiddleware(self.wsgi_app, &#123; self.static_path: target &#125;)</span><br></pre></td></tr></table></figure><p>这里的作用和 python 中的装饰器一样，就是在执行 self.wsgi_app 前后执行 SharedDataMiddleware 中的一些内容。中间件做的事，很类似python中装饰器做的事情。SharedDataMiddleware 中间件是 <a href="https://github.com/pallets/werkzeug/blob/2e9f5c0d0c1c36b612f6797c00f8c6ac3ba7b1db/werkzeug/wsgi.py">werkzeug</a> 库提供的，用来支持站点托管静态内容。此外，还有DispatcherMiddleware 中间件，用来支持根据不同的请求，调用不同的 application，这样就可以解决前面场景 1, 2 中的问题了。</p><p>下面来看看 DispatcherMiddleware 的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DispatcherMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Allows one to mount middlewares or applications in a WSGI application.</span></span><br><span class="line"><span class="string">    This is useful if you want to combine multiple WSGI applications::</span></span><br><span class="line"><span class="string">        app = DispatcherMiddleware(app, &#123;</span></span><br><span class="line"><span class="string">            &#x27;/app2&#x27;:        app2,</span></span><br><span class="line"><span class="string">            &#x27;/app3&#x27;:        app3</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, app, mounts=<span class="literal">None</span></span>):</span><br><span class="line">        self.app = app</span><br><span class="line">        self.mounts = mounts <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">        script = environ.get(<span class="string">&#x27;PATH_INFO&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        path_info = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> script:</span><br><span class="line">            <span class="keyword">if</span> script <span class="keyword">in</span> self.mounts:</span><br><span class="line">                app = self.mounts[script]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            script, last_item = script.rsplit(<span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">            path_info = <span class="string">&#x27;/%s%s&#x27;</span> % (last_item, path_info)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            app = self.mounts.get(script, self.app)</span><br><span class="line">        original_script_name = environ.get(<span class="string">&#x27;SCRIPT_NAME&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        environ[<span class="string">&#x27;SCRIPT_NAME&#x27;</span>] = original_script_name + script</span><br><span class="line">        environ[<span class="string">&#x27;PATH_INFO&#x27;</span>] = path_info</span><br><span class="line">        <span class="keyword">return</span> app(environ, start_response)</span><br></pre></td></tr></table></figure><p>初始化中间件时需要提供一个 mounts 字典，用来指定不同 URL 路径到 application 的映射关系。这样对于一个请求，中间件检查其路径，然后选择合适的 application 进行处理。</p><p>关于 WSGI 的原理部分基本结束，下一篇我会介绍下对 flask 框架的理解。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="https://wsgi.readthedocs.io/en/latest/">WSGI Content</a><br><a href="http://wsgi.tutorial.codepoint.net/intro">WSGI Tutorial by Clodoaldo Neto</a><br><a href="http://linuxgazette.net/115/orr.html">WSGI Explorations in Python</a><br><a href="http://codingpy.com/article/build-a-simple-web-server-part-two/">自己动手开发网络服务器（二）</a><br><a href="https://segmentfault.com/a/1190000003069785">WSGI 是什么?</a><br><a href="https://segmentfault.com/a/1190000005640475">自己写一个 wsgi 服务器运行 Django 、Tornado 等框架应用</a><br><a href="https://www.python.org/dev/peps/pep-3333/">PEP 3333 – Python Web Server Gateway Interface v1.0.1</a><br><a href="http://stackoverflow.com/questions/111234/what-is-a-callable-in-python">What is a “callable” in Python?</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;a href=&quot;http://selfboot.cn/2016/07/28/forum_design_framework/&quot;&gt;从零开始搭建论坛（一）：Web服务器与Web框架&lt;/a&gt; 中我们弄清楚了Web 服务器、Web 应用程序、Web框架的概念。对于 Python 来说，越来越多的 Web 框架面世，在给我们更多选择机会的同时，也限制了我们对于 Web Server 的选择。同样是有着很多 Web 框架的Java，因为有着 servlet API 的存在，任何Java Web框架写的应用程序都可以运行在任意一个 Web Server 上。&lt;/p&gt;
&lt;p&gt;Python 社区当然也需要这样一套 API，来适配Web服务器和应用程序，这套 API 就是 WSGI（Python Web Server Gateway Interface），在 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333/&quot;&gt;PEP 3333&lt;/a&gt; 里有详细的说明。简单来说，WSGI是连接Web服务器和Web应用程序的桥梁，一方面从Web server 拿到原始 HTTP 数据，处理成统一格式后交给 Web 应用程序，另一方面从应用程序／框架这边进行业务逻辑处理，生成响应内容后交给服务器。&lt;/p&gt;
&lt;p&gt;Web服务器和框架通过 WSGI 来进行耦合的详细过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160807_forum_design_WSGI_1.png&quot; alt=&quot;WSGI Server 适配&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="项目实践" scheme="https://selfboot.cn/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Flask" scheme="https://selfboot.cn/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建论坛（一）：Web服务器与Web框架</title>
    <link href="https://selfboot.cn/2016/07/28/forum_design_framework/"/>
    <id>https://selfboot.cn/2016/07/28/forum_design_framework/</id>
    <published>2016-07-28T22:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>之前用 Django 做过一个小的站点，感觉Django太过笨重，于是就准备换一个比较轻量级的 Web 框架来玩玩。Web.py 作者已经挂掉，项目好久没有更新，所以不准备用它。而 Flask 也是一个成熟的轻量级 Web 框架，在 github 上有众多的 Star 和 Fork，文档和扩展也很丰富，值得学习。</p><p>学习一个框架最好的方式就是用框架做一个项目，在实战中理解掌握框架。这里我用 Flask 框架，使用 Mysql 数据库做了一个<a href="https://github.com/xuelangZF/NaHan">论坛系统</a>。麻雀虽小，五脏俱全，论坛效果图如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_1.png" alt="论坛系统截图"></p><span id="more"></span><p>下面是论坛的基本功能：</p><ul><li>完整的用户模块（注册、登录，更改、找回密码、信息修改、站内消息通知）；</li><li>丰富的论坛模块（创建、回复话题，站内搜索，markdown支持，@user 提醒）；</li><li>强大的后台管理，支持屏蔽用户、话题、评论，支持各种条件搜索话题、评论；</li></ul><p>本博客将会用一系列文章，记录论坛系统搭建的过程，希望对刚入门Web开发的同学有所帮助。</p><p>我们经常听说 Django, Flask 这些 python 语言的<code>Web 框架</code>，那么框架到底是什么，Web框架和Web服务器（Nginx, Apache等）有什么区别？离开框架还能用 Python 搭建Web站点吗？要解决这些疑问，我们有必要来理解下 Web 服务器的工作原理，以及 Web 框架的本质。</p><h1 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h1><p>当我们在浏览器输入URL后，浏览器会先请求<a href="http://selfboot.cn/2015/11/05/dns_theory/">DNS服务器，获得请求站点的 IP 地址</a>。然后发送一个HTTP Request（请求）给拥有该 IP 的主机，接着就会接收到服务器给我们的 HTTP Response（响应），浏览器经过渲染后，以一种较好的效果呈现给我们。这个过程中，正是Web服务器在幕后默默做贡献。</p><p>简单来说，Web服务器是在运行在物理服务器上的一个程序，它永久地等待客户端（主要是浏览器，比如Chrome，Firefox等）发送请求。当收到请求之后，它会生成相应的响应并将其返回至客户端。Web服务器通过HTTP协议与客户端通信，因此也被称为HTTP服务器。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_2.png" alt="Web 服务器"></p><p>Web服务器的工作原理并不复杂，一般可分成如下4个步骤：<code>建立连接、请求过程、应答过程以及关闭连接</code>。</p><ol><li>建立连接：客户机通过TCP&#x2F;IP协议建立到服务器的TCP连接。</li><li>请求过程：客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档。</li><li>应答过程：服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端。由客户端解释HTML文档，在客户端屏幕上渲染图形结果。</li><li>关闭连接：客户机与服务器断开。</li></ol><p>下面我们实现一个简单的 Web 服务器。运行<a href="https://gist.github.com/xuelangZF/19cd52525b64ed3973f480902447a9ea">示例程序</a>后，会监听本地端口 8000，在浏览器访问 <a href="http://localhost:8000/">http://localhost:8000</a> 就能看到响应内容。而我们的程序也能够打印出客户端发来的请求内容，如下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_3.png" alt="简单Web服务器"></p><p>这里Request 和 Response 都需要遵守 HTTP 协议，关于 HTTP 协议的详细内容，可以读读《HTTP 权威指南》，或者看我整理的<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Network/HTTP.md">HTTP 部分内容</a>。</p><p>虽然说web服务器的主要工作是根据request返回response，但是实际中的 Web 服务器远远比上面示例的复杂的多，因为要考虑的因素实在是太多了，比如：</p><ul><li>缓存机制：讲一些经常被访问的页面缓存起来，提高响应速度；</li><li>安全：防止黑客的各种攻击，比如 SYN Flood 攻击；</li><li>并发处理：如何响应不同客户端同时发起的请求；</li><li>日志：记录访问日至，方便做一些分析。</li></ul><p>目前在UNIX和LINUX平台下使用最广泛的免费 Web 服务器有Apache和 Nginx 。</p><h1 id="Web-应用程序"><a href="#Web-应用程序" class="headerlink" title="Web 应用程序"></a>Web 应用程序</h1><p>Web 服务器接受 Http Request，返回 Response，很多时候 Response 并不是静态文件，因此需要有一个应用程序根据 Request 生成相应的 Response。这里的应用程序主要用来处理相关业务逻辑，读取或者更新数据库，根据不同 Request 返回相应的 Response。注意这里并不是 Web 服务器本身来做这件事，它只负责 Http 协议层面和一些诸如并发处理，安全，日志等相关的事情。</p><p>应用程序可以用各种语言编写（Java, PHP, Python, Ruby等），这个应用程序会从Web服务器接收客户端的请求，处理完成后，再返回响应给Web服务器，最后由Web服务器返回给客户端。整个架构如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_4.png" alt="Web应用程序"></p><p>以 Python 为例，使用Python开发Web，最原始和直接的办法是使用<a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI标准</a>，在1998年这种方式很流行。首先确保 Web 服务器支持CGI及已经配置了CGI的处理程序，然后设置好CGI目录，在目录里面添加相应的 python 文件，每一个 python 文件处理相应输入，生成一个 html 文件即可，如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Content-type:text/html&quot;</span></span><br><span class="line"><span class="built_in">print</span>  <span class="comment"># 空行，告诉服务器结束头部</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;html&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;head&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;/head&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;body&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;h2&gt;Hello Word! 我是一个CGI程序&lt;/h2&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;/body&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;/html&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>这样在浏览器访问该文件就可以得到一个简单的 Hello World 网页内容。直接通过 CGI 写 Web 应用程序看起来很简单，每一个文件处理输入，生成html。但是实际开发中，可能会遇到许多不方便的地方。比如：</p><ul><li>每个独立的CGI脚本可能会重复写数据库连接，关闭的代码；</li><li>后端开发者会看到一堆 Content-Type 等和自己无关的 html 页面元素；</li></ul><h1 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h1><p>早期开发站点确做了许多重复性劳动，后来为了减少重复，避免写出庞杂，混乱的代码，人们将 Web 开发的关键性过程提取出来，开发出了各种 Web 框架。有了框架，就可以专注于编写清晰、易维护的代码，无需关心数据库连接之类的重复性工作。</p><p>其中一种比较经典的Web框架采用了 <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> 架构，如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_5.png" alt="MVC 架构"></p><p>用户输入 URL，客户端发送请求，<code>控制器（Controller）</code>首先会拿到请求，然后用<code>模型（Models）</code>从数据库取出所有需要的数据，进行必要的处理，将处理后的结果发送给 <code>视图（View）</code>，视图利用获取到的数据，进行渲染生成 Html Response返回给客户端。</p><p>以 python web 框架 flask 为例，框架本身并不限定我们用哪种架构来组织我们的应用，不过 flask 可以很好地支持以 MVC 方式组织应用。</p><p>控制器：flask 可以用装饰器来添加路由项，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_page</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>模型：主要用来取出需要的数据，如下面函数中操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_page</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Searches the database for entries, then displays them.&quot;&quot;&quot;</span></span><br><span class="line">    db = get_db()</span><br><span class="line">    cur = db.execute(<span class="string">&#x27;select * from entries order by id desc&#x27;</span>)</span><br><span class="line">    entries = cur.fetchall()</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, entries=entries)</span><br></pre></td></tr></table></figure><p>视图：flask 利用 jinja2 来渲染页面，下面的模版文件指定了页面的样式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> entry <span class="keyword">in</span> entries %&#125;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; entry.title &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; entry.text|safe &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">&lt;li&gt;&lt;em&gt;No entries yet. Add some!&lt;/em&gt;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h1 id="Web-服务器网关接口"><a href="#Web-服务器网关接口" class="headerlink" title="Web 服务器网关接口"></a>Web 服务器网关接口</h1><p>我们知道Python有着许多的 Web 框架，而同时又有着许多的 Web 服务器（Apache, Nginx, Gunicorn等），框架和Web服务器之间需要进行通信，如果在设计时它们之间不可以相互匹配的，那么选择了一个框架就会限制对 Web 服务器的选择，这显然是不合理的。</p><p>那么，怎样确保可以在不修改Web服务器代码或网络框架代码的前提下，使用自己选择的服务器，并且匹配多个不同的网络框架呢？答案是接口，设计一套双方都遵守的接口就可以了。对python来说，就是<code>WSGI</code>（Web Server Gateway Interface，Web服务器网关接口）。其他编程语言也拥有类似的接口：例如Java的Servlet API和Ruby的Rack。</p><p>Python WSGI的出现，让开发者可以将 Web 框架与 Web 服务器的选择分隔开来，不再相互限制。现在，你可以真正地将不同的 Web 服务器与Web框架进行混合搭配，选择满足自己需求的组合。例如，可以使用 Gunicorn 或Nginx&#x2F;uWSGI来运行Django、Flask或web.py应用。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_6.jpeg" alt="WSGI 适配"></p><p><a href="http://selfboot.cn/2016/08/07/forum_design_wsgi/">下一篇</a>我们将会仔细分析 WSGI 接口标准，然后一起来写一个简单的 WSGI Web 服务器。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://codingpy.com/article/build-a-simple-web-server-part-one/">自己动手开发网络服务器（一）</a><br><a href="http://codingpy.com/article/build-a-simple-web-server-part-two/">自己动手开发网络服务器（二）</a><br><a href="http://codingpy.com/article/build-a-simple-web-server-part-three/">自己动手开发网络服务器（三）</a><br><a href="https://www.hitoy.org/principle-of-wsgi.html">Web服务器网关接口实现原理分析</a><br><a href="http://pythonguidecn.readthedocs.io/zh/latest/scenarios/web.html">Python最佳实践指南：Web 应用</a><br><a href="http://feilong.me/2011/01/talk-about-python-web-framework">浅谈Python web框架</a><br><a href="http://www.runoob.com/python/python-cgi.html">Python CGI编程</a><br><a href="https://www.airpair.com/python/posts/django-flask-pyramid">Django vs Flask vs Pyramid: Choosing a Python Web Framework</a><br><a href="https://www.python.org/dev/peps/pep-0333/">PEP 333 – Python Web Server Gateway Interface v1.0</a><br><a href="https://segmentfault.com/a/1190000003069785">WSGI简介</a><br><a href="https://realpython.com/blog/python/the-model-view-controller-mvc-paradigm-summarized-with-legos/">Model-View-Controller (MVC) Explained – With Legos</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前用 Django 做过一个小的站点，感觉Django太过笨重，于是就准备换一个比较轻量级的 Web 框架来玩玩。Web.py 作者已经挂掉，项目好久没有更新，所以不准备用它。而 Flask 也是一个成熟的轻量级 Web 框架，在 github 上有众多的 Star 和 Fork，文档和扩展也很丰富，值得学习。&lt;/p&gt;
&lt;p&gt;学习一个框架最好的方式就是用框架做一个项目，在实战中理解掌握框架。这里我用 Flask 框架，使用 Mysql 数据库做了一个&lt;a href=&quot;https://github.com/xuelangZF/NaHan&quot;&gt;论坛系统&lt;/a&gt;。麻雀虽小，五脏俱全，论坛效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_1.png&quot; alt=&quot;论坛系统截图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="项目实践" scheme="https://selfboot.cn/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Flask" scheme="https://selfboot.cn/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 刷题指南（一）：为什么要刷题</title>
    <link href="https://selfboot.cn/2016/07/24/leetcode_guide_why/"/>
    <id>https://selfboot.cn/2016/07/24/leetcode_guide_why/</id>
    <published>2016-07-24T22:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>虽然刷题一直饱受诟病，不过不可否认刷题确实能锻炼我们的编程能力，相信每个认真刷题的人都会有体会。现在提供在线编程评测的平台有很多，比较有名的有 <a href="http://hihocoder.com/">hihocoder</a>，<a href="http://www.lintcode.com/zh-cn/">LintCode</a>，以及这里我们关注的 <a href="https://leetcode.com/">LeetCode</a>。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160724_leetcode_guide_1.png" alt="LeetCode"></p><span id="more"></span><p>LeetCode 是一个非常棒的 OJ（Online Judge）平台，收集了许多公司的面试题目。相对其他 OJ 平台而言，有着下面的几个优点：</p><ul><li>题目全部来自业内大公司的真实面试</li><li>不用处理输入输出，精力全放在解决具体问题上</li><li>题目有丰富的讨论，可以参考别人的思路</li><li>精确了解自己代码在所有提交代码中运行效率的排名</li><li>支持多种主流语言：C&#x2F;C++，Python, Java</li><li>可以在线进行测试，方便调试</li></ul><p>下面是我刷 LeetCode 的一些收获，希望能够引诱大家有空时刷刷题目。</p><h1 id="问题：抽象思维"><a href="#问题：抽象思维" class="headerlink" title="问题：抽象思维"></a>问题：抽象思维</h1><p><a href="https://en.wikipedia.org/wiki/George_P%C3%B3lya">波利亚</a>用三本书：《How To Solve It》、《数学的发现》、《数学与猜想》）来试图阐明人类解决问题的一般性的思维方法，总结起来主要有以下几种：</p><ul><li><code>时刻不忘未知量</code>。即时刻别忘记你到底想要求什么，问题是什么。（<a href="https://github.com/xuelangZF/LeetCode/tree/master/DynamicProgramming">动态规划</a>中问题状态的设定）</li><li><code>试错</code>。对题目这里捅捅那里捣捣，用上所有的已知量，或使用所有你想到的操作手法，尝试着看看能不能得到有用的结论，能不能离答案近一步（<a href="https://github.com/xuelangZF/LeetCode/tree/master/Backtracking">回溯算法</a>中走不通就回退）。</li><li><code>求解一个类似的题目</code>。类似的题目也许有类似的结构，类似的性质，类似的解方案。通过考察或回忆一个类似的题目是如何解决的，也许就能够借用一些重要的点子（比较 Ugly Number 的三个题目：<a href="https://leetcode.com/problems/ugly-number/">263. Ugly Number</a>， <a href="https://leetcode.com/problems/ugly-number-ii/">264. Ugly Number II</a>， <a href="https://leetcode.com/problems/super-ugly-number/">313. Super Ugly Number</a>）。</li><li><code>用特例启发思考</code>。通过考虑一个合适的特例，可以方便我们快速寻找出一般问题的解。</li><li><code>反过来推导</code>。对于许多题目而言，其要求的结论本身就隐藏了推论，不管这个推论是充分的还是必要的，都很可能对解题有帮助。</li></ul><p>刷 LeetCode 的最大好处就是可以锻炼解决问题的思维能力，相信我，如何去思考本身也是一个需要不断学习和练习的技能。</p><p>此外，大量高质量的题目可以加深我们对计算机科学中经典数据结构的<code>深刻理解</code>，从而可以快速用合适的数据结构去解决现实中的问题。我们看到很多ACM大牛，拿到题目后立即就能想出解法，大概就是因为他们对于各种数据结构有着深刻的认识吧。LeetCode 上面的题目涵盖了几乎所有常用的数据结构：</p><ul><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/Stack">Stack</a>：简单来说具有后进先出的特性，具体应用起来也是妙不可言，可以看看题目 <a href="https://leetcode.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a>。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/LinkedList">Linked List</a>：链表可以快速地插入、删除，但是查找比较费时（具体操作链表时结合图会简单很多，此外要注意空节点）。通常链表的相关问题可以用双指针巧妙的解决，<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a> 可以帮我们重新审视链表的操作。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/HashTable">Hash Table</a>：利用 Hash 函数来将数据映射到固定的一块区域，方便 O(1) 时间内读取以及修改。<a href="https://leetcode.com/problems/sudoku-solver/">37. Sudoku Solver</a> 数独是一个经典的回溯问题，配合 HashTable 的话，运行时间将大幅减少。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/Tree">Tree</a>：树在计算机学科的应用十分广泛，常用的有二叉搜索树，红黑书，B+树等。树的建立，遍历，删除相对来说比较复杂，通常会用到递归的思路，<a href="https://leetcode.com/problems/path-sum-ii/">113. Path Sum II</a> 是一个不错的开胃菜。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/Heap">Heap</a>：特殊的完全二叉树，“等级森严”，可以用 O(nlogn) 的时间复杂度来进行排序，可以用 O(nlogk) 的时间复杂度找出 n 个数中的最大（小）k个，具体可以看看 <a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a>。</li></ul><h1 id="算法：时间空间"><a href="#算法：时间空间" class="headerlink" title="算法：时间空间"></a>算法：时间空间</h1><p>我们知道，除了数据结构，具体算法在一个程序中也是十分重要的，而算法效率的度量则是时间复杂度和空间复杂度。通常情况下，人们更关注时间复杂度，往往希望找到比 O( n^2 ) 快的算法，在数据量比较大的情况下，算法时间复杂度最好是O(logn)或者O(n)。计算机学科中经典的算法思想就那么多，LeetCode 上面的题目涵盖了其中大部分，下面大致来看下。</p><ul><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/DivideConquer">分而治之</a>：有点类似“大事化小、小事化了”的思想，经典的归并排序和快速排序都用到这种思想，可以看看  <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">Search a 2D Matrix II</a> 来理解这种思想。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/DynamicProgramming">动态规划</a>：有点类似数学中的归纳总结法，找出状态转移方程，然后逐步求解。 <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. Best Time to Buy and Sell Stock with Cooldown</a> 是理解动态规划的一个不错的例子。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/Greedy">贪心算法</a>：有时候只顾局部利益，最终也会有最好的全局收益。<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a> 看看该如何“贪心”。</li><li>搜索算法（<a href="https://github.com/xuelangZF/LeetCode/tree/master/DepthFirstSearch">深度优先</a>，<a href="https://github.com/xuelangZF/LeetCode/tree/master/BreadthFirstSearch">广度优先</a>，<a href="https://github.com/xuelangZF/LeetCode/tree/master/BinarySearch">二分搜索</a>）：在有限的解空间中找出满足条件的解，深度和广度通常比较费时间，二分搜索每次可以将问题规模缩小一半，所以比较高效。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/Backtracking">回溯</a>：不断地去试错，同时要注意回头是岸，走不通就换条路，最终也能找到解决问题方法或者知道问题无解，可以看看 <a href="https://leetcode.com/problems/palindrome-partitioning/">131. Palindrome Partitioning</a>。</li></ul><p>当然，还有一部分问题可能需要一些<a href="https://github.com/xuelangZF/LeetCode/tree/master/Math">数学知识</a>去解决，或者是需要一些<a href="https://github.com/xuelangZF/LeetCode/tree/master/BitManipulation">位运算的技巧</a>去快速解决。总之，我们希望找到时间复杂度低的解决方法。为了达到这个目的，我们可能需要在一个解题方法中融合多种思想，比如在 <a href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a> 中同时用到了动态规划和二分查找的方法，将复杂度控制在 O(nlogn)。如果用其他方法，时间复杂度可能会高很多，这种题目的运行时间统计图也比较有意思，可以看到不同解决方案运行时间的巨大差异，如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160724_leetcode_guide_2.png" alt="运行时间"></p><p>当然有时候我们会牺牲空间换取时间，比如在动态规划中状态的保存，或者是记忆化搜索，避免在递归中计算重复子问题。<a href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a> 的<a href="https://discuss.leetcode.com/topic/39834/step-by-step-tackling-of-the-problem">一个Discuss</a>会教我们如何用记忆化搜索减少程序执行时间。</p><h1 id="语言：各有千秋"><a href="#语言：各有千秋" class="headerlink" title="语言：各有千秋"></a>语言：各有千秋</h1><p>对一个问题来说，解题逻辑不会因编程语言而不同，但是具体coding起来语言之间的差别还是很大的。用不同语言去解决同一个问题，可以让我们更好地去理解语言之间的差异，以及特定语言的优势。</p><h2 id="速度-VS-代码量"><a href="#速度-VS-代码量" class="headerlink" title="速度 VS 代码量"></a>速度 VS 代码量</h2><p>C++ 以高效灵活著称，LeetCode 很好地印证了这一点。对于绝大多数题目来说，c++ 代码的运行速度要远远超过 python 以及其他语言。和 C++ 相比，Python 允许我们用更少的代码量实现同样的逻辑。通常情况下，Python程序的代码行数只相当于对应的C++代码的行数的三分之一左右。</p><p>以 <a href="https://leetcode.com/problems/top-k-frequent-elements/">347 Top K Frequent Elements</a> 为例，给定一个数组，求数组里出现频率最高的 K 个数字，比如对于数组 [1,1,1,2,2,3]，K&#x3D;2 时，返回 [1,2]。解决该问题的思路比较常规，首先用 hashmap 记录每个数字的出现频率，然后可以用 heap 来求出现频率最高的 k 个数字。</p><p>如果用 python 来实现的话，主要逻辑部分用两行代码就足够了，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_count = collections.Counter(nums)</span><br><span class="line"><span class="keyword">return</span> heapq.nlargest(k, num_count, key=<span class="keyword">lambda</span> x: num_count[x])</span><br></pre></td></tr></table></figure><p>当然了，要想写出短小优雅的 python 代码，需要对 python 思想以及模块有很好的了解。关于 python 的相关知识点讲解，可以参考<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python.md">这里</a>。</p><p>而用 C++ 实现的话，代码会多很多，带来的好处就是速度的飞跃。具体代码在<a href="https://github.com/xuelangZF/LeetCode/blob/master/Heap/347_TopKFrequentElements.cpp">这里</a>，建立大小为 k 的小顶堆，每次进堆时和堆顶进行比较，核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build the min-heap with size k.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = num_count.<span class="built_in">begin</span>(); it != num_count.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(frequent_heap.<span class="built_in">size</span>() &lt; k)&#123;</span><br><span class="line">        frequent_heap.<span class="built_in">push</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(it-&gt;second &gt;= frequent_heap.<span class="built_in">top</span>().second)&#123;</span><br><span class="line">        frequent_heap.<span class="built_in">pop</span>();</span><br><span class="line">        frequent_heap.<span class="built_in">push</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语言的差异"><a href="#语言的差异" class="headerlink" title="语言的差异"></a>语言的差异</h2><p>我们都知道 c++ 和 python 是不同的语言，它们有着显著的区别，不过一不小心我们就会忘记它们之间的差别，从而写出bug来。不信？来看 <a href="https://leetcode.com/problems/sqrtx/">69 Sqrt(x)</a>，实现 <code>int sqrt(int x)</code>。这题目是经典的二分查找（当然也可以用更高级的牛顿迭代法），用 python 来实现的话很容易写出 <a href="https://github.com/xuelangZF/LeetCode/blob/master/BinarySearch/69_Sqrt_x.py">AC 的代码</a>。</p><p>如果用 C++ 的话，相信很多人也能避开求中间值的整型溢出的坑：<code>int mid = low + (high - low) / 2;</code>，于是写出下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> low = <span class="number">0</span>, high = x;</span><br><span class="line"><span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line"><span class="comment">// int mid = (low+high) / 2,  may overflow.</span></span><br><span class="line">    <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=mid *mid &amp;&amp; x&lt;(mid+<span class="number">1</span>)*(mid+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;mid *mid)</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很可惜，这样的代码仍然存在整型溢出的问题，因为mid*mid 有可能大于 <code>INT_MAX</code>，正确的代码在<a href="https://github.com/xuelangZF/LeetCode/blob/master/BinarySearch/69_Sqrt_x.cpp">这里</a>。当我们被 python 的自动整型转换宠坏后，就很容易忘记c++整型溢出的问题。</p><p>除了臭名昭著的整型溢出问题，c++ 和 python 在位运算上也有着一点不同。以 <a href="https://leetcode.com/problems/sum-of-two-integers/">371 Sum of Two Integers</a> 为例，不用 +, - 实现 int 型的加法 <code>int getSum(int a, int b)</code>。其实就是模拟计算机内部加法的实现，很明显是一个位运算的问题，c++实现起来比较简单，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getSum</span>(a^b, (a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而用 python 的话，情况变的复杂了很多，归根到底还是因为 python 整型的实现机制，具体代码在<a href="https://github.com/xuelangZF/LeetCode/blob/master/BitManipulation/371_SumOfTwoIntegers.py">这里</a>。</p><h1 id="讨论：百家之长"><a href="#讨论：百家之长" class="headerlink" title="讨论：百家之长"></a>讨论：百家之长</h1><p>如果说 LeetCode 上面的题目是一块块金子的话，那么评论区就是一个点缀着钻石的矿山。多少次，当你绞尽脑汁终于 AC，兴致勃发地来到评论区准备吹水。结果迎接你的却是大师级的代码。于是，你高呼：尼玛，竟然可以这样！然后闭关去思考那些优秀的代码，顺便默默鄙视自己。</p><p>除了优秀的代码，有时候还会有直观的解题思路分享，方便看看别人是如何解决这个问题的。<a href="https://discuss.leetcode.com/user/missmary">@MissMary</a>在“两个排序数组中找出中位数”这个题目中，给出了一个很棒的解释：<a href="https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation/2">Share my o(log(min(m,n)) solution with explanation</a>，获得了400多个赞。</p><p>你也可以评论大牛的代码，或者提出改进方案，不过有时候可能并非如你预期一样改进后代码会运行地更好。在 <a href="https://leetcode.com/problems/n-queens/">51. N-Queens</a> 的讨论 <a href="https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand">Accepted 4ms c++ solution use backtracking and bitmask, easy understand</a> 中，@binz 在讨论区中纳闷自己将数组 vector<int> （取值非零即一）改为 vector<bool> 后，运行时间变慢。@prime_tang 随后就给出建议说最好不要用 vector<bool>，并给出了<a href="https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand/16">两个 StackOverflow 答案</a>。</p><p>当你逛讨论区久了，你可能会有那么一两个偶像，比如<a href="https://discuss.leetcode.com/user/stefanpochmann">@StefanPochmann</a>。他的一个粉丝 @agave 曾经问 StefanPochmann 一个问题：</p><blockquote><p>Hi Stefan, I noticed that you use a lot of Python tricks in your solutions, like “v +&#x3D; val,” and so on… Could you share where you found them, or how your learned about them, and maybe where we can find more of that? Thanks!</p></blockquote><p>StefanPochmann 也不厌其烦地给出了自己的答案：</p><blockquote><p>@agave From many places, though I’d say I learned a lot on CheckiO and StackOverflow (when I was very active there for a month). You might also find some by googling python code golf.</p></blockquote><p>原来大神也是在 StackOverflow 上修炼的，看来需要在 <a href="http://selfboot.cn/2016/06/26/why_need_to_read_StackOverflow/">为什么离不开 StackOverflow</a> 中添加一个理由了：因为 StefanPochmann 都混迹于此。</p><p>类似这样友好，充满技术味道的讨论，在 LeetCode 讨论区遍地都是，绝对值得我们去好好探访。</p><h1 id="成长：大有益处"><a href="#成长：大有益处" class="headerlink" title="成长：大有益处"></a>成长：大有益处</h1><p>偶尔会听旁边人说 XX 大牛 LeetCode 刷了3遍，成功进微软，还拿了 special offer！听起来好像刷题就可以解决工作问题，不过要知道还有<a href="http://www.1point3acres.com/bbs/thread-168094-1-1.html">刷5遍 LeetCode 仍然没有找到工作的人</a>呢。所以，不要想着刷了很多遍就可以找到好工作，毕竟比你刷的还疯狂的大有人在（开个玩笑）。</p><p>不过，想想前面列出的那些好处，应该值得大家抽出点时间来刷刷题了吧。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://mindhacks.cn/2008/04/18/learning-from-polya/">跟波利亚学解题</a><br><a href="http://coolshell.cn/articles/8138.html">为什么我反对纯算法面试题</a><br><a href="http://blog.iderzheng.com/coding-is-not-everything/">聊聊刷题</a><br><a href="https://www.zhihu.com/question/35133069">如何看待中国学生为了进 Google、微软等企业疯狂地刷题？</a><br><a href="http://coolshell.cn/articles/12052.html">LeetCode 编程训练</a><br><a href="https://www.zhihu.com/question/25574458">国内有哪些好的刷题网站?</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然刷题一直饱受诟病，不过不可否认刷题确实能锻炼我们的编程能力，相信每个认真刷题的人都会有体会。现在提供在线编程评测的平台有很多，比较有名的有 &lt;a href=&quot;http://hihocoder.com/&quot;&gt;hihocoder&lt;/a&gt;，&lt;a href=&quot;http://www.lintcode.com/zh-cn/&quot;&gt;LintCode&lt;/a&gt;，以及这里我们关注的 &lt;a href=&quot;https://leetcode.com/&quot;&gt;LeetCode&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160724_leetcode_guide_1.png&quot; alt=&quot;LeetCode&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="思考" scheme="https://selfboot.cn/tags/%E6%80%9D%E8%80%83/"/>
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>为什么离不开 Stackoverflow</title>
    <link href="https://selfboot.cn/2016/06/26/why_need_to_read_stackoverflow/"/>
    <id>https://selfboot.cn/2016/06/26/why_need_to_read_stackoverflow/</id>
    <published>2016-06-26T22:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名程序员，如果没有听过 Stackoverflow，那么你最好去面壁思过一下。程序员最需要阅读的一本编程书籍（其实编程书留下这本就够了！）：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160626_stackoverflow_book.jpg" alt="虚构的书"></p><p>那些还没有读过这本书的程序员，是时候买一本了。如果还在犹豫，那么先看下这篇文章，看看为什么离不开 stackoverflow。</p><span id="more"></span><h1 id="提问的智慧"><a href="#提问的智慧" class="headerlink" title="提问的智慧"></a>提问的智慧</h1><blockquote><p>当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。 –Eric S. Raymond</p></blockquote><p>有时候，清晰描述一个问题，特别是技术问题没有想象的那么简单。提问从来就是一门学问，可惜很多人没有意识到这一点，或者没有给予足够的重视。或者，有的提问者根本不是抱着提问的态度来请求大家的帮助。所以我们会发现各种让人无法解答或者无心解答的问题：</p><ul><li><a href="https://segmentfault.com/q/1010000005694368">java正则表达式问题？</a></li><li><a href="https://segmentfault.com/q/1010000005695451">sla响应时间是指什么？</a></li><li><a href="https://segmentfault.com/q/1010000005694256">ATL类与一般的类继承有什么区别</a></li></ul><p>为了避免上面的问题被关闭或者修改，放一张图片在这里，来体会下这种狗屎问题：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160626_shit_questions.png" alt="不好的问题"></p><p>去 segmentfault 的未回答题目中随便就能找到一堆这样的问题，所以很多人显然并没有提问的智慧或者没有很好的态度。Raymond 和 Rick Moen 写了一份经典的文章 <a href="http://www.catb.org/~esr/faqs/smart-questions.html#translations">How To Ask Questions The Smart Way</a>专门来描述如何提问，这篇文章被翻译成各国文字，留传很广，可以在<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">这里</a>找到中文版。Stackoverflow 和 Segmentfalut 也给出了关于提问的建议：</p><ul><li><a href="https://stackoverflow.com/help/asking">Help Center &gt; Asking</a></li><li><a href="https://stackoverflow.com/questions/ask/advice">How to Ask</a></li><li><a href="https://stackoverflow.com/help/how-to-ask">How do I ask a good question?</a></li><li><a href="https://segmentfault.com/faq#what-should-ask">什么样的问题才是受欢迎的</a></li></ul><p>在 Stackoverflow 可以看到太多经典的问题，我们可以从这些问题中学习如何去提问，如何和答题者沟通。当你看习惯了stackoverflow 上面的问题，提问时就会不自觉去模仿，从而避免问出无脑问题。下面是提问时最需要注意的几个问题：</p><ul><li>问搜索引擎没有满意答案（google 起码过四页）的问题</li><li>问那些自己无法独立解决，已经做过很多尝试的问题</li><li>尽量清楚地描述问题：良好的排版，代码，错误提示，图片等</li><li>让你的问题对别人有帮助</li><li>问题要有确定的答案，不要有太多的主观性</li></ul><h1 id="不同的方案"><a href="#不同的方案" class="headerlink" title="不同的方案"></a>不同的方案</h1><p>很多时候我们希望能够找到一个解决办法，但是在 stackoverflow 上，经常会有意外的收获。你可能会看到对一个问题不同的解决方案，甚至包括对这些解决方案的比较。</p><p>假设现在你想知道 python 中如何调用外部命令，比如 ls -l 来打印某个目录下面的文章。Google一下 <code>python call system command</code>，第一条就是stackoverflow 上面的一个相关问题：<a href="http://stackoverflow.com/questions/89228/calling-an-external-command-in-python">Calling an external command in Python.</a> （google技术问题，基本都会显示 stackoverflow 相关问题）。</p><p>然后在这个问题下面，有人总结了调用外部命令的几种方法：</p><ul><li>os.system()</li><li>os.popen()</li><li>subprocess.popen()</li><li>subprocess.call()</li><li>subprocess.run()</li></ul><p>并且还对每个方法做了介绍，你可以选择适合自己应用场景的方法。再比如这个问题 <a href="http://stackoverflow.com/questions/82831/how-to-check-whether-a-file-exists-using-python">How to check whether a file exists using Python?</a>，介绍了 python 中检查文件是否存在的不同方法。</p><h1 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h1><p>有许多强有力的工具可以帮我们更好地研究问题，你可能知道gdb调试工具，可能知道python的timeit时间监控模块，但是你不知道那些自己不知道的工具。很多时候，当第一次知道某个工具时，我们心中会产生相见恨晚的感觉。然而，心仪的趁手工具总是那么可遇不可求。</p><p>在 stackoverflow，每一个问题答案或者评论中都可能会有一些好的工具，你总有机会发现那些遗落在字里行间的优秀工具。</p><p>下面列出我发现的一些不错的工具：</p><ul><li><code>truss/strace</code>：跟踪进程执行时的系统调用和所接收的信号，strace可以跟踪到一个进程产生的系统调用，包括参数，返回值，执行消耗的时间。（来自问题：<a href="https://stackoverflow.com/questions/9371238/why-is-reading-lines-from-stdin-much-slower-in-c-than-python">Why is reading lines from stdin much slower in C++ than Python?</a>）</li><li><a href="https://github.com/nvdv/vprof">vprof</a>：一个可视化工具，可以分析 Python 程序的特点，比如运行时间，内存使用等。（来自问题：<a href="https://stackoverflow.com/questions/582336/how-can-you-profile-a-python-script">How can you profile a Python script?</a>）</li><li><a href="http://www.regex101.com/">Regex 101</a>：一款在线的正则表达式辅助工具，可以帮助理解正则表达式的含义，方便调试正则表达式以及做一些简单的尝试。（来自问题：<a href="http://stackoverflow.com/questions/4736/learning-regular-expressions">Learning Regular Expressions</a>）</li></ul><p>下面为 Regex 101 的一个简单示例：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160626_regex101.png" alt="Regex 101"></p><h1 id="思考的过程"><a href="#思考的过程" class="headerlink" title="思考的过程"></a>思考的过程</h1><p>很多时候，遇到一个问题，我们根本无从下手，不知道朝哪个方向思考。但是通过 stackoverflow，我们可以轻易知道具体的解决方案，有时候甚至还能知道别人面对这个问题时候是怎么思考的。</p><p>假设你想利用装饰器来完成一个任务，即在下面say函数返回的字符串前后加上<code>&lt;b&gt;&lt;i&gt;</code>，你想想这样定义 say。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@makebold</span></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p>每次调用 say 返回 <code>&lt;b&gt;&lt;i&gt;Hello&lt;/i&gt;&lt;/b&gt;</code>。但是要如何实现 makebold 和 makeitalic 呢，这是一个<a href="https://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python">问题</a>。在 stackoverflow 上，有大牛会直接告诉你答案，并扔给你一个装饰器的文档链接。但是还有大牛会把自己的思考过程，把自己对装饰器的理解详细地告诉你，让你深入去理解装饰器机制。</p><p>针对上面的这个问题，有一个答案获得了 3000 多赞，一步步告诉大家如何解决问题。首先告诉我们python中函数有什么特点：</p><ul><li>函数是对象</li><li>函数可以被赋给一个变量</li><li>函数可以被定义在另一个函数中</li><li>一个函数可以返回另一个函数</li><li>可以把函数作为参数传递</li></ul><p>然后开始解释什么是装饰器：其实就是封装器，可以让我们在不修改原函数的基础上，在执行原函数的前后执行别的代码。接下来手工实现了一个简单的装饰器原型，紧接着引入 python 中的装饰器语法。最后还列出了一些装饰器的高级用法，包括给装饰器传递参数等。读完整个答案，一定能对装饰器有较深的理解，并且知道理解装饰器的思考过程。这样，沿着这条思考的路径，你自己就可以推导出装饰器的使用方法。</p><h1 id="可能的盲区"><a href="#可能的盲区" class="headerlink" title="可能的盲区"></a>可能的盲区</h1><p>没有问题要提问时也可以时常逛一逛 stackoverflow，浏览一些投票比较多的问题，看看别人的回答。在这个庞大的知识库中，你很可能会发现自己的一些认知盲区，发现一些自己从未关注过的内容。</p><p>我就发现了一些比较有意思的问题，比如：</p><ul><li><a href="http://stackoverflow.com/questions/287871/print-in-terminal-with-colors-using-python">Print in terminal with colors using Python?</a></li><li><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">What is a metaclass in Python?</a></li><li><a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim">What is your most productive shortcut with Vim?</a></li></ul><p>我整理了一份 Python 的高质量问题清单，放在<a href="https://github.com/xuelangZF/CS_Offer/blob/master/More/Python_StackOverflow.md">这里</a>以供时常翻阅。</p><h1 id="相见恨晚"><a href="#相见恨晚" class="headerlink" title="相见恨晚"></a>相见恨晚</h1><p>那么怎么才能找到 stackoverflow 呢，两个建议：</p><ul><li>英语精确描述问题</li><li>用 Google 去搜索</li></ul><p>只要你不是第一个遇见某个技术问题的人，你基本就会在 stackoverflow 找到相同或者类似的问题。早日遇见，早日喜欢上 stackoverflow，你会发现生活是如此惬意。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://blog.jobbole.com/101980/">玩转 Stack Overflow 之提问篇</a><br><a href="http://www.thegeekstuff.com/2011/11/strace-examples/">7 Strace Examples to Debug the Execution of a Program in Linux</a><br><a href="https://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python">How can I make a chain of function decorators in Python?</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一名程序员，如果没有听过 Stackoverflow，那么你最好去面壁思过一下。程序员最需要阅读的一本编程书籍（其实编程书留下这本就够了！）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160626_stackoverflow_book.jpg&quot; alt=&quot;虚构的书&quot;&gt;&lt;/p&gt;
&lt;p&gt;那些还没有读过这本书的程序员，是时候买一本了。如果还在犹豫，那么先看下这篇文章，看看为什么离不开 stackoverflow。&lt;/p&gt;</summary>
    
    
    
    <category term="工具介绍" scheme="https://selfboot.cn/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="方法" scheme="https://selfboot.cn/tags/%E6%96%B9%E6%B3%95/"/>
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Python 性能分析大全</title>
    <link href="https://selfboot.cn/2016/06/13/python_performance_analysis/"/>
    <id>https://selfboot.cn/2016/06/13/python_performance_analysis/</id>
    <published>2016-06-13T22:02:50.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>虽然运行速度慢是 Python 与生俱来的特点，大多数时候我们用 Python 就意味着放弃对性能的追求。但是，就算是用纯 Python 完成同一个任务，老手写出来的代码可能会比菜鸟写的代码块几倍，甚至是几十倍（这里不考虑算法的因素，只考虑语言方面的因素）。很多时候，我们将自己的代码运行缓慢地原因归结于python本来就很慢，从而心安理得地放弃深入探究。</p><p>但是，事实真的是这样吗？面对python代码，你有分析下面这些问题吗：</p><ul><li>程序运行的速度如何？</li><li>程序运行时间的瓶颈在哪里？</li><li>能否稍加改进以提高运行速度呢？</li></ul><p>为了更好了解python程序，我们需要一套工具，能够记录代码运行时间，生成一个性能分析报告，方便彻底了解代码，从而进行针对性的优化（本篇侧重于代码性能分析，不关注如何优化）。</p><span id="more"></span><h1 id="谁快谁慢"><a href="#谁快谁慢" class="headerlink" title="谁快谁慢"></a>谁快谁慢</h1><p>假设有一个字符串，想将里面的空格替换为字符‘-’，用python实现起来很简单，下面是四种方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">slowest_replace</span>(<span class="params">orignal_str</span>):</span><br><span class="line">    replace_list = []</span><br><span class="line">    <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(orignal_str):</span><br><span class="line">        c = char <span class="keyword">if</span> char != <span class="string">&quot; &quot;</span> <span class="keyword">else</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">        replace_list.append(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(replace_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slow_replace</span>(<span class="params">orignal_str</span>):</span><br><span class="line">    replace_str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(orignal_str):</span><br><span class="line">        c = char <span class="keyword">if</span> char != <span class="string">&quot; &quot;</span> <span class="keyword">else</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">        replace_str += c</span><br><span class="line">    <span class="keyword">return</span> replace_str</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fast_replace</span>(<span class="params">orignal_str</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-&quot;</span>.join(orignal_str.split())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fastest_replace</span>(<span class="params">orignal_str</span>):</span><br><span class="line">    <span class="keyword">return</span> orignal_str.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;-&quot;</span>)</span><br></pre></td></tr></table></figure><p>这四种方案的效率如何呢，哪种方案比较慢呢？这是一个问题！</p><h1 id="时间断点"><a href="#时间断点" class="headerlink" title="时间断点"></a>时间断点</h1><p>最直接的想法是在开始 replace 函数之前记录时间，程序结束后再记录时间，计算时间差即为程序运行时间。python提供了模块 time，其中 time.clock() 在Unix&#x2F;Linux下返回的是CPU时间(浮点数表示的秒数)，Win下返回的是以秒为单位的真实时间(Wall-clock time)。</p><p>由于替换函数耗时可能非常短，所以这里考虑分别执行 100000次，然后查看不同函数的效率。我们的性能分析辅助函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_time_analyze_</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">from</span> time <span class="keyword">import</span> clock</span><br><span class="line">    start = clock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(exec_times):</span><br><span class="line">        func()</span><br><span class="line">    finish = clock()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;&#123;:&lt;20&#125;&#123;:10.6&#125; s&quot;</span>.<span class="built_in">format</span>(func.__name__ + <span class="string">&quot;:&quot;</span>, finish - start)</span><br></pre></td></tr></table></figure><p>这样就可以了解上面程序的运行时间情况：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160613_simple_analyze.png" alt="程序运行时间检测"></p><p>第一种方案耗时是第四种的 45 倍多，大跌眼镜了吧！同样是 python代码，完成一样的功能，耗时可以差这么多。为了避免每次在程序开始、结束时插入时间断点，然后计算耗时，可以考虑实现一个上下文管理器，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, verbose=<span class="literal">False</span></span>):</span><br><span class="line">        self.verbose = verbose</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.start = clock()</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        self.end = clock()</span><br><span class="line">        self.secs = self.end - self.start</span><br><span class="line">        self.msecs = self.secs * <span class="number">1000</span>  <span class="comment"># millisecs</span></span><br><span class="line">        <span class="keyword">if</span> self.verbose:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;elapsed time: %f ms&#x27;</span> % self.msecs</span><br></pre></td></tr></table></figure><p>使用时只需要将要测量时间的代码段放进 with 语句即可，具体的使用例子放在 <a href="https://gist.github.com/xuelangZF/1d83cd5da734836bc7641bcc92b13ce0">gist</a> 上。</p><h1 id="timeit"><a href="#timeit" class="headerlink" title="timeit"></a><a href="https://docs.python.org/2/library/timeit.html">timeit</a></h1><p>上面手工插断点的方法十分原始，用起来不是那么方便，即使用了上下文管理器实现起来还是略显笨重。还好 Python 提供了timeit模块，用来测试代码块的运行时间。它既提供了命令行接口，又能用于代码文件之中。</p><h3 id="命令行接口"><a href="#命令行接口" class="headerlink" title="命令行接口"></a>命令行接口</h3><p>命令行接口可以像下面这样使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python -m timeit -n <span class="number">1000000</span> <span class="string">&#x27;&quot;I like to reading.&quot;.replace(&quot; &quot;, &quot;-&quot;)&#x27;</span></span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">3</span>: <span class="number">0.253</span> usec per loop</span><br><span class="line">$ python -m timeit -s <span class="string">&#x27;orignal_str = &quot;I like to reading.&quot;&#x27;</span> <span class="string">&#x27;&quot;-&quot;.join(orignal_str.split())&#x27;</span></span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">3</span>: <span class="number">0.53</span> usec per loop</span><br></pre></td></tr></table></figure><p>具体参数使用可以用命令 <code>python -m timeit -h</code> 查看帮助。使用较多的是下面的选项：</p><ul><li>-s S, –setup&#x3D;S: 用来初始化statement中的变量，只运行一次；</li><li>-n N, –number&#x3D;N: 执行statement的次数，默认会选择一个合适的数字；</li><li>-r N, –repeat&#x3D;N: 重复测试的次数，默认为3；</li></ul><h3 id="Python-接口"><a href="#Python-接口" class="headerlink" title="Python 接口"></a>Python 接口</h3><p>可以用下面的程序测试四种 replace函数的运行情况（完整的测试程序可以在 <a href="https://gist.github.com/xuelangZF/67c97f92d4e4d70208d1e592a1bac1da">gist</a> 上找到）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_timeit_analyze_</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line">    t1 = Timer(<span class="string">&quot;%s()&quot;</span> % func.__name__, <span class="string">&quot;from __main__ import %s&quot;</span> % func.__name__)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;&#123;:&lt;20&#125;&#123;:10.6&#125; s&quot;</span>.<span class="built_in">format</span>(func.__name__ + <span class="string">&quot;:&quot;</span>, t1.timeit(exec_times))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160613_timeit_analyze.png" alt="timeit 模块使用"></p><p>Python的timeit提供了 timeit.Timer() 类，类构造方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timer(stmt=<span class="string">&#x27;pass&#x27;</span>, setup=<span class="string">&#x27;pass&#x27;</span>, timer=&lt;timer function&gt;)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>stmt: 要计时的语句或者函数；</li><li>setup: 为stmt语句构建环境的导入语句；</li><li>timer: 基于平台的时间函数(timer function)；</li></ul><p>Timer()类有三个方法：</p><ul><li>timeit(number&#x3D;1000000): 返回stmt执行number次的秒数(float)；</li><li>repeat(repeat&#x3D;3, number&#x3D;1000000): repeat为重复整个测试的次数，number为执行stmt的次数，返回以秒记录的每个测试循环的耗时列表；</li><li>print_exc(file&#x3D;None): 打印stmt的跟踪信息。</li></ul><p>此外，timeit 还提供了另外三个函数方便使用，参数和 Timer 差不多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timeit.timeit(stmt=<span class="string">&#x27;pass&#x27;</span>, setup=<span class="string">&#x27;pass&#x27;</span>, timer=&lt;default timer&gt;, number=<span class="number">1000000</span>)</span><br><span class="line">timeit.repeat(stmt=<span class="string">&#x27;pass&#x27;</span>, setup=<span class="string">&#x27;pass&#x27;</span>, timer=&lt;default timer&gt;, repeat=<span class="number">3</span>, number=<span class="number">1000000</span>)</span><br><span class="line">timeit.default_timer()</span><br></pre></td></tr></table></figure><h1 id="profile"><a href="#profile" class="headerlink" title="profile"></a><a href="https://docs.python.org/2/library/profile.html">profile</a></h1><p>以上方法适用于比较简单的场合，更复杂的情况下，可以用标准库里面的profile或者cProfile，它可以统计程序里每一个函数的运行时间，并且提供了可视化的报表。大多情况下，建议使用cProfile，它是profile的C实现，适用于运行时间长的程序。不过有的系统可能不支持cProfile，此时只好用profile。</p><p>可以用下面程序测试 timeit_profile() 函数运行时间分配情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"><span class="keyword">from</span> time_profile <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">cProfile.run(<span class="string">&quot;timeit_profile()&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样的输出可能会很长，很多时候我们感兴趣的可能只有耗时最多的几个函数，这个时候先将cProfile 的输出保存到诊断文件中，然后用 pstats 定制更加有好的输出（完整代码在 <a href="https://gist.github.com/xuelangZF/b1787c8ab4159de9f797fc13dad47808">gist</a> 上）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cProfile.run(<span class="string">&quot;timeit_profile()&quot;</span>, <span class="string">&quot;timeit&quot;</span>)</span><br><span class="line">p = pstats.Stats(<span class="string">&#x27;timeit&#x27;</span>)</span><br><span class="line">p.sort_stats(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line">p.print_stats(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160613_cprofile_analyze.png" alt="pstats 输出"></p><p>如果觉得 pstats 使用不方便，还可以使用一些图形化工具，比如 <a href="https://github.com/jrfonseca/gprof2dot">gprof2dot</a> 来可视化分析 cProfile 的诊断结果。</p><h3 id="vprof"><a href="#vprof" class="headerlink" title="vprof"></a>vprof</h3><p><a href="https://github.com/nvdv/vprof">vprof</a> 也是一个不错的可视化工具，可以用来分析 Python 程序运行时间情况。如下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160613_vprof_analyze.png" alt="vprof 性能诊断"></p><h1 id="line-profiler"><a href="#line-profiler" class="headerlink" title="line_profiler"></a><a href="https://github.com/rkern/line_profiler">line_profiler</a></h1><p>上面的测试最多统计到函数的执行时间，很多时候我们想知道函数里面每一行代码的执行效率，这时候就可以用到 line_profiler 了。</p><p>line_profiler 的使用特别简单，在需要监控的函数前面加上 <code>@profile</code> 装饰器。然后用它提供的 <code>kernprof -l -v [source_code.py]</code> 行进行诊断。下面是一个简单的测试程序 line_profile.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time_profile <span class="keyword">import</span> slow_replace, slowest_replace</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10000</span>):</span><br><span class="line">    slow_replace()</span><br><span class="line">    slowest_replace()</span><br></pre></td></tr></table></figure><p>运行后结果如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160613_line_analyze.png" alt="line_profiler 使用示例"></p><p>输出每列的含义如下：</p><ul><li>Line #: 行号</li><li>Hits: 当前行执行的次数.</li><li>Time: 当前行执行耗费的时间，单位为 “Timer unit:”</li><li>Per Hit: 平均执行一次耗费的时间.</li><li>% Time: 当前行执行时间占总时间的比例.</li><li>Line Contents: 当前行的代码</li></ul><p>line_profiler 执行时间的估计不是特别精确，不过可以用来分析当前函数中哪些行是瓶颈。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="https://www.huyng.com/posts/python-performance-analysis">A guide to analyzing Python performance</a><br><a href="https://pymotw.com/2/timeit/">timeit – Time the execution of small bits of Python code</a><br><a href="https://julien.danjou.info/blog/2015/guide-to-python-profiling-cprofile-concrete-case-carbonara">Profiling Python using cProfile: a concrete case</a><br><a href="https://pymotw.com/2/profile/">profile, cProfile, and pstats – Performance analysis of Python programs.</a><br><a href="https://stackoverflow.com/questions/582336/how-can-you-profile-a-python-script">How can you profile a Python script?</a><br><a href="http://python.jobbole.com/80754/">检测Python程序执行效率及内存和CPU使用的7种方法</a><br><a href="http://coolshell.cn/articles/2967.html">代码优化概要</a><br><a href="https://segmentfault.com/a/1190000000666603">Python性能优化的20条建议</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然运行速度慢是 Python 与生俱来的特点，大多数时候我们用 Python 就意味着放弃对性能的追求。但是，就算是用纯 Python 完成同一个任务，老手写出来的代码可能会比菜鸟写的代码块几倍，甚至是几十倍（这里不考虑算法的因素，只考虑语言方面的因素）。很多时候，我们将自己的代码运行缓慢地原因归结于python本来就很慢，从而心安理得地放弃深入探究。&lt;/p&gt;
&lt;p&gt;但是，事实真的是这样吗？面对python代码，你有分析下面这些问题吗：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序运行的速度如何？&lt;/li&gt;
&lt;li&gt;程序运行时间的瓶颈在哪里？&lt;/li&gt;
&lt;li&gt;能否稍加改进以提高运行速度呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了更好了解python程序，我们需要一套工具，能够记录代码运行时间，生成一个性能分析报告，方便彻底了解代码，从而进行针对性的优化（本篇侧重于代码性能分析，不关注如何优化）。&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="总结" scheme="https://selfboot.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>由 sort 中 key 的用法浅谈 python</title>
    <link href="https://selfboot.cn/2016/05/04/pythonic/"/>
    <id>https://selfboot.cn/2016/05/04/pythonic/</id>
    <published>2016-05-04T22:54:01.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>用 Python 时间也算不短了，但总感觉自己在用写 C++ 代码的思维写 Python，没有真正用到其作为脚本语言的优势。之前刷 LeetCode 时，自己的 Python 代码总是很长，很像披着 Python 外衣的 C++ 代码（放在<a href="https://github.com/xuelangZF/LeetCode">这里</a>，不断重构中）。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160504_pythonic_cpp.png" alt="Python不是C++"></p><span id="more"></span><p>想来大概是因为觉得python简单，平时只是零零碎碎的学习，也没有去读别人的代码，导致掌握的不够深入。回想起前段时间的面试，面试官看我简历写熟悉Python，就问了两个Python的问题：</p><ol><li>Python 中常用的优化技巧（能够提升 Python 执行效率的，除了算法层面）</li><li>按照 value 从小到大输出 dict 中的 key-value值。</li></ol><p>我支支吾吾半天，就是没有答到点上，直接导致被拒（后来整理的内容放在<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python.md">这里</a>）。所谓知耻而后勇，经过一段时间对 Python 的重新学习，才慢慢发现 Python 的一些强大与美妙之处。</p><h1 id="从排序说起！"><a href="#从排序说起！" class="headerlink" title="从排序说起！"></a>从排序说起！</h1><p>程序中经常用到排序函数，Python 提供了 sort 和 sorted 函数，一个原地排序，一个返回排序后的新结果，函数原型很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort([cmp[, key[, reverse]]])</span><br></pre></td></tr></table></figure><p>自己用的最多的类似下面的语句：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">l = [<span class="number">43</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">6</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">l.sort()</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">l</span></span><br><span class="line">[4, 6, 12, 43]</span><br></pre></td></tr></table></figure><p>曾经窃以为这就体现了 Python 的简单优雅，不像 C++ STL中那样还需要指定迭代器范围，然后对 sort 的理解也就止步于此。后来遇到稍微复杂一点的排序场景，自己就 <a href="http://blog.csdn.net/foruok/article/details/44870749">Google-Stackoverflow-Copy</a>，解决了眼前的问题，但是从来没有去深挖（这也就导致那次面试中中没有回答出来上面的第二个问题）。</p><h2 id="sort-之美"><a href="#sort-之美" class="headerlink" title="sort 之美"></a>sort 之美</h2><p>后来去看了下 sort 的函数说明，包括 cmp, key, reverse 参数究竟怎么去用，又写了几个例子，以为这下子对 sort 可谓是理解透彻了。比如要要根据值的大小输出字典内容，那么就可以像下面这样优雅地解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>: <span class="string">&#x27;z&#x27;</span>, <span class="number">2</span>:<span class="string">&#x27;y&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;x&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">[(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;z&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>我甚至可以得到一个根据value排序的字典，只需要用 <code>collections.OrderedDict</code> 即可：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import OrderedDict</span><br><span class="line">&gt;&gt;&gt; sorted_d = OrderedDict(<span class="name">sorted</span>(<span class="name">d</span>.items(), key=lambda x: x[<span class="number">1</span>]))</span><br><span class="line">&gt;&gt;&gt; sorted_d</span><br><span class="line">OrderedDict([(<span class="number">3</span>, &#x27;x&#x27;), (<span class="number">2</span>, &#x27;y&#x27;), (<span class="number">1</span>, &#x27;z&#x27;)])</span><br></pre></td></tr></table></figure><h2 id="sort-之魅"><a href="#sort-之魅" class="headerlink" title="sort 之魅"></a>sort 之魅</h2><p>我以为我对 sort 理解足够了，直到在 <a href="https://www.hackerrank.com/">hackerrank</a> 遇到这个<a href="https://www.hackerrank.com/challenges/ginorts">题目</a>。</p><p>给定一个只包含大小写字母，数字的字符串，对其进行排序，保证：</p><ul><li>所有的小写字母在大写字母前面</li><li>所有的字母在数字前面</li><li>所有的奇数在偶数前面</li></ul><p>考虑用 sort 函数来完成排序。开始之前，再来看看文档对sort函数中key的说明：</p><blockquote><p>key parameter to specify a function to be called on each list element prior to making comparisons.  The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes.</p></blockquote><p>通俗讲，<strong>key 用来决定在排序算法中 cmp 比较的内容，key 可以是任何可被比较的内容，比如元组（python 中元组是可被比较的）</strong>。所以上面的排序问题可以用下面的代码来解决：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s <span class="operator">=</span> <span class="string">&quot;Sorting1234&quot;</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">&quot;&quot;</span>.join(sorted(s<span class="punctuation">,</span> key<span class="operator">=</span>lambda <span class="keyword">x</span>: (<span class="keyword">x</span>.isdigit()<span class="punctuation">,</span> <span class="keyword">x</span>.isdigit() <span class="keyword">and</span> int(<span class="keyword">x</span>) % <span class="number">2</span> <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span>.isupper()<span class="punctuation">,</span> <span class="keyword">x</span>.islower()<span class="punctuation">,</span> <span class="keyword">x</span>)))</span><br><span class="line">&#x27;ginortS<span class="number">1324</span>&#x27;</span><br></pre></td></tr></table></figure><p>这里，lambda 函数将输入的字符转换为一个元组，然后 <code>sorted 函数将根据元组</code>（而不是字符）来进行比较，进而判断每个字符的前后顺序。</p><p>如果同样的程序用 C++ 来写的话，可能需要一个复杂的仿函数，来定义排序的规则，远没有 Python 这般简洁优雅。</p><h1 id="再探-Python"><a href="#再探-Python" class="headerlink" title="再探 Python"></a>再探 Python</h1><p>Python 是一门简单方便的语言，相信这是大部分人对 Python 的第一感觉。初学 Python，我们可能痴迷于 Python 的列表解析，list 切片，字典推导，或者是陶醉在各种强大的第三方库里，比如网络库 requests，科学计算库 numpy，web开发框架 Django 等。</p><p>但是实际写程序中，我们经常会写出许多<code>繁杂的、丑陋的</code>Python代码。比如要<a href="https://leetcode.com/problems/palindrome-number/">判断一个数字是否是回文数字</a>，可能会习惯性地写出下面这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    reversed_x = <span class="number">0</span></span><br><span class="line">    original_x = x</span><br><span class="line">    <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        reversed_x = reversed_x * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">        x /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> reversed_x == original_x</span><br></pre></td></tr></table></figure><p>仔细一看，这简直就是 C++ 代码，完全没有 Python 的优雅与简单。那么，该怎样写才能够显的 Pythonic 呢？其实，用 Python 的话只要一行就可以啦（这里不考虑效率，如果考虑效率的话，C++会更加合适，单对这题来说，其实有比上面<a href="https://leetcode.com/discuss/33500/an-easy-lines-code-only-reversing-till-half-and-then-compare">更高效的方法</a>）！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">str</span>(x) == <span class="built_in">str</span>(x)[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>那么如何养成用 Pythonic 的思维解决问题呢？我觉得首先要对 Python 十分熟悉，精通大部分函数以及 Python 的特色：比如装饰器，迭代器，生成器以等，下面举几个简单的例子：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 函数式编程</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">nums = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="string">&quot;123456789&quot;</span> )</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">nums</span></span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span></span><br><span class="line">15</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">sum</span>(nums)</span></span><br><span class="line">45</span><br><span class="line"># 生成器</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span></span><br><span class="line"><span class="meta prompt_">...</span> <span class="language-python">    <span class="built_in">print</span> i</span></span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span></span><br><span class="line"><span class="meta prompt_">...</span> <span class="language-python">    <span class="built_in">print</span> i</span></span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line"># lambda 匿名函数</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">c = <span class="keyword">lambda</span> *z: z</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">c( <span class="number">10</span>, <span class="string">&#x27;test&#x27;</span>)</span></span><br><span class="line">(10, &#x27;test&#x27;)</span><br><span class="line"># 迭代</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">l = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">l_iter = <span class="built_in">iter</span>(l)</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">next</span>(l_iter)</span></span><br><span class="line">0</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">next</span>(l_iter)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">next</span>(l_iter)</span></span><br><span class="line">4</span><br><span class="line"># 数据结构 set</span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">set_a = <span class="built_in">set</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>)])</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">set_b = <span class="built_in">set</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>,<span class="number">2</span>)])</span></span><br><span class="line"><span class="meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="built_in">print</span> set_a | set_b</span></span><br><span class="line">set([0, 1, 2, 3, 4, 5, 6, 7, 8])</span><br></pre></td></tr></table></figure><p>其次，要多读一些 Pythonic 的代码，学习别人如何优雅地使用python。这里我推荐去看 Leetcode 的 Discuss，里面有许多惊才艳艳的代码。特别推荐 <a href="https://leetcode.com/discuss/user/StefanPochmann">@StefanPochmann</a>，许多代码让我获益匪浅，比如这里对 <a href="https://leetcode.com/discuss/66147/recursive-preorder-python-and-c-o-n">iter()</a> 的使用。</p><p>再来看一个问题，按照二进制位<a href="https://leetcode.com/problems/reverse-bits/">反转 32 位的一个整形无符号数字</a>。用 Python 可以写出很简单直观的代码，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseBits</span>(<span class="params">n</span>):</span><br><span class="line">    bit_str = <span class="string">&#x27;&#123;0:032b&#125;&#x27;</span>.<span class="built_in">format</span>(n)</span><br><span class="line">    reverse_str = bit_str[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(reverse_str, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>当然，上面不考虑效率，<a href="https://leetcode.com/discuss/27405/o-1-bit-operation-c-solution-8ms">这里</a>有一个利用分治法思想的高效的方法。</p><p>Python 是一门高效、简单、方便的语言，但这并不意味你不花时间就可以用的很好。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="https://wiki.python.org/moin/HowTo/Sorting">Sorting Mini-HOW TO</a><br><a href="https://segmentfault.com/q/1010000000405289">sort()中cmp参数的用法</a><br><a href="https://www.hackerrank.com/challenges/ginorts/forum">hackerrank: ginortS</a><br><a href="http://stackoverflow.com/questions/613183/sort-a-python-dictionary-by-value">Sort a Python dictionary by value</a><br><a href="http://python.jobbole.com/61171/">Python高级编程技巧</a><br><a href="http://wuzhiwei.net/be_pythonic/">让你的Python代码更加pythonic</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;用 Python 时间也算不短了，但总感觉自己在用写 C++ 代码的思维写 Python，没有真正用到其作为脚本语言的优势。之前刷 LeetCode 时，自己的 Python 代码总是很长，很像披着 Python 外衣的 C++ 代码（放在&lt;a href=&quot;https://github.com/xuelangZF/LeetCode&quot;&gt;这里&lt;/a&gt;，不断重构中）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160504_pythonic_cpp.png&quot; alt=&quot;Python不是C++&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="思考" scheme="https://selfboot.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>让我们一起愉快地逃课吧</title>
    <link href="https://selfboot.cn/2015/11/25/skip_classes/"/>
    <id>https://selfboot.cn/2015/11/25/skip_classes/</id>
    <published>2015-11-25T14:03:24.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>逃课，在大多数人眼中都是“坏学生”的专利，一说起逃课，就会联想起逃课打游戏，逃课出去玩，逃课把妹等。然而，还可以为了学习而逃课，这里我们要说的就是逃课去学习的故事。</p><h1 id="为什么我要逃掉算法课？"><a href="#为什么我要逃掉算法课？" class="headerlink" title="为什么我要逃掉算法课？"></a>为什么我要逃掉算法课？</h1><p>写这篇文章的时候我本来应该在教室上《算法分析与设计》这门课，算法对于学计算机的同学来说，重要性不言而喻。我们应该花费大量的时间去熟悉各种算法，同时了解<a href="http://selfboot.cn/2015/11/03/howto_find_algorithm/">算法背后的思想</a>。那么我为什么会逃掉这么重要的一门课呢？</p><span id="more"></span><p>忘了在哪里看过一句话，大致意思是看一个人读过的书就知道这个人的品味。同样，我觉得看一个老师推荐的教材就知道这个老师的水平了。下面来看看老师推荐的算法教材吧，排名有先后（完全复制课件内容，排版未做更改）：</p><ol><li>郑宗汉等，算法设计与分析，清华大学出版社</li><li>王晓东等，计算机算法设计与分析，电子工业出版社</li><li>Thomas H.Cormen;Charles E.Leiserson;Ronald L.Rivest;Clifford Stein. Introduction to Algorithms, 2th Ed. The MIT Press, 2001, ISBN 978-0-262-33293-3. 影印版: 《算法导论》(第二版),北京:高等教育出版社, 2007,ISBN 978-7-040-11050-0. 中译版:潘金贵等译, 《算法导论》(第2版),北京:机械工业出版社, 2006,ISBN 7-111-18777-6</li><li>郭嵩山、李志业、金涛、梁锋.《国际大学生程序设计竞赛例题解(一)数论、计算几何、搜索算法专集》. 电子工业出版社, 2006.5</li></ol><p>推荐的书中只知道《算法导论》这本，不过早在2012年已经出了<a href="https://book.douban.com/subject/20432061/">第三版</a>了，这里还是第二版，其中原因想必大家也猜的到。其他三本，真的没有听说过，也没有兴趣去看，国内写的计算机教材，可以看的寥寥可数，这几本当然不在其中。</p><p>本来我也不用看这几本书的，直到碰见这么一道小组作业题（作业还是要做的，不然挂科了怎么办）：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151125_one_problem.png" alt="动态规划"></p><p>我左看右看，上看下看，也不明白这道题什么意思（看了其他小组的作业题目，发现基本也没有能看懂的）。于是，Google之，果真被我找到了原题，原来就是郑宗汉《算法设计与分析》里面的课后题，再一看，原来我们的全部作业题都是这本书的课后题。这里的资源最优分配问题，在书中给过解释，终于可以写作业了。</p><p>其实只看推荐的书就确定这门课不值得上，当然是不科学的，不去听听你永远不知道这门课到底怎么样。第一节课，我当然没有错过，并且坐到前排，洗耳恭听（前排人挺多，基本很少人坐后面）。然后，不好意思，我已经忘了那节课讲的啥了。后面还连续去了几次，发现根本听不下去，为了讲一个算法思想，比如递归，老师给出一个又一个的例子，然后“深入浅出”用递归搞定问题。整节课感觉就是在听例子，听解法，让我想起了高中时代的题海战术与填鸭式教育。</p><p>其实，除了第一节课大家都在前面，后面几次课，几乎所有人都坐在后排，前排已经空了。然后去上课的人要不自己看书，要不睡觉，很少有人听老师讲了。</p><h1 id="该逃掉哪些课"><a href="#该逃掉哪些课" class="headerlink" title="该逃掉哪些课"></a>该逃掉哪些课</h1><p>前面就是我逃掉算法课的主要理由了，其实我现在逃掉了大部分课，那么我如何决定某一门课是不是可以逃掉呢？其实自己也没有刻意去找理由，很多时候就是一种感觉。不过我猜测潜意识里可能会经过下面一番思考。</p><p>1、我是真的想去认真上这门课吗？有时候，我们选择一门课只是为了拿学分而已，这种课完全没有必要在课堂上花费时间，应该毫不犹豫地逃掉。</p><p>2、这门课需要花费时间去学习，但是老师讲的太没水平了，还不如自己看书。上面的算法课就是这种情况了，对我来说大多数的逃课都是因为老师讲的没水平（你必须面对这个残酷的现实）。</p><p>其实想讲好一门课还是很难的，特别是理工科专业性比较强的课。需要老师自己有深厚的专业素养，同时还要有很好的授课技巧，确保能够清晰明了、又不枯燥无味地传达知识，能做到这一点的老师真的是屈指可数。</p><p>或许正是因为讲好一门课是如此之难，所以部分老师干脆就不负责任地糊弄大家。于是，我遇到过、听说过下面这些奇葩事：</p><ol><li>老师完全“照本宣科”，但是读着读着发现自己都读不懂了</li><li>课件是 N 多年前的，内容十分陈旧</li><li>课上一直在吹水，讲自己的一些经历或者其它和课程完全无关的事</li><li>给我们把一个介绍技术概念的视频连续播放了三遍</li><li>考试试题是前一年的，年份、年级都没改</li><li>给我们演示一个简单的实验时，不知道怎么安装一个常用工具</li><li>教C++时，一个 Hello World 编译不通过，调试了半天才找到问题所在</li></ol><p>上面的比较极端也不常见。然而大多数课堂也好不到哪里去，常常是台上“高谈阔论”，台下漠不关心，台上问题一出，台下寂寥无声。总之，如果你在上一门课时，总是精神奕奕地走进教室，然后听着听着就萎了，那么可以考虑逃掉这门课了。</p><h1 id="如何说服自己逃课"><a href="#如何说服自己逃课" class="headerlink" title="如何说服自己逃课"></a>如何说服自己逃课</h1><p>其实好多同学都知道在教室里听课并不能学到什么，但是还有许多“好学生”作为老师的“忠实”听众，老老实实坐在台下（听课？）。</p><p>刚上大学时，我也是从不逃课，并且有点鄙视那些逃课的人。那时候天真地认为<strong>学生怎么可以逃课呢？课堂是那么神圣庄严的地方，是我们学习科学文化知识的天堂啊</strong>（好幼稚的想法啊），在这种想法的激励下，不论什么课我都逼自己认真听讲，好好消化。</p><p>然而渐渐发现，有的老师照本宣科（最典型的是当时的数学分析这门课了），有的老师讲的不明不白，有的课特别没意思。逼了自己一个学期后，实在太累，上课再也不能坚持认真听讲了，于是上课基本就是听着听着就困了，睡了。或者是，干脆不听老师讲，自己拿本书在看。</p><p>那时，虽然在获取知识上，去上课已经失去了意义。但是从小到大养成的不逃课“好习惯”以及“要想学习好就得认真听讲”的观念仍旧像一个无形牢笼，把我束缚在无聊的课堂上。</p><p>后来遇到了中特、毛概这两门全国统一、全球唯一的课程，本来就十分讨厌这些在初、高中必须背诵的东西，加上老师讲的又太不精彩，一怒之下就不去上课。然后发现逃课也不是多么坏的事情，于是渐渐地逃掉越来越多无关紧要的课。现在看来，应该感谢这两门课，让我认识到不是所有的课都需要去学，那些无关紧要的课甚至逃掉了也没有关系。</p><p>但是，那些重要的专业课，即使老师讲的很差，自己也不敢逃掉。生怕逃掉这些课，就失去了学好这门课的机会（虽然知道课堂上学不到什么，但是当时还是这样想）。后来，发现系里面好多大牛都不怎么去上课，但他们的专业素质不是一般的强。一个偶然的机会，听一个大牛说，老师讲的那么差，干嘛要去上课，自己想学好一个东西，就去找书找资料学啊。这道理自己也懂，但是听大牛说出来完全是不一样的感觉，并最终促使我把这种想法转变为实践，并开始了逃课之旅。如果你还害怕逃掉重要的课，那么请默念<strong>不去上课也能成为大牛，成不成为大牛和上不上课没有关系</strong>！</p><p>挣脱了“必须去上课才能成为大牛”这个枷锁，其实你可以学的更多更快。此外，逃课不仅可以让学生学得更好，也有可能刺激老师好好讲课呢。毕竟，台下没人听课对老师来说也是一种打击吧。（希望不是我在 YY）</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151125_free_learning.png" alt="挣脱束缚"></p><h1 id="逃课是为了更好地学习"><a href="#逃课是为了更好地学习" class="headerlink" title="逃课是为了更好地学习"></a>逃课是为了更好地学习</h1><p>现在，我们不需要按时上课，坐在教室一味听老师啦。我们可以找本经典的书，坐在一个安静的地方，按照自己的节奏去理解书中的内容。其实这样的学习效率，比在教室听老师讲好太多了。算法这门课，我买了 Robert Sedgewick，Kevin Wayne 写的 <a href="https://book.douban.com/subject/19952400/">算法（第4版）</a>，感觉写的还不错。另外，也顺便刷一刷 LeetCode 上面的算法题，收获也是颇丰的。</p><p>除了看书外，还可以选修一些经典的<a href="http://mooc.guokr.com/course/">开放式网络课程</a>，然后认真听讲，做作业，考试，拿证书。同样是课程，为什么要逃掉传统的课堂教室，去参加虚拟的网络课程呢？因为网络课程有着许多无可比拟的优点：</p><ol><li>老师水平普遍较高，讲授内容质量高。这里的老师好多来自世界名校，内容准备的也特别用心；这点是最重要的。</li><li>完善的在线作业系统，作业得到很好的反馈。传统课堂中作业更多是用来给定平时成绩，交上作业就完事了，没有一个反馈，你甚至不知道老师有没有去看你的作业；</li><li>活跃的课程论坛。每一个课程都有一个供学生讨论的板块，在这里可以和全世界各地的学生交流学习心得，讨论作业题目；</li><li>弹性的学习时间，学习地点。没有说你必须在什么时候上课，你只要在 Deadline 前听完课，写完作业就可以了。</li><li>顺着大脑学习的规律教学，每次讲一小段时间就会穿插一些测试之类的，不会让你感到消化不了。想想传统课堂，一下子两节课，大脑早疲劳了。</li></ol><p>还不知道MOOC（大规模在线开放课程）？看看下面这些文章吧：</p><ul><li><a href="http://mooc.guokr.com/post/610535/">大学已死，大学永存</a></li><li><a href="http://mooc.guokr.com/post/610592/">中国MOOC先行者：在家里上常春藤</a></li><li><a href="http://mooc.guokr.com/post/384608/">Coursera，Udacity，edX：MOOC的三座大山</a></li><li><a href="http://mooc.guokr.com/post/610557/">塞巴斯蒂安.特隆，重塑在线大学课程</a></li></ul><p>哦，对了，亲测上面的“三座大山”都没有挂掉，所以你访问不了的话，一定是你的问题。</p><p>最后问一个问题，今天你逃课去学习了吗？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;逃课，在大多数人眼中都是“坏学生”的专利，一说起逃课，就会联想起逃课打游戏，逃课出去玩，逃课把妹等。然而，还可以为了学习而逃课，这里我们要说的就是逃课去学习的故事。&lt;/p&gt;
&lt;h1 id=&quot;为什么我要逃掉算法课？&quot;&gt;&lt;a href=&quot;#为什么我要逃掉算法课？&quot; class=&quot;headerlink&quot; title=&quot;为什么我要逃掉算法课？&quot;&gt;&lt;/a&gt;为什么我要逃掉算法课？&lt;/h1&gt;&lt;p&gt;写这篇文章的时候我本来应该在教室上《算法分析与设计》这门课，算法对于学计算机的同学来说，重要性不言而喻。我们应该花费大量的时间去熟悉各种算法，同时了解&lt;a href=&quot;http://selfboot.cn/2015/11/03/howto_find_algorithm/&quot;&gt;算法背后的思想&lt;/a&gt;。那么我为什么会逃掉这么重要的一门课呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="思考" scheme="https://selfboot.cn/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>从理论到实践，全方位认识DNS（实践篇）</title>
    <link href="https://selfboot.cn/2015/11/14/dns_practice/"/>
    <id>https://selfboot.cn/2015/11/14/dns_practice/</id>
    <published>2015-11-14T00:00:00.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://selfboot.cn/2015/11/05/dns_theory/">理论篇</a>我们基本了解了DNS的整个协议原理，但是可能还会有着下面的疑问：</p><ol><li>为什么我想申请的域名都没了？</li><li>DNS 域名还要备案，这是为什么啊？</li><li>如何将刚申请的域名绑定到自己的网站呢？</li><li>怎么才能看到那些在背后默默给我解析的域名服务器呢？</li><li>他们说用一个什么文件就可以访问好多好多<code>不存在的</code>网站，是真的吗？</li><li>可信任的域名服务器是怎么一回事，难道有些域名服务器会做坏事？</li><li>怎么知道我现在用的域名服务器有没有使坏呢？</li><li>……</li></ol><span id="more"></span><p>我不准备一个一个地去回答这些问题，不过相信我，读完本文，对于上面问题的答案你会有一个清晰的认识，并且可以解决其他各种各样关于 DNS 方面的问题。</p><h1 id="域名注册、绑定"><a href="#域名注册、绑定" class="headerlink" title="域名注册、绑定"></a>域名注册、绑定</h1><p>首先明确一点，每个人都可以去注册域名。大多数时候我们希望去注册一个顶级域名（比如selfboot.cn, google.com等），那些二级域名毕竟不够好记（比如github托管博客的域名：username.github.io）。有的顶级域名（比如<a href="http://www.dot.tk/zh/index.html?lang=zh">.tk</a>域名）提供免费的一年域名试用，不过绝大多时候还是要为自己的域名付费的（一般是按年付费，也不是很贵）。要想去注册域名，首先得找到域名注册商，国内的比较著名的有<a href="https://domains.dnspod.cn/">DNSpod</a>等，国外的有<a href="https://www.godaddy.com/">godaddy</a>等。相信注册过域名的人都知道绝大多数我们能想到的自己喜欢的域名都已名花有主了，只剩那些不是那么惹人关注的域名供我们选择。所以，注册域名时，发现自己每想到一个域名都显示被人注册后，那太正常不过了，说明你的品味比较正常。</p><p>这里一点个人建议，选中一个域名后不要轻易去改了，因为换域名成本挺高的（我猜现在就算给淘宝一千万，它也不会换另成一个域名吧）。所以，最好不要去用免费的域名，因为指不定啥时候就不让你用了。你应该相信这么一个观点：<strong>天下没有免费的午餐</strong>。拓展一下就是，掏钱买服务，心里踏实。</p><p>接下来你可能会希望将自己的站点或者博客挂在自己选中的域名下，这其实很简单，只需要找到一个提供域名解析的服务商，然后填写相应的域名解析记录。大多时候，你注册域名的服务商都会免费提供域名解析服务。</p><p>现实中，大部分人可能会拥有个人博客，以前我们都是依赖一个博客平台（如CSDN），或者是买一台VPS托管自己的博客。不过自从Github推出了Blog服务，好多程序员都转而将博客托管在上面。Github Blog支持绑定个人域名，并提供了详细的绑定文档：<a href="https://help.github.com/articles/adding-a-cname-file-to-your-repository/">Adding a CNAME file to your repository</a>。假设你的博客已经可以通过 username.github.io 访问，接下来只需要用 CNAME 告诉Github你的博客绑定了哪个域名（比如说是selfboot.cn），然后在域名解析商那里添加解析记录即可，下图是我个人博客在DNSpod的解析记录：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151114_github_record.png" alt="域名解析记录"></p><p>现在当我们访问 selfboot.cn 时，DNSpod就会将请求解析到 Github 提供的 IP 地址上。之后 Github 上面的博客托管服务器在所有用户的 CNAME 记录中，找到本次请求的域名对应的博客项目地址，比如说是 xuelangZF.github.io，然后返回博客内容。</p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>我们都知道一个域名的解析过程中，可能会有多台域名服务器给我们帮助，那么我们怎么能看到这些背后的功臣呢？先介绍两个常用的关于DNS的命令。</p><h2 id="dig-nslookup"><a href="#dig-nslookup" class="headerlink" title="dig, nslookup"></a>dig, nslookup</h2><p><code>dig</code>(Domain Information Groper), 是 UNIX&#x2F;BSD 系统自带的 DNS 诊断工具，使用十分灵活、方便。</p><p>查询 selfboot.cn 的A记录，并返回简短的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dig selfboot.cn -t A +short</span><br><span class="line">192.30.252.153</span><br><span class="line">192.30.252.154</span><br></pre></td></tr></table></figure><p>用 dig 还可以查询某一 ip 对应的域名，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dig -x 192.30.252.153 +short</span><br><span class="line">pages.github.com.</span><br></pre></td></tr></table></figure><p>这里返回的是pages.github.com，因为当你访问博客地址 selfboot.cn 时，其实是Github的pages 服务器（域名是：pages.github.com）在后台返回该博客内容的（根据 CNAME 确定返回哪个博客）。</p><p>nslookup 也是一个 DNS 诊断工具，几乎所有平台都自带该工具，使用也很简答，可以用 man 查询手册。</p><h2 id="解析路径查询"><a href="#解析路径查询" class="headerlink" title="解析路径查询"></a>解析路径查询</h2><p>接下来用 dig 命令查看从根域名到指定域名中间可能经过的所有域名服务器，使用 <code>+trace</code> 选项即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dig selfboot.cn +trace @8.8.8.8</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; selfboot.cn +trace @8.8.8.8</span><br><span class="line">;; global options: +cmd</span><br><span class="line">.474418INNSj.root-servers.net.</span><br><span class="line">.474418INNSg.root-servers.net.</span><br><span class="line">......</span><br><span class="line">.474418INNSl.root-servers.net.</span><br><span class="line">.474418INNSm.root-servers.net.</span><br><span class="line">;; Received 496 bytes from 8.8.8.8<span class="comment">#53(8.8.8.8) in 12 ms</span></span><br><span class="line"></span><br><span class="line">cn.172800INNSa.dns.cn.</span><br><span class="line">......</span><br><span class="line">cn.172800INNSe.dns.cn.</span><br><span class="line">cn.172800INNSns.cernet.net.</span><br><span class="line">;; Received 292 bytes from 2001:500:1::803f:235<span class="comment">#53(2001:500:1::803f:235) in 382 ms</span></span><br><span class="line"></span><br><span class="line">selfboot.cn.86400INNSf1g1ns2.dnspod.net.</span><br><span class="line">selfboot.cn.86400INNSf1g1ns1.dnspod.net.</span><br><span class="line">;; Received 83 bytes from 203.119.25.1<span class="comment">#53(203.119.25.1) in 816 ms</span></span><br><span class="line"></span><br><span class="line">selfboot.cn.14400INA192.30.252.153</span><br><span class="line">selfboot.cn.14400INA192.30.252.154</span><br><span class="line">selfboot.cn.600INNSf1g1ns1.dnspod.net.</span><br><span class="line">selfboot.cn.600INNSf1g1ns2.dnspod.net.</span><br><span class="line">;; Received 125 bytes from 115.236.137.40<span class="comment">#53(115.236.137.40) in 31 ms</span></span><br></pre></td></tr></table></figure><p>可以看到最开始是13台顶级域名服务器的NS记录（中间省去一些记录减少行数，方便观察更清楚），接下来是顶级域名 cn. 的权威域名服务器（省略一些输出），然后是 selfboot.cn 的 NS 记录，即 DNSpod 的两条 NS 记录，最后从 f1g1ns2.dnspod.net 找到 selfboot.cn 的 A 记录。</p><p><a href="https://github.com/seveas">seveas</a> 提供了一个可视化的路径查询工具：<a href="http://ip.seveas.net/dnsgraph/">dnsgraph</a>，可以在线绘制跟域名到指定域名的所有可能路径。</p><p>当然，实际查询过程中，大多时候我们在本地缓存或者本地域名服务器缓存就能直接找到需要的域名记录，不需要每次都向根域名服务器发起请求，然后重复迭代或者递归查询过程。</p><h1 id="DNS-缺陷"><a href="#DNS-缺陷" class="headerlink" title="DNS 缺陷"></a>DNS 缺陷</h1><p>域名系统设计的很理想很美好，然而仍有一些小的瑕疵，可能会给我们带来些许困扰。</p><h2 id="域名抢注"><a href="#域名抢注" class="headerlink" title="域名抢注"></a>域名抢注</h2><p>首先，有些域名对注册人没有限制，而另外一些域名则对谁可以得到一个域名空间中的名字有限制。比如pro域名是分配给合适的专业人员，但问题是谁才是专业的呢？显然医生、工程师是专业人员，但理发师、管道工呢？</p><p>此外，域名也可以被倒卖。黄牛们会批量注册大量域名（据说com域名下几乎每一个普通词都被人尝试注册了域名），然后转身就以高价转卖给那些对该域名感兴趣的人，这就是所谓的域名抢注。所以，现在你想注册一个符合自己网站特点的域名是很难的。</p><p>这个问题其实还不算严重，更要命的是下面两个问题。</p><h2 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h2><p>我们知道一个域名服务器对其区域内的用户解析请求负责，但是并没有一个机制去监督它有没有真地负责。也就是说域名服务器的权力并没有被关在笼子里，所以它既可以认真地“为人民服务”，也可以<strong>指鹿为马</strong>。于是有些流氓的域名服务器故意更改一些域名的解析结果，将用户引向一个错误的目标地址。这就叫作 DNS 劫持，主要用来阻止用户访问某些特定的网站，或者是将用户引导到广告页面。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151114_dns_hijacking.png" alt="DNS 劫持"></p><p>下面验证下我所用的域名服务器有没有干这种坏事，只需要一条简单的命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~  nslookup google.com</span><br><span class="line">Server:10.8.4.4</span><br><span class="line">Address:10.8.4.4<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:google.com</span><br><span class="line">Address: 120.196.0.5</span><br></pre></td></tr></table></figure><p>我的DNS服务器地址为10.8.4.4，他告诉我google.com的地址是120.196.0.5，我才不信呢。于是用<code>whois 120.196.0.5</code>一看，果真不是Google的地址。针对DNS劫持，我们可以简单地更换域名服务器，比较靠谱的一个是Google提供的8.8.8.8。下面用 8.8.8.8 来解析一下 <a href="http://www.google.com/">www.google.com</a> 就能看到正确的地址了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup www.google.com 8.8.8.8</span><br><span class="line">Server:8.8.8.8</span><br><span class="line">Address:8.8.8.8<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:www.google.com</span><br><span class="line">Address: 216.58.221.68</span><br></pre></td></tr></table></figure><h2 id="DNS-欺骗"><a href="#DNS-欺骗" class="headerlink" title="DNS 欺骗"></a>DNS 欺骗</h2><p>DNS 劫持通过简单的切换域名服务器就可以绕过，不过一旦你遇上了 <code>DNS 欺骗</code>，就无法简单地绕过了。下面我们用不同的域名服务器来查看 fb 的 IP 地址，结果都返回了同一个地址，看起来好像是真的一样，不过也仅仅是看起来而已。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup facebook.com</span><br><span class="line">Server:10.8.4.4</span><br><span class="line">Address:10.8.4.4<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:facebook.com</span><br><span class="line">Address: 159.106.121.75</span><br><span class="line"></span><br><span class="line">$ nslookup facebook.com 8.8.8.8</span><br><span class="line">Server:8.8.8.8</span><br><span class="line">Address:8.8.8.8<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:facebook.com</span><br><span class="line">Address: 159.106.121.75</span><br></pre></td></tr></table></figure><p>这个地址并不是 fb 的服务器地址（可以在 <a href="http://viewdns.info/dnsrecord/">ViewDNS</a> 查询所有域名<strong>真实的</strong>域名资源记录，ViewDNS是个很好玩的网站，里面有许多有意思的工具）。其实我Google了一下这个地址，竟然发现了一篇不错的<a href="http://ichuan.net/post/7/dns-cache-poisoning-in-china/">译文</a>，看来这个地址早在 2011 年就有了特殊的含义（英文原文是相关阅读第一个）。</p><p>DNS 欺骗简单来说就是用一个假的 DNS 应答来欺骗用户计算机，让其相信这个假的地址，并且抛弃真正的 DNS 应答。在一台主机发出 DNS 请求后，它就开始等待应答，如果此时有一个看起来正确（拥有和DNS请求一样的序列号）的应答包，它就会信以为真，并且丢弃稍晚一点到达的应答。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151114_dns_spoofing.png" alt="DNS欺骗原理"></p><p>实施 DNS 欺骗的关键在于伪造一个有特定序列号的应答包，并且让其抢先一步到达发起请求的主机。这对于个人来说还有点难度，但是对于拥有骨干网节点的组织来说，实在是易如反掌，所以这么多网站都已沦陷。不过使用网上流传的那些 hosts文件，就可以在本机缓存许多网站的ip地址，进而可以和部分网站通信。但是通过hosts文件并不能完全 Cross the Great FireWall，因为人家还有很多其他手段。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://viewdns.info/research/dns-cache-poisoning-in-the-peoples-republic-of-china/">DNS cache poisoning</a><br><a href="http://security.stackexchange.com/questions/33257/dns-spoofing-vs-dns-cache-poisoning">DNS Spoofing vs DNS Cache Poisoning</a><br><a href="https://support.apple.com/en-us/HT202516">Reset the DNS cache in OS X</a><br><a href="http://www.williamlong.info/archives/2195.html">人为网络故障</a><br><a href="http://blog.csdn.net/zhaqiwen/article/details/10108667">DNS欺骗原理及工作工程分析</a><br><a href="http://www.wildlee.org/2010_08_965.html">DNS污染与劫持之个人小见</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;http://selfboot.cn/2015/11/05/dns_theory/&quot;&gt;理论篇&lt;/a&gt;我们基本了解了DNS的整个协议原理，但是可能还会有着下面的疑问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么我想申请的域名都没了？&lt;/li&gt;
&lt;li&gt;DNS 域名还要备案，这是为什么啊？&lt;/li&gt;
&lt;li&gt;如何将刚申请的域名绑定到自己的网站呢？&lt;/li&gt;
&lt;li&gt;怎么才能看到那些在背后默默给我解析的域名服务器呢？&lt;/li&gt;
&lt;li&gt;他们说用一个什么文件就可以访问好多好多&lt;code&gt;不存在的&lt;/code&gt;网站，是真的吗？&lt;/li&gt;
&lt;li&gt;可信任的域名服务器是怎么一回事，难道有些域名服务器会做坏事？&lt;/li&gt;
&lt;li&gt;怎么知道我现在用的域名服务器有没有使坏呢？&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://selfboot.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="DNS" scheme="https://selfboot.cn/tags/DNS/"/>
    
    <category term="Protocol" scheme="https://selfboot.cn/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>从理论到实践，全方位认识DNS（理论篇）</title>
    <link href="https://selfboot.cn/2015/11/05/dns_theory/"/>
    <id>https://selfboot.cn/2015/11/05/dns_theory/</id>
    <published>2015-11-05T00:00:00.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>对于 <a href="https://en.wikipedia.org/wiki/Domain_Name_System">DNS(Domain Name System)</a> 大家肯定不陌生，不就是用来将一个网站的域名转换为对应的IP吗。当我们发现可以上QQ但不能浏览网页时，我们会想到可能是域名服务器挂掉了；当我们用别人提供的hosts文件浏览到一个“<code>不存在</code>”的网页时，我们会了解到域名解析系统的脆弱。</p><p>然而关于DNS还有一大堆故事值得我们去倾听，去思考。</p><span id="more"></span><h1 id="DNS-源起"><a href="#DNS-源起" class="headerlink" title="DNS 源起"></a>DNS 源起</h1><p>要想访问网络上的一台计算机，我们必须要知道它的IP地址，但是这些地址（比如243.185.187.39）只是一串数字，没有规律，因此我们很难记住。并且如果一台计算机变更IP后，它必须通知所有的人。</p><p>显然，直接使用IP地址是一个愚蠢的方案。于是人们想出了一个替代的方法，即为每一台计算机起一个名字，然后建立计算机名字到地址的一个映射关系。我们访问计算机的名字，剩下的名字到地址的转换过程则由计算机自动完成。</p><h2 id="hosts映射"><a href="#hosts映射" class="headerlink" title="hosts映射"></a>hosts映射</h2><p>早期，名字到地址的转换过程十分简单。每台计算机保存一个<code>hosts</code>文件，里面列出所有计算机名字和对应的IP地址，然后定期从一个维护此文件的站点更新里面的记录。当我们访问某个计算机名字时，先在hosts文件找到对应的IP，然后就可以建立连接。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151105_hosts_local.png" alt="hosts 管理主机"></p><p>早期的<a href="https://en.wikipedia.org/wiki/ARPANET">ARPANET</a>就是这样做的，但是随着网络规模的扩大，这种方法渐渐吃不消了。主要有以下三个原因：</p><ol><li>hosts文件变得非常大；</li><li>主机名字会冲突；</li><li>集中的维护站点会不堪重负（需要给几百万机器提供hosts文件，想想就可怕）。</li></ol><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>为了解决上面的问题，1983年<a href="https://en.wikipedia.org/wiki/Paul_Mockapetris">Paul Mockapetris</a>提出了域名系统（DNS, Domain Name System)，这是一种<strong>层次的、基于域</strong>的命名方案，并且用一个分布式数据库系统加以实现。当我们需要访问一个域名（其实就是前面说的计算机的名字）时，应用程序会向DNS服务器发起一个DNS请求，DNS服务器返回该域名对应的IP地址。通过下面三种手段解决了上面的问题：</p><ol><li>用户计算机上并没有存储所有的名字到IP的映射，这样避免了hosts文件过于庞大（现在各操作系统中hosts文件默认都是空的）。</li><li>规定了域名的命名规则，保证主机名字不会重复。</li><li>DNS服务器不再是单一的一台机器，而是一个层次的、合理组织的服务器集群。</li></ol><p>这样访问一个域名的过程可以简化为下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151105_dns_concept.png" alt="域名hosts解析过程"></p><h1 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h1><p>那么如何具体实现这个所谓的域名系统呢，要知道管理一个超大型并且不断变化的域名到IP的映射集合可不是一个简单的事，况且还要去应付成千上万的DNS查询请求。人们最终想出了一套不错的协议，规定如何来实现这个系统，下面我们一起来看看吧。</p><h2 id="域名空间"><a href="#域名空间" class="headerlink" title="域名空间"></a>域名空间</h2><p>首先我们需要制定一套命名规则，防止域名出现重复。DNS关于域名的规则和我们生活中的快递系统类似，使用层次的地址结构。快递系统中要给某人邮寄物品，地址可能是这样：中国、广东省、广州市、番禺区、中山西路12号 XXX。而一个域名看起来则是这样的groups.google.com（为什么不是com.google.groups？我猜可能和老外写地址的习惯有关）。</p><p>对于Internet来说，域名层次结构的顶级（相当于国际快递地址中的国家部分）由<a href="https://www.icann.org/">ICANN</a>（互联网名称与数字地址分配机构）负责管理。目前，已经有超过250个顶级域名，每个顶级域名可以进一步划为一些子域（二级域名），这些子域可被再次划分（三级域名），依此类推。所有这些域名可以组织成一棵树，如下图所示（图片来自Computer Networks: 7-1 ）：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151105_domain_tree.png" alt="域名空间树"></p><h2 id="域名资源记录"><a href="#域名资源记录" class="headerlink" title="域名资源记录"></a>域名资源记录</h2><p>DNS设计之初是用来建立域名到IP地址的映射，理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可。这里的记录一般叫作域名资源记录，它是一个五元组，可以用以下格式表示：</p><p><code>Domain_name Time_to_live Class Type Value</code></p><p>其中：</p><ol><li>Domain_name: 指出这条记录适用于哪个域名；</li><li><code>Time_to_live</code>: 用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间（后面会讲到缓存机制）；</li><li>Class: 一般总是IN；</li><li>Type: 记录的类型；</li><li>Value: 记录的值，如果是A记录，则value是一个IPv4地址。</li></ol><p>我们看到域名资源记录有一个Type字段，用来表明记录的类型。这是为什么呢？因为对于一个域名来说，通常并非只记录其IP地址，还可能需要一些其他种类的记录，一些常见的记录类型如下：</p><p>| 记录类型| 含义          |<br>|—   |—    |<br>|A    | 主机的IPv4地址 |<br>|AAAA | 主机的IPv6地址 |<br>|NS   | 该域名所在域的权威域名服务器|<br>|MX      | 接受特定域名电子邮件的服务器域名 |<br>|CNAME   | 当前域名的一个别名|</p><p>关于这些域名资源记录的实例我们将在下一篇文章（实践篇）看到。</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>我们知道不能只用一台域名服务器来响应所有的DNS查询，因为没有一台机器能够给全球的用户提供查询服务，计算能力、存储、带宽都不允许。只能合理组织一个域名服务器集群，使他们协同工作，共同提供域名解析服务。接下来首先要面对的一个问题是<strong>如何合理地将所有的域名资源记录存储到不同的域名服务器上。</strong></p><p>前面说过域名的名字空间可以组织为一棵树，这里我们可以进一步将其划分为不重叠的区域（<a href="https://en.wikipedia.org/wiki/DNS_zone">DNS zone</a>），针对上图的域名空间，一种可能的域名划分如下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151105_domain_zone.png" alt="域名划分"></p><p>然后将每个区域与多个域名服务器（其中一个是master，其他slave服务器则用来提供数据备份、加快解析速度、保证服务可用性）关联起来，称这些域名服务器为该区域的<code>权威域名服务器(Authoritative Name Servers )</code>，它保存两类域名资源记录：</p><ol><li>该区域内所有域名的域名资源记录。</li><li>父区域和子区域的域名服务器对应的域名资源记录（主要是NS记录）。</li></ol><p>这样，所有的域名资源记录都保存在多个域名服务器中，并且所有的域名服务器也组成了一个层次的索引结构，便于我们后面进行域名解析。下面以一个简化的域名空间为例子，说明域名资源记录是如何保存在域名服务器中的，如下图a：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151105_name_servers.png" alt="域名服务器"></p><p>图中域名空间划分为A, B, C, D, E, F, G七个DNS区域，每个DNS区域都有多个权威域名服务器，这些域名服务器里面保存了许多域名解析记录。对于上图的NDS区域E来说，它的权威域名服务器里面保存的记录如图中表格所示。</p><p>仔细观察上图你可能会发现区域A、B并没有父区域，他们之间并没有一条路径连在一起。这将导致一个很麻烦的问题，那就是区域A的权威域名服务器可能根本不知道区域B的存在。认识到这一点后，你可能会想出一个很自然的解决方案，就是在A中记录B域名服务器的地址，同时在B中记录A的，这样它们两个就联系起来了。但是考虑到我们有超过250个顶级域名，这样做并不是很恰当。</p><p>而我们使用的域名系统则采用了一种更加聪明的方法，那就是引入<a href="https://en.wikipedia.org/wiki/Root_name_server">根域名服务器</a>，它保存了所有顶级区域的权威域名服务器记录。现在通过根域名服务器，我们可以找到所有的顶级区域的权威域名服务器，然后就可以往下一级一级找下去了。下图为全球根域名服务器的分布图，可以在<a href="http://www.root-servers.org/">这里</a>找到。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151105_root_servers.png" alt="顶级域名服务器"></p><p>现在为止，我们的权威域名服务器和根域名服务器其实组成了一个树，树根为根域名服务器，下面每个节点都是一个区域的权威域名服务器，对于图a中各个DNS区域的权威域名服务器，它们组成了下面这棵树（<em>实际中，一个权威域名服务器可能保存有多个DNS区域的记录，因此权威域名服务器之间的联系并不构成一棵树。这部分的详细内容可以参考RFC 1034: 4. NAME SERVERS。下面为了容易理解，将其简化为一棵树</em>）：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151105_servers_tree.png" alt="域名服务器树"></p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>我们已经有了一个域名服务器集群，该集群合理地保存了域名空间和域名资源记录的对应关系。现在我们要做的就是发送一个DNS请求给域名服务器，然后坐等它返回正确的域名资源记录，这个过程叫作域名解析。</p><p>严格来说，域名解析的过程最早要追溯到建立网络连接。因为每当连接上网络之后，计算机会自动获得一个默认的DNS服务器，当然你也可以用自己信任的DNS服务器，比如8.8.8.8（DNS服务器也有信任不信任之分，是的，实践篇会讲到），我们把这个域名服务器也叫作<code>本地域名服务器</code>。接下来当我们需要知道一个域名对应的资源记录时，会向本地域名服务器发起请求，如果该域名恰好在本地域名服务器所辖属的域名区域（DNS zone）内，那么可以直接返回记录。</p><p>如果在本地域名服务器没有发现该域名的资源记录，就需要在整个域名空间搜索该域名。而整个域名空间的资源记录存储在一个分层的、树状联系的一系列域名服务器上，所以本地域名服务器首先要从根域名服务器开始往下搜索。这里有一个问题就是<strong>本地域名服务器如何找到根域名服务器在哪里呢？</strong>其实域名服务器启动的时候，就会加载一个配置文件，里面保存了根域名服务器的NS记录（要知道根域名服务器地址一般非常稳定，不会轻易改变，并且数量很少，所以这个配置文件会很小）。找到根域名服务器之后，就可以一级一级地往下查找啦。</p><p>仍然以我们的图a为例，现在假设区域E内的某个用户想访问math.sysu.edu.cn，那么请求的过程如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151105_name_resolution.png" alt="域名解析过程"></p><p>用语言简单描述如下：</p><ol><li>用户：喂，本地域名服务器，告诉我math.sysu.edu.cn的地址；</li><li>本地域名服务器：哎呀，我不知道啊，不在我的辖区，容我去问问老大哥吧。root老大，能告诉我math.sysu.edu.cn的地址吗；</li><li>根域名服务器：忙着呢，你去问B（.cn）；</li><li>本地域名服务器：喂，B，告诉我math.sysu.edu.cn的地址；</li><li>B：你去问D（.edu.cn）；</li><li>本地域名服务器：喂，D，告诉我math.sysu.edu.cn的地址；</li><li>D：你去问F（sysu.edu.cn）；</li><li>本地域名服务器：喂，F，告诉我math.sysu.edu.cn的地址；</li><li>F：容老衲看看，哎呀，找到了，是X.X.X.X；</li><li>本地域名服务器：踏破铁鞋终于找到啦，喂用户，出来啊，我找到了，是X.X.X.X</li></ol><p>仔细想想，这和我们邮寄快递实在是如出一辙啊，假设你从美国邮东西到广州市番禺区，首先快递送到中国（不过这里没有一个类似根域名服务器的中转站而已），然后往下到广东省，接下来是广州市，再往下是番禺了。</p><p>上面的是本地域名服务器的迭代解析过程，其实也可以递归查询，这里就不说了，道理差不多。</p><h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>现在整个域名系统已经可以为我们提供域名解析服务了，当我们输入域名，计算机发送DNS请求，然后DNS服务器返回给我们解析的结果，一切看起来很完美。然而是不是可以更完美呢？</p><p>回顾一下平时浏览网站的情况，我们会发现两个比较有意思的结论：</p><ol><li>80%的时间我们都在看那些20%的网站，这就是大名鼎鼎的<a href="https://en.wikipedia.org/wiki/Pareto_principle">80&#x2F;20 Rule</a>；</li><li>我们会在一个网站的不同网页之间跳转，也就是不断地访问同一个域名，类似程序访问的局部性原理。</li></ol><p>这两条结论很容易让我们联想到<code>缓存机制</code>。如果我们将已经访问过的那些域名的解析结果缓存在自己的计算机上，那么下次访问的时候可以直接读取结果，不用再次重复DNS查询过程，给自己和域名服务器都节省了麻烦。</p><p>当然，这样做的一个前提是要缓存的解析结果不会频繁更改，也就是说我十分钟后解析一个域名的结果和现在解析的结果是一样的。对大多数域名来说，这都是一个不争的事实。但是难免有一些“善变”的域名，他们可能会频繁更改自己的解析结果。为了使缓存机制适应这两类情况，我们在域名资源记录里面添加一个<code>Time_to_live</code>字段，表明这条记录最多可以缓存多久。对于那些“稳如泰山”的域名，给一个比较大的值，而那些“朝三暮四”的域名，则可以给定一个小的值。</p><p>我们既然可以在本机利用缓存，那么可不可以在域名服务器上也利用缓存机制呢，答案当然是可以的。因为对于域名服务器来说，上面的两条有意思的结论仍然有效。所以，域名服务器可以将那些访问过的域名资源记录缓存，用户再次发起请求时，可以直接返回缓存结果，不用去迭代或者递归解析。</p><p>关于DNS理论部分，更多内容还可以参考这两个文本：</p><ul><li><a href="https://tools.ietf.org/html/rfc1034">RFC 1034: Domain Names - Concepts and Facilities</a></li></ul><h1 id="并没有结束"><a href="#并没有结束" class="headerlink" title="并没有结束"></a>并没有结束</h1><p>上面一大堆理论，看上去有点不明所以是吧，没事，接下来会结合实践来更加清晰地认识DNS这一最基础的系统。</p><p>其实不止是DNS，还有HTTPS、TCP、UDP这些很基础的协议，都值得我们静下心去好好认识它们。因为，写DNS之前，我以为我已经完全搞明白了它，但是写的过程发现好多地方自己根本就不知道，之前完全是停留在一个很浮夸的层面上。所以，是时候找时间好好把这些协议过一遍，用自己的语言，从<code>解决问题</code>的角度，记录下这些经典协议的故事了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_Name_System&quot;&gt;DNS(Domain Name System)&lt;/a&gt; 大家肯定不陌生，不就是用来将一个网站的域名转换为对应的IP吗。当我们发现可以上QQ但不能浏览网页时，我们会想到可能是域名服务器挂掉了；当我们用别人提供的hosts文件浏览到一个“&lt;code&gt;不存在&lt;/code&gt;”的网页时，我们会了解到域名解析系统的脆弱。&lt;/p&gt;
&lt;p&gt;然而关于DNS还有一大堆故事值得我们去倾听，去思考。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://selfboot.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="DNS" scheme="https://selfboot.cn/tags/DNS/"/>
    
    <category term="Protocol" scheme="https://selfboot.cn/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>知其所以然之永不遗忘的算法</title>
    <link href="https://selfboot.cn/2015/11/03/howto_find_algorithm/"/>
    <id>https://selfboot.cn/2015/11/03/howto_find_algorithm/</id>
    <published>2015-11-03T00:00:00.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>相信大部分同学曾经都学习过快速排序、Huffman、KMP、Dijkstra等经典算法，初次学习时我们惊叹于算法的巧妙，同时被设计者的智慧所折服。于是，我们仔细研读算法的每一步，甚至去证明算法的正确性，或者是去尝试优雅地实现这些算法。总之，我们会花费很大的时间精力去理解这些智慧的结晶。</p><p>然而，现在对于这些经典的算法你仍然了然于胸吗？就算现在你仍然记得这些算法的步骤，你敢确保一年后、十年后自己不会忘记？我想没有多少人敢保证吧。</p><span id="more"></span><p>我们当然希望自己掌握一个算法后，就永远不会忘记，最好还能举一反三，利用算法中的思想去解决新的问题。然而，现实与美好的愿景往往是背道而驰，不要说举一反三，我们甚至经常忘记那些算法本身。</p><h1 id="背算法与设计算法"><a href="#背算法与设计算法" class="headerlink" title="背算法与设计算法"></a>背算法与设计算法</h1><p>为什么会这样？简单来说，因为我们从来就没有真正掌握过这些算法，我们只不过是在<strong>背诵</strong>别人发明的算法，就像我们背诵历史书上的那些历史事件一样，时间久了自然会慢慢遗忘。</p><p>我们接触到某个算法时，看到的只是对算法过程的讲解，对其正确性的证明，或者对其效率的分析（想想大名鼎鼎的<a href="https://book.douban.com/subject/20432061/">《算法导论》</a>，<a href="https://book.douban.com/subject/19952400/">《算法》</a>是如何讲解某一算法的），我们不会看到那些牛人是如何“<strong>灵机一动</strong>”设计出了这惊天地泣鬼神的算法。也就是说我们只是知其然，并没有知其所以然。当我们不知道一个算法的来龙去脉，不知道设计它经历的那些思维历程时，就很容易忘记它的具体内容。相反，那些牛人就不会忘记自己设计的算法。</p><p>所以，当看到别人牛逼的闪闪发光的算法后，我们一定要探寻算法背后那“曲径通幽”的思维之路。只有经历了思维之路的磨难，才配得上永远占有一个算法，并有可能举一反三，或者是设计一个巧妙算法。刘未鹏在<a href="http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/">知其所以然（三）：为什么算法这么难？</a>中探索了Huffman编码的思维历程，值得一看。顺便说一下，探索算法背后的思维历程不是件容易的事，要知道就是霍夫曼本人也是花了一个学期才想出它的编码算法。</p><p>下面我们以LeetCode上一个<code>好问题</code>，来探索这个问题的算法背后的思维之路。关于什么是好问题，刘未鹏在<a href="http://mindhacks.cn/2008/04/18/learning-from-polya/">跟波利亚学解题</a>上有一个不错的观点：<strong>好问题即测试一个人思维的习惯的题目</strong>，通常考察你的联想能力、类比能力、抽象能力、演绎能力、归纳能力、观察能力、发散能力等。</p><h1 id="一个好问题"><a href="#一个好问题" class="headerlink" title="一个好问题"></a>一个好问题</h1><p>LeetCode 84题：<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">Largest Rectangle in Histogram</a>，给定一个直方图（下图a），求直方图中能够组成的所有矩形中，面积最大为多少。对于图a来说，我们很容易看出来面积最大的矩形为高度为5和6的直方图组成的矩形（图b隐形部分），其面积为5 * 2 &#x3D; 10。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151103_histogram_area.png" alt="题目描述"></p><p>其实这个题稍微加以变化，就是另一个相当有趣的问题：<a href="https://leetcode.com/problems/maximal-rectangle/">Maximal Rectangle</a>.</p><p>这道题目一个显而易见的解决方法就是<code>暴力搜索</code>：找出所有可能的矩形，然后求出面积最大的那个。要找出所有可能的矩形，只需要从左到右扫描每个立柱，然后以这个立柱为矩形的左边界（假设为第i个），再向右扫面，分别以（i+1, i+2, n）为右边界确定矩形的形状。</p><p>这符合我们本能的思考过程：要找出最大的一个，就先列出所有的可能，比较大小后求出最大的那个。然而不幸的是，本能的思考过程通常是简单粗暴而又低效的，就这个题目来说，时间复杂度为N^2 。那么有没有一种更加高效的解决办法呢？</p><h1 id="一个好算法"><a href="#一个好算法" class="headerlink" title="一个好算法"></a>一个好算法</h1><p>我第一次面对这个题时，并没有想出一个漂亮的解决方案。因为从给定的条件来看，似乎找不到一个约束条件使得满足这个条件的矩形面积最大，也就是说无法缩减问题的规模，因此必须找出所有可能的矩形，这样的话效率肯定是N^2 。</p><p>然而去Google了一下，立即发现了一个时间复杂度O(n)的算法，当时就被这神奇的解法所震撼到。它的代码十分简单，简单到一开始我根本就看不懂，不明白为什么这样子求出的就是最大的矩形。网上好多所谓的解题报告里面只是人云亦云地给出了算法的步骤，没有算法正确性的证明，更没有我们最想要的关于解题思路。</p><p>我也先给出算法步骤和代码，看看你是不是同样一头雾水。在程序中维护一个栈，栈中元素为直方图中bar的下标，然后从头开始扫描每个bar：</p><ol><li>如果当前bar的高度大于栈顶bar的高度，则将当前bar的下标入栈；</li><li>否则执行出栈操作，记录弹出下标对应的bar的高度，并计算出一个面积，然后用这个面积更新最大面积。</li></ol><p>代码也是相当简洁，python源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, height</span>):</span><br><span class="line">    height.append(<span class="number">0</span>)</span><br><span class="line">    size = <span class="built_in">len</span>(height)</span><br><span class="line">    no_decrease_stack = [<span class="number">0</span>]</span><br><span class="line">    max_size = height[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; size:</span><br><span class="line">        cur_num = height[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> no_decrease_stack <span class="keyword">or</span></span><br><span class="line">                    cur_num &gt; height[no_decrease_stack[-<span class="number">1</span>]]):</span><br><span class="line">            no_decrease_stack.append(i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            index = no_decrease_stack.pop()</span><br><span class="line">            <span class="keyword">if</span> no_decrease_stack:</span><br><span class="line">                width = i - no_decrease_stack[-<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                width = i</span><br><span class="line">            max_size = <span class="built_in">max</span>(max_size, width * height[index])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_size</span><br></pre></td></tr></table></figure><p>高效而难以理解，这就是那些神奇算法的共性。</p><h1 id="一个思维历程"><a href="#一个思维历程" class="headerlink" title="一个思维历程"></a>一个思维历程</h1><p>那么这个算法真的就是我等凡夫俗子不能想出来的？难道我们只能仰望高山，恨自己智商不高？我还真不服气呢，于是又静下心去思考这个问题。</p><p>这次我们不从已知条件推结果，而直接从结论入手，就是说假设现在已经找到了面积最大的那个矩形。接着我们来分析该矩形有什么特征，然后可以用下面两种方法之一来缩减问题的规模（因为这两种方法都不用找出所有的矩形一一比较）。</p><ol><li>找出满足这些特征的矩形，面积最大的矩形肯定是其中之一；</li><li>排除那些不满足这些特征的矩形，面积最大的矩形在剩下的那些矩形里面。</li></ol><p>为了使考虑情况尽可能全面，画了许多直方图，防止使用原题目图片可能存在的一些特定假设，其中一个直方图如下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151103_histogram.png" alt="题目情况分析"></p><p>通过不断地对多个直方图的观察，发现面积最大的那个矩形好像都包含至少一个完整的bar，那么这条规律适用于所有的直方图吗？我们用反证法来证明，假设某个最大矩形中每个竖直块都是所在的bar的一小段，那么这个矩形高度增加1后仍然是一个合法的矩形，但新的矩形面积更大，与假设矛盾，所以面积最大的矩形必须至少有一个竖直块是整个bar。</p><p>至此我们找到了面积最大矩形的一个特性：<code>各组成竖直块中至少有一个是完整的Bar</code>。有了这条特性，我们再找面积最大的矩形时，就有了一个比较小的范围。具体来说就是针对每个bar，我们找出包含这个bar的面积最大的矩形，然后只需要比较这N个矩形即可（N为bar的个数）。</p><p>那么问题又来了，如何找出“<strong>包含某个bar的面积最大的矩形呢</strong>”？对于上面的直方图，包含下标为4的bar的最大矩形如下图橘黄色部分：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151103_histogram_more.png" alt="局部最大矩形"></p><p>简单观察一下，就会发现要找到包含某个bar的最大矩形其实很简答，只需要找到高度小于该bar的左、右边界即可，上图中分别是下标为1的bar和下标为10的bar。</p><p>至此问题已经变为<strong>“对于给定的bar，如何确定高度比它小的左、右边界”</strong>。其实求左边界和右边界是同样的求法，下面我们考虑求每个bar的左边界。最直接的思路是对于每个bar，扫面其前面所有的bar，找出最后一个高度小于它的bar，这样的话时间复杂度明显又是N^2 ，Holy Shit。</p><p>到这里似乎没有路可走了，但如果我们继续绞尽脑汁地去想，<strong>可能</strong>（或许你对栈理解的很深入，或许是你在一个类似的问题中用到了栈，当然你也可能想到动态规划的思想，那也是可行的）会<strong>联想</strong>到<code>栈</code>这一数据结构。<strong>用栈维护一个高度递增的bar的集合，也就是说栈底到栈顶部对应的bar的高度越来越大</strong>。那么对应一个刚读入的bar，我们只需要比较它的高度和栈顶对应bar的高度，如果当前bar比较高，则弹出栈顶元素继续比较，直到栈顶bar比它低或者栈为空。之后，将当前bar入栈，更新栈内的递增序列。</p><p>我们从左到右扫一遍得到每个bar对应的左边界，然后从右到左扫一遍得到bar的右边界。两次扫描过程中，每个bar都只有出栈、入栈操作，所以时间复杂度为O(N)。通过这样的预处理，即可以O(N)的时间复杂度得到每个bar的左右边界。之后对于每个bar求出包含它的最大面积，也即是由左右边界和bar的高度围起来的矩形的面积。再做N次比较，即可得出最终的结果。</p><p>这里先预处理用两个栈扫描两次得到左、右边界，再计算面积，是按照推导过程一步一步来的。当我们写完程序后，再综合看这个问题，可能会发现其实没必要这样分开来做，我们可以在扫描的同时，维护一个递增的栈，同时在“合适的”时候计算面积，然后更新最大面积。具体实现方法就是前面给出的那个神奇的算法，不过现在看来一点也不神奇了，我们已经探索到了它背后的思维历程。</p><p>当然，条条道路通罗马，上面思维过程只是其中一条通往解决方案的路径，你可能以另一种思维过程找到了答案。不过，我们上面的整个推导过程没有涉及一些类似“神谕”的启发，只是一些简单的方法：比如从结论推导、反证法、归纳总结、联想（可能联想到栈有点难）等，因此每个人都可以学会，并且很容易被大脑记住。值得注意的是，我们的整个思考过程并不简简单单地跟上面写的那样是线性的，它更可能是树形的，只是我们剪去了那些后来证明行不通的枝。</p><h1 id="解题的万能思考法则"><a href="#解题的万能思考法则" class="headerlink" title="解题的万能思考法则?"></a>解题的万能思考法则?</h1><p>人类在漫长的进化史中，解决了各种各样的问题。例如</p><ul><li>如何度过一条湍急的河流</li><li>如何保留火种</li><li>如何治愈天花</li><li>如何制造一个会飞的机器</li><li>…</li></ul><p>同时也对自己的思维方式进行总结和反思，笛卡尔曾经试图将人类思维的规则总结为36条（最终完成了<a href="https://en.wikisource.org/wiki/Rules_for_the_Direction_of_the_Mind">21条</a>）。</p><p>那么有没有一个解题的万能思考法则，按照这个法则去思考，最终能解决所有的问题或者是证明某个问题不可解？目前看来是没有这样的思考法则的，不然我们就可以制造出真正的会思考的机器了。</p><p>不过还是有许多思维方法值得我们去学习强化，波利亚在《How To Solve It》上总结了这些方法，如果想培养良好的思维习惯，那么这本书是必不可少的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;相信大部分同学曾经都学习过快速排序、Huffman、KMP、Dijkstra等经典算法，初次学习时我们惊叹于算法的巧妙，同时被设计者的智慧所折服。于是，我们仔细研读算法的每一步，甚至去证明算法的正确性，或者是去尝试优雅地实现这些算法。总之，我们会花费很大的时间精力去理解这些智慧的结晶。&lt;/p&gt;
&lt;p&gt;然而，现在对于这些经典的算法你仍然了然于胸吗？就算现在你仍然记得这些算法的步骤，你敢确保一年后、十年后自己不会忘记？我想没有多少人敢保证吧。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="方法" scheme="https://selfboot.cn/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>别惊讶，这只是营销！</title>
    <link href="https://selfboot.cn/2015/10/23/marketing/"/>
    <id>https://selfboot.cn/2015/10/23/marketing/</id>
    <published>2015-10-23T00:00:00.000Z</published>
    <updated>2023-05-25T05:02:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>说到营销，你可能会想起街头派发的传单，想起地铁里的各种宣传海报，想起优酷视频开始前漫长的无聊的广告，想起史玉柱的脑残广告台词（敢问有谁没听过？！）：</p><blockquote><p>今年过节不收礼啊不收礼，收礼只收脑白金脑白金！</p></blockquote><p>虽然我们很厌烦这些强迫式、入侵式的宣传，但不得不说它们的效果真的是不一般。想想一下，当你面对眼花缭乱的纷杂商品时，你是会买（<strong>被</strong>）听过的那些，还是那些根本没听人说过的无名之物呢？亦或者，你根本不知道买什么时，会不会被那些浮夸的宣传俘获，抱着试试的心态去体验下呢。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151023_market.png" alt="强迫式、入侵式的营销"></p><span id="more"></span><p>如果你以为所有的营销都是这么简单粗暴，那么你就太小看人民群众（真的是人民群众，不一定要是营销大师哦）的智慧啦。话说天下之势合久必分，分久必合，正如月有圆有缺、人有聚有散。所以，有强迫式营销，也就有“诱惑式”营销了。不过如何施展诱惑式营销，可谓是“八仙过海，各显神通”了。</p><h1 id="福利：快来占我便宜"><a href="#福利：快来占我便宜" class="headerlink" title="福利：快来占我便宜"></a>福利：快来占我便宜</h1><p>脑补一个画面：</p><blockquote><p>我注视着“静静”的电脑，一直在思考到底哪里有问题？月亮高高的挂着，风透过玻璃缝隙细细地吹着。静静给我端了杯咖啡，香气伴随着黄莺般的声音弥漫在我充满0、1的头脑里：“天很晚了，明天再修吧，今晚就先住我这里吧”。</p></blockquote><p>接下来发生了什么不在我们谈论的范围内了，但是我还是想说要是我，我就扔下电脑了，不再理会那烦人的Bug，毕竟有比Bug更美的妹子。</p><p>然而Bug有时候也是十分有吸引力的！一些技术男可能会想，你这不是废话吗，我要知道支付宝的Bug，我就能买我所想买了；要知道微信的Bug，就能看女神的位置了。你说的很对，但请注意我们只谈营销，我们要用Bug来优雅地营销。有点难度，不是吗？来看看人家百度是怎样做的吧！</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151023_baidu_bug.png" alt="百度网盘出Bug了？"></p><p>2013年，人们在各大论坛，微博，QQ群疯传<code>百度云网盘的支付系统疑似出现重大Bug，所有付费套餐的价格变成了原来的1/1000，1毛钱就可以买一年会员！</code>一时间，百度云盘红极一时，风靡网络，以前不知道什么是云盘的人都去抢云盘（<strong>便宜</strong>）啦。</p><p>高潮过后，大家冷静下来反思一下，这场抢购风潮会不会是百度一手策划的呢？我给大家一些分析依据，来便于你们推出自己的结论：</p><ol><li>百度对这次的Bug态度暧昧，过了几十小时后“低调”修复（百度可是媲美腾讯、阿里的巨头，保证支付系统的安全可靠完全没有技术难度）；</li><li>几天过后，百度开心地宣布云盘用户量突破7千万人，并持续高速增长。</li><li>一周后，迅雷也以类似的支付页面Bug出了一个卖萌的微博，大意是你们1分钱抢了我的会员卡，好狠心啊）。</li></ol><h1 id="玩耍：我们来谈游戏吧"><a href="#玩耍：我们来谈游戏吧" class="headerlink" title="玩耍：我们来谈游戏吧"></a>玩耍：我们来谈游戏吧</h1><p>如果从小到大，你没有玩过游戏，那么我给你一个建议，玩玩游戏吧！游戏不是洪水猛兽，不是毒品，不是赌博，游戏只是很单纯、很有趣而已。</p><p>有人用游戏赚钱，有人用游戏放松，有人用游戏挥霍青春，有人用游戏交朋友，这些你或多或少见过听过，但你知道游戏也可以拿来营销吗。</p><p>你肯定见过微信朋友圈里面的类似下面的游戏：</p><ul><li>围住神经猫</li><li>哈佛心理系情感分析检测</li><li>你心爱的人的名字是？</li><li>你上一辈子的职业是什么？</li></ul><p>通常出一款新的这种小游戏后，会有很多人去尝鲜。然后玩完后就会看到快来试用X X的广告，似乎不是很高明，和优酷前面的广告没太大差别。那么下面这种呢？</p><p>百度魔图为了抢占美图秀秀的市场，在应用里面添加了“PK大咖”这个小游戏性质的功能，用户上传一张本人的照片后，系统便会在0.1秒内告诉你与哪位明星最为相像。于是乎，大家为了看自己与哪个明星长得像，就下载百度魔图来玩。这款应用也连续10天蝉联苹果App Store中国区免费总榜第一名，真的是赚足了名声。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151023_pk.png" alt="PK 大咖"></p><h1 id="情怀：对不起，我只过1-的生活"><a href="#情怀：对不起，我只过1-的生活" class="headerlink" title="情怀：对不起，我只过1%的生活"></a>情怀：对不起，我只过1%的生活</h1><p>曾经，伟大的安妮以一篇<a href="http://weibo.com/1854627907/BAGsq9rbJ?type=comment#_rnd1445582370930">对不起，我只过1%的生活</a>红遍漫画界，红遍文艺界，红遍社会各界（有点夸张）。结果就是，她的<code>快看漫画</code>也火了起来。</p><p>你看，人家安妮多聪明，不到处贴广告劝大家赶快来用我的“快看漫画”（相信没多少人会去用的），人家先给我们讲人生，讲理想，讲情怀。讲她小时候的梦想，讲她如何坚持自己的梦想，讲她怎么实现自己的梦想。虽然自己的目的是宣传“快看漫画”，但人家就是轻描淡写地提了一下，却让我们流连忘返，三日不绝。 最后，人家真的翻山越岭，触摸到云了。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151023_anni.png" alt="伟大的安妮"></p><p>还有人家老罗，一直在强调自己的情怀，强调自己的认真与工匠精神，发布会最后还来一张段文艺的话。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151023_laoluo.png" alt="我不是为了输赢，我就是认真"></p><p>不管锤子手机卖的如何，老罗当年营销的效果真的是很好，毕竟有这么多人知道锤子了。</p><h1 id="万变不离其宗"><a href="#万变不离其宗" class="headerlink" title="万变不离其宗"></a>万变不离其宗</h1><p>不管是强迫式还是诱惑式的营销，都必须要抓住人们的心理，投其所好。<a href="https://book.douban.com/subject/26541801/">《增长黑客》</a>里面很好地总结了营销中需要把握的用户心理。</p><ol><li>喜爱：抓住你的爱好，就抓住了你！</li><li>逐利：天下熙熙皆为利来，…</li><li>互惠：互惠才能长久；</li><li>求助：求助也是一种美德（给别人表现的机会）；</li><li>炫耀：谁不希望站在舞台中央，…</li><li>稀缺：物以稀为贵；</li><li>害怕失去或错过：曾经有一份真挚的爱情放在我眼前，…</li><li>懒惰：能点一下鼠标，我不会点两下。</li></ol><p>推荐一下《增长黑客》，名字有黑客，但不是讲计算机上的黑客的，不需要任何技术底子，完全可以拿来当小说看的一本书。内容很有趣，好多地方让人忍不住拍案叫绝的，谁不看谁吃亏。（看我像不像在给《增长黑客》做营销，诱惑式的营销哦）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;说到营销，你可能会想起街头派发的传单，想起地铁里的各种宣传海报，想起优酷视频开始前漫长的无聊的广告，想起史玉柱的脑残广告台词（敢问有谁没听过？！）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今年过节不收礼啊不收礼，收礼只收脑白金脑白金！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然我们很厌烦这些强迫式、入侵式的宣传，但不得不说它们的效果真的是不一般。想想一下，当你面对眼花缭乱的纷杂商品时，你是会买（&lt;strong&gt;被&lt;/strong&gt;）听过的那些，还是那些根本没听人说过的无名之物呢？亦或者，你根本不知道买什么时，会不会被那些浮夸的宣传俘获，抱着试试的心态去体验下呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20151023_market.png&quot; alt=&quot;强迫式、入侵式的营销&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="社会百态" scheme="https://selfboot.cn/categories/%E7%A4%BE%E4%BC%9A%E7%99%BE%E6%80%81/"/>
    
    
    <category term="见闻" scheme="https://selfboot.cn/tags/%E8%A7%81%E9%97%BB/"/>
    
  </entry>
  
</feed>
