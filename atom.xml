<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just For Fun</title>
  <icon>https://www.gravatar.com/avatar/0de0c23d97c75300e32f8494b1485fb8</icon>
  <subtitle>知其然，知其所以然。知识广度是深度的副产品！</subtitle>
  <link href="https://selfboot.cn/atom.xml" rel="self"/>
  
  <link href="https://selfboot.cn/"/>
  <updated>2024-08-20T02:06:29.217Z</updated>
  <id>https://selfboot.cn/</id>
  
  <author>
    <name>selfboot</name>
    <email>xuezaigds@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LevelDB Explained - How To Read and Write WAL Logs</title>
    <link href="https://selfboot.cn/en/2024/08/14/leveldb_source_wal_log/"/>
    <id>https://selfboot.cn/en/2024/08/14/leveldb_source_wal_log/</id>
    <published>2024-08-14T21:05:31.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB uses Write-Ahead Logging (WAL) to ensure data durability. When a write operation occurs, LevelDB first writes the data to the log file, and then applies it to the in-memory data structure (such as MemTable). When the system or database restarts after a crash, LevelDB checks the records in the WAL log file. By reading and replaying these log records, LevelDB can rebuild the data state that had not been fully written to disk when the crash occurred.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_leveldb_source_wal_log_cover.svg" alt="LevelDB WAL Log Writing Process"></p><p>The overall WAL log-related operation process is as follows:</p><ol><li>LevelDB first writes the data to the WAL log. This ensures that the data won’t be lost even in the event of a system crash.</li><li>The data is written to the MemTable in memory, which is a fast memory operation.</li><li>LevelDB confirms the write completion to the client.</li><li>Over time, when the MemTable is full, it is flushed to SSTable files on disk.</li><li>Once the MemTable has been successfully flushed to SSTable, the corresponding WAL log can be cleared.</li></ol><p>Let’s take a detailed look at the implementation.</p><span id="more"></span><h2 id="Writing-WAL-Logs"><a href="#Writing-WAL-Logs" class="headerlink" title="Writing WAL Logs"></a>Writing WAL Logs</h2><p>First, let’s see how LevelDB writes WAL logs. In LevelDB, a Writer class is defined in <a href="https://github.com/google/leveldb/blob/main/db/log_writer.h">db&#x2F;log_writer.h</a> for writing to WAL log files. The main method of the Writer class is <code>AddRecord</code>, used to append a record to the log file. The main data member is <code>WritableFile* dest_;</code>, which points to the log file that supports append writes. Here, WritableFile is an abstract class interface defined in <a href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h#L277">include&#x2F;leveldb&#x2F;env.h</a>, used to encapsulate sequential file write operations. For specific interfaces and implementations, refer to <a href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/#%E9%A1%BA%E5%BA%8F%E5%86%99%E6%96%87%E4%BB%B6">LevelDB Source Code Reading: Posix File Operation Interface Implementation Details</a>.</p><p>The main implementation of WAL log writing is in the <a href="https://github.com/google/leveldb/blob/main/db/log_writer.cc">db&#x2F;log_writer.cc</a> file, and the overall process is quite clear. The AddRecord method handles data of different sizes, ensuring they are segmented according to the correct format and type, and then calls <a href="https://github.com/google/leveldb/blob/main/db/log_writer.cc#L82">EmitPhysicalRecord</a> to set the header and store a single record.</p><h3 id="Single-Record-Storage-Format"><a href="#Single-Record-Storage-Format" class="headerlink" title="Single Record Storage Format"></a>Single Record Storage Format</h3><p>The single record storage format is quite clear, with a complete implementation in EmitPhysicalRecord. Each record consists of two parts: a <strong>fixed-length 7-byte</strong> Header and a Data part of variable length. The Header part includes 1 byte for record type, 2 bytes for record length, and 4 bytes for checksum. Specifically:</p><ul><li>Record Type: Identifies whether it’s a complete record, first part, middle part, or last part.</li><li>Length: The length of a single record, referring to the length of the data part, not including the header length. The maximum length of a single record is kBlockSize - kHeaderSize, which can be adequately expressed with 2 bytes.</li><li>CRC32: Cyclic redundancy check code, used to check if the data has changed during storage or transmission.</li></ul><p>As shown in the following diagram:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+--------------------------------------------------+</span><br><span class="line">|     Header      |                     Data/Payload                  |</span><br><span class="line">+-----------------+--------------------------------------------------+</span><br><span class="line">| Record Type (1B)| Actual data written by the application...         |</span><br><span class="line">| Length (2B)     |                                                  |</span><br><span class="line">| CRC (4B)        |                                                  |</span><br><span class="line">+-----------------+--------------------------------------------------+</span><br></pre></td></tr></table></figure><p>The implementation of writing a single record is as follows. First, it calculates the values of each field in the header, then writes the header and data parts to the log file.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="type">const</span> <span class="type">char</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="type">char</span> buf[kHeaderSize];</span><br><span class="line">  buf[<span class="number">4</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(t);</span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="type">uint32_t</span> crc = crc32c::<span class="built_in">Extend</span>(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::<span class="built_in">Mask</span>(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">  <span class="built_in">EncodeFixed32</span>(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(ptr, length));</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = dest_-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When calculating the CRC32 here, it uses <code>type_crc_[t]</code>. This array is initialized in the Writer’s constructor using the InitTypeCrc function, which can improve calculation efficiency and avoid recalculating the CRC32 checksum each time a record is written. If the type_crc_ array is not initialized, you could also use <code>crc32c::Extend(0, ptr, length)</code> to calculate the CRC checksum. However, this would only calculate the CRC checksum for the data part, without considering the <strong>record type</strong>. By using type_crc_, the record type is used as the initial value for the crc32 calculation, so that even for the same content, if the types are different, the calculated crc32 will also be different.</p><p>We’ve mentioned record types here, and the code also records a <code>block_offset_</code>. What are these used for? This is the <strong>data segmentation logic</strong> done in AddRecord.</p><h3 id="Data-Segmentation-Records"><a href="#Data-Segmentation-Records" class="headerlink" title="Data Segmentation Records"></a>Data Segmentation Records</h3><p><strong>When writing data, if a single piece of data is too large, LevelDB will segment the data into multiple records and write them bit by bit</strong>. After segmentation, one piece of data may include multiple records, so it’s necessary to design a good <strong>record organization format</strong> to correctly rebuild the complete data when reading. LevelDB’s approach here is quite direct: it adds a record type to each record to identify whether it’s a complete record, first part, middle part, or last part. This way, when reading, the data can be assembled in the order of the record types. A piece of data might be segmented in the following ways:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first(R1), middle(R1), middle(R1), ..., last(R1)</span><br><span class="line">first(R2), last(R2)</span><br><span class="line">full(R3)</span><br></pre></td></tr></table></figure><p>Here, first, middle, last, and full represent the types of records. All records are placed in <strong>logical blocks</strong>, with the size of a logical block being kBlockSize (32768&#x3D;32KB), which is defined in <a href="https://github.com/google/leveldb/blob/main/db/log_format.h#L27">db&#x2F;log_format.h</a>. When segmenting data, it ensures that <strong>a single record does not span logical blocks</strong>. The overall logic for segmenting records is implemented in AddRecord, mainly based on the size of the data, the remaining space in the current logical block, and then determining whether segmentation is needed. For scenarios requiring segmentation, the data is segmented into records, the correct record type is set, and then EmitPhysicalRecord is called to write them one by one. The core code is as follows, with some comments and assert validation logic removed:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="type">const</span> Slice&amp; slice)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ptr = slice.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">size_t</span> left = slice.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="type">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="built_in">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(<span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="built_in">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that for data of length 0, a record will still be written here, with the record type as fulltype, and the record only containing a header without a data part. There are specific test cases to verify this situation. Also, note that if after writing some records, the remaining space in the current logical block is less than 7, not enough to write a Header, it will fill the remaining space with <code>\x00</code> and then switch to the next logical block.</p><p>The <strong>implementation of determining the current record type is quite clever</strong> here, only needing to maintain two flags: begin and end. When starting to write data, begin is true, and after writing a record, begin is updated to false. The update of end is determined by whether the remaining data length is 0. Then, based on the values of begin and end, the current record type can be determined. Note that the order of if-else here is also crucial: if it’s both begin and end, it indicates a kFullType record; then if it’s only begin, it’s kFirstType; if it’s only end, it’s kLastType; in other cases, it’s kMiddleType.</p><p>There’s a design here worth considering: <strong>why not cross logical blocks when segmenting records</strong>? In fact, if you look at the code for reading WAL logs later, you’ll find that this design allows for block-by-block reading. <strong>Records within each block are complete, which means there’s no need to handle records spanning blocks, greatly simplifying the reading logic</strong>. Additionally, if a block is damaged, it will only affect the records within that block, not the records in other blocks.</p><p>So far, we’ve introduced the process of writing data to WAL log files. Next, let’s look at how to read WAL log files.</p><h2 id="Reading-WAL-Logs"><a href="#Reading-WAL-Logs" class="headerlink" title="Reading WAL Logs"></a>Reading WAL Logs</h2><p>Compared to segmenting data into records and then writing to log files, the logic for reading logs and reconstructing data is slightly more complex. The <a href="https://github.com/google/leveldb/blob/main/db/log_reader.h#L20">db&#x2F;log_reader.h</a> defines a Reader class for reading data from log files. The main data member of Reader is <code>SequentialFile* const file_;</code>, which points to a <strong>log file that supports sequential reading</strong>. Similar to WritableFile, SequentialFile is also an abstract class interface defined in include&#x2F;leveldb&#x2F;env.h, encapsulating the sequential read operations of the file system. For specific interfaces and implementations, refer to <a href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%96%87%E4%BB%B6">LevelDB Source Code Reading: Posix File Operation Interface Implementation Details</a>.</p><p>The main method of the Reader class is <code>ReadRecord</code>, used to read a complete piece of data. It can be called multiple times to sequentially read all the data. If some unexpected data occurs during the reading process, such as invalid record length or CRC check failure, the Reporter interface defined in Reader can be used to record error information. Additionally, Reader supports skipping a certain length of data in the file, used to skip over already read data when recovering data. The complete implementation is in <a href="https://github.com/google/leveldb/blob/main/db/log_reader.cc">db&#x2F;log_reader.cc</a>, let’s take a detailed look.</p><h3 id="Skipping-Initial-Data"><a href="#Skipping-Initial-Data" class="headerlink" title="Skipping Initial Data"></a>Skipping Initial Data</h3><p>Reader has a last_record_offset_ that records the offset of the latest complete data read, initialized to 0. Subsequently, each time a record of type kFullType or kLastType is read, this value is updated. At the entrance of ReadRecord, it first compares the size of last_record_offset_ and initial_offset_. Here, initial_offset_ is passed in during construction, used to specify the length of data to skip reading. If last_record_offset_ is less than initial_offset_, it needs to skip the initial_offset_ part at the beginning of the file. The implementation of skipping the beginning part is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::SkipToInitialBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> offset_in_block = initial_offset_ % kBlockSize;</span><br><span class="line">  <span class="type">uint64_t</span> block_start_location = initial_offset_ - offset_in_block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t search a block if we&#x27;d be in the trailer</span></span><br><span class="line">  <span class="keyword">if</span> (offset_in_block &gt; kBlockSize - <span class="number">6</span>) &#123;</span><br><span class="line">    block_start_location += kBlockSize;</span><br><span class="line">  &#125;</span><br><span class="line">  end_of_buffer_offset_ = block_start_location;</span><br><span class="line">  <span class="comment">// Skip to start of first block that can contain the initial record</span></span><br><span class="line">  <span class="keyword">if</span> (block_start_location &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Status skip_status = file_-&gt;<span class="built_in">Skip</span>(block_start_location);</span><br><span class="line">    <span class="keyword">if</span> (!skip_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReportDrop</span>(block_start_location, skip_status);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s a special case here: if initial_offset_ happens to be at the end of a logical block, the entire logical block needs to be skipped. Determining whether it’s at the end of a logical block is simple: take the modulus of initial_offset_ with the size of the logical block (32kb), and if the remaining part is just within the last 6 bytes of the logical block, it’s considered to be at the end of the logical block. Note that when skipping, it will only skip entire logical blocks, ensuring reading starts from the <strong>head of the logical block</strong> containing initial_offset_. This may cause the offset of the first record read to be smaller than initial_offset_, which will be handled later in ReadPhysicalRecord.</p><h3 id="Parsing-a-Complete-Piece-of-Data"><a href="#Parsing-a-Complete-Piece-of-Data" class="headerlink" title="Parsing a Complete Piece of Data"></a>Parsing a Complete Piece of Data</h3><p>ReadRecord is used to read a complete piece of data from the log file. Here, a complete piece of data may include multiple records, each of which needs to be read out and then concatenated.</p><p>First, <strong>in_fragmented_record</strong> is used to mark whether we’re currently in a <strong>fragmented record</strong>, initialized to false. Then it enters a while loop, continuously calling ReadPhysicalRecord to read out records, saving them in fragment, and then processing them according to the record type. Note that there’s a <code>resyncing_</code> here, which is set to true during initialization if there’s data to be skipped (initial_offset_&gt;0), indicating that it’s currently in a state of skipping data. In this state, as long as a record of type kFullType is read, resyncing_ will be updated to false, indicating the end of data skipping and the start of normal data reading.</p><p>When reading data, it will determine whether data needs to be concatenated based on the current record type.</p><ul><li>If it’s of type kFullType, it means this is a complete piece of data. fragment is directly set as result, and last_record_offset_ is updated.</li><li>If it’s of type kFirstType, it means this is the beginning of a new piece of data. This record is saved in scratch, and in_fragmented_record is set to true.</li><li>If it’s of type kMiddleType, it means this is a middle part of a piece of data. in_fragmented_record must be true at this time, otherwise an error is reported. In this case, scratch continues to concatenate new records.</li><li>If it’s of type kLastType, it means this is the last part of a piece of data. in_fragmented_record must be true at this time, otherwise an error is reported. The last part of fragment is concatenated to scratch, then scratch is set as result, last_record_offset_ is updated, and it returns.</li></ul><p>There are also other record types, such as kEof and kBadRecord, which are abnormal situations and need special handling. The core logic of ReadRecord is as follows, with some error handling code omitted:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::ReadRecord</span><span class="params">(Slice* record, std::string* scratch)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  record-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">bool</span> in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">  Slice fragment;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> record_type = <span class="built_in">ReadPhysicalRecord</span>(&amp;fragment);</span><br><span class="line">    <span class="keyword">if</span> (resyncing_) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (record_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> kFullType:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *record = fragment;</span><br><span class="line">        last_record_offset_ = prospective_record_offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">case</span> kFirstType:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        scratch-&gt;<span class="built_in">assign</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        in_fragmented_record = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kMiddleType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(1)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kLastType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(2)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">          *record = <span class="built_in">Slice</span>(*scratch);</span><br><span class="line">          last_record_offset_ = prospective_record_offset;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reading-a-Single-Logical-Block"><a href="#Reading-a-Single-Logical-Block" class="headerlink" title="Reading a Single Logical Block"></a>Reading a Single Logical Block</h3><p>ReadPhysicalRecord <strong>encapsulates the process of extracting records from logical blocks</strong>. The size of a logical block is kBlockSize&#x3D;32KB, which is defined in <a href="https://github.com/google/leveldb/blob/main/db/log_format.h#L27">db&#x2F;log_format.h</a>. When we read files from disk, we <strong>use logical blocks as the minimum reading unit</strong>, read them into memory cache, and then parse the records one by one. Here, the outermost layer is a while loop. It first checks the size of buffer_. If the data in buffer_ is not enough to parse out a record (length less than kHeaderSize), it reads a logical block of data from the file into buffer_.</p><ul><li>If the length read from the file is less than kBlockSize, it means it has reached the end of the file. In this case, eof_ is set to true, then it continues into the loop, clears the data in buffer_, and returns kEof.</li><li>If there’s an error reading the file, it reports the read failure using ReportDrop, clears buffer_, sets eof_ to true, and then directly returns kEof.</li><li>If it successfully reads kBlockSize of content into buffer_, it proceeds to parse the records.</li></ul><p>Of course, there might be multiple records in a logical block Block. ReadPhysicalRecord returns after parsing each record. Before returning, it updates the pointer of buffer_ to point to the start position of the next record. When re-entering ReadPhysicalRecord, if it finds there are still records in buffer_ (length greater than kHeaderSize), it won’t read from the file but directly parse from buffer_ continuing from the last position.</p><p>The specific code for parsing records is the opposite of writing records above. It first parses information such as length and crc32 from the Header, then saves the record data in result, and finally updates the data of buffer_ to point to the start position of the next record.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Reader::ReadPhysicalRecord</span><span class="params">(Slice* result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer_.<span class="built_in">size</span>() &lt; kHeaderSize) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* header = buffer_.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">4</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">5</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> type = header[<span class="number">6</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    buffer_.<span class="built_in">remove_prefix</span>(kHeaderSize + length);    <span class="comment">// Point to the start position of the next record</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *result = <span class="built_in">Slice</span>(header + kHeaderSize, length);</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>The code above omitted some exception handling logic, such as invalid record length and CRC check failure. The exception handling here mainly uses the Reporter interface to record error information and then clear buffer_. This way, even if some exceptions occur during the reading process, it will at most affect the current buffer_ parsing without affecting the reading and parsing of subsequent logical blocks.</p><p>There’s another exception: <strong>when the current record is within the skipped initial_offset_ range</strong>. This is because when we skipped earlier, we only skipped entire logical blocks, ensuring reading starts from the <strong>head of the logical block</strong> containing initial_offset_. If the offset of the current record is less than initial_offset_, it means this record needs to be skipped. In this case, it adjusts the starting part of buffer_ and returns kBadRecord.</p><h2 id="WAL-Read-and-Write-Testing"><a href="#WAL-Read-and-Write-Testing" class="headerlink" title="WAL Read and Write Testing"></a>WAL Read and Write Testing</h2><p><a href="https://github.com/google/leveldb/blob/main/db/log_test.cc">db&#x2F;log_test.cc</a> provides some utility helper classes and functions, as well as detailed test cases, to fully test the WAL log reading and writing here. For example, BigString is used to generate strings of specified length, and the LogTest class encapsulates the read and write logic of Reader and Writer, exposing convenient interfaces for testing, such as Write, ShrinkSize, Read, etc. Additionally, it doesn’t directly read files but implements a StringSource class inheriting from SequentialFile, using string to simulate file reading. It also implements a StringDest class inheriting from WritableFile, using string to simulate file writing.</p><p>Here are some test cases for normal reading and writing:</p><ul><li>Empty: Tests reading an empty file directly, returning EOF.</li><li>ReadWrite: Tests simple writing and reading, ensuring that written data can be correctly read. Here, an empty string is written and can be normally read out.</li><li>ManyBlocks: Tests writing a large number of strings of different lengths, occupying multiple logical blocks. Then reads them one by one to ensure they can be correctly read.</li><li>Fragmentation: Tests writing extremely large strings, where each piece of data needs to occupy multiple records. Then reads them one by one to ensure they can be correctly read.</li></ul><p>In addition, some test cases for abnormal situations are constructed. For example, TruncatedTrailingRecordIsIgnored is used in LevelDB’s log system to verify the handling of <strong>truncated records at the end of log files</strong>. When the last record of a log file is not completely written (for example, due to system crash or other write interruption events), this incomplete record should be ignored rather than treated as an error.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(LogTest, TruncatedTrailingRecordIsIgnored) &#123;</span><br><span class="line">  <span class="built_in">Write</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="built_in">ShrinkSize</span>(<span class="number">4</span>);  <span class="comment">// Drop all payload as well as a header byte</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;EOF&quot;</span>, <span class="built_in">Read</span>());</span><br><span class="line">  <span class="comment">// Truncated last record is ignored, not treated as an error.</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">0</span>, <span class="built_in">DroppedBytes</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;&quot;</span>, <span class="built_in">ReportMessage</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BadLength is used to verify the behavior when dealing with corrupted record length fields. The test ensures that the log system can correctly identify and ignore invalid records caused by <strong>errors in the record length field</strong>, while being able to continue reading subsequent valid records and report appropriate error messages.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(LogTest, BadLength) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> kPayloadSize = kBlockSize - kHeaderSize;</span><br><span class="line">  <span class="built_in">Write</span>(<span class="built_in">BigString</span>(<span class="string">&quot;bar&quot;</span>, kPayloadSize));</span><br><span class="line">  <span class="built_in">Write</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="comment">// Least significant size byte is stored in header[4].</span></span><br><span class="line">  <span class="built_in">IncrementByte</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;foo&quot;</span>, <span class="built_in">Read</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kBlockSize, <span class="built_in">DroppedBytes</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;OK&quot;</span>, <span class="built_in">MatchError</span>(<span class="string">&quot;bad record length&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, IncrementByte is used to increase the value at the 4th byte by 1. This position stores the length information of the record, thus causing the record length to increase. When reading, it will find that the record length is invalid and then report an error message. The logic for checking the length is in ReadPhysicalRecord, as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kHeaderSize + length &gt; buffer_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  <span class="type">size_t</span> drop_size = buffer_.<span class="built_in">size</span>();</span><br><span class="line">  buffer_.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">if</span> (!eof_) &#123;</span><br><span class="line">    <span class="built_in">ReportCorruption</span>(drop_size, <span class="string">&quot;bad record length&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kBadRecord;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> kEof;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In addition, a large number of test cases are constructed to verify the initial skip length. A function CheckInitialOffsetRecord is encapsulated here to verify whether the records with initial skip length are correctly skipped. This function will write some records, then set initial_offset_ to read records, verifying whether records of initial_offset_ length have been skipped.</p><p>Through a large number of test cases, the correctness of the WAL log read and write logic is ensured. The test cases here are also very worth learning, as they can help us better understand the read and write logic of WAL logs.</p>]]></content>
    
    
    <summary type="html">This article explores the Write-Ahead Logging (WAL) log read and write interfaces in LevelDB. It provides a detailed analysis of the WAL log writing process, including data segmentation, record format, and storage methods. It also explains the complex logic of log reading, including how to handle cross-block records and abnormal situations. Additionally, it showcases relevant test cases to verify the correctness of WAL logs in various scenarios.</summary>
    
    
    
    <category term="Source Code Analysis" scheme="https://selfboot.cn/categories/Source-Code-Analysis/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB 源码阅读：读写 WAL 日志保证持久性</title>
    <link href="https://selfboot.cn/2024/08/14/leveldb_source_wal_log/"/>
    <id>https://selfboot.cn/2024/08/14/leveldb_source_wal_log/</id>
    <published>2024-08-14T21:05:31.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 使用 WAL（Write-Ahead Logging）日志来确保数据的持久性。当写入操作发生时，LevelDB 首先将数据写入到日志文件中，然后再应用到内存中的数据结构（如 MemTable）。系统或数据库崩溃后重新启动时，LevelDB 会检查 WAL 日志文件中的记录。通过读取并重放这些日志记录，LevelDB 可以重建那些在崩溃发生时还未被完全写入磁盘的数据状态。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_leveldb_source_wal_log_cover.svg" alt="LevelDB WAL 日志写入流程"></p><p>整个 WAL 日志相关的操作流程如下：</p><ol><li>LevelDB首先将数据写入WAL日志。确保即使在系统崩溃的情况下，数据也不会丢失。</li><li>数据被写入内存中的MemTable，这个是内存操作，很快。</li><li>LevelDB向客户端确认写入完成。</li><li>随着时间推移，当MemTable满了之后，它会被刷新到磁盘上的SSTable文件中。</li><li>一旦MemTable被成功刷新到SSTable，相应的WAL日志就可以被清除了。</li></ol><p>接下来详细看看这里的实现。</p><span id="more"></span><h2 id="写-WAL-日志"><a href="#写-WAL-日志" class="headerlink" title="写 WAL 日志"></a>写 WAL 日志</h2><p>先来看看 LevelDB 是如何写 WAL 日志的。在 LevelDB 中，<a href="https://github.com/google/leveldb/blob/main/db/log_writer.h">db&#x2F;log_writer.h</a> 中定义了个 Writer 类，用于写入 WAL 日志文件。Writer 类的主要方法是 <code>AddRecord</code>，用于将一个记录追加到日志文件中。主要的数据成员是 <code>WritableFile* dest_;</code>，指向支持追加写的日志文件。这里 WritableFile 是 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h#L277">include&#x2F;leveldb&#x2F;env.h</a> 中定义的抽象类接口，用于封装顺序写文件的操作，具体接口和实现可以参考 <a href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/#%E9%A1%BA%E5%BA%8F%E5%86%99%E6%96%87%E4%BB%B6">LevelDB 源码阅读：Posix 文件操作接口实现细节</a>。</p><p>WAL 日志写入的主要实现在 <a href="https://github.com/google/leveldb/blob/main/db/log_writer.cc">db&#x2F;log_writer.cc</a> 文件中，整体流程比较清晰。AddRecord 方法处理不同大小的数据，确保它们按照正确的格式和类型进行切分，然后调用 <a href="https://github.com/google/leveldb/blob/main/db/log_writer.cc#L82">EmitPhysicalRecord</a> 设置头部，存储单条记录。</p><h3 id="单条记录存储格式"><a href="#单条记录存储格式" class="headerlink" title="单条记录存储格式"></a>单条记录存储格式</h3><p>单条记录存储格式比较清晰，EmitPhysicalRecord 中有完整的实现。每条记录由 2 部分组成：<strong>7 字节固定长度</strong>的 Header以及长度不定的 Data 部分。Header 部分包括 1 字节的记录类型、2 字节的记录长度和 4 字节的校验码。其中：</p><ul><li>Record Type：记录类型，标识是完整记录、第一部分、中间部分还是最后部分。</li><li>Length：单条记录长度，指的是数据部分的长度，不包括头部的长度。单条记录长度最长为 kBlockSize - kHeaderSize，用 2 个字节表达足够了。</li><li>CRC32：循环冗余校验码，用于检查数据在存储或传输过程中是否发生了更改。</li></ul><p>如下图；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+--------------------------------------------------+</span><br><span class="line">|     Header      |                     Data/Payload                  |</span><br><span class="line">+-----------------+--------------------------------------------------+</span><br><span class="line">| Record Type (1B)| Actual data written by the application...         |</span><br><span class="line">| Length (2B)     |                                                  |</span><br><span class="line">| CRC (4B)        |                                                  |</span><br><span class="line">+-----------------+--------------------------------------------------+</span><br></pre></td></tr></table></figure><p>写单条记录的实现如下，首先计算头部各个字段的值，然后将头部和数据部分写入到日志文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="type">const</span> <span class="type">char</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="type">char</span> buf[kHeaderSize];</span><br><span class="line">  buf[<span class="number">4</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(t);</span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="type">uint32_t</span> crc = crc32c::<span class="built_in">Extend</span>(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::<span class="built_in">Mask</span>(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">  <span class="built_in">EncodeFixed32</span>(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(ptr, length));</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = dest_-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里计算 CRC32 的时候，用了<code>type_crc_[t]</code>，这个数组是在 Writer 的构造函数中用 InitTypeCrc 函数来进行初始化，这样可以提高计算效率，避免在每次写入记录时都重新计算 CRC32 校验码。如果没有初始化 type_crc_ 数组，其实也可以使用 <code>crc32c::Extend(0, ptr, length)</code> 来计算 CRC 校验码。不过这样的话，只计算了数据部分的 CRC 校验码，而没有考虑<strong>记录类型</strong>。用 type_crc_ 的话，把记录类型作为 crc32 计算的初始值，这样同样的内容，如果类型不同，计算出的 crc32 也不同。</p><p>这里提到了记录类型，代码中还记录了一个 <code>block_offset_</code>，这些又是做什么用的呢？这就是 AddRecord 中做的<strong>数据切分逻辑</strong>了。</p><h3 id="数据切分记录"><a href="#数据切分记录" class="headerlink" title="数据切分记录"></a>数据切分记录</h3><p><strong>在写数据的时候，如果单条数据太大，LevelDB 会将数据进行切分，分为多条记录，然后来一点点写入</strong>。经过切分后，一条数据可能就会包含多条记录，因此需要设计好<strong>记录组织格式</strong>，以便在读取时能够正确地重建完整的数据。这里 LevelDB 的做法比较直接，每条记录增加一个记录类型，用于标识是完整记录、第一部分、中间部分还是最后部分。这样在读取时，只要按照记录类型的顺序组装数据即可。这样一条数据可能分下面几种切分情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first(R1), middle(R1), middle(R1), ..., last(R1)</span><br><span class="line">first(R2), last(R2)</span><br><span class="line">full(R3)</span><br></pre></td></tr></table></figure><p>这里的 first、middle、last 和 full 分别表示记录的类型。所有的记录都放在<strong>逻辑块</strong>中，逻辑块的大小是 kBlockSize（32768&#x3D;32KB），这个值在 <a href="https://github.com/google/leveldb/blob/main/db/log_format.h#L27">db&#x2F;log_format.h</a> 中定义。在切分数据的时候会保证，<strong>单条记录不跨越逻辑块</strong>。整体切分记录的逻辑在 AddRecord 中实现，主要是根据数据的大小，当前逻辑块剩余空间，然后判断是否需要切分。对于需要切分的场景，将数据切分记录，设置好正确的记录类型，然后调用 EmitPhysicalRecord 逐条写入。核心代码如下，去掉了部分注释和 assert 校验逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="type">const</span> Slice&amp; slice)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ptr = slice.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">size_t</span> left = slice.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="type">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="built_in">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(<span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="built_in">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意对于长度为 0 的数据，这里也会写入一条记录，记录类型为 fulltype，记录只含有头部，没有数据部分，有测试用例专门来验证这种情况。另外注意如果写入一些记录后，当前逻辑块剩余空间小于 7，不足以写入 Header，则会用 <code>\x00</code> 填充剩余空间，然后切换到下一个逻辑块。</p><p>这里<strong>判断当前记录类型的实现比较聪明</strong>，只需要维护两个标志 begin 和 end。刚开始写入数据的时候，begin 为 true，写入一条记录后，就更新 begin 为 false。end 的更新则是根据剩余数据长度是否为 0 来判断。然后根据 begin 和 end 的值，就可以确定当前记录的类型了。注意这里 if else 的顺序也很关键，即是 begin 又是 end 的说明是 kFullType 的记录；接着如果只是 begin，就是 kFirstType；如果只是 end，就是 kLastType，其他情况就是 kMiddleType。</p><p>这里有个设计值得思考下，<strong>切分记录的时候，为什么不跨逻辑块</strong>？其实如果看后面读取 WAL 日志部分代码，就会发现这样设计后可以按块进行读取。<strong>每个块内的记录都是完整的，这意味着不需要处理跨块的记录，大大简化了读取逻辑</strong>。另外，如果某个块损坏，只会影响该块内的记录，不会影响其他块的记录。</p><p>至此，将数据写入 WAL 日志文件的流程就介绍完了。下面我们来看看如何读取 WAL 日志文件。</p><h2 id="读-WAL-日志"><a href="#读-WAL-日志" class="headerlink" title="读 WAL 日志"></a>读 WAL 日志</h2><p>相比把数据切分记录然后写日志文件，读取日志并重构数据的逻辑稍微复杂一些。<a href="https://github.com/google/leveldb/blob/main/db/log_reader.h#L20">db&#x2F;log_reader.h</a> 中定义了 Reader 类，用于从日志文件中读取数据。Reader 中主要的数据成员是 <code>SequentialFile* const file_;</code>，指向<strong>支持顺序读取的日志文件</strong>。和 WritableFile 类似，SequentialFile 也是在 include&#x2F;leveldb&#x2F;env.h 中定义的抽象类接口，封装了文件系统的顺序读取操作，具体接口和实现可以参考 <a href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%96%87%E4%BB%B6">LevelDB 源码阅读：Posix 文件操作接口实现细节</a>。</p><p>Reader 类的主要方法是 <code>ReadRecord</code>，用于读取一条完整的数据，可以多次调用，顺序读取出所有的数据。读取过程如果发生一些意外数据，比如记录长度不合法、CRC 校验失败等，可以用 Reader 中定义的 Reporter 接口来记录错误信息。此外，Reader 还支持跳过文件中一定长度的数据，用于恢复数据时跳过已经读取过的数据。完整的实现在 <a href="https://github.com/google/leveldb/blob/main/db/log_reader.cc">db&#x2F;log_reader.cc</a> 中，下面详细看看。</p><h3 id="跳过开头数据"><a href="#跳过开头数据" class="headerlink" title="跳过开头数据"></a>跳过开头数据</h3><p>Reader 中有一个 last_record_offset_ 记录当前读取到的最新一条完整数据的偏移量，初始化为 0。后续每次读取到 kFullType 或者 kLastType 类型的记录时，会更新这个值。在 ReadRecord 入口处，先判断 last_record_offset_ 和 initial_offset_ 的大小，这里 initial_offset_ 在构造时传入，用于指定跳过读取的数据长度。如果 last_record_offset_ 小于 initial_offset_，则需要跳过文件中开始的 initial_offset_ 部分。这里跳过开头部分的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::SkipToInitialBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> offset_in_block = initial_offset_ % kBlockSize;</span><br><span class="line">  <span class="type">uint64_t</span> block_start_location = initial_offset_ - offset_in_block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t search a block if we&#x27;d be in the trailer</span></span><br><span class="line">  <span class="keyword">if</span> (offset_in_block &gt; kBlockSize - <span class="number">6</span>) &#123;</span><br><span class="line">    block_start_location += kBlockSize;</span><br><span class="line">  &#125;</span><br><span class="line">  end_of_buffer_offset_ = block_start_location;</span><br><span class="line">  <span class="comment">// Skip to start of first block that can contain the initial record</span></span><br><span class="line">  <span class="keyword">if</span> (block_start_location &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Status skip_status = file_-&gt;<span class="built_in">Skip</span>(block_start_location);</span><br><span class="line">    <span class="keyword">if</span> (!skip_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReportDrop</span>(block_start_location, skip_status);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个特殊的情况，如果 initial_offset_ 恰好位于一个逻辑块的末尾，这时候需要跳过这整个逻辑块。判断是否处于逻辑块的末尾比较简单，直接拿 initial_offset_ 取模逻辑块的大小(32kb)，如果剩余部分刚好在逻辑块的最后 6 个字节内，则说明处于逻辑块的尾部。注意这里跳的时候，只会跳过整个逻辑块，只保证了从 initial_offset_ 所在的<strong>逻辑块头部</strong>开始读取。可能导致读取到的第一条记录的偏移量小于 initial_offset_，这种情况在后面的 ReadPhysicalRecord 中会处理。</p><h3 id="解析一条完整数据"><a href="#解析一条完整数据" class="headerlink" title="解析一条完整数据"></a>解析一条完整数据</h3><p>ReadRecord 用于从日志文件中读取一条完整的数据，这里的完整数据可能包括多条记录，要把每一条都读出来然后拼接。</p><p>首先用 <strong>in_fragmented_record</strong> 来标记目前是否处于一个<strong>拆分的记录</strong>中，初始化为 false。然后进入一个 while 循环，不断调用 ReadPhysicalRecord 读取出记录，保存在 fragment 中，然后根据记录类型进行处理。注意这里有一个 <code>resyncing_</code>，在初始化的时候，如果有需要跳过的数据(initial_offset_&gt;0)，则会设置为 true，表示当前处于跳过数据的状态。在这种状态下，只要读取到 kFullType 类型的记录，就会更新 resyncing_ 为 false，表示跳过数据结束，开始正常读取数据。</p><p>读取数据部分，会根据当前记录的类型来判断是否需要拼接数据。</p><ul><li>如果是 kFullType 类型，说明这是一条完整的数据，直接将 fragment 设置为 result，更新 last_record_offset_；</li><li>如果是 kFirstType 类型，说明这是一条新的数据，将这条记录保存在 scratch 中，设置 in_fragmented_record 为 true；</li><li>如果是 kMiddleType 类型，说明这是一个数据的中间部分，in_fragmented_record 此时必须为 true，否则就报告错误。这时候 scratch 继续拼接新的记录。</li><li>如果是 kLastType 类型，说明这是一个数据的最后部分，in_fragmented_record 此时必须为 true，否则就报告错误。将最后部分的 fragment 拼接在 scratch 中，然后将 scratch 设置为 result，更新 last_record_offset_ 后返回。</li></ul><p>接着其实还有其他记录类型，比如 kEof 和 kBadRecord，这些都是异常情况，需要特殊处理。ReadRecord 核心逻辑如下，忽略掉部分错误处理的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::ReadRecord</span><span class="params">(Slice* record, std::string* scratch)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  record-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">bool</span> in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">  Slice fragment;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> record_type = <span class="built_in">ReadPhysicalRecord</span>(&amp;fragment);</span><br><span class="line">    <span class="keyword">if</span> (resyncing_) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (record_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> kFullType:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *record = fragment;</span><br><span class="line">        last_record_offset_ = prospective_record_offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">case</span> kFirstType:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        scratch-&gt;<span class="built_in">assign</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        in_fragmented_record = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kMiddleType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(1)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kLastType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(2)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">          *record = <span class="built_in">Slice</span>(*scratch);</span><br><span class="line">          last_record_offset_ = prospective_record_offset;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取单个逻辑块"><a href="#读取单个逻辑块" class="headerlink" title="读取单个逻辑块"></a>读取单个逻辑块</h3><p>ReadPhysicalRecord <strong>封装了从逻辑块提取记录的过程</strong>。一个逻辑块的大小是 kBlockSize&#x3D;32KB，这个值在 <a href="https://github.com/google/leveldb/blob/main/db/log_format.h#L27">db&#x2F;log_format.h</a> 中定义。我们从磁盘读取文件的时候，<strong>以逻辑块为最小读取单元</strong>，读出来后缓存在内存中，然后逐条解析记录。这里最外层是一个 while 循环，首先判断 buffer_ 的大小，如果 buffer_ 中的数据不足以解析出一条记录(长度小于 kHeaderSize)，则从文件中读取一个逻辑块的数据到 buffer_ 中。</p><ul><li>如果从文件读取出来的长度小于 kBlockSize，说明读到了文件末尾，则设置 eof_ 为 true，然后继续进来循环，清空 buffer_ 中的数据，然后返回 kEof。</li><li>如果读文件出错，用 ReportDrop 报告读失败，清理 buffer_，设置 eof_ 为 true，然后直接返回 kEof。 </li><li>如果成功读取到 kBlockSize 的内容到 buffer_ ，则接着开始解析记录。</li></ul><p>当然，一个逻辑块 Block 中可能有多条记录，每次解析一条后 ReadPhysicalRecord 就会返回。这里返回前会更新 buffer_ 的指针，指向下一条记录的开始位置。下次重新进入 ReadPhysicalRecord 后，判断 buffer_ 中还有记录(长度大于 kHeaderSize)，则不会从文件读取，直接接着上次的位置从 buffer_ 中解析。</p><p>具体解析记录的代码和上面写记录的相反，先从 Header 中解析长度，crc32 等信息，然后把记录数据保存在 result 中，接着更新 buffer_ 的数据，指向下一条记录的开始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Reader::ReadPhysicalRecord</span><span class="params">(Slice* result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer_.<span class="built_in">size</span>() &lt; kHeaderSize) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* header = buffer_.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">4</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">5</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> type = header[<span class="number">6</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    buffer_.<span class="built_in">remove_prefix</span>(kHeaderSize + length);    <span class="comment">// 指向下一条记录的开始位置</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *result = <span class="built_in">Slice</span>(header + kHeaderSize, length);</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面代码注释了一些异常处理部分逻辑，比如记录长度不合法，CRC 校验失败。这里的异常处理主要是通过 Reporter 接口来记录错误信息，然后清空 buffer_。这样即使在读取过程中发生了一些异常，最多只影响当前 buffer_ 解析，不会影响后续逻辑块的读取和解析。</p><p>还有一种异常是<strong>当前记录位于跳过的 initial_offset_ 范围内</strong>，这是因为前面我们跳过的时候，只跳过整个逻辑块，保证从 initial_offset_ <strong>所在的逻辑块头部</strong>开始读。如果当前记录的偏移量小于 initial_offset_，则说明这条记录是需要跳过的，调整 buffer_ 的开始部分，然后返回 kBadRecord。</p><h2 id="WAL-读写测试"><a href="#WAL-读写测试" class="headerlink" title="WAL 读写测试"></a>WAL 读写测试</h2><p><a href="https://github.com/google/leveldb/blob/main/db/log_test.cc">db&#x2F;log_test.cc</a> 中提供了一些工具辅助类和函数，以及详细的测试用例，来完整测试这里的 WAL 日志读写。比如用 BigString 生成指定长度的字符串，LogTest 类封装了 Reader 和 Writer 的读写逻辑，暴露了方便测试的接口，比如 Write、ShrinkSize、Read 等。此外这里没有直接读取文件，而是自己实现了 StringSource 类，继承自 SequentialFile，用 string 模拟读文件。实现了 StringDest 类，继承自 WritableFile，也是用 string 模拟写文件。</p><p>下面是一些正常读写的测试 case：</p><ul><li>Empty：测试直接读空文件，返回 EOF。</li><li>ReadWrite：测试简单的写入和读取，确保写入的数据能够正确读取。这里写入了一个空字符串，也是能正常读出来。</li><li>ManyBlocks：测试写入大量不同长度字符串，占用多个逻辑块。然后逐条读取，确保能够正确读取。</li><li>Fragmentation：测试写入超大的字符串，每条数据需要占用多条记录。然后逐条读取，确保能够正确读取。</li></ul><p>此外还构造了一些异常情况的测试 case，比如 TruncatedTrailingRecordIsIgnored 在 LevelDB 的日志系统中用于验证对<strong>日志文件末尾被截断的记录</strong>的处理。当日志文件的最后一个记录未能完整写入（例如，由于系统崩溃或者其他写入中断事件）时，这个不完整的记录会被忽略而不是被视为一个错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(LogTest, TruncatedTrailingRecordIsIgnored) &#123;</span><br><span class="line">  <span class="built_in">Write</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="built_in">ShrinkSize</span>(<span class="number">4</span>);  <span class="comment">// Drop all payload as well as a header byte</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;EOF&quot;</span>, <span class="built_in">Read</span>());</span><br><span class="line">  <span class="comment">// Truncated last record is ignored, not treated as an error.</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">0</span>, <span class="built_in">DroppedBytes</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;&quot;</span>, <span class="built_in">ReportMessage</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BadLength 用来验证在处理记录长度字段被破坏（corrupted）的情况下的行为。测试确保日志系统能正确识别并且忽略由于<strong>记录长度字段错误导致的不合法记录</strong>，同时能够继续读取之后的有效记录，并且报告适当的错误信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(LogTest, BadLength) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> kPayloadSize = kBlockSize - kHeaderSize;</span><br><span class="line">  <span class="built_in">Write</span>(<span class="built_in">BigString</span>(<span class="string">&quot;bar&quot;</span>, kPayloadSize));</span><br><span class="line">  <span class="built_in">Write</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="comment">// Least significant size byte is stored in header[4].</span></span><br><span class="line">  <span class="built_in">IncrementByte</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;foo&quot;</span>, <span class="built_in">Read</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kBlockSize, <span class="built_in">DroppedBytes</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;OK&quot;</span>, <span class="built_in">MatchError</span>(<span class="string">&quot;bad record length&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用 IncrementByte 把第 4 个字节地方的值加 1，该位置存储的是记录的长度信息，因此导致记录长度增加。在读取的时候，会发现记录长度不合法，然后报告错误信息。校验长度部分逻辑在 ReadPhysicalRecord 中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kHeaderSize + length &gt; buffer_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  <span class="type">size_t</span> drop_size = buffer_.<span class="built_in">size</span>();</span><br><span class="line">  buffer_.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">if</span> (!eof_) &#123;</span><br><span class="line">    <span class="built_in">ReportCorruption</span>(drop_size, <span class="string">&quot;bad record length&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kBadRecord;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> kEof;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还构造了大量的测试 case，用来验证初始跳过长度。这里封装了一个函数 CheckInitialOffsetRecord，来验证初始跳过长度的记录是否被正确跳过。这个函数会写入一些记录，然后设置 initial_offset_ 来读取记录，验证是否跳过了 initial_offset_ 长度的记录。</p><p>通过大量的测试用例，保证了 WAL 日志的读写逻辑的正确性。这里的测试用例也是非常值得学习的，可以帮助我们更好地理解 WAL 日志的读写逻辑。</p>]]></content>
    
    
    <summary type="html">探讨 LevelDB 的WAL（Write-Ahead Logging）日志读写接口。详细分析 WAL日志的写入过程，包括数据切分、记录格式和存储方式，同时阐述了日志读取的复杂逻辑，如何处理跨块记录和异常情况。还展示了相关的测试用例，验证WAL日志在各种场景下的正确性。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB Explained -  Understanding Advanced C++ Techniques</title>
    <link href="https://selfboot.cn/en/2024/08/13/leveldb_source_unstand_c++/"/>
    <id>https://selfboot.cn/en/2024/08/13/leveldb_source_unstand_c++/</id>
    <published>2024-08-13T21:00:00.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>The overall code of LevelDB is quite understandable, <strong>without using many esoteric C++ techniques</strong>. However, there are some implementations that are relatively uncommon, such as flexible arrays, symbol exporting for linking, and Pimpl class design. This article will review these advanced C++ techniques to help better understand the implementation of LevelDB.</p><h2 id="Flexible-Arrays"><a href="#Flexible-Arrays" class="headerlink" title="Flexible Arrays"></a>Flexible Arrays</h2><p>In the LRUHandle structure definition in <a href="https://github.com/google/leveldb/blob/main/util/cache.cc">util&#x2F;cache.cc</a>, there’s a flexible array member <code>char key_data[1]</code>, used to implement <strong>variable-length data structures</strong> in C&#x2F;C++.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LRUHandle</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>In this handle structure, <code>key_data[1]</code> is actually just a placeholder. The space actually allocated to <code>key_data</code> is larger than 1 byte, determined by the total_size calculated during malloc. Specifically, in LevelDB’s implementation, when inserting a new cache entry, memory is dynamically allocated based on the length of the key, and then the content of the key is copied into this memory. The code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash, <span class="type">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">void</span> (*deleter)(<span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// Calculate the total memory size needed. Note that 1 is subtracted here because key_data[1] is a placeholder, already having one byte</span></span><br><span class="line">  LRUHandle* e = <span class="built_in">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  <span class="comment">// Copy key data into key_data</span></span><br><span class="line">  std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// ... omitted</span></span><br></pre></td></tr></table></figure><p>The code above allocates <strong>contiguous memory</strong> for both the LRUHandle structure and the trailing key_data array in a single malloc call. This avoids allocating memory separately for the key data, thereby <strong>reducing additional memory allocation overhead and potential memory fragmentation issues</strong>. At the same time, the entire data structure of LRUHandle is compactly stored in a contiguous block of memory, improving space utilization and potentially enhancing cache locality. If std::vector or std::string were used instead, it would require two memory allocations for each LRUHandle object: one for the LRUHandle object itself, and one for the dynamically allocated memory by std::vector or std::string to store the data. In a high-performance database implementation, such memory allocation overhead is not negligible.</p><p>Furthermore, the array length at the end of the structure here is 1. In many other code examples, <strong>the trailing array length is 0 or not written at all</strong>. What’s the difference between these two methods? In fact, both approaches are used to add variable-length data at the end of a structure. <code>char key_data[];</code> is a more explicit way of declaring a trailing array, directly indicating that the array itself doesn’t allocate any space, introduced in the C99 standard. However, this declaration is not legal in some standard C++ versions, although some compilers may support it as an extension. In C++, to avoid compatibility issues, it’s usually recommended to use <code>char key_data[1];</code>, as it typically has better support in compilers.</p><p>There are some discussions about this that you can refer to: <a href="https://stackoverflow.com/questions/14643406/whats-the-need-of-array-with-zero-elements">What’s the need of array with zero elements?</a> and <a href="https://stackoverflow.com/questions/4559558/one-element-array-in-struct">One element array in struct</a>.</p><h2 id="Symbol-Exporting-for-Linking"><a href="#Symbol-Exporting-for-Linking" class="headerlink" title="Symbol Exporting for Linking"></a>Symbol Exporting for Linking</h2><p>In many classes in include&#x2F;leveldb, such as the <a href="https://github.com/google/leveldb/blob/main/include/leveldb/db.h#L46">DB class</a> in <a href="https://github.com/google/leveldb/blob/main/include/leveldb/db.h">db.h</a>, the definition includes a macro <code>LEVELDB_EXPORT</code>, as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> DB &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The definition of this macro is in <a href="https://github.com/google/leveldb/blob/main/include/leveldb/export.h">include&#x2F;leveldb&#x2F;export.h</a>, with many compilation option branches. For ease of reading, indentation has been added below (the actual code doesn’t have it):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LEVELDB_EXPORT)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_SHARED_LIBRARY)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> defined(_WIN32)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_COMPILE_LIBRARY)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __declspec(dllexport)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __declspec(dllimport)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(LEVELDB_COMPILE_LIBRARY)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span>  <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_COMPILE_LIBRARY)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __attribute__((visibility(<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span>  <span class="comment">// defined(LEVELDB_SHARED_LIBRARY)</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(LEVELDB_EXPORT)</span></span></span><br></pre></td></tr></table></figure><p>We know that leveldb itself doesn’t provide database services like MySQL or PostgreSQL; it’s just a library that we can link to for reading and writing data. To export leveldb as a dynamic link library, it’s necessary to control the visibility and linking attributes of symbols. To support cross-platform builds, different attributes are specified based on different platform information.</p><p>On Linux systems, when compiling the library, if LEVELDB_COMPILE_LIBRARY is defined, the <code>__attribute__((visibility(&quot;default&quot;)))</code> attribute will be added. This sets the linking visibility of the symbol to default, so that other code linking to this shared library can use this class.</p><p>What’s the problem if we don’t use this macro to export symbols? In the Linux environment, <strong>all symbols are visible by default</strong>, which will export more symbols. This not only increases the size of the library but may also conflict with symbols in other libraries. Hiding some symbols that are not intended for public use can help the linker optimize the program, <strong>improving loading speed and reducing memory usage</strong>. Moreover, through export macros, we can explicitly control which interfaces are public and which are private, <strong>hiding implementation details to achieve good encapsulation</strong>.</p><p>When <code>LEVELDB_SHARED_LIBRARY</code> is not defined, the LEVELDB_EXPORT macro <strong>is defined as empty</strong>, which means that when leveldb is compiled as a static library, all symbols that might otherwise need special export&#x2F;import markers don’t need such markers. In the case of static linking, symbol exporting is not necessary for the linking process because the code of the static library will be directly included in the final binary file during compilation.</p><h2 id="Pimpl-Class-Design"><a href="#Pimpl-Class-Design" class="headerlink" title="Pimpl Class Design"></a>Pimpl Class Design</h2><p>In many classes in LevelDB, there is only one private member variable of pointer type. For example, in the TableBuild class definition in the include&#x2F;leveldb&#x2F;table_builder.h header file, there is a private member variable Rep *rep_, which is a pointer to the Rep structure:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Rep</span>;</span><br><span class="line"> Rep* rep_;</span><br></pre></td></tr></table></figure><p>Then in the <a href="https://github.com/google/leveldb/blob/main/table/table_builder.cc">table&#x2F;table_builder.cc</a> file, the Rep structure is defined:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TableBuilder</span>::Rep &#123;</span><br><span class="line">  <span class="built_in">Rep</span>(<span class="type">const</span> Options&amp; opt, WritableFile* f)</span><br><span class="line">      : <span class="built_in">options</span>(opt),</span><br><span class="line">        <span class="built_in">index_block_options</span>(opt),</span><br><span class="line">        <span class="built_in">file</span>(f),</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><strong>Why not directly define the Rep structure in the header file</strong>? In fact, this is using the <strong>Pimpl (Pointer to Implementation)</strong> design pattern, which has several advantages:</p><ul><li><strong>Binary compatibility</strong> (ABI stability). When the TableBuilder class library is updated, as long as its interface (.h file) remains unchanged, even if members are added to the Rep structure in the implementation or the implementation of the interface is changed, applications depending on this library <strong>only need to update the dynamic library file, without recompilation</strong>. If binary compatibility is not achieved, for example, if some member variables are added to a public class, and the application only updates the dynamic library without recompiling, it will cause the program to crash at runtime due to inconsistent object memory distribution. You can refer to a similar problem encountered in a previous business scenario, <a href="https://selfboot.cn/2024/03/15/object_memory_coredump/">Analysis of C++ Process Coredump Caused by Missing Bazel Dependencies</a>.</li><li><strong>Reduced compilation dependencies</strong>. If the definition of the Rep structure is in the header file, any modification to the Rep structure would cause files that include table_builder.h to be recompiled. By putting the definition of the Rep structure in the source file, only table_builder.cc needs to be recompiled.</li><li><strong>Separation of interface and implementation</strong>. The interface (public methods defined in the .h file) and the implementation (the Rep structure and specific implementation defined in the .cc file) are completely separate. This allows developers to freely modify implementation details, such as adding new private member variables or modifying internal logic, without changing the public interface.</li></ul><p><strong>Why do these advantages exist after using member pointers</strong>? This comes down to the memory layout of C++ objects. The layout of an object of a class in memory is contiguous and directly includes all of its non-static member variables. If the member variables are simple types (like int, double, etc.) or objects of other classes, these members will be directly embedded into the object’s memory layout. You can refer to my previous article <a href="https://selfboot.cn/2024/05/10/c++_object_model/">In-depth Understanding of C++ Object Memory Layout with Examples</a> for more information.</p><p>When a member variable is a pointer to another class, its layout in memory is just a pointer (Impl* pImpl), not the specific class object. The <strong>size and alignment of this pointer are fixed, regardless of what data Impl contains</strong>. Therefore, no matter how the internal implementation of the class corresponding to the pointer changes (e.g., adding or removing data members, changing the types of members, etc.), the size and layout of the external class remain unchanged and unaffected.</p><p>In “Effective C++”, Item 31 mentions using this approach to reduce compilation dependencies:</p><blockquote><p>If you can accomplish a task with object references or pointers, don’t use objects. You can define references and pointers to a type with just a type declaration; but if you define objects of a type, you need the type’s definition.</p></blockquote><p>Of course, there’s no silver bullet in software development, and these advantages come with corresponding costs. Refer to <a href="https://en.cppreference.com/w/cpp/language/pimpl">cppreference.com: PImpl</a>:</p><ul><li><strong>Lifecycle management overhead (Runtime Overhead)</strong>: Pimpl typically requires dynamically allocating memory on the heap to store the implementation object (Impl object). This dynamic allocation is <strong>slower than allocating objects on the stack</strong> (usually a faster allocation method) and involves more complex memory management. Additionally, allocating memory on the heap can cause memory leaks if not released. However, in the above example, Rep is allocated during object construction and released during destruction, so it won’t cause memory leaks.</li><li><strong>Access overhead</strong>: Each time a private member function or variable is accessed through Pimpl, it requires indirect access through a pointer.</li><li><strong>Space overhead</strong>: Each class using Pimpl will add at least one pointer’s worth of space overhead in its object to store the implementation pointer. If the implementation part needs to access public members, additional pointers may be needed or pointers may need to be passed as parameters.</li></ul><p>Overall, Pimpl is a good design pattern for basic libraries. You can also refer to <a href="https://stackoverflow.com/questions/8972588/is-the-pimpl-idiom-really-used-in-practice">Is the PIMPL idiom really used in practice?</a> for more discussion.</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p><code>constexpr</code> specifies variables or functions used to declare constant expressions. The purpose of this declaration is to inform the compiler that <strong>this value or function is known at compile time</strong>, allowing for more optimization and checks during compilation.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kCacheSize = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>Compared to const, constexpr emphasizes compile-time constants, while const variables are initialized at the time of declaration, but they <strong>don’t necessarily have to be determined at compile time</strong>, usually just indicating that they cannot be modified at runtime.</p>]]></content>
    
    
    <summary type="html">This article delves into the advanced C++ techniques used in LevelDB, including flexible arrays, symbol exporting for linking, and the Pimpl class design. Through specific code examples, it explains in detail how to implement variable-length data structures using flexible arrays, optimizing memory usage and reducing memory fragmentation. It also introduces different methods of symbol exporting and their importance for cross-platform compilation, as well as the application of the Pimpl design pattern in encapsulation and binary compatibility.</summary>
    
    
    
    <category term="Source Code Analysis" scheme="https://selfboot.cn/categories/Source-Code-Analysis/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB 源码阅读：理解其中的 C++ 高级技巧</title>
    <link href="https://selfboot.cn/2024/08/13/leveldb_source_unstand_c++/"/>
    <id>https://selfboot.cn/2024/08/13/leveldb_source_unstand_c++/</id>
    <published>2024-08-13T21:00:00.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 整体代码还是比较好懂，<strong>没有用很多 C++奇淫技巧</strong>。不过还是有部分实现，相当比较少见，比如柔性数组、链接符号导出、Pimpl 类设计等。本文会梳理这里的 C++ 高级技巧，帮助更好地理解 LevelDB 的实现。</p><h2 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h2><p>在 <a href="https://github.com/google/leveldb/blob/main/util/cache.cc">util&#x2F;cache.cc</a> 的 LRUHandle 结构体定义中，有一个柔性数组(<strong>flexible array member</strong>) <code>char key_data[1]</code>，用来在 C&#x2F;C++ 中实现<strong>可变长数据结构</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LRUHandle</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>在这个 handle 结构体中，<code>key_data[1]</code>实际上只是一个占位符，真正分配给<code>key_data</code>的空间要比 1 字节大，它由 malloc 时计算的total_size确定。具体到 LevelDB 的实现中，在插入新的缓存条目时，会根据 key 的长度动态分配内存，然后将 key 的内容拷贝到这块内存中。如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash, <span class="type">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">void</span> (*deleter)(<span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 计算好一共需要的内存大小, 注意这里减去 1 是因为 key_data[1] 是一个占位符，本来已经有一个字节了</span></span><br><span class="line">  LRUHandle* e = <span class="built_in">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  <span class="comment">// 复制 key 数据到 key_data 中</span></span><br><span class="line">  std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// ... 忽略</span></span><br></pre></td></tr></table></figure><p>上面代码在单个 malloc 调用中同时为 LRUHandle 结构体和尾部的 key_data 数组<strong>分配连续的内存</strong>。避免了为键数据单独分配内存，从而<strong>减少了额外的内存分配开销和潜在的内存碎片问题</strong>。同时 LRUHandle 的整个数据结构紧凑地存储在一块连续的内存中，提高了空间利用率，还可能改善缓存局部性（cache locality）。如果改为使用 std::vector 或 std::string，将需要为每个 LRUHandle 对象分配两次内存：一次是为LRUHandle对象本身，一次是std::vector或std::string为存储数据动态分配的内存。在一个高性能的数据库实现中，这种内存分配的开销是不容忽视的。</p><p>另外，这里结构体尾部的数组长度为 1，还有不少代码中，<strong>尾部数组长度为 0 或者直接不写</strong>，这两种方法有啥区别吗？其实这两种做法都用于在结构体末尾添加可变长度的数据，<code>char key_data[];</code>是一种更明确的尾部数组声明方式，直接表示数组本身没有分配任何空间，是在C99标准中引入。不过这种声明在某些标准 C++ 版本中并不合法，尽管一些编译器可能作为扩展支持它。在C++中，为了避免兼容性问题，通常推荐使用<code>char key_data[1];</code>，因为在编译器中通常有更好的支持。</p><p>这里有一些讨论，也可以看看：<a href="https://stackoverflow.com/questions/14643406/whats-the-need-of-array-with-zero-elements">What’s the need of array with zero elements?</a> 和 <a href="https://stackoverflow.com/questions/4559558/one-element-array-in-struct">One element array in struct</a> 。</p><h2 id="链接符号导出"><a href="#链接符号导出" class="headerlink" title="链接符号导出"></a>链接符号导出</h2><p>在 include&#x2F;leveldb 中的很多类，比如 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/db.h">db.h</a> 中的 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/db.h#L46">DB 类</a>， 定义的时候带有一个宏 <code>LEVELDB_EXPORT</code>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> DB &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里宏的定义在 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/export.h">include&#x2F;leveldb&#x2F;export.h</a> 中，有许多编译选项分支，为了方便看，下面加了缩进(实际代码没有)，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LEVELDB_EXPORT)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_SHARED_LIBRARY)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> defined(_WIN32)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_COMPILE_LIBRARY)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __declspec(dllexport)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __declspec(dllimport)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(LEVELDB_COMPILE_LIBRARY)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span>  <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_COMPILE_LIBRARY)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __attribute__((visibility(<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span>  <span class="comment">// defined(LEVELDB_SHARED_LIBRARY)</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(LEVELDB_EXPORT)</span></span></span><br></pre></td></tr></table></figure><p>我们知道 leveldb 本身不像 mysql、postgres 一样提供数据库服务，它只是一个库，我们可以链接这个库来读写数据。为了将 leveldb 导出为动态链接库，需要控制符号的可见性和链接属性。为了支持跨平台构建，这里根据不同的平台信息来指定不同的属性。</p><p>在 Linux 系统上，编译库时如果有定义 LEVELDB_COMPILE_LIBRARY，则会加上 <code>__attribute__((visibility(&quot;default&quot;)))</code> 属性。它会将符号的链接可见性设置为默认的，这样其他链接到这个共享库的代码都可以使用这个类。</p><p>如果不加这个宏来导出符号有什么问题吗？在 Linux 环境下，<strong>所有符号默认都是可见的</strong>，这样会导出更多的符号，这不仅会导致库的尺寸增大，还可能与其他库中的符号发生冲突。而隐藏部分不对外公开的符号则可以帮助链接器优化程序，<strong>提高加载速度，减少内存占用</strong>。此外，通过导出宏，可以显式地控制哪些接口是公共的，哪些是私有的，<strong>隐藏实现细节实现良好的封装</strong>。</p><p>在没有定义 <code>LEVELDB_SHARED_LIBRARY</code> 的时候，LEVELDB_EXPORT 宏<strong>被定义为空</strong>，这意味着当 leveldb  被编译为静态库时，所有原本可能需要特殊导出导入标记的符号都不需要这样的标记了。静态链接的情况下，符号导出对于链接过程不是必需的，因为静态库的代码在编译时会直接被包含到最终的二进制文件中。</p><h2 id="Pimpl-类设计"><a href="#Pimpl-类设计" class="headerlink" title="Pimpl 类设计"></a>Pimpl 类设计</h2><p>在 LevelDB 的许多类中，都是只有一个指针类型的私有成员变量。比如 include&#x2F;leveldb&#x2F;table_builder.h 头文件的 TableBuild 类定义中，有私有成员变量 Rep *rep_，它是一个指向 Rep 结构体的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Rep</span>;</span><br><span class="line"> Rep* rep_;</span><br></pre></td></tr></table></figure><p>然后在 <a href="https://github.com/google/leveldb/blob/main/table/table_builder.cc">table&#x2F;table_builder.cc</a> 文件中定义了 Rep 结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TableBuilder</span>::Rep &#123;</span><br><span class="line">  <span class="built_in">Rep</span>(<span class="type">const</span> Options&amp; opt, WritableFile* f)</span><br><span class="line">      : <span class="built_in">options</span>(opt),</span><br><span class="line">        <span class="built_in">index_block_options</span>(opt),</span><br><span class="line">        <span class="built_in">file</span>(f),</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里<strong>为什么不直接在头文件中定义 Rep 结构体</strong>呢？其实这里是使用了 <strong>Pimpl(Pointer to Implementation)</strong> 设计模式，主要有下面几个优点：</p><ul><li><strong>二进制兼容</strong>（ABI stability）。当 TableBuilder 类库更新时，只要其接口(.h 文件)保持不变，即使实现中 Rep 结构体增加成员，或者更改接口的实现，依赖该库的应用程序<strong>只用更新动态库文件，无需重新编译</strong>。如果没有做到二进制兼容，比如为公开的类增加一些成员变量，应用程序只更新动态库，不重新编译的话，运行时就会因为对象内存分布不一致，导致程序崩溃。可以参考之前业务遇到的类似问题，<a href="https://selfboot.cn/2024/03/15/object_memory_coredump/">Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析</a>。</li><li><strong>减少编译依赖</strong>。如果 Rep 结构体的定义在头文件中，那么任何对 Rep 结构体的修改都会导致包含了 table_builder.h 的文件重新编译。而将 Rep 结构体的定义放在源文件中，只有 table_builder.cc 需要重新编译。</li><li><strong>接口与实现分离</strong>。接口（在 .h 文件中定义的公共方法）和实现（在 .cc 文件中定义的 Rep 结构体以及具体实现）是完全分开的。这使得在不更改公共接口的情况下，开发者可以自由地修改实现细节，如添加新的私有成员变量或修改内部逻辑。</li></ul><p><strong>为什么使用成员指针后，会有上面的优点呢</strong>？这就要从 C++ 对象的内存布局说起，一个类的对象在内存中的布局是连续的，并且直接包含其所有的非静态成员变量。如果成员变量是简单类型（如 int、double 等）或其他类的对象，这些成员将直接嵌入到对象内存布局中。可以参考我之前的文章<a href="https://selfboot.cn/2024/05/10/c++_object_model/">结合实例深入理解 C++ 对象的内存布局</a> 了解更多内容。</p><p>当成员变量是一个指向其他类的指针，该成员在内存中的布局只有一个指针（Impl* pImpl），而不是具体的类对象。这个<strong>指针的大小和对齐方式是固定的，与 Impl 中具体包含什么数据无关</strong>。因此无论指针对应的类内部实现如何变化（例如增加或移除数据成员、改变成员的类型等），外部类的大小和布局都保持不变，也不会受影响。</p><p>在 《Effective C++》中，条款 31 就提到用这种方式来减少编译依赖：</p><blockquote><p>如果使用 object references 或 object pointers 可以完成任务，就不要使用objects。你可以只靠一个类型声明式就定义出指向该类型的 references 和 pointers；但如果定义某类型的 objects，就需要用到该类型的定义式。</p></blockquote><p>当然，软件开发没有银弹，这里的优点需要付出相应的开销，参考 <a href="https://en.cppreference.com/w/cpp/language/pimpl">cppreference.com: PImpl</a>：</p><ul><li><strong>生命周期管理开销（Runtime Overhead）</strong>: Pimpl 通常需要在堆上动态分配内存来存储实现对象（Impl 对象）。这种动态分配比<strong>在栈上分配对象（通常是更快的分配方式）慢</strong>，且涉及到更复杂的内存管理。此外，堆上分配内存，如果没有释放会造成内存泄露。不过就上面例子来说，Rep 在对象构造时分配，并在析构时释放，不会造成内存泄露。</li><li><strong>访问开销（Access Overhead）</strong>: 每次通过 Pimpl 访问私有成员函数或变量时，都需要通过指针间接访问。</li><li><strong>空间开销（Space Overhead）</strong>: 每个使用 Pimpl 的类都会在其对象中增加至少一个指针的空间开销来存储实现的指针。如果实现部分需要访问公共成员，可能还需要额外的指针或者通过参数传递指针。</li></ul><p>总的来说，对于基础库来说，Pimpl 是一个很好的设计模式。也可以参考 <a href="https://stackoverflow.com/questions/8972588/is-the-pimpl-idiom-really-used-in-practice">Is the PIMPL idiom really used in practice?</a> 了解更多讨论。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p><code>constexpr</code> 指定了用于声明常量表达式的变量或函数。这种声明的目的是告知编译器<strong>这个值或函数在编译时是已知</strong>的，这允许在编译期间进行更多的优化和检查。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kCacheSize = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>与 const 相比，constexpr 更强调编译期常量，而 const 变量在声明时就被初始化，但它们<strong>不一定非得在编译时确定</strong>，通常只是表示运行时不可修改。</p>]]></content>
    
    
    <summary type="html">深入解析了 LevelDB 中使用的 C++ 高级技巧，包括柔性数组、链接符号导出和 Pimpl 类设计等。文章通过具体代码示例详细说明了如何通过柔性数组实现可变长数据结构，优化内存使用和减少内存碎片。同时，介绍了符号导出的不同方法及其对跨平台编译的重要性，以及 Pimpl 设计模式在封装和二进制兼容性方面的应用。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB Explained - Bloom Filter Implementation and Visualization</title>
    <link href="https://selfboot.cn/en/2024/08/08/leveldb_source_bloom_filter/"/>
    <id>https://selfboot.cn/en/2024/08/08/leveldb_source_bloom_filter/</id>
    <published>2024-08-08T11:38:52.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>In LevelDB, data is stored in SSTable files. When using Get() to query a key, it may be necessary to read multiple blocks from the SST file. To reduce disk reads, LevelDB provides a FilterPolicy strategy. If it can determine that a key is not in the current SSTable file, it can skip reading that file, thus improving query efficiency.</p><p>LevelDB supports user-defined filter policies but provides a default Bloom filter implementation. A Bloom filter is a space-efficient data structure used to determine whether an element is a member of a set. It has a certain false positive rate but no false negatives. In simple terms, <strong>if a Bloom filter determines that an element does not exist, then the element definitely does not exist; if a Bloom filter determines that an element exists, then the element may not exist</strong>.</p><span id="more"></span><p>Using a Bloom filter in LevelDB is quite simple, as shown in the following code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Options options;</span><br><span class="line">options.filter_policy = <span class="built_in">NewBloomFilterPolicy</span>(<span class="number">10</span>);</span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;/tmp/testdb&quot;</span>, &amp;db);</span><br><span class="line"><span class="comment">// ... use the database ...</span></span><br><span class="line"><span class="keyword">delete</span> db;</span><br><span class="line"><span class="keyword">delete</span> options.filter_policy;</span><br></pre></td></tr></table></figure><p>So what are the principles behind Bloom filters? And how are they implemented in LevelDB? Let’s take a look together in this article.</p><h2 id="LevelDB-Interface-Definition"><a href="#LevelDB-Interface-Definition" class="headerlink" title="LevelDB Interface Definition"></a>LevelDB Interface Definition</h2><p>Before delving into the implementation details of Bloom filters, let’s first look at how LevelDB defines the filter interface.</p><p>LevelDB <strong>defines the interface for filter policies</strong> in <a href="https://github.com/google/leveldb/blob/main/include/leveldb/filter_policy.h">filter_policy.h</a>. FilterPolicy itself is an abstract class that defines 3 pure virtual functions as interfaces. It cannot be instantiated directly and must be implemented by subclasses.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">FilterPolicy</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, <span class="type">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::string* dst)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; filter)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>All three of these interfaces are important, and the code comments explain them in detail:</p><ul><li>Name(): Returns the name of the filter policy, which is <strong>very important for version compatibility</strong>. If the implementation of the filter policy (i.e., data structure or algorithm) changes, potentially causing incompatibility with old versions, the returned name should reflect this change to prevent old filter policies from being used incorrectly.</li><li>CreateFilter(): Used to create a filter, i.e., adding all keys in keys to the filter and then saving the content in dst.</li><li>KeyMayMatch(): Used to determine if a key exists in the filter, where filter is the dst generated by CreateFilter(). If the key exists in the filter, it must return true. <strong>If it doesn’t exist, it can return either true or false, but the probability of returning false should be as high as possible</strong>.</li></ul><p>Additionally, a factory function is provided to create a Bloom filter instance. However, one drawback is that after using the returned filter policy instance, you need to remember to manually release the resources. The use of a factory function here <strong>allows library maintainers to change the object creation process without affecting existing client code</strong>. For example, if a more efficient Bloom filter implementation is developed in the future, <strong>the factory function can simply be modified to return the new implementation without needing to modify the code that calls it. This provides convenience for future expansion and maintenance</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LEVELDB_EXPORT <span class="type">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="type">int</span> bits_per_key)</span></span>;</span><br></pre></td></tr></table></figure><p>By defining the filter policy interface and using a factory function, developers can easily implement different filter policies. To implement a new filter policy, you only need to inherit the <code>FilterPolicy</code> class and implement the corresponding methods. For the caller, they only need to pass the new filter policy to the <code>Options</code> object, and the overall changes will be relatively simple.</p><h2 id="Bloom-Filter-Principles"><a href="#Bloom-Filter-Principles" class="headerlink" title="Bloom Filter Principles"></a>Bloom Filter Principles</h2><p>LevelDB implemented its own Bloom filter as the default filter policy. Before we start looking at the implementation code, let’s first understand the principles of Bloom filters.</p><p>In 1970, Burton Howard Bloom created the <a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a>, an efficient data structure, to check whether an English word is in the dictionary for a spell checker. Its core is an m-bit bit array and k hash functions. The core operations are as follows:</p><ol><li>Initialization: At the start, the Bloom filter is an array of m bits, with each bit set to 0.</li><li>Adding elements: When adding an element to the Bloom filter, first use k hash functions to hash the element, producing k array position indices, then set all these positions to 1.</li><li>Querying elements: To check if an element is in the Bloom filter, use the same k hash functions to hash the element, obtaining k indices. If all these indices correspond to bits that are 1, then <strong>the element may exist in the set</strong>; if any bit is 0, then <strong>the element definitely does not exist in the set</strong>.</li></ol><p>From the above description, we can see that the time required to add or check whether an element is in the set is a fixed constant $ O( k )$, completely independent of the number of elements already in the set. Compared to other data structures representing sets, such as hash tables, balanced binary trees, skip lists, etc., in addition to fast lookup speed, Bloom filters are also very space-efficient as they don’t need to store the elements themselves, saving considerable space.</p><p>However, Bloom filters also have drawbacks. Careful consideration of the above process reveals that <strong>the query results of Bloom filters can be false positives</strong>. Bloom filters use multiple hash functions to process each element, setting multiple resulting positions to 1, <strong>and these positions may overlap with the hash results of other elements</strong>. Suppose a key does not exist in the set, but its hash results overlap with the hash results of other elements. In this case, the Bloom filter would determine that this key exists in the set, which is known as a false positive.</p><p>The probability that a Bloom filter incorrectly determines an element exists when it actually does not is called the false positive rate. Intuitively, <strong>for a fixed number k of hash functions, the larger the array size m, the fewer hash collisions, and thus the lower the false positive rate</strong>. To design a good Bloom filter ensuring a very low false positive rate, this qualitative analysis is not enough; we need to perform mathematical derivation for quantitative analysis.</p><h3 id="Mathematical-Derivation"><a href="#Mathematical-Derivation" class="headerlink" title="Mathematical Derivation"></a>Mathematical Derivation</h3><p>Here’s a simple derivation of the Bloom filter error rate calculation. You can skip this part and directly read the <a href="#LevelDB-Implementation">LevelDB Implementation</a> section. Assume the bit array size of the Bloom filter is $( m )$, the number of hash functions is $( k )$, and $( n )$ elements have been added to the filter. We assume that the hash functions we use are very random, so <strong>we can assume that the hash functions choose positions in the array with equal probability</strong>. During the insertion of elements, the probability of a certain bit being set to 1 by a certain hash function is $( \frac{1}{m} )$, and the probability of not being set to 1 is $( 1 - \frac{1}{m} )$.</p><p>$ k $ is the number of hash functions, and the hash functions we choose are uncorrelated and independent of each other. So the probability of <strong>a bit not being set to 1 by any hash function</strong> is:</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{k}} $$</p><p>Next is a mathematical trick. The natural logarithm $ e $ has an identity:</p><p>$$ {\displaystyle \lim _{m\to \infty }\left(1-{\frac {1}{m}}\right)^{m}&#x3D;{\frac {1}{e}}} $$</p><p>For relatively large m, we can deduce:</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{k}&#x3D;\left(\left(1-{\frac {1}{m}}\right)^{m}\right)^{k&#x2F;m}\approx e^{-k&#x2F;m}} $$</p><p>We have inserted n elements, so the probability of a certain bit not being set to 1 is:</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{kn}\approx e^{-kn&#x2F;m}} $$</p><p>Therefore, the probability of a certain bit being set to 1 is:</p><p>$$ {\displaystyle 1-\left(1-{\frac {1}{m}}\right)^{kn}\approx 1-e^{-kn&#x2F;m}} $$</p><p>Assuming an element is not in the set, the probability that all k bits are set to 1 is:</p><p>$$ {\displaystyle \left(1-e^{-kn&#x2F;m}\right)^{k}} $$</p><h3 id="Parameter-Selection"><a href="#Parameter-Selection" class="headerlink" title="Parameter Selection"></a>Parameter Selection</h3><p>From the above derivation, we can see that the false positive rate is related to the number of hash functions $ k $, the size of the bit array $ m $, and the number of added elements $ n $.</p><ul><li>$ n $ is usually determined by the application scenario, representing the <strong>expected total number of elements to be inserted into the Bloom filter</strong>. It can be predicted, determined by external factors, and is not easily adjustable.</li><li>Increasing $ m $ can directly reduce the false positive rate, but this will <strong>increase the storage space requirements of the Bloom filter</strong>. In storage-constrained environments, you may not want to increase it indefinitely. Additionally, the effect of expanding $ m $ is <strong>linear</strong>, and you need to balance performance improvement with additional storage costs.</li><li>Changing $ k $ has a <strong>very significant impact on the false positive rate</strong> because it directly affects the probability of bits in the bit array being set to 1.</li></ul><p>Considering all these factors, in practical applications, $ n $ is determined by the usage scenario, while $ m $ is limited by storage costs, making adjusting $ k $ a practical and direct optimization method. Given the expected number of elements $n$ and the bit array size $m$, <strong>we need to find an appropriate k that minimizes the false positive rate</strong>.</p><p>Finding the appropriate k here is an optimization problem that can be solved mathematically. It’s quite complex, so we’ll just state the conclusion. The optimal $(k)$ is as follows:</p><p>$$ k &#x3D; \frac{m}{n} \ln 2 $$</p><h2 id="LevelDB-Implementation"><a href="#LevelDB-Implementation" class="headerlink" title="LevelDB Implementation"></a>LevelDB Implementation</h2><p>Above, we introduced the principles of Bloom filters. Now let’s see how they are specifically implemented in LevelDB. The implementation of Bloom filters in LevelDB is in <a href="https://github.com/google/leveldb/blob/main/util/bloom.cc">bloom.cc</a>, where BloomFilterPolicy inherits from FilterPolicy and implements the aforementioned interfaces.</p><h3 id="Hash-Function-Count-Selection"><a href="#Hash-Function-Count-Selection" class="headerlink" title="Hash Function Count Selection"></a>Hash Function Count Selection</h3><p>First, let’s look at the selection of the number of hash functions k. The code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="type">int</span> bits_per_key)</span> : bits_per_key_(bits_per_key) &#123;</span></span><br><span class="line">  <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">  k_ = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">  <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The bits_per_key parameter is passed in when constructing the Bloom filter, and LevelDB always passes 10. This value represents the <strong>average number of bits occupied by each key</strong>, i.e., $ \frac{m}{n} $. The 0.69 here is an approximation of $ \ln (2) $, and this coefficient comes from the optimal hash function count formula $ k &#x3D; \frac{m}{n} \ln 2 $ discussed above. Finally, some boundary protection is performed here to ensure that the value of k is between 1 and 30, avoiding k being too large and making hash calculations too time-consuming.</p><h3 id="Creating-the-Filter"><a href="#Creating-the-Filter" class="headerlink" title="Creating the Filter"></a>Creating the Filter</h3><p>Next, let’s see how the filter is created here. The <a href="https://github.com/google/leveldb/blob/main/util/bloom.cc#L28">complete code</a> is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, <span class="type">int</span> n, std::string* dst)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">  <span class="type">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">  <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">  <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">  bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">  dst-&gt;<span class="built_in">resize</span>(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">  dst-&gt;<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">  <span class="type">char</span>* array = &amp;(*dst)[init_size];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">    <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">    <span class="type">uint32_t</span> h = <span class="built_in">BloomHash</span>(keys[i]);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      array[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">      h += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First, it calculates the space needed for the bit array, based on the number of keys $ n $ and the average number of bits per key. It also considers some boundary conditions: if the resulting number of bits is too small (less than 64 bits), it sets it to 64 bits to avoid a high false positive rate. Additionally, it considers byte alignment, converting the number of bits to bytes while ensuring the total number of bits is a multiple of 8.</p><p>Next, it uses resize to increase the size of dst, <strong>allocating space for the bit array after the target string</strong>. Here, the Bloom filter <strong>is designed to be appended to existing data without overwriting or deleting existing data</strong>. The newly added space is initialized to 0 because the Bloom filter’s bit array needs to start from an all-zero state. Then k_, the number of hash functions, is added to the end of the target string dst. This value is part of the Bloom filter’s metadata and is used to determine how many hash calculations need to be performed when querying whether a key exists.</p><p>Finally, there’s the core part of the Bloom filter, calculating which bit array positions need to be set to 1. Normally, you would need to set up <strong>k hash functions, calculate k times, and then set the corresponding positions</strong>. However, LevelDB’s implementation seems different. For each key, it uses the BloomHash function to calculate the initial hash value h of the key, then sets the corresponding position. In subsequent calculations, each time it right-shifts the previous hash value by 17 bits, left-shifts by 15 bits, and then performs an OR operation to calculate delta. Then it adds delta to the previous hash value to calculate the next hash value. This way, it can obtain k hash values and then set the corresponding positions.</p><p>In the previous <a href="#Mathematical-Derivation">Mathematical Derivation</a> section, we mentioned that these <strong>k hash functions need to be random and mutually independent</strong>. Can the above method meet this requirement? The code comment mentions that it adopts the <strong>double-hashing</strong> method, referring to the analysis in <a href="https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf">[Kirsch,Mitzenmacher 2006]</a>. Although the hash values generated by double hashing are not as completely unrelated as those from completely independent hash functions, in practical applications, they provide sufficient randomness and independence to meet the requirements of Bloom filters.</p><p>The advantages here are also obvious. Double hashing can generate multiple pseudo-independent hash values from one basic hash function, without needing to implement k hashes, making the implementation very simple. Moreover, compared to multiple independent hash functions, <strong>the double hashing method reduces computational overhead because it only needs to calculate one real hash value, with the rest of the hash values obtained through simple arithmetic and bit operations</strong>.</p><h3 id="Querying-Key-Existence"><a href="#Querying-Key-Existence" class="headerlink" title="Querying Key Existence"></a>Querying Key Existence</h3><p>Finally, let’s look at how to query whether a key exists. If you understood the previous part about creating the filter, this part should be easy to understand. The <a href="https://github.com/google/leveldb/blob/main/util/bloom.cc#L56">complete code</a> is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; bloom_filter)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* array = bloom_filter.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line">  <span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> k = array[len - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line">    <span class="comment">// Consider it a match.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> h = <span class="built_in">BloomHash</span>(key);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h % bits;</span><br><span class="line">    <span class="keyword">if</span> ((array[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    h += delta;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The beginning part is just some boundary condition checks. If the filter length is less than 2, it returns false. It reads the value of k from the last byte of the filter data, which was stored when creating the filter and is used to determine how many hash calculations need to be performed. If k is greater than 30, this case is considered as possibly for future new encoding schemes, so the function directly returns true, assuming the key might exist in the set (as of 2024, no new encoding schemes have been extended here).</p><p>The next part is similar to when creating the filter. It uses the BloomHash function to calculate the hash value of the key, then performs bit rotation to generate delta, which is used to modify the hash value in the loop to simulate the effect of multiple hash functions. During this process, if any bit is 0, it indicates that <strong>the key is definitely not in the set</strong>, and the function returns false. If all relevant bits are 1, it returns true, indicating that <strong>the key might be in the set</strong>.</p><h2 id="Bloom-Filter-Testing"><a href="#Bloom-Filter-Testing" class="headerlink" title="Bloom Filter Testing"></a>Bloom Filter Testing</h2><p>The implementation of Bloom filters in LevelDB also provides complete test code, which can be found in <a href="https://github.com/google/leveldb/blob/main/util/bloom_test.cc">bloom_test.cc</a>.</p><p>First, the BloomTest class is derived from the testing::Test class, used to organize and execute test cases related to Bloom filters. Its constructor and destructor are used to create and release instances of NewBloomFilterPolicy, ensuring that each test case can run in a clean environment. The Add method is used to add keys to the Bloom filter, and Build converts the collected keys into a filter. The Matches method is used to check whether a specific key matches the filter, while the FalsePositiveRate method is used to <strong>evaluate the false positive rate of the filter</strong>.</p><p>Then there’s a series of specific test cases defined by the TEST_F macro, allowing each test case to automatically possess the methods and properties defined in the BloomTest class. The first two test cases are relatively simple:</p><ul><li>EmptyFilter: Tests an empty filter, i.e., whether the filter can correctly determine that a key does not exist when no keys have been added.</li><li>Small: Tests the case of adding a small number of keys, checking whether the filter can correctly determine if keys exist.</li></ul><p>It’s worth noting the VaryingLengths test case, which is a more complex test case used to evaluate and verify <strong>the performance and efficiency of the Bloom filter under different data scales (i.e., different numbers of keys)</strong>. By using the defined NextLength function to incrementally increase the number of keys, it tests the performance of the Bloom filter under different key set sizes. It mainly tests the following three aspects:</p><ol><li>Ensures that the size of the constructed Bloom filter is within the expected range;</li><li>Ensures that all keys added to the filter can be correctly identified as existing;</li><li>Evaluates the false positive rate (false positive rate) of the Bloom filter at different lengths, ensuring that the false positive rate does not exceed 2%. At the same time, it categorizes filters as “good” or “mediocre” based on their false positive rates, and performs statistics and comparisons on their numbers, ensuring that the number of “mediocre” filters is not too high.</li></ol><p>The complete test code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">TEST_F</span>(BloomTest, VaryingLengths) &#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="built_in">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count number of filters that significantly exceed the false positive rate</span></span><br><span class="line">  <span class="type">int</span> mediocre_filters = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> good_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> length = <span class="number">1</span>; length &lt;= <span class="number">10000</span>; length = <span class="built_in">NextLength</span>(length)) &#123;</span><br><span class="line">    <span class="built_in">Reset</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="built_in">Add</span>(<span class="built_in">Key</span>(i, buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(<span class="built_in">FilterSize</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;((length * <span class="number">10</span> / <span class="number">8</span>) + <span class="number">40</span>))</span><br><span class="line">        &lt;&lt; length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All added keys must match</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">Matches</span>(<span class="built_in">Key</span>(i, buffer)))</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Length &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;; key &quot;</span> &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check false positive rate</span></span><br><span class="line">    <span class="type">double</span> rate = <span class="built_in">FalsePositiveRate</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      std::<span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                   <span class="string">&quot;False positives: %5.2f%% @ length = %6d ; bytes = %6d\n&quot;</span>,</span><br><span class="line">                   rate * <span class="number">100.0</span>, length, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">FilterSize</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(rate, <span class="number">0.02</span>);  <span class="comment">// Must not be over 2%</span></span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0.0125</span>)</span><br><span class="line">      mediocre_filters++;  <span class="comment">// Allowed, but not too often</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      good_filters++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    std::<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Filters: %d good, %d mediocre\n&quot;</span>, good_filters,</span><br><span class="line">                 mediocre_filters);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ASSERT_LE</span>(mediocre_filters, good_filters / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here’s the result of executing the test:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_testcase.png" alt="Bloom Filter Test Results"></p><h2 id="Bloom-Filter-Visualization"><a href="#Bloom-Filter-Visualization" class="headerlink" title="Bloom Filter Visualization"></a>Bloom Filter Visualization</h2><p>Before concluding the article, let’s take a look at <a href="https://gallery.selfboot.cn/zh/algorithms/bloomfilter">a visualization demonstration of the Bloom filter</a>, which displays the principles and implementation discussed above in the form of charts, deepening our understanding.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_visualization.png" alt="Bloom Filter Visualization Demo"></p><p>In this demonstration site, you can choose different numbers of hash functions and predicted key counts. It will then automatically adjust the bit array. After that, you can add elements and check if elements are in the Bloom filter. If an element is present, the corresponding array bits will be displayed with black boxes. If it’s not present, the corresponding array bits will be displayed with red boxes. This allows for an intuitive understanding of how Bloom filters work.</p><p>Also, for ease of demonstration, clicking on a bit group will show which keys would hash to this location. In reality, Bloom filters don’t store this information; it’s stored additionally here just for demonstration purposes.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Bloom filters are an efficient data structure used to determine whether an element exists in a set. Its core is a bit array and multiple hash functions, using multiple hash calculations to set bits in the bit array. Through rigorous mathematical derivation, we can conclude that the false positive rate of Bloom filters is related to the number of hash functions, the size of the bit array, and the number of added elements. In practical applications, the false positive rate can be optimized by adjusting the number of hash functions.</p><p>LevelDB implemented a Bloom filter as the default filter policy, which can be created through a factory function, maintaining extensibility. To save hash resource consumption, LevelDB generates multiple pseudo-independent hash values through the double hashing method, then sets the corresponding bits. When querying, it also uses multiple hash calculations to determine whether a key exists in the set. LevelDB provides complete test cases to verify the correctness and false positive rate of the Bloom filter.</p><p>Additionally, to intuitively understand how Bloom filters work, I’ve created a visualization demonstration of Bloom filters here, showing the principles of Bloom filters through charts.</p>]]></content>
    
    
    <summary type="html">This article provides a detailed introduction to the basic concepts, mathematical principles, and parameter selection of Bloom filters. It analyzes the specific implementation in LevelDB&#39;s source code, including hash function selection, filter creation, and query processes. The article also showcases LevelDB&#39;s Bloom filter test cases, verifying its correctness and performance. Additionally, it offers a visual demonstration of Bloom filters to help readers intuitively understand their working principles.</summary>
    
    
    
    <category term="Source Code Analysis" scheme="https://selfboot.cn/categories/Source-Code-Analysis/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB 源码阅读：布隆过滤器原理、实现、测试与可视化</title>
    <link href="https://selfboot.cn/2024/08/08/leveldb_source_bloom_filter/"/>
    <id>https://selfboot.cn/2024/08/08/leveldb_source_bloom_filter/</id>
    <published>2024-08-08T11:38:52.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 中数据存储在 SSTable 文件中，当用 Get() 来查询 key 的时候，可能需要从 SST 文件中读取多个块。为了减少磁盘读取，LevelDB 提供了 FilterPolicy 过滤策略，如果判断出来一个 Key 不在当前 SSTable 文件中，那么就可以跳过读取该文件，从而提高查询效率。</p><p>LevelDB 支持用户自定义过滤策略，不过提供了一个默认的布隆过滤器实现。布隆过滤器是一种空间效率极高的数据结构，用于判断一个元素是否存在于一个集合中，有一定的误判率但没有漏判。简单说就是如果<strong>布隆过滤器判断一个元素不存在，那么这个元素一定不存在；如果布隆过滤器判断一个元素存在，那么这个元素可能不存在</strong>。</p><span id="more"></span><p>在 LevelDB 中使用布隆过滤器也比较简单，如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Options options;</span><br><span class="line">options.filter_policy = <span class="built_in">NewBloomFilterPolicy</span>(<span class="number">10</span>);</span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;/tmp/testdb&quot;</span>, &amp;db);</span><br><span class="line"><span class="comment">// ... use the database ...</span></span><br><span class="line"><span class="keyword">delete</span> db;</span><br><span class="line"><span class="keyword">delete</span> options.filter_policy;</span><br></pre></td></tr></table></figure><p>那么布隆过滤器的原理是什么？LevelDB 中又是怎么实现的呢？本文一起来看看。</p><h2 id="LevelDB-接口定义"><a href="#LevelDB-接口定义" class="headerlink" title="LevelDB 接口定义"></a>LevelDB 接口定义</h2><p>在开始布隆过滤器的实现细节之前，先来看看 LevelDB 中对过滤器接口的定义。</p><p>LevelDB 在 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/filter_policy.h">filter_policy.h</a> 中<strong>定义了过滤策略的接口</strong>。FilterPolicy 本身是一个抽象类，定义了 3 个纯虚函数作为接口，它不能直接实例化，而是必须由子类实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">FilterPolicy</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, <span class="type">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::string* dst)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; filter)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这 3 个接口都比较重要，代码里注释也写的非常详细，其中：</p><ul><li>Name(): 返回过滤策略的名称，<strong>对于版本兼容性非常重要</strong>。如果过滤策略的实现（即数据结构或算法）改变了，可能导致与旧版本不兼容，那么返回的名称应该反映这种改变，以防止旧的过滤策略被错误地使用。</li><li>CreateFilter(): 用于创建一个过滤器，即将 keys 中的所有 key 添加到过滤器中，然后将内容保存在 dst 中。</li><li>KeyMayMatch(): 用于判断 key 是否存在于过滤器中，这里的 filter 是 CreateFilter() 生成的 dst。如果 key 存在于过滤器中，那么一定要返回 true。<strong>如果不存在，那么可以返回 true，也可以返回 false，但是要保证返回 false 的概率要尽可能高</strong>。</li></ul><p>此外还提供了一个工厂函数，用于创建一个布隆过滤器实例。不过有个缺点就是使用完返回的过滤策略实例后，需要记得手动释放资源。这里使用工厂函数，<strong>允许库的维护者在不影响现有客户端代码的情况下更改对象的创建过程</strong>。例如，如果未来开发了一个更高效的布隆过滤器实现，<strong>可以简单地修改工厂函数以返回新的实现，而无需修改调用它的代码。这为将来的扩展和维护提供了便利</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LEVELDB_EXPORT <span class="type">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="type">int</span> bits_per_key)</span></span>;</span><br></pre></td></tr></table></figure><p>这里通过定义过滤策略接口和使用工厂函数，可以方便开发者实现不同的过滤策略。要实现一个新的过滤策略，只用继承 <code>FilterPolicy</code> 类，并实现相应的方法即可。对于调用方来说，只需要将新的过滤策略传递给 <code>Options</code> 对象即可，整体改动会比较简单。</p><h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>LevelDB 自己实现了一个布隆过滤器，作为默认的过滤策略。在开始看实现代码之前，先大致了解下布隆过滤器的原理。</p><p>1970 年布顿·霍华德·布隆（Burton Howard Bloom）为了在拼写检查器中检查一个英语单词是否在字典里，创建了<a href="https://en.wikipedia.org/wiki/Bloom_filter">布隆过滤器</a>这个高效的数据结构。它的核心是一个 m 位的位数组和 k 个哈希函数，核心操作如下：</p><ol><li>初始化：开始时，布隆过滤器是一个包含 m 位的数组，每一位都设置为 0。</li><li>添加元素：将某个元素添加到布隆过滤器中时，首先使用 k 个哈希函数对元素进行哈希处理，产生 k 个数组位置索引，然后将这些位置的位都设置为 1。</li><li>查询元素：要检查一个元素是否在布隆过滤器中，也用相同的 k 个哈希函数对该元素进行哈希，得到 k 个索引。如果所有这些索引对应的位都是 1，那么<strong>元素可能存在于集合中</strong>；如果任何一个位是 0，则<strong>元素绝对不在集合中</strong>。</li></ol><p>通过上面的描述，可以发现添加或检查元素是否在集合中所需的时间是固定常数$ O( k )$，完全独立于集合中已有的元素数量。和其他表示集合的数据结构，比如 hash 表、平衡二叉树、跳表等相比，除了查找速度快，布隆过滤器的空间效率也非常高，它不需要存储元素本身，可以节省不少空间。</p><p>不过布隆过滤器也是有缺点的，仔细思考上面过程可以发现，<strong>布隆过滤器的查询结果有可能是误判的</strong>。布隆过滤器使用多个哈希函数对每个元素进行处理，将多个结果位置的位设置为 1，<strong>这些位置可能与其他元素的哈希结果重叠</strong>。假设有个 key 并不存在于集合中，但是它的哈希结果与其他元素的哈希结果重叠，那么布隆过滤器就会判断这个 key 存在于集合中，这就是所谓的假阳性（False Positive）。</p><p>当一个元素并不在集合中时，布隆过滤器错误地判定其存在的概率，就是假阳性率（false positive rate）。直观感觉上的话，<strong>对于固定的 k 个哈希函数，数组位数 m 越大，那么哈希碰撞越少，假阳性率就越低</strong>。为了设计一个良好的布隆过滤器，保证很低的假阳性率，上面的定性分析并不够，需要进行数学推导来定量分析。</p><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>这里先简单推导一下布隆过滤器误差率计算，可以跳过这部分直接阅读<a href="#LevelDB-%E5%AE%9E%E7%8E%B0">LevelDB 实现</a>部分。假设布隆过滤器使用的位数组大小为 $( m )$，哈希函数的数量为 $( k )$，并且已经向过滤器中添加了 $( n )$ 个元素。我们用的 hash 函数都很随机，因此<strong>可以假设哈希函数以相等的概率选择数组中的位置</strong>。插入元素过程中，某个位被某个哈希函数设置为 1 的概率是 $( \frac{1}{m} )$，未被设置为 1 的概率是 $( 1 - \frac{1}{m} )$。</p><p>$ k $ 是哈希函数的数量，我们选择的每个哈希函数之间没有相关性，互相独立。所以该位<strong>未被任何哈希函数设置为 1 的概率</strong>为：</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{k}} $$</p><p>接下来是一个数学技巧，自然对数 $ e $ 有个恒等式：</p><p>$$ {\displaystyle \lim _{m\to \infty }\left(1-{\frac {1}{m}}\right)^{m}&#x3D;{\frac {1}{e}}} $$</p><p>对于比较大的 m，我们可以得出：</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{k}&#x3D;\left(\left(1-{\frac {1}{m}}\right)^{m}\right)^{k&#x2F;m}\approx e^{-k&#x2F;m}} $$</p><p>我们插入了 n 个元素，所以某个位没有被设置为 1 的概率是：</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{kn}\approx e^{-kn&#x2F;m}} $$</p><p>所以某个位被设置为 1 的概率是：</p><p>$$ {\displaystyle 1-\left(1-{\frac {1}{m}}\right)^{kn}\approx 1-e^{-kn&#x2F;m}} $$</p><p>假设某个元素不在集合中，但是 k 个位都被设置为 1 的概率是：</p><p>$$ {\displaystyle \left(1-e^{-kn&#x2F;m}\right)^{k}} $$</p><h3 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h3><p>通过上面的推导可以看出，假阳率与哈希函数的数量 $ k $、位数组的大小 $ m $ 以及添加的元素数量 $ n $ 有关。</p><ul><li>$ n $ 通常由应用场景确定，表示<strong>预期插入布隆过滤器的元素总数</strong>。可以预测，由外部因素决定，不易调整。</li><li>增加 $ m $ 可以直接减少误判率，但这会<strong>增加布隆过滤器的存储空间需求</strong>。在存储资源受限的环境中，可能不希望无限制地增加。另外扩大 $ m $ 的效果是<strong>线性的</strong>，需要平衡性能提升和额外的存储成本。</li><li>改变 $ k $ 对于<strong>误判率的影响非常显著</strong>，因为它直接影响到位数组中的位被设置为 1 的概率。</li></ul><p>综合考虑下来，在实际应用中，$ n $ 由使用场景决定，而 $ m $ 受到存储成本的限制，调整 $ k $ 成为了一个实际且直接的优化手段。在已知预期元素数量 $n$ 和位数组大小 $m$ 的情况下，<strong>需要找到一个合适的 k，使得误判率最小</strong>。</p><p>这里找到合适的 k 是一个优化问题，可以通过数学方法求解。比较复杂，这里直接说结论，最优的 $(k)$ 如下：</p><p>$$ k &#x3D; \frac{m}{n} \ln 2 $$</p><h2 id="LevelDB-实现"><a href="#LevelDB-实现" class="headerlink" title="LevelDB 实现"></a>LevelDB 实现</h2><p>上面介绍了布隆过滤器的原理，接下来看看 LevelDB 中具体是如何实现的。LevelDB 中布隆过滤器的实现在 <a href="https://github.com/google/leveldb/blob/main/util/bloom.cc">bloom.cc</a>，BloomFilterPolicy 继承了 FilterPolicy，实现了前面的接口。</p><h3 id="hash-个数选择"><a href="#hash-个数选择" class="headerlink" title="hash 个数选择"></a>hash 个数选择</h3><p>首先看这里 hash 函数个数 k 的选择，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="type">int</span> bits_per_key)</span> : bits_per_key_(bits_per_key) &#123;</span></span><br><span class="line">  <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">  k_ = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">  <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bits_per_key 这个参数在构造布隆过滤器的时候传入，LevelDB 中传的都是 10。这个值代表<strong>平均每个 key 占用的 bit 位数</strong>，即 $ \frac{m}{n} $。这里的 0.69 是 $ \ln (2) $ 的近似值，这个系数来源于上面讨论的最优哈希函数数量公式 $ k &#x3D; \frac{m}{n} \ln 2 $。最后这里进行了一些边界保护，保证 k 的取值范围在 1 到 30 之间，避免 k 过大 hash 计算太耗时。</p><h3 id="创建过滤器"><a href="#创建过滤器" class="headerlink" title="创建过滤器"></a>创建过滤器</h3><p>接下来看看这里过滤器是怎么创建的，<a href="https://github.com/google/leveldb/blob/main/util/bloom.cc#L28">完整代码</a>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, <span class="type">int</span> n, std::string* dst)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">  <span class="type">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">  <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">  <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">  bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">  dst-&gt;<span class="built_in">resize</span>(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">  dst-&gt;<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">  <span class="type">char</span>* array = &amp;(*dst)[init_size];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">    <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">    <span class="type">uint32_t</span> h = <span class="built_in">BloomHash</span>(keys[i]);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      array[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">      h += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是计算位数组需要的空间，根据键的数量 $ n $ 和每个键的平均位数计算需要的总位数。这里还考虑了些边界条件，如果得到的位数太少（少于 64 位），则设为 64 位以避免过高的误判率。另外，也考虑了字节对齐，将位数转换为字节，同时确保总位数是 8 的倍数。</p><p>接着用 resize 增加 dst 的大小，在<strong>目标字符串后面分配位数组的空间</strong>，这里布隆过滤器<strong>被设计为可以附加到现有的数据后面，而不会覆盖或删除已有数据</strong>。新增的空间会被初始化为 0，因为布隆过滤器的位数组需要从一个全零的状态开始。然后在目标字符串 dst 尾部添加 k_，即哈希函数的数量。这个值是布隆过滤器元数据的一部分，在查询键是否存在的时候用来确定需要进行多少次哈希计算。</p><p>最后是布隆过滤器的核心部分，计算哪些位数组位置需要设置为 1。正常来说需要设置 <strong>k 个 hash 函数，计算 k 次然后来设置对应位置</strong>。但是 LevelDB 的实现似乎不是这样的，对于每个键，使用 BloomHash 函数计算该键的初始哈希值 h，然后设置相应位置。之后的计算中，每次将上次的哈希值右移 17 位，左移 15 位然后进行或操作来计算 delta，然后用上次 hash 值加上 delta 来计算下一个 hash 值。这样就可以得到 k 个 hash 值，然后设置对应位置。</p><p>在前面的<a href="#%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC">数学推导</a>中提到过，这里 <strong>k 个 hash 函数要保证随机并且互相独立</strong>，上面的方法能满足这个要求吗？代码注释里提示有提到，这里是采用 <strong>double-hashing（双重哈希）</strong> 的方法，参考了 <a href="https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf">[Kirsch,Mitzenmacher 2006]</a> 的分析，虽然双重哈希生成的哈希值不如完全独立的哈希函数那样完全无关，但在实际应用中，它们提供了足够的随机性和独立性，可以满足布隆过滤器的要求。</p><p>这里的好处也是显而易见的，双重哈希可以从一个基础哈希函数生成多个伪独立的哈希值，不用实现 k 个 hash，实现上很简单。此外，与多个独立的哈希函数相比，<strong>双重哈希方法减少了计算开销，因为它只需计算一次真正的哈希值，其余的哈希值通过简单的算术和位操作得到</strong>。</p><h3 id="查询键存在"><a href="#查询键存在" class="headerlink" title="查询键存在"></a>查询键存在</h3><p>最后是查询键是否存在，如果看懂了前面的创建过滤器部分，这里就很容易理解了。<a href="https://github.com/google/leveldb/blob/main/util/bloom.cc#L56">完整代码</a> 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; bloom_filter)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* array = bloom_filter.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line">  <span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> k = array[len - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line">    <span class="comment">// Consider it a match.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> h = <span class="built_in">BloomHash</span>(key);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h % bits;</span><br><span class="line">    <span class="keyword">if</span> ((array[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    h += delta;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始部分就是一些边界条件判断，如果过滤器长度小于 2 返回 false。从过滤器数据的最后一个字节读取 k 的值，k 是在创建过滤器时存储的，用来确定需要进行多少次哈希计算。如果 k 大于 30，这种情况被视为可能用于未来新的编码方案，因此函数直接返回 true，假设键可能存在于集合中（直到 2024 年，这里也没扩展新的编码方案了）。</p><p>接下来的部分和创建过滤器的时候类似，使用 BloomHash 函数计算键的哈希值，然后进行位旋转以生成 delta，用于在循环中修改哈希值以模拟多个哈希函数的效果。在这个过程中，如果任何一个位为 0，则表明<strong>键绝对不在集合中</strong>，函数返回 false。如果所有相关位都是 1，则返回 true，表示<strong>键可能在集合中</strong>。</p><h2 id="布隆过滤器测试"><a href="#布隆过滤器测试" class="headerlink" title="布隆过滤器测试"></a>布隆过滤器测试</h2><p>LevelDB 中布隆过滤器的实现还提供了完整的测试代码，可以在 <a href="https://github.com/google/leveldb/blob/main/util/bloom_test.cc">bloom_test.cc</a> 中找到。</p><p>首先从 testing::Test 类派生 BloomTest 类，用于组织和执行与布隆过滤器相关的测试用例。其构造函数和析构函数用于创建和释放 NewBloomFilterPolicy 的实例，确保每个测试用例都能在一个干净的环境中运行。Add 方法用于向布隆过滤器添加键，Build 将收集的键转换成过滤器。Matches 方法用于检查特定键是否与过滤器匹配，而 FalsePositiveRate 方法用于<strong>评估过滤器的误判率</strong>。</p><p>接着就是一系列 TEST_F 宏定义的具体测试用例，允许每个测试用例自动拥有 BloomTest 类中定义的方法和属性。前面两个测试用例比较简单：</p><ul><li>EmptyFilter: 测试空过滤器，即没有添加任何键的情况下，过滤器是否能正确判断键不存在。</li><li>Small: 测试添加少量键的情况，检查过滤器是否能正确判断键是否存在。</li></ul><p>这里值得注意的是 VaryingLengths 测试用例，它是一个比较复杂的测试用例，来评估和验证<strong>布隆过滤器在不同数据规模（即不同数量的键）下的性能和效率</strong>。通过定义的 NextLength 函数来递增键的数量，测试在不同的键集大小下布隆过滤器的表现。主要测试下面三个方面：</p><ol><li>确保构建的布隆过滤器的大小在预期范围内;</li><li>确保所有添加到过滤器的键都能被正确地识别为存在;</li><li>评估布隆过滤器在不同长度下的误判率（假阳性率），确保误判率不超过2%。同时，根据误判率的大小分类过滤器为“好”（good）或“一般”（mediocre），并对它们的数量进行统计和比较，确保“一般”过滤器的数量不会太多。</li></ol><p>完整的测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">TEST_F</span>(BloomTest, VaryingLengths) &#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="built_in">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count number of filters that significantly exceed the false positive rate</span></span><br><span class="line">  <span class="type">int</span> mediocre_filters = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> good_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> length = <span class="number">1</span>; length &lt;= <span class="number">10000</span>; length = <span class="built_in">NextLength</span>(length)) &#123;</span><br><span class="line">    <span class="built_in">Reset</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="built_in">Add</span>(<span class="built_in">Key</span>(i, buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(<span class="built_in">FilterSize</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;((length * <span class="number">10</span> / <span class="number">8</span>) + <span class="number">40</span>))</span><br><span class="line">        &lt;&lt; length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All added keys must match</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">Matches</span>(<span class="built_in">Key</span>(i, buffer)))</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Length &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;; key &quot;</span> &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check false positive rate</span></span><br><span class="line">    <span class="type">double</span> rate = <span class="built_in">FalsePositiveRate</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      std::<span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                   <span class="string">&quot;False positives: %5.2f%% @ length = %6d ; bytes = %6d\n&quot;</span>,</span><br><span class="line">                   rate * <span class="number">100.0</span>, length, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">FilterSize</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(rate, <span class="number">0.02</span>);  <span class="comment">// Must not be over 2%</span></span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0.0125</span>)</span><br><span class="line">      mediocre_filters++;  <span class="comment">// Allowed, but not too often</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      good_filters++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    std::<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Filters: %d good, %d mediocre\n&quot;</span>, good_filters,</span><br><span class="line">                 mediocre_filters);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ASSERT_LE</span>(mediocre_filters, good_filters / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是执行测试的结果：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_testcase.png" alt="布隆过滤器测试结果"></p><h2 id="布隆过滤器可视化"><a href="#布隆过滤器可视化" class="headerlink" title="布隆过滤器可视化"></a>布隆过滤器可视化</h2><p>在结束文章之前，我们再来看下<a href="https://gallery.selfboot.cn/zh/algorithms/bloomfilter">布隆过滤器的一个可视化演示</a>，把上面的原理和实现用图表展示出来，加深理解。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_visualization.png" alt="布隆过滤器可视化演示"></p><p>这个演示站点中，可以选择不同的哈希函数数量、预测 key 的数量。然后会自动调整位数组，之后可以添加元素，并检查元素是否在布隆过滤器中。如果在的话，会用黑色方框显示相应数组位。如果不在的话，会用红色方框显示相应数组位。这样可以直观理解布隆过滤器的工作原理。</p><p>同时为了方便演示，点击位组的时候会显示有哪些 key 经过 hash 后会落在这里。实际上布隆过滤器是不会存储这些信息的，这里是额外存储的，只是为了方便演示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>布隆过滤器是一种高效的数据结构，用于判断一个元素是否存在于一个集合中。它的核心是一个位数组和多个哈希函数，通过多次哈希计算来设置位数组中的位。通过严谨的数学推导，可以得出布隆过滤器的误判率与哈希函数的数量、位数组的大小和添加的元素数量有关。在实际应用中，可以通过调整哈希函数的数量来优化误判率。</p><p>LevelDB 中实现了一个布隆过滤器，作为默认的过滤策略，可以通过工厂函数创建，保留了扩展性。为了节省 hash 资源消耗，LevelDB 通过双重哈希方法生成多个伪独立的哈希值，然后设置对应的位。在查询时，也是通过多次哈希计算来判断键是否存在于集合中。LevelDB 提供了完整的测试用例，用于验证布隆过滤器的正确性和误判率。</p><p>另外，为了直观理解布隆过滤器的工作原理，我这里还做了一个布隆过滤器的可视化演示，通过图表展示了布隆过滤器的原理。</p>]]></content>
    
    
    <summary type="html">文章详细介绍了布隆过滤器的基本概念、数学原理和参数选择，并分析了LevelDB源码中的具体实现，包括哈希函数选择、过滤器创建和查询过程。同时展示了LevelDB的布隆过滤器测试用例，验证其正确性和性能。文章还提供了布隆过滤器的可视化演示，帮助读者直观理解其工作原理。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB Explained - Preparing the Development Environment</title>
    <link href="https://selfboot.cn/en/2024/08/06/leveldb_source_prepare/"/>
    <id>https://selfboot.cn/en/2024/08/06/leveldb_source_prepare/</id>
    <published>2024-08-06T20:31:43.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB is an excellent LSM Tree storage component developed in C++. Although its overall codebase is not large, its design is ingenious and worth studying. During the process of reading the source code, I have compiled a <a href="https://selfboot.cn/en/tags/LevelDB/">series of articles</a> to gradually break down the implementation details of LevelDB. However, before reading the code, it’s best to prepare the entire development environment.</p><p>This article will start from the most basic step of pulling the code, recording my process of preparing the entire environment, including configuring the VSCode IDE and using the clangd plugin, as well as how to configure compilation options. Then, through a simple read and write code demo, we’ll briefly use LevelDB to gain a perceptual understanding of this library. Additionally, we’ll introduce how to run test cases. LevelDB’s test cases are well-written, and during the code reading process, we can use these cases to better understand the code.</p><span id="more"></span><h2 id="Source-Code-Compilation"><a href="#Source-Code-Compilation" class="headerlink" title="Source Code Compilation"></a>Source Code Compilation</h2><p>First is pulling the code. Here we use <code>git clone --recurse-submodules</code>, which can pull all submodules at once. Although LevelDB’s implementation doesn’t depend on third-party libraries, benchmark is used for pressure testing and googletest is used for functional testing, both of which are introduced as submodules.</p><p>If you encounter network issues when pulling the code, such as the following, you need to bypass the firewall first. You can refer to the methods in the article <a href="https://selfboot.cn/2023/12/25/how-to-use-chatgpt/">Safe, Fast, and Affordable Access to ChatGPT, Latest and Most Comprehensive Practical Tutorial!</a>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &#x27;/root/leveldb/third_party/googletest&#x27;...</span><br><span class="line">fatal: unable to access &#x27;https://github.com/google/googletest.git/&#x27;: GnuTLS recv error (-110): The TLS connection was non-properly terminated.</span><br><span class="line">fatal: clone of &#x27;https://github.com/google/googletest.git&#x27; into submodule path &#x27;/root/leveldb/third_party/googletest&#x27; failed</span><br><span class="line">Failed to clone &#x27;third_party/googletest&#x27;. Retry scheduled</span><br></pre></td></tr></table></figure><p>Next is compiling the entire source code. LevelDB uses cmake for building. To facilitate later code reading, we add <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=1</code> during compilation, which will generate a <code>compile_commands.json</code> file. This file is a configuration file for tools like clangd and can help IDEs like VSCode better understand the code. With this file, features like code jumping and auto-completion will work better. Additionally, to facilitate debugging with GDB, we add <code>-DCMAKE_BUILD_TYPE=Debug</code> to generate libraries with debugging information.</p><p>You can refer to the complete command below:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone --recurse-submodules  git@github.com:google/leveldb.git</span><br><span class="line"></span><br><span class="line">cd leveldb</span><br><span class="line">mkdir -p build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_INSTALL_PREFIX=$(pwd) .. &amp;&amp; cmake --build . --target install</span><br></pre></td></tr></table></figure><p>The <code>CMAKE_INSTALL_PREFIX</code> option is used to specify the installation directory. Here it’s specified as the current directory (build directory), so after compilation, the generated library files and header files will be placed in the build directory for convenient future use.</p><p>There are quite a few options for CMake building here. For example, <code>BUILD_SHARED_LIBS</code> is used to control whether the generated library is a static link library (.a file) or a dynamic link library (.so file). If <code>BUILD_SHARED_LIBS</code> is not explicitly set in CMakeLists.txt or through command-line arguments passed to CMake, CMake’s default behavior is usually not to enable shared library building. You can use <code>cmake -DBUILD_SHARED_LIBS=ON ..</code> on the command line to enable shared library building.</p><h2 id="IDE-Configuration"><a href="#IDE-Configuration" class="headerlink" title="IDE Configuration"></a>IDE Configuration</h2><p>I personally use vscode quite often. As a code IDE, vscode can be said to be very user-friendly. For C++ projects, although Microsoft provides an official <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C++ plugin</a> for convenient code jumping and other features, from my personal experience, it’s not very user-friendly. Here, I strongly recommend using clangd to read C++ code. You only need to <strong>install Clangd on the server, then install the clangd plugin in vscode, and use it in conjunction with the compile_commands.json compilation database file generated by Cmake earlier</strong>.</p><p>Clangd is a language server based on the LLVM project, mainly supporting code analysis for C and C++. It can <strong>provide code completion, diagnostics (i.e., errors and warnings), code jumping, and code formatting features</strong>. Compared to Microsoft’s built-in C++ plugin, clangd responds very quickly and can achieve more precise jumping and warnings with the help of clang. It also supports using <code>clang-tidy</code> to perform static analysis on project code to discover potential errors.</p><p>For example, in the code below, clang-tidy found a suspicious issue: <code>Suspicious usage of &#39;sizeof(A*)&#39;</code>, and also provided the clang-tidy check rule item <a href="https://clang.llvm.org/extra/clang-tidy/checks/bugprone/sizeof-expression.html">bugprone-sizeof-expression</a>, which is used to check whether the use of <code>sizeof</code> expressions is correct.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_clangd_tidy.png" alt="Suspicious spot found by clangd plugin using clang-tidy"></p><p>Here, new_list itself is a pointer to a pointer, so new_list[0] is actually a pointer. sizeof(new_list[0]) is getting the size of the pointer, not the size of the element pointed to by the pointer. However, this is the intended design here, which is to set the initial value of the new bucket to nullptr. In fact, this rule is intended to prevent errors like the following:</p><blockquote><p>A common mistake is to compute the size of a pointer instead of its pointee. These cases may occur because of explicit cast or implicit conversion.</p></blockquote><p>For example, code like this:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="built_in">sizeof</span>(A + <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> point;</span><br><span class="line"><span class="built_in">memset</span>(point, <span class="number">0</span>, <span class="built_in">sizeof</span>(&amp;point));</span><br></pre></td></tr></table></figure><p>Overall, the code quality of LevelDB is very high, with very few clang-tidy prompts. It’s a world apart from business code, so it’s very worth learning.</p><h2 id="LevelDB-Read-Modify-Write"><a href="#LevelDB-Read-Modify-Write" class="headerlink" title="LevelDB Read, Modify, Write"></a>LevelDB Read, Modify, Write</h2><p>LevelDB is <strong>not a database like MySQL</strong>, nor does it support SQL queries and other features. It’s just a <strong>fast key-value storage library</strong>. LevelDB doesn’t come with client and server code. If you need to provide storage functionality, you need to implement the corresponding logic yourself. Additionally, it only supports single-process access to a specified database and does not support multi-process access.</p><p>In the industry, LevelDB is generally used as an underlying dependency for storage components. For example, WeChat’s core storage <a href="https://github.com/Tencent/paxosstore">paxosstore</a> uses LevelDB to store data. Getting started with LevelDB is relatively simple. You just need to include the header file and then call the corresponding interfaces. The code below implements a simple command-line interface that uses the LevelDB library to read and write keys.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple_client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  leveldb::DB* db;</span><br><span class="line">  leveldb::Options options;</span><br><span class="line">  options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">  leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;./db&quot;</span>, &amp;db);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unable to open/create test database &#x27;./db&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string key;</span><br><span class="line">  std::string value;</span><br><span class="line">  std::string cmd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;leveldb&gt; &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; cmd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="string">&quot;set&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key &gt;&gt; value;</span><br><span class="line">      status = db-&gt;<span class="built_in">Put</span>(leveldb::<span class="built_in">WriteOptions</span>(), key, value);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error setting value: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;get&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key;</span><br><span class="line">      status = db-&gt;<span class="built_in">Get</span>(leveldb::<span class="built_in">ReadOptions</span>(), key, &amp;value);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;del&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key;</span><br><span class="line">      status = db-&gt;<span class="built_in">Delete</span>(leveldb::<span class="built_in">WriteOptions</span>(), key);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error deleting key: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;exit&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Unknown command. Supported commands are: set, get, del, exit&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here we use Cmake to build. You can refer to the following CMakeLists.txt file. Of course, the directories for include and lib libraries need to be changed according to the previously compiled directories.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(SimpleLevelDBExamples VERSION <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># Set build type to Debug to include debugging information</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"><span class="keyword">add_executable</span>(SimpleClient simple_client.cpp)</span><br><span class="line"><span class="keyword">include_directories</span>(../build/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(SimpleClient <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../build/libleveldb.a pthread)</span><br></pre></td></tr></table></figure><p>Then you can use <code>cmake --build .</code> to compile the binary file. Of course, if you’re not used to cmake, you can also use gcc directly, but you need to manually specify the paths for header files and library files. Then execute as shown in the image below, you can operate LevelDB in a command-line client similar to redis.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240806_leveldb_source_prepare_simpleclient.png" alt="Simple read and write command-line interface for LevelDB"></p><p>You can see LevelDB’s data storage files in the db folder of the current directory, as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> db</span> </span><br><span class="line">000005.ldb  000018.ldb  000020.ldb  000031.ldb  000036.log  CURRENT  LOCK  LOG  LOG.old  MANIFEST-000035</span><br></pre></td></tr></table></figure><p>We will explain LevelDB’s data storage method in detail later, and will also expand on the functions of these files. Let’s not go into details here.</p><h2 id="Running-Test-Cases"><a href="#Running-Test-Cases" class="headerlink" title="Running Test Cases"></a>Running Test Cases</h2><p>So far, we have compiled the LevelDB library and written a simple read and write command-line interface using LevelDB. Next, let’s look at LevelDB’s test cases. LevelDB’s core code all has corresponding test cases, such as <a href="https://github.com/google/leveldb/blob/main/util/cache_test.cc">cache_test.cc</a> in LRU cache, <a href="https://github.com/google/leveldb/blob/main/db/db_test.cc">db_test.cc</a> in db implementation, <a href="https://github.com/google/leveldb/blob/main/table/table_test.cc">table_test.cc</a> in table, and so on. The executable file <code>build/leveldb_tests</code> for test cases is generated along with the library using the previous compilation command.</p><h3 id="Dynamic-Library-Dependencies"><a href="#Dynamic-Library-Dependencies" class="headerlink" title="Dynamic Library Dependencies"></a>Dynamic Library Dependencies</h3><p>If you run <code>leveldb_tests</code> directly, it may prompt that the <code>libtcmalloc</code> dynamic library is missing. This is a memory allocator from Google Perftools, which LevelDB uses and needs to be installed on the system.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/leveldb_tests: error while loading shared libraries: libtcmalloc.so.4: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>The installation command is also simple. For example, on a debian system, you can use the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libgoogle-perftools-dev</span><br></pre></td></tr></table></figure><p>After installation, you can use <code>ldd</code> to check if it can be found. If it’s normal as follows, you can run the binary.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ldd ./build/leveldb_tests</span><br><span class="line">linux-vdso.so.1 (0x00007ffc0d1fc000)</span><br><span class="line">libtcmalloc.so.4 =&gt; /usr/local/lib/libtcmalloc.so.4 (0x00007f5277e91000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f5277c77000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f5277b98000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f5277b78000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5277997000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f52782ed000)</span><br></pre></td></tr></table></figure><p>Before installing the library, it prompted <code>libtcmalloc.so.4 =&gt; not found</code>, but after installing the dynamic library, it <strong>automatically linked</strong> to the correct path. How is this achieved? This is because the binary file contains references to dynamic libraries, especially <strong>the name of the library and the required symbols (functions or data)</strong>. The dynamic linker (usually <code>ld-linux.so</code> in Linux) is responsible for handling these references. It determines which libraries the binary file needs, and then loads the used libraries according to the specified paths and methods.</p><p>After we install the tcmalloc library, the dynamic library file libtcmalloc.so.4 is copied to the system’s library directory &#x2F;usr&#x2F;local&#x2F;lib. Then the installation program executes ldconfig to update ld.so.cache, which contains path information for libraries to speed up library lookup. This way, when running the binary again, the dynamic linker checks the cache, finds the newly installed library, and resolves all relevant symbol references, thus completing the linking.</p><h3 id="Modifying-and-Running"><a href="#Modifying-and-Running" class="headerlink" title="Modifying and Running"></a>Modifying and Running</h3><p>These functional test cases are all written using the gtest framework. We can view all the test cases using the <code>--gtest_list_tests</code> parameter. As shown in the image below:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_list_tests.png" alt="All current test cases for LevelDB"></p><p>If you run leveldb_tests directly, it will execute all the test cases. However, we can use the <code>--gtest_filter</code> parameter to specify running only certain test cases, for example, <code>--gtest_filter=&#39;CacheTest.*&#39;</code> only runs the test cases related to LRU cache. The result is as follows:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_cache_test.png" alt="Running only certain test cases"></p><p><strong>Test cases can help better understand the code logic.</strong> During the process of reading the code, sometimes we want to verify some logic, so we can modify the test cases a bit. For example, I deliberately broke a test case that could pass:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--- a/util/cache_test.cc</span><br><span class="line">+++ b/util/cache_test.cc</span><br><span class="line">@@ <span class="number">-69</span>,<span class="number">7</span> +<span class="number">69</span>,<span class="number">7</span> @@ <span class="built_in">TEST_F</span>(CacheTest, HitAndMiss) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Insert</span>(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">   <span class="built_in">ASSERT_EQ</span>(<span class="number">101</span>, <span class="built_in">Lookup</span>(<span class="number">100</span>));</span><br><span class="line">-  <span class="built_in">ASSERT_EQ</span>(<span class="number">-1</span>, <span class="built_in">Lookup</span>(<span class="number">200</span>));</span><br><span class="line">+  <span class="built_in">ASSERT_EQ</span>(<span class="number">101</span>, <span class="built_in">Lookup</span>(<span class="number">200</span>));</span><br><span class="line">   <span class="built_in">ASSERT_EQ</span>(<span class="number">-1</span>, <span class="built_in">Lookup</span>(<span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Insert</span>(<span class="number">200</span>, <span class="number">201</span>);</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>After modifying the test case, you need to recompile leveldb_tests. Because we configured the project’s compilation options during the previous compilation, CMake has already cached them, so the following command automatically uses the previous configuration items, such as -DCMAKE_BUILD_TYPE&#x3D;Debug, etc.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target leveldb_tests</span><br><span class="line"></span><br><span class="line">[  2%] Built target gtest</span><br><span class="line">[ 58%] Built target leveldb</span><br><span class="line">[ 61%] Built target gtest_main</span><br><span class="line">[ 64%] Built target gmock</span><br><span class="line">[ 65%] Building CXX object CMakeFiles/leveldb_tests.dir/util/cache_test.cc.o</span><br><span class="line">[ 67%] Linking CXX executable leveldb_tests</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target leveldb_tests</span></span><br></pre></td></tr></table></figure><p>Note that from the output above, you can see that only the modified file was recompiled here, generating a new object file <code>cache_test.cc.o</code>, so the compilation speed is very fast. After running it again, you’ll see that the test case doesn’t pass, as shown below:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_cache_test_fail.png" alt="Test case failing"></p><p>You can see the specific reason for the test case validation failure. During the process of reading the code, you can modify the test cases of some code at any time to verify whether your understanding is correct.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Following this article, everyone should be able to quickly prepare the development environment for LevelDB. After configuring the IDE, compiling the source code, running simple read and write examples and test cases, let’s start reading the source code together!</p>]]></content>
    
    
    <summary type="html">This article introduces how to prepare the development environment for LevelDB, including source code retrieval, compilation, and VSCode configuration. Through simple read and write examples, readers can gain a preliminary understanding of LevelDB. The article also explains how to use the gtest framework to run and modify test cases for better understanding of the code logic.</summary>
    
    
    
    <category term="Source Code Analysis" scheme="https://selfboot.cn/categories/Source-Code-Analysis/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB 源码阅读：准备开发环境</title>
    <link href="https://selfboot.cn/2024/08/06/leveldb_source_prepare/"/>
    <id>https://selfboot.cn/2024/08/06/leveldb_source_prepare/</id>
    <published>2024-08-06T20:31:43.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 是 C++ 开发的优秀的 LSM Tree 的存储组件，整体代码量不大，但是设计精巧，值得学习。在阅读源码过程中，整理了<a href="https://selfboot.cn/tags/LevelDB/">系列文章</a>，逐步拆解 LevelDB 的实现细节。不过在阅读代码前，最好先准备好整个开发环境。</p><p>本文会从最基本的拉取代码开始，记录自己准备整个环境的过程，包括配置 VSCode IDE 和 clangd 插件使用，以及如何配置编译选项等。然后会通过简单的读写代码 demo，来简单使用下 LevelDB，对这个库有个感性的认识。另外，还会介绍如何运行测试用例，LevelDB 的测试用例写的很好，在代码阅读过程中，可以借助用例更好的理解代码。</p><span id="more"></span><h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><p>首先是拉代码，这里使用的是 <code>git clone --recurse-submodules</code>，可以一次性拉取所有的子模块。虽然 leveldb 的实现不依赖第三方库，不过压测用到了 benchmark，功能测试用到了 googletest，这两个库都是作为子模块引入的。</p><p>如果拉取代码遇到网络问题，比如下面这种，需要先绕过防火墙才行，可以参考<a href="https://selfboot.cn/2023/12/25/how-to-use-chatgpt/">安全、快速、便宜访问 ChatGPT，最新最全实践教程！</a> 这篇文章中的方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &#x27;/root/leveldb/third_party/googletest&#x27;...</span><br><span class="line">fatal: unable to access &#x27;https://github.com/google/googletest.git/&#x27;: GnuTLS recv error (-110): The TLS connection was non-properly terminated.</span><br><span class="line">fatal: clone of &#x27;https://github.com/google/googletest.git&#x27; into submodule path &#x27;/root/leveldb/third_party/googletest&#x27; failed</span><br><span class="line">Failed to clone &#x27;third_party/googletest&#x27;. Retry scheduled</span><br></pre></td></tr></table></figure><p>接下来就是编译整个源码，leveldb 用的 cmake 来构建，为了方便后面阅读代码，这里编译的时候加上了 <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=1</code>，这样会生成一个 <code>compile_commands.json</code> 文件，这个文件是 clangd 等工具的配置文件，可以帮助 VSCode 等 IDE 更好的理解代码。有了这个文件，代码跳转、自动补全等功能就会更好用。另外，为了方便用 GDB 进行调试，这里加上了 <code>-DCMAKE_BUILD_TYPE=Debug</code> 生成带调试信息的库。</p><p>完整的命令可以参考下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone --recurse-submodules  git@github.com:google/leveldb.git</span><br><span class="line"></span><br><span class="line">cd leveldb</span><br><span class="line">mkdir -p build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_INSTALL_PREFIX=$(pwd) .. &amp;&amp; cmake --build . --target install</span><br></pre></td></tr></table></figure><p>其中 <code>CMAKE_INSTALL_PREFIX</code> 选项用来指定安装目录，这里指定为当前目录(build 目录)，这样编译完之后，生成的库文件和头文件都会放在 build 目录下，方便后续使用。</p><p>这里 CMake 构建有不少选项，比如 <code>BUILD_SHARED_LIBS</code> 用来控制生成的库是静态链接库（.a 文件）还是动态链接库（.so 文件）。如果在 CMakeLists.txt 或通过命令行传递给 CMake 的参数中没有明确设置 <code>BUILD_SHARED_LIBS</code>，CMake 的默认行为通常是不启用构建共享库。命令行可以用 <code>cmake -DBUILD_SHARED_LIBS=ON ..</code> 来启用构建共享库。</p><h2 id="IDE-配置"><a href="#IDE-配置" class="headerlink" title="IDE 配置"></a>IDE 配置</h2><p>个人平时用 vscode 比较多，vscode 作为代码 IDE，可以说是十分好用。对 C++ 项目来说，虽然微软提供了官方的 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C++ 插件</a>，方便代码跳转等，但从个人使用体验来说，并不好用。这里强烈推荐使用 clangd 来阅读 C++ 代码，只需要<strong>在服务器安装 Clangd，然后在 vscode 安装 clangd 插件，再配合前面 Cmake 生成的编译数据库文件 compile_commands.json 即可</strong>。</p><p>Clangd 是一个基于 LLVM 项目的语言服务器，主要支持 C 和 C++ 的代码分析。它可以<strong>提供代码补全、诊断（即错误和警告）、代码跳转和代码格式化等功能</strong>。和微软自带的 C++ 插件比，clangd 响应速度十分快，并且借助 clang 能实现更精准的跳转和告警等。还支持用 <code>clang-tidy</code> 对项目代码进行静态分析，发现潜在错误。</p><p>比如在下面的代码中，clang-tidy 发现一个可疑问题：<code>Suspicious usage of ‘sizeof(A*)’</code>，还给出了 clang-tidy 的检查规则项 <a href="https://clang.llvm.org/extra/clang-tidy/checks/bugprone/sizeof-expression.html">bugprone-sizeof-expression</a>，这个规则是用来检查 <code>sizeof</code> 表达式的使用是否正确。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_clangd_tidy.png" alt="clangd 插件用 clang-tidy 找到的可疑地方"></p><p>这里 new_list 本身是一个指向指针的指针，new_list[0] 实际上就是一个指针，sizeof(new_list[0]) 是获取指针的大小，而不是指针所指向的元素的大小。不过这里设计本意就是如此，就是要给新的 bucket 设置初始值 nullptr。其实这个规则想防止的是下面这种错误：</p><blockquote><p>A common mistake is to compute the size of a pointer instead of its pointee. These cases may occur because of explicit cast or implicit conversion.</p></blockquote><p>比如下面这类代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="built_in">sizeof</span>(A + <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> point;</span><br><span class="line"><span class="built_in">memset</span>(point, <span class="number">0</span>, <span class="built_in">sizeof</span>(&amp;point));</span><br></pre></td></tr></table></figure><p>整体看，LevelDB 的代码质量很高，极少有 clang-tidy 提示。和业务代码的真是云泥之别，所以很值得学习。</p><h2 id="LevelDB-读改写"><a href="#LevelDB-读改写" class="headerlink" title="LevelDB 读改写"></a>LevelDB 读改写</h2><p>LevelDB 并<strong>不是一个类似 mysql 这样的数据库</strong>，也不支持 SQL 查询等功能，它只是一个<strong>快速的 key-value 存储库</strong>。LevelDB 没有自带的客户端和服务器代码，如果需要提供存储功能，需要自己实现相应逻辑。此外，只支持单进程访问指定数据库，不支持多进程访问。</p><p>业界一般把 LevelDB 作为存储组件底层依赖的一个库来使用，比如微信的核心存储 <a href="https://github.com/Tencent/paxosstore">paxosstore</a>，就会用 LevelDB 来存储数据。LevelDB 的使用入门比较简单，只需要引入头文件，然后调用相应的接口即可。下面代码实现了一个简单的命令行接口，使用 LevelDB 库来读写 key。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple_client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  leveldb::DB* db;</span><br><span class="line">  leveldb::Options options;</span><br><span class="line">  options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">  leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;./db&quot;</span>, &amp;db);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unable to open/create test database &#x27;./db&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string key;</span><br><span class="line">  std::string value;</span><br><span class="line">  std::string cmd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;leveldb&gt; &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; cmd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="string">&quot;set&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key &gt;&gt; value;</span><br><span class="line">      status = db-&gt;<span class="built_in">Put</span>(leveldb::<span class="built_in">WriteOptions</span>(), key, value);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error setting value: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;get&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key;</span><br><span class="line">      status = db-&gt;<span class="built_in">Get</span>(leveldb::<span class="built_in">ReadOptions</span>(), key, &amp;value);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;del&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key;</span><br><span class="line">      status = db-&gt;<span class="built_in">Delete</span>(leveldb::<span class="built_in">WriteOptions</span>(), key);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error deleting key: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;exit&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Unknown command. Supported commands are: set, get, del, exit&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用 Cmake 来构建，可以参考下面的 CMakeLists.txt 文件，当然下面的 include 和 lib 库的目录要根据前面编译好的目录来更改。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(SimpleLevelDBExamples VERSION <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 设置构建类型为 Debug 以包含调试信息</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"><span class="keyword">add_executable</span>(SimpleClient simple_client.cpp)</span><br><span class="line"><span class="keyword">include_directories</span>(../build/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(SimpleClient <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../build/libleveldb.a pthread)</span><br></pre></td></tr></table></figure><p>接着就可以用 <code>cmake --build .</code> 来编译二进制文件了。当然不习惯 cmake，直接用 gcc 也是可以的，只是需要手动指定头文件和库文件的路径。然后执行如下图，可以在类似 redis 的命令行 client 中操作 LevelDB。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240806_leveldb_source_prepare_simpleclient.png" alt="LevelDB 简单读写命令行接口"></p><p>可以在当前目录的 db 文件夹，看到 LevelDB 的数据存储文件，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> db</span> </span><br><span class="line">000005.ldb  000018.ldb  000020.ldb  000031.ldb  000036.log  CURRENT  LOCK  LOG  LOG.old  MANIFEST-000035</span><br></pre></td></tr></table></figure><p>后面会详细介绍 LevelDB 的数据存储方式，也会展开讲这些文件的作用，这里先不展开。</p><h2 id="跑好测试用例"><a href="#跑好测试用例" class="headerlink" title="跑好测试用例"></a>跑好测试用例</h2><p>到现在为止，我们已经编译 LevelDB 库，并且用 LevelDB 写了一个简单的读写命令行接口。接下来看看 LevelDB 的测试用例。LevelDB 的核心代码都有配套的测试用例，比如 LRU cache 中的 <a href="https://github.com/google/leveldb/blob/main/util/cache_test.cc">cache_test.cc</a>，db实现中的 <a href="https://github.com/google/leveldb/blob/main/db/db_test.cc">db_test.cc</a>，table 中的 <a href="https://github.com/google/leveldb/blob/main/table/table_test.cc">table_test.cc</a> 等等。用前面编译命令生成库的同时，会生成测试用例的可执行文件 <code>build/leveldb_tests</code>。</p><h3 id="动态库依赖"><a href="#动态库依赖" class="headerlink" title="动态库依赖"></a>动态库依赖</h3><p>如果直接运行 <code>leveldb_tests</code> 可能会提示缺少 <code>libtcmalloc</code> 动态库，这是 Google Perftools 的一个内存分配器，LevelDB 用到了这个库，需要在系统上安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/leveldb_tests: error while loading shared libraries: libtcmalloc.so.4: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>安装命令也很简单，比如在 debian 系统上，可以使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libgoogle-perftools-dev</span><br></pre></td></tr></table></figure><p>安装完之后，可以用 <code>ldd</code> 查看是否能找到，正常如下就可以运行二进制了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ldd ./build/leveldb_tests</span><br><span class="line">linux-vdso.so.1 (0x00007ffc0d1fc000)</span><br><span class="line">libtcmalloc.so.4 =&gt; /usr/local/lib/libtcmalloc.so.4 (0x00007f5277e91000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f5277c77000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f5277b98000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f5277b78000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5277997000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f52782ed000)</span><br></pre></td></tr></table></figure><p>这里在没有安装库之前，提示 <code>libtcmalloc.so.4 =&gt; not found</code>，安装动态库之后就<strong>自动链接</strong>到了正确的路径。怎么做到的呢？这是因为二进制文件包含了对动态库的引用，特别是<strong>库的名字和所需的符号（functions 或 data）</strong>。动态链接器（在 Linux 中通常是 <code>ld-linux.so</code>）负责处理这些引用。它会确定二进制文件需要哪些库，然后按照指定的路径和方法加载用到的库。</p><p>我们安装 tcmalloc 库之后，动态库文件 libtcmalloc.so.4 被复制到系统的库目录 &#x2F;usr&#x2F;local&#x2F;lib 中。然后安装程序会执行 ldconfig 更新 ld.so.cache，这个缓存包含库的路径信息，用来加快库的查找速度。这样后面再次运行二进制时，动态链接器查看缓存，找到新安装的库，并解析所有相关的符号引用，从而完成链接。</p><h3 id="修改、运行"><a href="#修改、运行" class="headerlink" title="修改、运行"></a>修改、运行</h3><p>这些功能测试用例都是用 gtest 框架编写的，我们可以通过 <code>--gtest_list_tests</code> 参数查看所有的测试用例。如下图所示：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_list_tests.png" alt="LevelDB 目前所有的测试用例"></p><p>如果直接运行 leveldb_tests，会执行所有的测试用例，不过我们可以通过 <code>--gtest_filter</code> 参数来指定只运行某个测试用例，比如 <code>--gtest_filter=&#39;CacheTest.*&#39;</code> 只运行 LRU cache 相关的测试用例。结果如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_cache_test.png" alt="只运行某个测试用例"></p><p><strong>测试用例可以帮助更好的理解代码逻辑。</strong>在阅读代码的过程中，有时候想验证一些逻辑，因此可以改动一下测试用例。比如我把一个能通过的测试用例故意改坏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--- a/util/cache_test.cc</span><br><span class="line">+++ b/util/cache_test.cc</span><br><span class="line">@@ <span class="number">-69</span>,<span class="number">7</span> +<span class="number">69</span>,<span class="number">7</span> @@ <span class="built_in">TEST_F</span>(CacheTest, HitAndMiss) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Insert</span>(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">   <span class="built_in">ASSERT_EQ</span>(<span class="number">101</span>, <span class="built_in">Lookup</span>(<span class="number">100</span>));</span><br><span class="line">-  <span class="built_in">ASSERT_EQ</span>(<span class="number">-1</span>, <span class="built_in">Lookup</span>(<span class="number">200</span>));</span><br><span class="line">+  <span class="built_in">ASSERT_EQ</span>(<span class="number">101</span>, <span class="built_in">Lookup</span>(<span class="number">200</span>));</span><br><span class="line">   <span class="built_in">ASSERT_EQ</span>(<span class="number">-1</span>, <span class="built_in">Lookup</span>(<span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Insert</span>(<span class="number">200</span>, <span class="number">201</span>);</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>修改用例后，需要重新编译 leveldb_tests。因为前面编译的时候，配置了项目的编译选项，CMake 已经缓存了下来，所以下面命令自动用了前面的配置项，比如 -DCMAKE_BUILD_TYPE&#x3D;Debug 等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target leveldb_tests</span><br><span class="line"></span><br><span class="line">[  2%] Built target gtest</span><br><span class="line">[ 58%] Built target leveldb</span><br><span class="line">[ 61%] Built target gtest_main</span><br><span class="line">[ 64%] Built target gmock</span><br><span class="line">[ 65%] Building CXX object CMakeFiles/leveldb_tests.dir/util/cache_test.cc.o</span><br><span class="line">[ 67%] Linking CXX executable leveldb_tests</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target leveldb_tests</span></span><br></pre></td></tr></table></figure><p>注意上面的输出可以看到，这里只重新编译了改动的文件，生成了新的目标文件<code>cache_test.cc.o</code>，因此编译速度很快。重新运行后，就会看到测试用例不过了，如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_cache_test_fail.png" alt="测试用例不过"></p><p>可以看到测试用例验证失败的具体原因。在阅读代码过程中，可以随时修改部分代码的用例，验证自己的理解是否正确。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跟着本文，大家应该都能快速准备好 LevelDB 的开发环境了吧。配置好 IDE，编译好源码，跑完简单的读写示例以及测试用例，然后一起来阅读源码吧～</p>]]></content>
    
    
    <summary type="html">介绍如何为 LevelDB 准备开发环境，包括源码拉取、编译和 VSCode 配置。通过简单的读写示例，读者可以对 LevelDB 有一个初步的认识。文章还介绍了如何使用 gtest 框架运行和修改测试用例，以便更好地理解代码逻辑。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB Explained - Posix File Operation Details</title>
    <link href="https://selfboot.cn/en/2024/08/02/leveldb_source_env_posixfile/"/>
    <id>https://selfboot.cn/en/2024/08/02/leveldb_source_env_posixfile/</id>
    <published>2024-08-02T10:37:38.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB supports running on various operating systems. To adapt to different operating systems, it needs to encapsulate some system calls, such as file operations, thread operations, time operations, etc. In the exposed include files, the <a href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h">env.h</a> file defines various interfaces used by LevelDB. This includes the Env class, which encapsulates file operations, directory operations, etc., as well as some file abstract classes such as SequentialFile, WritableFile, and RandomAccessFile for sequential reading, random reading, and writing files.</p><p>Through abstract interfaces, LevelDB can run on different operating systems by implementing the corresponding Env subclass for each platform. This article takes the POSIX system environment as an example to first look at how the abstracted <strong>file operation-related interfaces</strong> are implemented.</p><span id="more"></span><h2 id="Sequential-File-Reading"><a href="#Sequential-File-Reading" class="headerlink" title="Sequential File Reading"></a>Sequential File Reading</h2><p>First, let’s look at the abstract base class SequentialFile for <strong>sequential file reading</strong>, which provides a standard interface for sequential reading and skipping operations on files, and can be used for reading WAL log files. The class defines two main virtual functions:</p><ul><li>Read(size_t n, Slice* result, char* scratch): This function is used to read up to n bytes of data from the file. result is a pointer to a Slice type, used to store the read data. scratch is a character array used as a temporary buffer, and the function may write data to this buffer.</li><li>Skip(uint64_t n): This function is used to skip n bytes of data in the file. If the file is read to the end, the skip operation will stop at the end of the file, and the function returns an OK status.</li></ul><p>Of course, the comments also indicate that this class requires <strong>the caller to perform synchronization to ensure thread safety</strong>. In the POSIX environment, the implementation of this class is in the <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L136">env_posix.cc</a> file, where the PosixSequentialFile class finally inherits from SequentialFile, preventing it from being inherited by any other class, and implements the above two virtual functions. The implementation of Read is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">size_t</span> n, Slice* result, <span class="type">char</span>* scratch)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      ::<span class="type">ssize_t</span> read_size = ::<span class="built_in">read</span>(fd_, scratch, n);</span><br><span class="line">      <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) &#123;  <span class="comment">// Read error.</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">        &#125;</span><br><span class="line">        status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      *result = <span class="built_in">Slice</span>(scratch, read_size);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Here, when the system call <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> returns a value less than 0, it will judge whether it is an EINTR error based on the value of errno, and if so, it will <strong>retry reading</strong>. This is because when performing a read() operation on a file descriptor with the O_NONBLOCK flag set, if there is not enough data available to read, read() will return immediately instead of blocking to wait for data to become available. In this case, read() will return -1 and errno will be set to EAGAIN, indicating that there is no data to read and to try again later.</p><p>The implementation of Skip is relatively simple, directly calling the system call <a href="https://man7.org/linux/man-pages/man2/lseek.2.html">lseek()</a> to skip n bytes in the file. Here, the third parameter is SEEK_CUR, indicating to <strong>skip n bytes from the current position</strong>. In the operating system, each open file has an associated file position pointer (sometimes also called file offset). This pointer indicates where the next read or write operation will take place in the file. <strong>The operating system is responsible for tracking and maintaining this file position pointer</strong>. Of course, you can also specify SEEK_SET or SEEK_END, which represent skipping n bytes from the beginning and end of the file, respectively.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Skip</span><span class="params">(<span class="type">uint64_t</span> n)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">lseek</span>(fd_, n, SEEK_CUR) == <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(<span class="number">-1</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>The file descriptor should also be closed when the object is destroyed to ensure that resources are properly released</strong>. Each time a file is opened, the operating system allocates some resources, such as kernel buffers, file locks, etc. Then it returns a file descriptor (a non-negative integer) to the user, which the user then uses to operate on the file. When we call <a href="https://man7.org/linux/man-pages/man2/close.2.html">close</a>, the operating system reduces the reference count for that file, and if the reference count becomes 0, the operating system releases the corresponding resources. Additionally, there is a limit to the number of files each process can open, and not calling close(fd) may cause the process to be unable to open new files.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">PosixSequentialFile</span>() <span class="keyword">override</span> &#123; <span class="built_in">close</span>(fd_); &#125;</span><br></pre></td></tr></table></figure><h2 id="Random-File-Reading"><a href="#Random-File-Reading" class="headerlink" title="Random File Reading"></a>Random File Reading</h2><p>RandomAccessFile is an abstract base class that defines the interface for <strong>random file reading</strong>. It declares a pure virtual function Read, forcing subclasses to implement this method. The Read method is designed to allow reading a specified number of bytes from any position in the file. Because it’s a read-only interface, it supports lock-free multi-threaded concurrent access.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">char</span>* scratch)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>In the POSIX environment, this class has two implementations, one is <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L176">PosixRandomAccessFile</a> implemented using <a href="https://man7.org/linux/man-pages/man2/pread.2.html">pread()</a>, and the other is <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L238">PosixMmapReadableFile</a> implemented using mmap().</p><h3 id="Random-Reading-with-pread"><a href="#Random-Reading-with-pread" class="headerlink" title="Random Reading with pread"></a>Random Reading with pread</h3><p>The PosixRandomAccessFile class implements the RandomAccessFile interface, mainly using the POSIX pread() system call. The constructor of this class is quite interesting, receiving filename, fd, and an externally passed fd_limiter pointer. fd_limiter is used to limit the number of file descriptors held, avoiding too many open file descriptors. The specific implementation of limiter is in the <a href="#Limiter">Limiter</a> section of this article. During construction, if fd_limiter-&gt;Acquire() returns true, it means it can always hold this file descriptor. Otherwise, the file descriptor needs to be closed in the constructor, and <strong>a temporary file descriptor will be used each time content is read from the file later</strong>.</p><p>Here, fd_limiter is created in the factory function of <a href="#Env-Encapsulation-Interface">PosixEnv</a>, and the maximum number of persistent file descriptors is obtained by the MaxOpenFiles function. It first checks if the global variable g_open_read_only_file_limit has been modified to a non-negative number, and if so, uses this value. If not set, it needs to decide based on the system’s resource limits. Here, the system call <a href="https://www.man7.org/linux/man-pages/man2/getrlimit.2.html">getrlimit</a> is used to <strong>get the maximum number of file descriptors that the current process can open</strong>. If the system doesn’t limit the number of file descriptors a process can open, it returns the maximum value of an int type, otherwise it allocates 20% of this limit to read-only file operations. If getting the resource limit fails, or if the system (like the Fuchsia operating system) doesn’t support getting resource limits, a hard-coded value of 50 is used.</p><p>Next, let’s look at the constructor of PosixRandomAccessFile:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The new instance takes ownership of |fd|. |fd_limiter| must outlive this</span></span><br><span class="line"><span class="comment">// instance, and will be used to determine if .</span></span><br><span class="line"><span class="built_in">PosixRandomAccessFile</span>(std::string filename, <span class="type">int</span> fd, Limiter* fd_limiter)</span><br><span class="line">    : <span class="built_in">has_permanent_fd_</span>(fd_limiter-&gt;<span class="built_in">Acquire</span>()),</span><br><span class="line">      <span class="built_in">fd_</span>(has_permanent_fd_ ? fd : <span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">fd_limiter_</span>(fd_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd_ == <span class="number">-1</span>);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);  <span class="comment">// The file will be opened on every read.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The constructor uses the member variable has_permanent_fd_ to record whether it always holds an open file descriptor, and if not, fd_ is -1. Correspondingly, in the destructor, if has_permanent_fd_ is true, it needs to call close() to close the file descriptor and release the resource count of fd_limiter_. Next, let’s look at the core Read method of this class, the code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = fd_;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    fd = ::<span class="built_in">open</span>(filename_.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(fd != <span class="number">-1</span>);</span><br><span class="line">  Status status;</span><br><span class="line">  <span class="type">ssize_t</span> read_size = ::<span class="built_in">pread</span>(fd, scratch, n, <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(offset));</span><br><span class="line">  *result = <span class="built_in">Slice</span>(scratch, (read_size &lt; <span class="number">0</span>) ? <span class="number">0</span> : read_size);</span><br><span class="line">  <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// An error: return a non-ok status.</span></span><br><span class="line">    status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    <span class="comment">// Close the temporary file descriptor opened earlier.</span></span><br><span class="line">    <span class="built_in">assert</span>(fd != fd_);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, it first determines whether it holds a <strong>persistent file descriptor</strong>, and if not, it needs to open the file each time it reads the file. Then it calls pread() to read the file content. pread() is similar to read(), but it can read data from a specified position in the file. The first parameter of pread() is the file descriptor, the second parameter is the buffer for reading, the third parameter is the number of bytes to read, and the fourth parameter is the offset in the file. If the read is successful, the read data is stored in result, otherwise an error status is returned. Finally, if it doesn’t hold a persistent file descriptor, it needs to close the temporary file descriptor after reading the data.</p><p>The implementation of the PosixRandomAccessFile class is relatively simple, directly using the system file API, without the need for additional memory mapping management, suitable for small files or infrequent read operations. However, if access is frequent, too many system calls may lead to performance degradation, in which case <strong>memory mapping files</strong> can be used to improve performance.</p><h3 id="Random-Reading-with-mmap"><a href="#Random-Reading-with-mmap" class="headerlink" title="Random Reading with mmap"></a>Random Reading with mmap</h3><p>The PosixMmapReadableFile class also implements the RandomAccessFile interface, but it maps the file or part of the file to the process’s address space through memory mapping (mmap), and accessing this part of memory is equivalent to accessing the file itself. <strong>Memory mapping allows the operating system to utilize page caches, which can significantly improve the performance of frequent reads, especially in large file scenarios, improving read efficiency</strong>.</p><p>Unlike PosixRandomAccessFile, here the constructor needs to pass in the mmap_base pointer, which points to the file content mapped through the mmap system call, and also needs to pass in length, which is the length of the mapped area, i.e., the size of the file. The mapping is done in the external NewRandomAccessFile method, and PosixMmapReadableFile directly uses the mapped address.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PosixMmapReadableFile</span>(std::string filename, <span class="type">char</span>* mmap_base, <span class="type">size_t</span> length,</span><br><span class="line">                      Limiter* mmap_limiter)</span><br><span class="line">    : <span class="built_in">mmap_base_</span>(mmap_base),</span><br><span class="line">      <span class="built_in">length_</span>(length),</span><br><span class="line">      <span class="built_in">mmap_limiter_</span>(mmap_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>Of course, mmap also needs to limit resources to avoid exhausting virtual memory. Here, the Limiter class is also used, which will be described in detail later. The Read method <strong>directly reads data from mmap_base_, without the need to call system calls</strong>, which is much more efficient. The overall code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (offset + n &gt; length_) &#123;</span><br><span class="line">    *result = <span class="built_in">Slice</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, EINVAL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *result = <span class="built_in">Slice</span>(mmap_base_ + offset, n);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sequential-File-Writing"><a href="#Sequential-File-Writing" class="headerlink" title="Sequential File Writing"></a>Sequential File Writing</h2><p>The previous sections were all about reading files, of course, we can’t miss the writing file interface. WritableFile is an abstract base class that defines the interface for <strong>sequential file writing</strong>. It provides a standard interface for sequential writing and synchronization operations on files, which can be used for writing WAL log files. The class defines three main virtual functions:</p><ul><li>Append(const Slice&amp; data): Appends data to the file object. For small blocks of data, it appends to the object’s memory cache, and for large blocks of data, it calls WriteUnbuffered to write to disk.</li><li>Flush(): Calls the system write to write the data currently in the memory cache to disk. Note that <strong>this does not guarantee that the data has been synchronized to the physical disk</strong>.</li><li>Sync(): Ensures that the data in the internal buffer is written to the file, and also <strong>ensures that the data is synchronized to the physical disk</strong> to guarantee data persistence. After calling Sync(), the data will not be lost even if a power failure or system crash occurs.</li></ul><p>In the POSIX environment, the implementation of this class is <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L277">PosixWritableFile</a>. The class internally uses a <strong>buffer of 65536 bytes</strong> <code>buf_</code>, and only writes data to the disk file when the buffer is full. If there are a large number of short content writes, they can be merged in memory first, thereby reducing the number of calls to the underlying file system and improving the efficiency of write operations.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">size_t</span> kWritableFileBufferSize = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf_[0, pos_ - 1] contains data to be written to fd_.</span></span><br><span class="line">  <span class="type">char</span> buf_[kWritableFileBufferSize];</span><br></pre></td></tr></table></figure><p>The strategy for merging writes is implemented in Append, and the code is quite clear. For the content to be written, if it can be completely placed in the buffer, it is directly copied to the buffer, and then returns success. Otherwise, it first fills the buffer, then writes the data in the buffer to the file. At this point, if the remaining data can be written to the buffer, it is written directly, otherwise it is flushed directly to the disk. The complete implementation is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Append</span><span class="params">(<span class="type">const</span> Slice&amp; data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> write_size = data.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* write_data = data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fit as much as possible into buffer.</span></span><br><span class="line">  <span class="type">size_t</span> copy_size = std::<span class="built_in">min</span>(write_size, kWritableFileBufferSize - pos_);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(buf_ + pos_, write_data, copy_size);</span><br><span class="line">  write_data += copy_size;</span><br><span class="line">  write_size -= copy_size;</span><br><span class="line">  pos_ += copy_size;</span><br><span class="line">  <span class="keyword">if</span> (write_size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Can&#x27;t fit in buffer, so need to do at least one write.</span></span><br><span class="line">  Status status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Small writes go to buffer, large writes are written directly.</span></span><br><span class="line">  <span class="keyword">if</span> (write_size &lt; kWritableFileBufferSize) &#123;</span><br><span class="line">    std::<span class="built_in">memcpy</span>(buf_, write_data, write_size);</span><br><span class="line">    pos_ = write_size;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WriteUnbuffered</span>(write_data, write_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The WriteUnbuffered function is called above to write data to disk, which is implemented through the system call <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>. The main code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteUnbuffered</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> write_result = ::<span class="built_in">write</span>(fd_, data, size);</span><br><span class="line">    <span class="keyword">if</span> (write_result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    data += write_result;</span><br><span class="line">    size -= write_result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In addition to the Append function, WritableFile also provides a Flush interface for writing the data in the memory buffer buf_ to the file, which is also implemented by calling WriteUnbuffered internally. However, it’s worth noting that even if Flush writes to disk successfully, it <strong>does not guarantee that the data has been written to the disk, or even that the disk has enough space to store the content</strong>. If you want to ensure that the data is successfully written to the physical disk file, you need to call the Sync() interface, implemented as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Sync</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  Status status = <span class="built_in">SyncDirIfManifest</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line">  status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SyncFd</span>(fd_, filename_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The core here is calling the SyncFd() method, which <strong>ensures that all buffered data associated with the file descriptor fd is synchronized to the physical disk</strong>. The implementation of this function considers different operating system characteristics and file system behaviors, using conditional compilation directives (#if, #else, #endif) to handle different environments. On macOS and iOS systems, it uses the <code>F_FULLFSYNC</code> option of the fcntl() function to ensure that data is synchronized to the physical disk. If HAVE_FDATASYNC is defined, it will use fdatasync() to synchronize data. In other cases, it defaults to using the fsync() function to achieve the same functionality.</p><p>Note that SyncDirIfManifest ensures that if the file is a manifest file (named starting with “MANIFEST”), related directory changes are also synchronized. The manifest file records the metadata of the database files, including version information, merge operations, database status, and other critical information. When the file system creates new files or modifies file directory entries, these changes may not be immediately written to disk. <strong>Ensuring that the data of the directory has been synchronized to disk before updating the manifest file</strong> prevents the files referenced by the manifest file from not being actually written to disk when the system crashes.</p><h2 id="Resource-Concurrent-Limitation"><a href="#Resource-Concurrent-Limitation" class="headerlink" title="Resource Concurrent Limitation"></a>Resource Concurrent Limitation</h2><p>As mentioned above, to avoid having too many open file descriptors, the Acquire method of the Limiter class is used for limitation. This class is also implemented in <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L73">env_posix.cc</a>. The comments for this class are particularly good, clearly explaining its purpose, which is mainly used to limit resource usage to avoid resource exhaustion. It is currently used to limit read-only file descriptors and mmap file usage to avoid running out of file descriptors or virtual memory, or encountering kernel performance problems in very large databases.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper class to limit resource usage to avoid exhaustion.</span></span><br><span class="line"><span class="comment">// Currently used to limit read-only file descriptors and mmap file usage</span></span><br><span class="line"><span class="comment">// so that we do not run out of file descriptors or virtual memory, or run into</span></span><br><span class="line"><span class="comment">// kernel performance problems for very large databases.</span></span><br></pre></td></tr></table></figure><p>The constructor takes a parameter max_acquires, which sets the maximum number of resources that can be acquired. The class internally maintains an atomic variable acquires_allowed_ to track the number of resources currently allowed to be acquired, with an initial value set to max_acquires. Conditional compilation is used here, NDEBUG is a commonly used preprocessor macro used to indicate whether the program is compiled in non-debug mode.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Limit maximum number of resources to |max_acquires|.</span></span><br><span class="line">  <span class="built_in">Limiter</span>(<span class="type">int</span> max_acquires)</span><br><span class="line">      :</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(NDEBUG)</span></span><br><span class="line">        <span class="built_in">max_acquires_</span>(max_acquires),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(NDEBUG)</span></span></span><br><span class="line">        <span class="built_in">acquires_allowed_</span>(max_acquires) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(max_acquires &gt;= <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>If in debug mode, max_acquires_ is used to record the maximum number of resources, and assertions are added in the Acquire and Release methods to ensure that resource acquisition and release operations are correct. In the production environment, <strong>when NDEBUG is defined, all assert calls will be ignored by the compiler and will not generate any execution code</strong>.</p><p>The core interfaces of this class are Acquire and Release. These two methods are used to acquire and release resources respectively. The code for Acquire is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> old_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (old_acquires_allowed &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pre_increment_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Silence compiler warnings about unused arguments when NDEBUG is defined.</span></span><br><span class="line">  (<span class="type">void</span>)pre_increment_acquires_allowed;</span><br><span class="line">  <span class="comment">// If the check below fails, Release() was called more times than acquire.</span></span><br><span class="line">  <span class="built_in">assert</span>(pre_increment_acquires_allowed &lt; max_acquires_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, fetch_sub(1, std::memory_order_relaxed) is used to atomically decrease the value of acquires_allowed_ and return the value before the decrease as old_acquires_allowed. If old_acquires_allowed is greater than 0, it means there were resources available before the decrease, so it returns true. If no resources are available (i.e., old_acquires_allowed is 0 or negative), it atomically adds the counter back to 1 using fetch_add(1, std::memory_order_relaxed) to restore the state, and returns false.</p><p>The Release method is used to release resources previously successfully acquired through the Acquire method. It uses fetch_add(1, std::memory_order_relaxed) to atomically increase the value of acquires_allowed_, indicating that the resource has been released, and uses an assertion to ensure that the number of Release calls does not exceed the number of successful Acquire calls, preventing resource count errors.</p><p>When operating on the atomic counter here, std::memory_order_relaxed is used, indicating that these atomic operations <strong>do not need any special ordering constraints on memory</strong>, only guaranteeing the atomicity of the operation. This is because the operations here do not depend on the results of any other memory operations, they simply increment or decrement the counter.</p><h2 id="Env-Encapsulation-Interface"><a href="#Env-Encapsulation-Interface" class="headerlink" title="Env Encapsulation Interface"></a>Env Encapsulation Interface</h2><p>In addition to the above file operation classes, there is also an important Env abstract base class, which derives PosixEnv under Posix, encapsulating many implementations.</p><h3 id="Factory-Construction-of-Objects"><a href="#Factory-Construction-of-Objects" class="headerlink" title="Factory Construction of Objects"></a>Factory Construction of Objects</h3><p>First are several factory methods used to create file read and write objects like SequentialFile, RandomAccessFile, and WritableFile objects. The NewSequentialFile factory method creates a PosixSequentialFile file object, encapsulating the call to open the file. The advantage of using the factory method here is that it can handle some errors, such as file opening failure. Additionally, the input parameter is <code>WritableFile**</code>, supporting polymorphism. If other WritableFile implementations are added in the future, they can be switched to different implementations by modifying the factory method without changing the calling code.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewSequentialFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                         SequentialFile** result)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    *result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename, errno);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *result = <span class="keyword">new</span> <span class="built_in">PosixSequentialFile</span>(filename, fd);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When opening a file here, in addition to O_RDONLY indicating read-only, there is also a kOpenBaseFlags. kOpenBaseFlags is a flag that is set based on the compilation option HAVE_O_CLOEXEC. If the system supports O_CLOEXEC, this flag will be set. O_CLOEXEC ensures that <strong>the file descriptor is automatically closed when executing exec() series functions, thus preventing file descriptor leakage to the newly executed program</strong>.</p><p>By default, when a process creates a child process, all file descriptors are inherited by the child process. Unless explicitly handled for each file descriptor, they will remain open after exec is executed. In most cases, if a process intends to execute another program (usually through exec series functions), it’s likely that it doesn’t want the new program to access certain resources of the current process, especially file descriptors. The O_CLOEXEC flag ensures that these file descriptors are automatically closed after exec, thus not leaking to the new program. Although LevelDB itself doesn’t call exec functions, this flag is still added here, which is a good defensive programming habit.</p><p>Of course, this flag may not be supported on all platforms. For cross-platform compatibility, in <a href="https://github.com/google/leveldb/blob/main/CMakeLists.txt#L54">CmakeLists.txt</a>, check_cxx_symbol_exists is used to detect whether the current environment’s fcntl.h file has O_CLOEXEC, and if so, the HAVE_O_CLOEXEC macro is defined. It’s worth mentioning that check_cxx_symbol_exists is quite useful, it can <strong>determine whether specific features are supported before compilation, so that compilation settings or source code can be adjusted appropriately based on the detection results</strong>. Several macros in LevelDB are detected in this way, such as fdatasync, F_FULLFSYNC, etc.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">check_cxx_symbol_exists(fdatasync <span class="string">&quot;unistd.h&quot;</span> HAVE_FDATASYNC)</span><br><span class="line">check_cxx_symbol_exists(F_FULLFSYNC <span class="string">&quot;fcntl.h&quot;</span> HAVE_FULLFSYNC)</span><br><span class="line">check_cxx_symbol_exists(O_CLOEXEC <span class="string">&quot;fcntl.h&quot;</span> HAVE_O_CLOEXEC)</span><br></pre></td></tr></table></figure><p>The NewWritableFile and NewAppendableFile factory functions are similar, first opening the file and then creating a PosixWritableFile object. However, different flags are used when opening the file:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_TRUNC | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_APPEND | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure><p>O_TRUNC indicates that if the file exists, its length will be truncated to 0. O_APPEND indicates that when writing data, it will always append the data to the end of the file, rather than overwriting existing data in the file.</p><p>NewRandomAccessFile is a bit more complex because it supports two modes of random reading. First, it opens the file to get the fd, then uses mmap_limiter_ to limit the number of memory-mapped open files. If it exceeds the mmap limit, it uses pread for random reading. If it doesn’t exceed the limit, it uses mmap to memory-map the file, gets the mapped address and file size, and then creates a PosixMmapReadableFile object.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewRandomAccessFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                           RandomAccessFile** result)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!mmap_limiter_.<span class="built_in">Acquire</span>()) &#123;</span><br><span class="line">    *result = <span class="keyword">new</span> <span class="built_in">PosixRandomAccessFile</span>(filename, fd, &amp;fd_limiter_);</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint64_t</span> file_size;</span><br><span class="line">  Status status = <span class="built_in">GetFileSize</span>(filename, &amp;file_size);</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="type">void</span>* mmap_base = ::<span class="built_in">mmap</span>(<span class="comment">/*addr=*/</span><span class="literal">nullptr</span>, file_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmap_base != MAP_FAILED) &#123;</span><br><span class="line">      *result = <span class="keyword">new</span> <span class="built_in">PosixMmapReadableFile</span>(filename,</span><br><span class="line">                                          <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(mmap_base),</span><br><span class="line">                                          file_size, &amp;mmap_limiter_);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  ::<span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    mmap_limiter_.<span class="built_in">Release</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, the maximum number of files limited by mmap_limiter_ is obtained by the MaxMmaps function. For 64-bit systems, due to the very large virtual memory address space (usually over 256TB in actual applications), LevelDB allows allocating 1000 memory-mapped areas, which should not have a significant impact on the overall performance of the system. For 32-bit systems, due to the limited virtual memory address space, LevelDB does not allow allocating memory-mapped areas.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Up to 1000 mmap regions for 64-bit binaries; none for 32-bit.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> kDefaultMmapLimit = (<span class="built_in">sizeof</span>(<span class="type">void</span>*) &gt;= <span class="number">8</span>) ? <span class="number">1000</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="File-Utility-Classes"><a href="#File-Utility-Classes" class="headerlink" title="File Utility Classes"></a>File Utility Classes</h3><p>In addition to the several core file classes mentioned above, Env also provides a series of file operation interfaces, including file metadata retrieval, file deletion, etc. This is a good opportunity to familiarize ourselves with <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc">various system calls in the Posix environment</a>.</p><p>FileExists: Determines <strong>whether the current process can access the file (inability to access does not mean the file does not exist)</strong>, implemented by calling the system call <a href="https://man7.org/linux/man-pages/man2/access.2.html">access()</a>;</p><p>RemoveFile: If no process is currently using the file (i.e., no open file descriptors point to this file), it will delete the file. Implemented through the system call <a href="https://man7.org/linux/man-pages/man2/unlink.2.html">unlink()</a>, unlink actually deletes the link between the filename and its corresponding inode. If this inode has no other links and no process has this file open, the actual data blocks and inode of the file will be released.</p><p>GetFileSize: Gets the size of the file. If the file does not exist or the retrieval fails, it returns 0. This is implemented through the <a href="https://man7.org/linux/man-pages/man2/stat.2.html">stat</a> system call. When calling the stat function, you need to pass the filename and a pointer to a stat structure. The system will check the path permissions corresponding to the filename, then retrieve the file’s inode. The inode is a data structure in the file system that stores the file’s metadata, including file size, permissions, creation time, last access time, etc. The file system maintains an inode table for quick lookup and access to inode information, and for most file systems (such as EXT4, NTFS, XFS, etc.), commonly used inodes are usually cached in memory, so retrieving the inode is generally very efficient.</p><p>RenameFile: Renames a file or folder. You can specify new and old filenames here, implemented through the system call <a href="https://man7.org/linux/man-pages/man2/rename.2.html">rename()</a>.</p><p>CreateDir: Creates a directory with default permissions of 755. This is implemented through the system call <a href="https://man7.org/linux/man-pages/man2/mkdir.2.html">mkdir()</a>. If pathname already exists, it returns failure.</p><p>RemoveDir: Deletes a directory, implemented through the system call <a href="https://man7.org/linux/man-pages/man2/rmdir.2.html">rmdir()</a>.</p><p>GetChildren: Slightly more complex, it uses the system call opendir to get the directory, then uses readdir to traverse the files in it, and finally remembers to use closedir to clean up resources.</p><h2 id="File-Operation-Summary"><a href="#File-Operation-Summary" class="headerlink" title="File Operation Summary"></a>File Operation Summary</h2><p>It must be said that a simple file operation encapsulation contains many implementation details. Let’s summarize them briefly:</p><ol><li>Buffer optimization: In the WritableFile implementation, a memory buffer is used, which can merge small write operations, reduce the number of system calls, and improve write efficiency.</li><li>Resource limit management: The Limiter class is used to limit the number of simultaneously open file descriptors and memory mappings (mmap). By setting reasonable upper limits, resource exhaustion is avoided, improving system stability and performance.</li><li>Flexible reading strategy: For random reading, LevelDB provides two implementations based on pread and mmap, which can dynamically choose the most appropriate method according to system resource conditions.</li><li>Factory method pattern: Using factory methods to create file objects encapsulates operations such as file opening, facilitating error handling and future expansion.</li><li>Cross-platform compatibility: Through conditional compilation and feature detection (such as checking for O_CLOEXEC), code compatibility on different platforms is ensured.</li><li>Synchronization mechanism: Flush and Sync interfaces are provided, allowing users to choose different levels of data persistence guarantees as needed.</li></ol><p>In addition to encapsulating file operations, there are other encapsulations in Env, which we’ll see in the next article.</p>]]></content>
    
    
    <summary type="html">This article details LevelDB&#39;s abstracted file operations, including the implementation of sequential read/write and random file access under Posix, and how to adapt to different operating systems through abstract interfaces. It also introduces key designs such as buffer optimization, resource limit management, and flexible reading strategies to improve system performance and usability. Additionally, it covers implementation details like the application of the factory method pattern, error handling mechanisms, and cross-platform compatibility considerations.</summary>
    
    
    
    <category term="Source Code Analysis" scheme="https://selfboot.cn/categories/Source-Code-Analysis/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB 源码阅读：Posix 文件操作接口实现细节</title>
    <link href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/"/>
    <id>https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/</id>
    <published>2024-08-02T10:37:38.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 支持在各种操作系统上运行，为了适配不同的操作系统，需要封装一些系统调用，比如文件操作、线程操作、时间操作等。在对外暴露的 include 文件中，<a href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h">env.h</a> 文件定义了 LevelDB 用到的各种接口。包括 Env 类，封装文件操作，目录操作等，还有一些文件抽象类，比如 SequentialFile、WritableFile、RandomAccessFile 3 个类，用于顺序读取，随机读取和写入文件。</p><p>通过抽象接口，只需要为每个平台实现相应的 Env 子类，LevelDB 就可以在不同的操作系统上运行。这篇文章以 POSIX 系统环境为例，先来看看抽象出来的和<strong>文件操作相关的接口</strong>是怎么实现的。</p><span id="more"></span><h2 id="顺序读文件"><a href="#顺序读文件" class="headerlink" title="顺序读文件"></a>顺序读文件</h2><p>首先看看<strong>顺序读文件</strong>的抽象基类 SequentialFile，它为文件的顺序读取和跳过操作提供了一个标准的接口，可以用于 WAL 日志文件的读取。类中定义了2个主要的虚函数：</p><ul><li>Read(size_t n, Slice* result, char* scratch)：这个函数用于从文件中读取多达 n 字节的数据。result 是一个指向 Slice 类型的指针，用来存储读取的数据。scratch 是一个字符数组，用作临时缓冲区，函数可能会向这个缓冲区写入数据。</li><li>Skip(uint64_t n)：这个函数用于跳过文件中的 n 字节数据。如果文件读取到末尾，跳过操作将停止在文件末尾，函数返回 OK 状态。</li></ul><p>当然，注释里也说明了这个类需要<strong>调用者进行同步，以确保线程安全</strong>。在 POSIX 环境下，这个类的实现是在 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L136">env_posix.cc</a> 文件中，PosixSequentialFile 类 final 继承自 SequentialFile，阻止被其他任何类继承，同时实现了上述两个虚函数。其中 Read 的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">size_t</span> n, Slice* result, <span class="type">char</span>* scratch)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      ::<span class="type">ssize_t</span> read_size = ::<span class="built_in">read</span>(fd_, scratch, n);</span><br><span class="line">      <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) &#123;  <span class="comment">// Read error.</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">        &#125;</span><br><span class="line">        status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      *result = <span class="built_in">Slice</span>(scratch, read_size);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里当系统调用 <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> 返回值小于 0 时，会根据 errno 的值判断是否是 EINTR 错误，如果是则<strong>重试读取</strong>。这是因为，当对一个设置了 O_NONBLOCK 标志的文件描述符进行 read() 操作时，如果没有足够的数据可供读取，read() 会立即返回而不是阻塞等待数据变得可用。这种情况下，read() 将返回 -1 并且 errno 被设置为 EAGAIN，表明没有数据可读，可以稍后再试。</p><p>Skip 的实现则比较简单，直接调用系统调用 <a href="https://man7.org/linux/man-pages/man2/lseek.2.html">lseek()</a> 来跳过文件中的 n 个字节。这里第三个参数是 SEEK_CUR，表示<strong>从当前位置开始跳过 n 个字节</strong>。操作系统中，每个打开的文件都有一个与之关联的文件位置指针（有时也称为文件偏移量）。这个指针指示了下一次读取或写入操作将在文件中的哪个位置进行。<strong>操作系统负责跟踪和维护这个文件位置指针</strong>。当然也可以指定 SEEK_SET 或 SEEK_END，分别表示从文件开始和文件末尾开始跳过 n 个字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Skip</span><span class="params">(<span class="type">uint64_t</span> n)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">lseek</span>(fd_, n, SEEK_CUR) == <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(<span class="number">-1</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在对象销毁时也要关闭文件描述符，确保资源被正确释放</strong>。每次打开文件，操作系统会分配一些资源，比如内核缓冲区、文件锁等。然后返回给用户一个文件描述符(非负整数)，之后用户通过这个文件描述符来操作文件。当我们调用 <a href="https://man7.org/linux/man-pages/man2/close.2.html">close</a> 时，操作系统会减少对该文件的引用计数，如果引用计数为 0，操作系统会释放相应资源。此外每个进程能打开的文件数量有限制，不调用 close(fd) 可能导致进程无法打开新的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">PosixSequentialFile</span>() <span class="keyword">override</span> &#123; <span class="built_in">close</span>(fd_); &#125;</span><br></pre></td></tr></table></figure><h2 id="随机读文件"><a href="#随机读文件" class="headerlink" title="随机读文件"></a>随机读文件</h2><p>RandomAccessFile 是一个抽象基类，定义<strong>随机读取文件</strong>的接口。它声明了一个纯虚函数 Read，强制子类实现这个方法。Read 方法的设计允许从文件的任意位置读取指定数量的字节。因为是一个只读接口，所以支持无锁多线程并发访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">char</span>* scratch)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>在 POSIX 环境下，这个类有 2 种实现，一个是用 <a href="https://man7.org/linux/man-pages/man2/pread.2.html">pread()</a> 实现的 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L176">PosixRandomAccessFile</a>，另一个是用 mmap() 实现的 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L238">PosixMmapReadableFile</a>。</p><h3 id="pread-随机读"><a href="#pread-随机读" class="headerlink" title="pread 随机读"></a>pread 随机读</h3><p>PosixRandomAccessFile 类实现了 RandomAccessFile 接口，主要用的是 POSIX 的 pread() 系统调用。该类的构造函数比较有意思，接收 filename，fd 和外部传入的 fd_limiter 指针。fd_limiter 用于限制持有的文件描述符的数量，避免打开的文件描述符过多，limiter 的具体实现在本文 <a href="#Limiter">Limiter</a> 部分。构造的时候，如果 fd_limiter-&gt;Acquire() 返回 true，说明可以一直持有这个文件描述符。否则的话，需要在构造函数中关闭文件描述符，<strong>在后面每次从文件读内容的时候再使用临时文件描述符</strong>。</p><p>这里 fd_limiter 在 <a href="#Env-%E5%B0%81%E8%A3%85%E6%8E%A5%E5%8F%A3">PosixEnv</a>的工厂函数里面创建，持久文件描述符的最大个数由 MaxOpenFiles 函数获得。首先检查全局变量 g_open_read_only_file_limit 是否被修改为非负数，如果是则使用这个值。如果没设置，则需要根据系统的资源限制来决定。这里通过系统调用 <a href="https://www.man7.org/linux/man-pages/man2/getrlimit.2.html">getrlimit</a> 来<strong>获取当前进程可以打开的最大文件描述符数</strong>。如果系统不限制进程可以打开的文件描述符数量，那么返回一个 int 类型的最大值，否则将这个限制数的20%分配给只读文件的操作。如果拿资源限制失败，或者系统(比如 Fuchsia 操作系统)不支持获取资源限制，则使用一个硬编码的数值 50。</p><p>接下来看看 PosixRandomAccessFile 的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The new instance takes ownership of |fd|. |fd_limiter| must outlive this</span></span><br><span class="line"><span class="comment">// instance, and will be used to determine if .</span></span><br><span class="line"><span class="built_in">PosixRandomAccessFile</span>(std::string filename, <span class="type">int</span> fd, Limiter* fd_limiter)</span><br><span class="line">    : <span class="built_in">has_permanent_fd_</span>(fd_limiter-&gt;<span class="built_in">Acquire</span>()),</span><br><span class="line">      <span class="built_in">fd_</span>(has_permanent_fd_ ? fd : <span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">fd_limiter_</span>(fd_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd_ == <span class="number">-1</span>);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);  <span class="comment">// The file will be opened on every read.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中还用成员变量 has_permanent_fd_ 来记录是否一直持有打开的文件描述符，如果没有则 fd_ 为 -1。对应的，在析构函数中，如果 has_permanent_fd_ 为 true，就需要调用 close() 关闭文件描述符，并释放 fd_limiter_ 的资源计数。接下来看该类的核心 Read 方法，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = fd_;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    fd = ::<span class="built_in">open</span>(filename_.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(fd != <span class="number">-1</span>);</span><br><span class="line">  Status status;</span><br><span class="line">  <span class="type">ssize_t</span> read_size = ::<span class="built_in">pread</span>(fd, scratch, n, <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(offset));</span><br><span class="line">  *result = <span class="built_in">Slice</span>(scratch, (read_size &lt; <span class="number">0</span>) ? <span class="number">0</span> : read_size);</span><br><span class="line">  <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// An error: return a non-ok status.</span></span><br><span class="line">    status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    <span class="comment">// Close the temporary file descriptor opened earlier.</span></span><br><span class="line">    <span class="built_in">assert</span>(fd != fd_);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先判断是否持有<strong>持久文件描述符</strong>，如果没有则需要在每次读取文件时打开文件。然后调用 pread() 读取文件内容，pread() 与 read() 类似，但是它可以从文件的指定位置读取数据。pread() 的第一个参数是文件描述符，第二个参数是读取的缓冲区，第三个参数是读取的字节数，第四个参数是文件中的偏移量。如果读取成功，将读取的数据存入 result 中，否则返回错误状态。最后如果没有持有持久文件描述符，需要在读取完数据后关闭临时文件描述符。</p><p>PosixRandomAccessFile 类实现相对简单，直接使用系统文件API，无需额外的内存映射管理，适用于小文件或者不频繁的读取操作。但是如果访问比较频繁，过多的系统调用可能导致性能下降，这时候就可以使用<strong>mmap 内存映射文件</strong>来提高性能。</p><h3 id="mmap-随机读"><a href="#mmap-随机读" class="headerlink" title="mmap 随机读"></a>mmap 随机读</h3><p>PosixMmapReadableFile 类同样实现了 RandomAccessFile 接口，不过通过内存映射（mmap）将文件或文件的一部分映射到进程的地址空间，访问这部分内存就相当于访问文件本身。<strong>内存映射允许操作系统利用页缓存，可以显著提高频读取的性能，尤其是在大文件场景下，可以提高读取效率</strong>。</p><p>和 PosixRandomAccessFile 有些不同，这里在构造的时候需要传入 mmap_base 指针，指向通过 mmap 系统调用映射的文件内容，同时还需要传入 length 即映射区域的长度，即文件的大小。这里的映射在外面 NewRandomAccessFile 方法中做，PosixMmapReadableFile 直接使用映射好的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PosixMmapReadableFile</span>(std::string filename, <span class="type">char</span>* mmap_base, <span class="type">size_t</span> length,</span><br><span class="line">                      Limiter* mmap_limiter)</span><br><span class="line">    : <span class="built_in">mmap_base_</span>(mmap_base),</span><br><span class="line">      <span class="built_in">length_</span>(length),</span><br><span class="line">      <span class="built_in">mmap_limiter_</span>(mmap_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>当然，这里 mmap 也需要限制资源，避免耗尽虚拟内存，这里同样用的是 Limiter 类，后面会详细介绍。Read 方法<strong>直接从 mmap_base_ 中读取数据，不需要再调用系统调用</strong>，效率高很多，整体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (offset + n &gt; length_) &#123;</span><br><span class="line">    *result = <span class="built_in">Slice</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, EINVAL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *result = <span class="built_in">Slice</span>(mmap_base_ + offset, n);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序写文件"><a href="#顺序写文件" class="headerlink" title="顺序写文件"></a>顺序写文件</h2><p>前面都是读文件，当然也少不了写文件接口了。WritableFile 是一个抽象基类，定义<strong>顺序写入文件</strong>的接口。它为文件的顺序写入和同步操作提供了一个标准的接口，可以用于 WAL 日志文件的写入。类中定义了3个主要的虚函数：</p><ul><li>Append(const Slice&amp; data)：向文件对象中追加数据，对于小块数据追加在对象的内存缓存中，对于大块数据则调用 WriteUnbuffered 写磁盘。</li><li>Flush()：将目前内存缓存中的数据调用系统 write 写磁盘，注意这里<strong>不保证数据已被同步到物理磁盘</strong>。</li><li>Sync()：确保内部缓冲区的数据被写入文件，还<strong>确保数据被同步到物理磁盘</strong>，以保证数据的持久性。调用 Sync() 之后，即使发生电源故障或系统崩溃，数据也不会丢失了。</li></ul><p>在 POSIX 环境下，这个类的实现是 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L277">PosixWritableFile</a>。类内部使用了一个<strong>大小为 65536 字节的缓冲区</strong> <code>buf_</code>，只有缓冲区满才会将数据写入磁盘文件。如果有大量的短内容写入，就可以先在内存中合并，从而减少对底层文件系统的调用次数，提高写操作的效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">size_t</span> kWritableFileBufferSize = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf_[0, pos_ - 1] contains data to be written to fd_.</span></span><br><span class="line">  <span class="type">char</span> buf_[kWritableFileBufferSize];</span><br></pre></td></tr></table></figure><p>这里合并写入的策略在 Append 中实现，代码比较清晰。对于写入的内容，如果能够完全放入缓冲区，则直接拷贝到缓冲区中，然后就返回成功。否则先填满缓冲区，然后将缓存区中的数据写入文件，此时如果剩余的数据能够写入缓冲区则直接写，不然就直接刷到磁盘中。完整实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Append</span><span class="params">(<span class="type">const</span> Slice&amp; data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> write_size = data.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* write_data = data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fit as much as possible into buffer.</span></span><br><span class="line">  <span class="type">size_t</span> copy_size = std::<span class="built_in">min</span>(write_size, kWritableFileBufferSize - pos_);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(buf_ + pos_, write_data, copy_size);</span><br><span class="line">  write_data += copy_size;</span><br><span class="line">  write_size -= copy_size;</span><br><span class="line">  pos_ += copy_size;</span><br><span class="line">  <span class="keyword">if</span> (write_size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Can&#x27;t fit in buffer, so need to do at least one write.</span></span><br><span class="line">  Status status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Small writes go to buffer, large writes are written directly.</span></span><br><span class="line">  <span class="keyword">if</span> (write_size &lt; kWritableFileBufferSize) &#123;</span><br><span class="line">    std::<span class="built_in">memcpy</span>(buf_, write_data, write_size);</span><br><span class="line">    pos_ = write_size;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WriteUnbuffered</span>(write_data, write_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面将数据写入磁盘调用的是 WriteUnbuffered 函数，该函数通过系统调用 <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> 实现，主要代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteUnbuffered</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> write_result = ::<span class="built_in">write</span>(fd_, data, size);</span><br><span class="line">    <span class="keyword">if</span> (write_result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    data += write_result;</span><br><span class="line">    size -= write_result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 Append 函数，WritableFile 还提供了 Flush 接口，用于将内存缓冲区 buf_ 的数据写入文件，它内部也是通过调用 WriteUnbuffered 来实现。不过值得注意的是，这里 Flush 写磁盘成功，并<strong>不保证数据已经写入磁盘，甚至不能保证磁盘有足够的空间来存储内容</strong>。如果要保证数据写物理磁盘文件成功，需要调用 Sync() 接口，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Sync</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  Status status = <span class="built_in">SyncDirIfManifest</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line">  status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SyncFd</span>(fd_, filename_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里核心是调用 SyncFd() 方法，<strong>确保文件描述符 fd 关联的所有缓冲数据都被同步到物理磁盘</strong>。该函数的实现考虑了不同的操作系统特性和文件系统行为，使用了条件编译指令（#if、#else、#endif）来处理不同的环境。在 macOS 和 iOS 系统上，使用了 fcntl() 函数的 <code>F_FULLFSYNC</code> 选项来确保数据被同步到物理磁盘。如果定义了 HAVE_FDATASYNC，将使用 fdatasync() 来同步数据。其他情况下，默认使用 fsync() 函数来实现同样的功能。</p><p>注意这里 SyncDirIfManifest 确保如果文件是 manifest 文件(以 “MANIFEST” 开始命名的文件)，相关的目录更改也得到同步。mainfest 文件记录数据库文件的元数据，包括版本信息、合并操作、数据库状态等关键信息。文件系统在创建新文件或修改文件目录项时，这些变更可能并不立即写入磁盘。<strong>在更新 manifest 文件前确保所在目录的数据已被同步到磁盘</strong>，防止系统崩溃时，manifest 文件引用的文件尚未真正写入磁盘。</p><h2 id="资源并发限制"><a href="#资源并发限制" class="headerlink" title="资源并发限制"></a>资源并发限制</h2><p>上面提到为了避免打开的文件描述符过多，使用 Limiter 类的 Acquire 来进行限制，该类的也在实现在 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L73">env_posix.cc</a>中。这个类的注释也写的特别棒，把它的作用讲的很明白，主要用来限制资源使用，避免资源耗尽。目前用于限制只读文件描述符和 mmap 文件使用，以避免耗尽文件描述符或虚拟内存，或者在非常大的数据库中遇到内核性能问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper class to limit resource usage to avoid exhaustion.</span></span><br><span class="line"><span class="comment">// Currently used to limit read-only file descriptors and mmap file usage</span></span><br><span class="line"><span class="comment">// so that we do not run out of file descriptors or virtual memory, or run into</span></span><br><span class="line"><span class="comment">// kernel performance problems for very large databases.</span></span><br></pre></td></tr></table></figure><p>构造函数接受一个参数 max_acquires，这个参数设定了可以获取的最大资源数量。类内部维护了一个原子变量 acquires_allowed_ 来跟踪当前允许被获取的资源数量，初始值设置为 max_acquires。这里用到了条件编译，NDEBUG 是一个常用的预处理宏，用来指明程序是否在非调试模式下编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Limit maximum number of resources to |max_acquires|.</span></span><br><span class="line">  <span class="built_in">Limiter</span>(<span class="type">int</span> max_acquires)</span><br><span class="line">      :</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(NDEBUG)</span></span><br><span class="line">        <span class="built_in">max_acquires_</span>(max_acquires),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(NDEBUG)</span></span></span><br><span class="line">        <span class="built_in">acquires_allowed_</span>(max_acquires) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(max_acquires &gt;= <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果在调试模式下，就用 max_acquires_ 来记录最大资源数量，同时在 Acquire 和 Release 方法中加入了断言，确保资源的获取和释放操作正确。在生产环境中，当 <strong>NDEBUG 被定义时，所有的 assert 调用将被编译器忽略，不会产生任何执行代码</strong>。</p><p>该类的核心接口是 Acquire 和 Release，这两个方法分别用来获取和释放资源，Acquire 的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> old_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (old_acquires_allowed &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pre_increment_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Silence compiler warnings about unused arguments when NDEBUG is defined.</span></span><br><span class="line">  (<span class="type">void</span>)pre_increment_acquires_allowed;</span><br><span class="line">  <span class="comment">// If the check below fails, Release() was called more times than acquire.</span></span><br><span class="line">  <span class="built_in">assert</span>(pre_increment_acquires_allowed &lt; max_acquires_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 fetch_sub(1, std::memory_order_relaxed) 原子地减少 acquires_allowed_ 的值，并返回减少前的值 old_acquires_allowed。如果 old_acquires_allowed 大于0，说明在减少之前还有资源可以被获取，因此返回 true。如果没有资源可用（即 old_acquires_allowed 为0或负），则通过 fetch_add(1, std::memory_order_relaxed) 原子地将计数器加回1，恢复状态，并返回 false。</p><p>Release 方法用来释放之前通过 Acquire 方法成功获取的资源。它使用 fetch_add(1, std::memory_order_relaxed) 原子地增加 acquires_allowed_ 的值，表示资源被释放，同时用断言保证 Release 的调用次数不会超过 Acquire 的成功次数，防止资源计数错误。</p><p>这里在操作原子计数的时候，使用的是 std::memory_order_relaxed，表明这些原子操作<strong>不需要对内存进行任何特别的排序约束</strong>，只保证操作的原子性。这是因为这里的操作并不依赖于任何其他的内存操作结果，只是简单地递增或递减计数器。</p><h2 id="Env-封装接口"><a href="#Env-封装接口" class="headerlink" title="Env 封装接口"></a>Env 封装接口</h2><p>除了上面的几个文件操作类来，还有一个重要的 Env 抽象基类，在 Posix 下派生了 PosixEnv，封装了不少实现。</p><h3 id="工厂构造对象"><a href="#工厂构造对象" class="headerlink" title="工厂构造对象"></a>工厂构造对象</h3><p>首先是几个工厂方法，用于创建前面提到的文件读写对象 SequentialFile、RandomAccessFile 和 WritableFile 对象。NewSequentialFile 工厂方法来创建一个 PosixSequentialFile 文件对象，这里封装了打开文件的调用。这里用工厂方法的好处是，可以在工厂方法中处理一些错误，比如文件打开失败。此外这里入参是 <code>WritableFile**</code> ，支持了多态，如果后续加入其他的 WritableFile 实现，可以在不修改调用代码的情况下，通过修改工厂方法来切换到不同的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewSequentialFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                         SequentialFile** result)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    *result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename, errno);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *result = <span class="keyword">new</span> <span class="built_in">PosixSequentialFile</span>(filename, fd);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里打开文件时候，传入 flag 除了 O_RDONLY 表示只读外，还有一个 kOpenBaseFlags。kOpenBaseFlags 是一个根据编译选项 HAVE_O_CLOEXEC 来决定是否设置的 flag，如果系统支持 O_CLOEXEC，就会设置这个 flag。O_CLOEXEC 确保在执行 exec() 系列函数时<strong>自动关闭文件描述符，从而防止文件描述符泄露到执行的新程序</strong>中。</p><p>默认情况下，当一个进程创建子进程时，所有的文件描述符都会被子进程继承。除非显式地对每个文件描述符进行处理，否则它们在 exec 执行后仍然会保持打开状态。大多数情况下，如果一个进程打算执行另一个程序（通常通过 exec 系列函数），很有可能不希望新程序访问当前进程的某些资源，特别是文件描述符。O_CLOEXEC 标志确保这些文件描述符在 exec 后自动关闭，从而不会泄露给新程序。虽然 LevelDB 本身不会调用 exec 函数，但是这里还是加上了这个 flag，这是一个良好的防御编程习惯。</p><p>当然这个 flag 不一定是所有平台支持，为了跨平台，在 <a href="https://github.com/google/leveldb/blob/main/CMakeLists.txt#L54">CmakeLists.txt</a> 中，用check_cxx_symbol_exists 来检测当前环境的 fcntl.h 文件是否有 O_CLOEXEC，有的话则定义 HAVE_O_CLOEXEC 宏。这里特别提下，check_cxx_symbol_exists 还挺有用的，可以<strong>在编译之前确定特定的特性是否被支持，以便根据检测结果适当调整编译设置或源代码</strong>。LevelDB 中有多个宏就是这样检测的，比如 fdatasync、F_FULLFSYNC 等。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">check_cxx_symbol_exists(fdatasync <span class="string">&quot;unistd.h&quot;</span> HAVE_FDATASYNC)</span><br><span class="line">check_cxx_symbol_exists(F_FULLFSYNC <span class="string">&quot;fcntl.h&quot;</span> HAVE_FULLFSYNC)</span><br><span class="line">check_cxx_symbol_exists(O_CLOEXEC <span class="string">&quot;fcntl.h&quot;</span> HAVE_O_CLOEXEC)</span><br></pre></td></tr></table></figure><p>NewWritableFile 和 NewAppendableFile 工厂函数都是类似的，先打开文件，然后创建 PosixWritableFile 对象。不过这里 open 文件的时候，用的不同 flag:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_TRUNC | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_APPEND | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure><p>O_TRUNC 表示如果文件存在，就将文件长度截断为 0。O_APPEND 表示在写入数据时，总是将数据追加到文件末尾，而不是覆盖文件中已有的数据。</p><p>NewRandomAccessFile 稍微复杂了一些，因为要支持两种随机读的模式。首先打开文件拿到 fd，然后根据 mmap_limiter_ 来限制内存映射打开文件数量，如果超过 mmap 限制，就用 pread 来随机读。没超过限制的话，就用 mmap 来内存映射文件，拿到映射的地址和文件大小，然后创建 PosixMmapReadableFile 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewRandomAccessFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                           RandomAccessFile** result)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!mmap_limiter_.<span class="built_in">Acquire</span>()) &#123;</span><br><span class="line">    *result = <span class="keyword">new</span> <span class="built_in">PosixRandomAccessFile</span>(filename, fd, &amp;fd_limiter_);</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint64_t</span> file_size;</span><br><span class="line">  Status status = <span class="built_in">GetFileSize</span>(filename, &amp;file_size);</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="type">void</span>* mmap_base = ::<span class="built_in">mmap</span>(<span class="comment">/*addr=*/</span><span class="literal">nullptr</span>, file_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmap_base != MAP_FAILED) &#123;</span><br><span class="line">      *result = <span class="keyword">new</span> <span class="built_in">PosixMmapReadableFile</span>(filename,</span><br><span class="line">                                          <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(mmap_base),</span><br><span class="line">                                          file_size, &amp;mmap_limiter_);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  ::<span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    mmap_limiter_.<span class="built_in">Release</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 mmap_limiter_ 限制的最大文件数量由 MaxMmaps 函数获得。对于64位系统，由于有非常大的虚拟内存地址空间（实际应用中通常超过 256TB），因此 LevelDB 允许分配 1000 个内存映射区，应该不会对系统的整体性能产生显著影响。而对于32位系统，由于虚拟内存地址空间有限，LevelDB 不允许分配内存映射区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Up to 1000 mmap regions for 64-bit binaries; none for 32-bit.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> kDefaultMmapLimit = (<span class="built_in">sizeof</span>(<span class="type">void</span>*) &gt;= <span class="number">8</span>) ? <span class="number">1000</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="文件工具类"><a href="#文件工具类" class="headerlink" title="文件工具类"></a>文件工具类</h3><p>除了上面几个核心的文件类，Env 还提供了一系列文件操作的接口，包括文件元信息获取、文件删除等，刚好可以借此来熟悉下 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc">Posix 环境下的各种系统调用</a>。</p><p>FileExists: 判断 <strong>当前进程是否可以访问该文件(不能访问不代表文件不存在)</strong> ，通过调用系统调用 <a href="https://man7.org/linux/man-pages/man2/access.2.html">access()</a> 实现；</p><p>RemoveFile: 如果没有任何进程正在使用该文件(即没有任何打开的文件描述符指向这个文件)，则会删除该文件。通过系统调用 <a href="https://man7.org/linux/man-pages/man2/unlink.2.html">unlink()</a> 实现，unlink 实际上删除的是文件名和其对应 inode 之间的链接。如果这个 inode 没有其他链接，并且没有任何进程打开这个文件，文件实际的数据块和 inode 才会被释放。</p><p>GetFileSize: 获取文件的大小，如果文件不存在或者获取失败，返回 0。这里通过 <a href="https://man7.org/linux/man-pages/man2/stat.2.html">stat</a> 系统调用实现。调用 stat 函数时，需要传递文件名和一个 stat 结构体的指针。系统会检查文件名对应的路径权限，然后获取文件的 inode。inode 是文件系统中的一个数据结构，保存了文件的元数据，包括文件大小、权限、创建时间、最后访问时间等。在文件系统会保持一个 inode 表，用于快速查找和访问 inode 信息，对于大部分文件系统（如 EXT4, NTFS, XFS 等）来说，通常会在内存中缓存常用的 inode，因此获取 inode 一般会十分高效。</p><p>RenameFile: 重命名文件或者文件夹，这里可以指定新旧文件名，通过系统调用 <a href="https://man7.org/linux/man-pages/man2/rename.2.html">rename()</a> 实现。</p><p>CreateDir: 创建一个目录，默认权限是 755。这里通过系统调用 <a href="https://man7.org/linux/man-pages/man2/mkdir.2.html">mkdir()</a> 实现，如果 pathname 已经存在，这里返回失败。</p><p>RemoveDir: 删除一个目录，这里通过系统调用 <a href="https://man7.org/linux/man-pages/man2/rmdir.2.html">rmdir()</a> 实现。</p><p>GetChildren: 稍微复杂一点，通过系统调用 opendir 获得目录，然后用 readdir 遍历其中的文件，最后还要记得 closedir 来清理资源。 </p><h2 id="文件操作总结"><a href="#文件操作总结" class="headerlink" title="文件操作总结"></a>文件操作总结</h2><p>不得不说，一个简单的文件操作封装，包含了不少实现细节，这里简单总结下吧：</p><ol><li>缓冲区优化: 在 WritableFile 实现中使用了内存缓冲区，可以合并小型写入操作，减少系统调用次数，提高写入效率。</li><li>资源限制管理: 使用 Limiter 类来限制同时打开的文件描述符数量和内存映射(mmap)数量，通过设置合理的限制上限，避免资源耗尽，提高系统稳定性和性能。</li><li>灵活的读取策略: 对于随机读取，LevelDB 提供了基于 pread 和 mmap 两种实现，可以根据系统资源情况动态选择最合适的方式。</li><li>工厂方法模式: 使用工厂方法创建文件对象，封装了文件打开等操作，方便错误处理和未来的扩展。</li><li>跨平台兼容性: 通过条件编译和特性检测(如 O_CLOEXEC 的检查)，保证了代码在不同平台上的兼容性。</li><li>同步机制: 提供了 Flush 和 Sync 接口，允许用户根据需要选择不同级别的数据持久化保证。</li></ol><p>除了封装文件操作，Env 里面还有其他封装，下篇见吧。</p>]]></content>
    
    
    <summary type="html">文章详细介绍了 LevelDB 抽象的文件操作，包括顺序读写、随机读取文件在 Posix 下的实现，以及如何通过抽象接口适配不同操作系统。还介绍了缓冲区优化、资源限制管理、灵活读取策略等关键设计，来提升系统的性能和可用性。此外还有工厂方法模式的应用、错误处理机制和跨平台兼容性考虑等实现细节。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>从法院判决书看性骚扰行为的后果</title>
    <link href="https://selfboot.cn/2024/07/23/lawer_sexual_harassment/"/>
    <id>https://selfboot.cn/2024/07/23/lawer_sexual_harassment/</id>
    <published>2024-07-23T21:08:29.000Z</published>
    <updated>2024-08-20T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<p>在当今社会，性骚扰问题引起了广泛关注，特别是高校内部的师生关系中性骚扰问题更是敏感而复杂。近期，一位来自某知名高校的教授因涉嫌对女学生进行性骚扰而被曝光，此事件迅速激发了公众对于高等教育环境中性问题的关注。这不仅是一个高校的内部问题，更触及到了社会法律对于性骚扰行为的态度与处理。</p><p>性骚扰不仅侵犯了个体的人格尊严，还可能对受害者造成长期的心理阴影。我国法律对此有着严格的规定与明确的法律后果，而通过具体的法院判决书，我们可以清晰地看到法律是如何审视这一行为的。本文将结合最新的判例，详细分析关于性骚扰行为的相关法律知识～</p><span id="more"></span><h1 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h1><p>在处理性骚扰案件时，法院对证据的要求非常严格。在提出诉讼时必须具备充分、确凿的证据，以便法院能够做出公正的判断。</p><ol><li>证据的重要性：在性骚扰案件中，证据是判决的关键。原告需<strong>提供充分证据来证明被告的性骚扰行为及其对原告造成的精神和身体伤害</strong>。</li><li>举证责任：侵权纠纷中，受害者必须承担起举证责任，证明被告的行为构成侵权并导致了损害后果。</li><li>法律定义和界定：性骚扰的法律定义涉及身体、语言、动作、文字或图像等方式，违背他人意愿而对其实施的<strong>以性为取向的有辱其尊严的性暗示、性挑逗以及性暴力等行为</strong>。</li></ol><h1 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h1><p>性骚扰很常见，但敢于拿起法律武器保护自己的，少之又少。从公开的裁判文书来看，最近 5 年只有 682 起性骚扰相关诉讼。</p><h2 id="撤诉"><a href="#撤诉" class="headerlink" title="撤诉"></a>撤诉</h2><p>性骚扰案件中有不少撤诉的，大部分是因为证据难以收集。性骚扰往往发生在没有其他证人的私密环境中，如办公室、私人会议。因此，收集直接证据非常困难。<strong>在缺乏物理证据或可信的第三方证人的情况下，受害者不得不撤回诉讼</strong>。</p><p>此外，有些受害者可能会因为害怕社会污名、职业损失或人际关系破裂而选择不公开发声。受害者<strong>可能遭受来自家庭、工作单位或社会的压力，促使他们撤回诉讼</strong>，以保护个人名誉或避免“麻烦”。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_lawer_sexual_harassment_withdrawal.png" alt="性骚扰案件撤诉的案件"></p><h2 id="败诉"><a href="#败诉" class="headerlink" title="败诉"></a>败诉</h2><p>有部分性骚扰案件虽然走到了诉讼环节，但法院的判决并不总是支持原告。在一些案件中，法院认为原告提供的证据不足以证明被告的性骚扰行为，或者认为原告的诉讼请求不符合法律规定。</p><p>下面的案件中，原告提供了录音证据，但法院认为这里的录音中仅表明原、被告在仅有一次言谈交流中，双方就家庭责任、喜欢男人的类型、社会交往等内容进行对话，<strong>并没有被告对原告实施了性暗示、性挑逗以及性暴力方面的陈述，双方也并没有肢体接触</strong>。因原告并未能提供充足的证据证明被告存在性骚扰行为及原告的抑郁、焦虑状态与该被告的行为存在法律上的因果关系，故其应当承担举证不能的法律后果。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_lawer_sexual_harassment_fail.png" alt="性骚扰案件起诉败诉的案件"></p><h2 id="胜诉"><a href="#胜诉" class="headerlink" title="胜诉"></a>胜诉</h2><p>当然，性骚扰案件中如果证据充分，法院肯定会支持原告的。在第三批人民法院大力弘扬社会主义核心价值观典型民事案例中，就有一起性骚扰案件。</p><p>傅某为追求王某，不断拨打王某电话，<strong>频繁向王某发送骚扰短信，内容低俗、语言污秽</strong>。后来王某以傅某骚扰、恐吓为由报警，公安确认傅某多次以发送骚扰短信、拨打骚扰电话方式干扰他人正常生活，<strong>给予傅某行政拘留七日并处罚款200元</strong>。因傅某频繁骚扰，王某被医院确诊患有抑郁发作，伴精神病性症状。王某认为，傅某的行为给其造成了严重的精神损害，向人民法院起诉请求判令傅某向其书面赔礼道歉，并赔偿其精神损害赔偿金 50000 元和医疗费等其他财产损失共计 228300 元。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_lawer_sexual_harassment_succ.png" alt="性骚扰案件胜诉的案件"></p><p>本案因为有短信证据，且医院确诊王某患有抑郁发作，伴精神病性症状，法院最终判决傅某赔偿王某精神损害赔偿金 30000 元和医疗费等61804.2 元，并向王某书面赔礼道歉。</p><h1 id="律师建议"><a href="#律师建议" class="headerlink" title="律师建议"></a>律师建议</h1><p>小盛律师建议，在遭受性骚扰时，要<strong>明确并坚定地向施害者表达拒绝</strong>。用口头和书面形式，清晰地表明自己的立场，不同意任何形式的性骚扰行为。</p><p>在保证自己人身安全的基础上，<strong>记录和收集好证据</strong>。尽可能记录下所有相关的信息，包括施害者的言行、时间、地点和可能的目击者。如果条件允许，可以保存电子通信记录、录音、视频或者文字消息等，这些都可能成为处理案件的关键证据。</p><p>之后可以寻求家人、朋友或同事的帮助，也可以向单位的人力资源部门或专门的性骚扰投诉部门举报，或者向公安机关报案。如果情况严重，对自己造成很大的影响，可以寻求法律援助。欢迎联系<a href="https://selfboot.cn/links">小盛律师</a>获得关于如何维权的具体建议，并通过法律途径进行诉讼。</p>]]></content>
    
    
    <summary type="html">性骚扰不仅侵犯人格尊严，还可能对受害者造成长期心理影响。小盛律师结合具体的法院判决书，展示了如何通过法律途径应对和处理性骚扰问题。此外，还详细讨论了性骚扰案件中证据的重要性和举证责任，以及法律对此类行为的定义和界定，为公众提供了宝贵的法律知识和应对策略。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="法律" scheme="https://selfboot.cn/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB Explained - Preventing C++ Object Destruction</title>
    <link href="https://selfboot.cn/en/2024/07/22/leveldb_source_nodestructor/"/>
    <id>https://selfboot.cn/en/2024/07/22/leveldb_source_nodestructor/</id>
    <published>2024-07-22T18:03:10.000Z</published>
    <updated>2024-08-20T02:06:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>In the LevelDB source code, there’s a function for getting a Comparator that seemed a bit strange when I first saw it. It looks like it constructs a singleton, but it’s slightly more complex. The complete code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/comparator.cc</span></span><br><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, <code>NoDestructor</code> is a template class that, judging by its name, is used to <strong>prevent object destruction</strong>. Why prevent object destruction, and how is it achieved? This article will delve into these questions.</p><span id="more"></span><h2 id="The-NoDestructor-Template-Class"><a href="#The-NoDestructor-Template-Class" class="headerlink" title="The NoDestructor Template Class"></a>The NoDestructor Template Class</h2><p>Let’s first look at the <code>NoDestructor</code> template class, which is used to <strong>wrap an instance so that its destructor is never called</strong>. This template class uses several advanced features, such as template programming, perfect forwarding, static assertions, alignment requirements, and placement new. Let’s explain each of these. First, here’s the complete code implementation:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/no_destructor.h</span></span><br><span class="line"><span class="comment">// Wraps an instance whose destructor is never called.</span></span><br><span class="line"><span class="comment">// This is intended for use with function-level static variables.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InstanceType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoDestructor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ConstructorArgTypes&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">NoDestructor</span><span class="params">(ConstructorArgTypes&amp;&amp;... constructor_args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(instance_storage_) &gt;= <span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                  <span class="string">&quot;instance_storage_ is not large enough to hold the instance&quot;</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        <span class="built_in">alignof</span>(<span class="keyword">decltype</span>(instance_storage_)) &gt;= <span class="built_in">alignof</span>(InstanceType),</span><br><span class="line">        <span class="string">&quot;instance_storage_ does not meet the instance&#x27;s alignment requirement&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> (&amp;instance_storage_)</span><br><span class="line">        <span class="built_in">InstanceType</span>(std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">NoDestructor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NoDestructor</span>(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  NoDestructor&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">InstanceType* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;InstanceType*&gt;(&amp;instance_storage_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typename</span> std::aligned_storage&lt;<span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                                <span class="built_in">alignof</span>(InstanceType)&gt;::type instance_storage_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Let’s start with the constructor part. <code>typename... ConstructorArgTypes</code> indicates that this is a variadic template function, which can accept any number and type of parameters. This allows the NoDestructor class to be used with any type of InstanceType, regardless of how many parameters or what types of parameters its constructor needs. For more on variadic templates, you can also check out an article I wrote earlier: <a href="https://selfboot.cn/2024/05/07/variadic_arguments_in_c++/">The Evolution of Variadic Arguments Implementation in C++</a>.</p><p>The constructor parameter <code>ConstructorArgTypes&amp;&amp;... constructor_args</code> is a universal reference parameter pack, which, when used in conjunction with std::forward, can achieve perfect forwarding of parameters.</p><p>The constructor begins with two <strong>static assertions (static_assert) to check if instance_storage_ is large enough and meets the alignment requirements</strong>. The first static_assert ensures that the storage space allocated for InstanceType, instance_storage_, is at least as large as the InstanceType instance itself, <strong>to ensure there’s enough space to store an object of that type</strong>. The second static_assert ensures that the alignment of instance_storage_ meets the alignment requirements of InstanceType. The memory alignment requirements for objects are related to performance, which we won’t expand on here.</p><p>Then it starts constructing the object, using <strong>C++’s placement new syntax</strong>. <code>&amp;instance_storage_</code> provides an address, telling the compiler to construct the InstanceType object at this pre-allocated memory address. This avoids additional memory allocation, constructing the object directly in the reserved memory block. Next, using perfect forwarding, <code>std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...</code> ensures that all constructor parameters are passed to InstanceType’s constructor with the correct type (preserving lvalue or rvalue properties). This is best practice for parameter passing in modern C++, reducing unnecessary copy or move operations and improving efficiency.</p><p>The memory address used for placement new construction earlier is provided by the member variable instance_storage_, whose type is defined by the <a href="https://en.cppreference.com/w/cpp/types/aligned_storage">std::aligned_storage</a> template. This is a specially designed type <strong>used to provide a raw memory block that can safely store any type, while ensuring that the stored object type (InstanceType here) has appropriate size and alignment requirements</strong>. Here, the raw memory area created by std::aligned_storage is consistent with the memory area where the NoDestructor object is located, meaning that if NoDestructor is defined as a local variable within a function, both it and its instance_storage_ will be located on the stack. If NoDestructor is defined as a static or global variable, it and instance_storage_ will be in the static storage area, and objects in the static storage area have a lifetime that spans the entire program execution.</p><p>It’s worth noting that in the C++23 standard, std::aligned_storage will be deprecated. For more details, refer to <a href="https://stackoverflow.com/questions/71828288/why-is-stdaligned-storage-to-be-deprecated-in-c23-and-what-to-use-instead">Why is std::aligned_storage to be deprecated in C++23 and what to use instead?</a>.</p><p>Returning to the example at the beginning of the article, the singleton object is a static local variable initialized the first time BytewiseComparator() is called, and its lifetime is as long as the entire program’s lifetime. When the program exits, <strong>the singleton object itself will be destructed and destroyed</strong>, but NoDestructor hasn’t added any logic in its destructor to destruct the object constructed in instance_storage_, so the BytewiseComparatorImpl object in instance_storage_ will never be destructed.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LevelDB also provides a test case to verify that NoDestructor here behaves as expected.</p><h2 id="Test-Case"><a href="#Test-Case" class="headerlink" title="Test Case"></a>Test Case</h2><p>In <code>util/no_destructor_test.cc</code>, a struct <code>DoNotDestruct</code> is first defined, which calls std::abort() in its destructor. If the program runs or exits and calls the destructor of a DoNotDestruct object, the test program will terminate abnormally.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DoNotDestruct</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DoNotDestruct</span>(<span class="type">uint32_t</span> a, <span class="type">uint64_t</span> b) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">DoNotDestruct</span>() &#123; std::<span class="built_in">abort</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used to check constructor argument forwarding.</span></span><br><span class="line">  <span class="type">uint32_t</span> a;</span><br><span class="line">  <span class="type">uint64_t</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Then two test cases are defined, one defining a NoDestructor object on the stack, and the other defining a static NoDestructor object. These two test cases verify the behavior of NoDestructor objects on the stack and in the static storage area, respectively.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StackInstance) &#123;</span><br><span class="line">  <span class="function">NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StaticInstance) &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the implementation of NoDestructor is problematic and cannot ensure that the destruction of the passed-in object is not executed, the test program will terminate abnormally. Let’s run these two test cases, and the result is as follows:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png" alt="Test cases pass, destructor not called"></p><p>Here we can add a test case to verify what happens if we directly define a DoNotDestruct object, whether the test process will terminate abnormally. We can first define an object on the stack to test, placing it before the other two test cases, as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, Instance) &#123;</span><br><span class="line">  <span class="function">DoNotDestruct <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The result of running is as follows, this test case will terminate abnormally during execution, indicating that the destructor of the DoNotDestruct object was called.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png" alt="Test process terminates abnormally, indicating destructor was called"></p><p>Actually, we can modify this further by directly defining the instance object here with static, then compiling and re-running the test cases. You’ll find that all 3 test cases pass, but the test process still aborts at the end. This is because when the process exits, static objects are destructed, and at this time, the destructor of the DoNotDestruct object is called.</p><h2 id="Why-Can’t-It-Be-Destructed"><a href="#Why-Can’t-It-Be-Destructed" class="headerlink" title="Why Can’t It Be Destructed?"></a>Why Can’t It Be Destructed?</h2><p>In the above example, we saw the implementation of the NoDestructor template class, which serves to prevent the destruction of static local singleton objects. So why prevent object destruction? Simply put, <strong>the C++ standard does not specify the destruction order of static local variables in different compilation units</strong>. If there are dependencies between static variables and their destruction order is incorrect, it may lead to the program accessing already destructed objects, resulting in undefined behavior that could cause the program to crash.</p><p>Let’s take an example. Suppose there are two classes, one is a logging system and the other is some kind of service. The service needs to log information to the logging system during destruction. The code for the logger class is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span> <span class="comment">// Include assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isAlive; <span class="comment">// Flag to check if the object has been destructed</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Logger instance; <span class="comment">// Static local variable</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>() : <span class="built_in">isAlive</span>(<span class="literal">true</span>) &#123;&#125; <span class="comment">// Constructor initializes isAlive to true</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Logger destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        isAlive = <span class="literal">false</span>; <span class="comment">// Mark as destructed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(isAlive); <span class="comment">// Assert the object is not destructed</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Note the isAlive member variable of this class, which is initialized to true in the constructor and set to false in the destructor. In the log function, it first checks if isAlive is true, and if it’s false, it will trigger an assertion failure. Next is the code for the service class, which, as an example, only uses the static local variable of the logger class to record a log during destruction.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Service</span>() &#123;</span><br><span class="line">        Logger::<span class="built_in">getInstance</span>().<span class="built_in">log</span>(<span class="string">&quot;Service destroyed.&quot;</span>); <span class="comment">// Log during destruction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>In the main function, use global variables globalService and globalLogger, where globalService is a global Service instance and globalLogger is a Logger singleton.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Service globalService; <span class="comment">// Global Service instance</span></span><br><span class="line">Logger&amp; globalLogger = Logger::<span class="built_in">getInstance</span>(); <span class="comment">// Global Logger instance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Compile and run this program:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -g -fno-omit-frame-pointer -o main main.cpp</span></span><br></pre></td></tr></table></figure><p>After running, the assert assertion will <strong>most likely fail</strong>. We know that <strong>in a single compilation unit (here main.cpp), global variables are initialized in the order they appear, and then destructed in the reverse order</strong>. Here, globalLogger will be destructed first, then globalService. In globalService’s destructor, it will call Logger’s log function, but at this point globalLogger has already been destructed, isAlive has been set to false, so it will likely trigger an assertion failure. The reason we say “most likely” is because after the globalLogger object is destructed, the memory space it occupied may <strong>not yet have been reclaimed by the operating system or used for other purposes</strong>, so access to its member variable isAlive may still appear “normal”. Here’s the result of my run:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">main: logger.h:22: void Logger::log(const string&amp;): Assertion `isAlive&#x27; failed.</span><br><span class="line">[1]    1017435 abort      ./main</span><br></pre></td></tr></table></figure><p>In fact, if we don’t add the isAlive-related logic here, the output when running will most likely be as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">Log: Service destroyed.</span><br></pre></td></tr></table></figure><p>From the output, we can see that, as before, globalLogger is destructed first, followed by globalService. However, the process is unlikely to crash here. This is because after globalLogger is destructed, <strong>although its lifecycle has ended, calls to member functions may still execute “normally”</strong>. The execution of member functions here usually depends on the class’s code (located in the code segment), and as long as the content of the code segment hasn’t been rewritten and the method doesn’t depend on member variables that have been destroyed or changed, it may still run without error.</p><p>Of course, even if it doesn’t trigger a program crash here, using an already destructed object is <a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">undefined behavior</a> in C++. Undefined behavior means the program may crash, may run normally, or may produce unpredictable results. The results of such behavior may vary on different systems or at different runtimes, and we must avoid this situation in our development.</p><p>Actually, as far as LevelDB’s implementation here is concerned, BytewiseComparatorImpl is a <a href="https://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor">trivially destructible</a> object that doesn’t depend on other global variables, so its own destruction won’t be problematic. If we use it to generate a static local singleton object and then use it in other static local objects or global objects, these objects will call BytewiseComparatorImpl’s destructor when they are destructed. And according to the previous analysis, BytewiseComparatorImpl itself is a static local object, <strong>which may be destructed earlier than the objects using it when the process ends and resources are reclaimed</strong>. This would lead to repeated destruction, producing undefined behavior.</p><p>For more explanations about static variable destruction, you can also refer to the article <a href="https://ppwwyyxx.com/blog/2023/Safe-Static-Initialization-No-Destruction/">Safe Static Initialization, No Destruction</a>, where the author discusses this issue in detail.</p>]]></content>
    
    
    <summary type="html">Delve into the NoDestructor template class in LevelDB&#39;s source code, revealing its implementation principles and motivations for preventing object destruction. Analyze the C++ static local variable destruction order issue, introduce NoDestructor&#39;s design details, test cases, and practical application scenarios. Suitable for C++ developers and programmers interested in low-level systems, helping you master advanced C++ programming techniques.</summary>
    
    
    
    <category term="Source Code Analysis" scheme="https://selfboot.cn/categories/Source-Code-Analysis/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB 源码阅读：禁止对象被析构</title>
    <link href="https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/"/>
    <id>https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/</id>
    <published>2024-07-22T18:03:10.000Z</published>
    <updated>2024-08-20T02:06:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 源码中有一个获取 Comparator 的函数，第一次看到的时候觉得有点奇怪，看起来像是构造了一个单例，但又略复杂。完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/comparator.cc</span></span><br><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>NoDestructor</code> 是一个模板类，看名字是用于<strong>禁止对象析构</strong>。为什么要禁止对象析构，又是如何做到禁止析构呢？这篇文章来深入探讨下这个问题。</p><span id="more"></span><h2 id="NoDestructor-模板类"><a href="#NoDestructor-模板类" class="headerlink" title="NoDestructor 模板类"></a>NoDestructor 模板类</h2><p>我们先来看看 <code>NoDestructor</code> 模板类，它用于<strong>包装一个实例，使得其析构函数不会被调用</strong>。这个模板类用了比较多的高级特性，如模板编程、完美转发、静态断言、对齐要求、以及原地构造（placement new）等，接下来一一解释。这里先给出完整的代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/no_destructor.h</span></span><br><span class="line"><span class="comment">// Wraps an instance whose destructor is never called.</span></span><br><span class="line"><span class="comment">// This is intended for use with function-level static variables.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InstanceType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoDestructor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ConstructorArgTypes&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">NoDestructor</span><span class="params">(ConstructorArgTypes&amp;&amp;... constructor_args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(instance_storage_) &gt;= <span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                  <span class="string">&quot;instance_storage_ is not large enough to hold the instance&quot;</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        <span class="built_in">alignof</span>(<span class="keyword">decltype</span>(instance_storage_)) &gt;= <span class="built_in">alignof</span>(InstanceType),</span><br><span class="line">        <span class="string">&quot;instance_storage_ does not meet the instance&#x27;s alignment requirement&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> (&amp;instance_storage_)</span><br><span class="line">        <span class="built_in">InstanceType</span>(std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">NoDestructor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NoDestructor</span>(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  NoDestructor&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">InstanceType* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;InstanceType*&gt;(&amp;instance_storage_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typename</span> std::aligned_storage&lt;<span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                                <span class="built_in">alignof</span>(InstanceType)&gt;::type instance_storage_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先来看构造函数部分。<code>typename... ConstructorArgTypes</code> 表示这是一个变参模板函数，可以接受任意数量和类型的参数。这使得 NoDestructor 类可以用于任何类型的 InstanceType，不管其构造函数需要多少个参数或是什么类型的参数。关于变参模板，也可以看看我之前写的一篇文章：<a href="https://selfboot.cn/2024/05/07/variadic_arguments_in_c++/">C++ 函数可变参实现方法的演进</a>。</p><p>构造函数的参数 <code>ConstructorArgTypes&amp;&amp;... constructor_args</code> 是一个万能引用（universal reference）参数包，结合 std::forward 使用，可以实现参数的完美转发。</p><p>构造函数开始是两个<strong>静态断言（static_assert），用于检查 instance_storage_ 是否足够大以及是否满足对齐要求</strong>。第一个 static_assert 确保为 InstanceType 分配的存储空间 instance_storage_ 至少要和 InstanceType 实例本身一样大，这是为了<strong>确保有足够的空间来存放该类型的对象</strong>。第二个 static_assert 确保 instance_storage_ 的对齐方式满足 InstanceType 的对齐要求。对象只所以有内存对齐要求，和性能有关，这里不再展开。</p><p>接着开始构造对象，这里使用了 <strong>C++ 的原地构造语法（placement new）</strong>。<code>&amp;instance_storage_</code> 提供了一个地址，告诉编译器在这个已经分配好的内存地址上构造 InstanceType 的对象。这样做避免了额外的内存分配，直接在预留的内存块中构造对象。接下来使用完美转发，<code>std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...</code> 确保所有的构造函数参数都以正确的类型（保持左值或右值属性）传递给 InstanceType 的构造函数。这是现代 C++ 中参数传递的最佳实践，能够减少不必要的拷贝或移动操作，提高效率。</p><p>前面 placement new 原地构造的时候用的内存地址由成员变量 instance_storage_ 提供，instance_storage_ 的类型由 <a href="https://en.cppreference.com/w/cpp/types/aligned_storage">std::aligned_storage</a> 模板定义。这是一个特别设计的类型，<strong>用于提供一个可以安全地存储任何类型的原始内存块，同时确保所存储的对象类型（这里是 InstanceType）具有适当的大小和对齐要求</strong>。这里 std::aligned_storage 创建的原始内存区域和 NoDestructor 对象所在的内存区域一致，也就是说如果 NoDestructor 被定义为一个函数内的局部变量，那么它和其内的 instance_storage_ 都会位于栈上。如果 NoDestructor 被定义为静态或全局变量，它和 instance_storage_ 将位于静态存储区，静态存储区的对象具有整个程序执行期间的生命周期。</p><p>值得注意的是 C++23 标准里，将废弃 std::aligned_storage，具体可以参考 <a href="https://stackoverflow.com/questions/71828288/why-is-stdaligned-storage-to-be-deprecated-in-c23-and-what-to-use-instead">Why is std::aligned_storage to be deprecated in C++23 and what to use instead?</a>。</p><p>回到文章开始的例子，singleton 对象是一个静态局部变量，第一次调用 BytewiseComparator() 时被初始化，它的生命周期和程序的整个生命周期一样长。程序退出的时候，<strong>singleton 对象本身会被析构销毁掉</strong>，但是 NoDestructor 没有在其析构函数中添加任何逻辑来析构 instance_storage_ 中构造的对象，因此 instance_storage_ 中的 BytewiseComparatorImpl 对象永远不会被析构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LevelDB 中还提供了一个测试用例，用来验证这里的 NoDestructor 是否符合预期。</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>在 <code>util/no_destructor_test.cc</code> 中首先定义了一个结构体 <code>DoNotDestruct</code>，这个结构体在析构函数中调用了 std::abort()。如果程序运行或者最后退出的时候，调用了 DoNotDestruct 对象的析构函数，那么测试程序将会异常终止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DoNotDestruct</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DoNotDestruct</span>(<span class="type">uint32_t</span> a, <span class="type">uint64_t</span> b) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">DoNotDestruct</span>() &#123; std::<span class="built_in">abort</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used to check constructor argument forwarding.</span></span><br><span class="line">  <span class="type">uint32_t</span> a;</span><br><span class="line">  <span class="type">uint64_t</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着定义了 2 个测试用例，一个定义了栈上的 NoDestructor 对象，另一个定义了一个静态的 NoDestructor 对象。这两个测试用例分别验证 NoDestructor 对象在栈上和静态存储区上的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StackInstance) &#123;</span><br><span class="line">  <span class="function">NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StaticInstance) &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 NoDestructor 的实现有问题，无法保证传入对象的析构不被执行，那么测试程序将会异常终止掉。我们跑下这两个测试用例，结果如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png" alt="测试用例通过，析构函数没有被调用"></p><p>这里我们可以增加个测试用例，验证下如果直接定义 DoNotDestruct 对象的话，测试进程会不会异常终止。可以先定义一个栈上的对象来测试，放在其他 2 个测试用例前面，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, Instance) &#123;</span><br><span class="line">  <span class="function">DoNotDestruct <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，这个测试用例执行过程中会异常终止，说明 DoNotDestruct 对象的析构函数被调用了。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png" alt="测试进程异常终止，说明调用了析构"></p><p>其实这里可以再改下，用 static 直接定义这里的 instance 对象，然后编译重新运行测试用例，就会发现 3 个测试用例都通过了，不过最后测试进程还是 abort 掉，这是因为进程退出的时候，才会析构静态对象，这时 DoNotDestruct 对象的析构函数被调用了。</p><h2 id="为什么不能析构？"><a href="#为什么不能析构？" class="headerlink" title="为什么不能析构？"></a>为什么不能析构？</h2><p>上面的例子中，我们看到了 NoDestructor 模板类的实现，它的作用是禁止静态局部的单例对象析构。那么为什么要禁止对象析构呢？简单来说，<strong>C++ 标准没有规定不同编译单元中静态局部变量的析构顺序</strong>，如果静态变量之间存在依赖关系，而它们的析构顺序错误，可能会导致程序访问已经析构的对象，从而产生未定义行为，可能导致程序崩溃。</p><p>举一个例子，假设有两个类，一个是日志系统，另一个是某种服务，服务在析构时需要向日志系统记录信息。日志类的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span> <span class="comment">// Include assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isAlive; <span class="comment">// Flag to check if the object has been destructed</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Logger instance; <span class="comment">// 静态局部变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>() : <span class="built_in">isAlive</span>(<span class="literal">true</span>) &#123;&#125; <span class="comment">// Constructor initializes isAlive to true</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Logger destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        isAlive = <span class="literal">false</span>; <span class="comment">// Mark as destructed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(isAlive); <span class="comment">// Assert the object is not destructed</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意这个类的 isAlive 成员变量，在构造函数中初始化为 true，析构函数中置为 false。在 log 函数中，会先检查 isAlive 是否为 true，如果为 false，就会触发断言失败。接着是服务类的代码，这里作为示例，只让它在析构的时候用日志类的静态局部变量记录一条日志。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Service</span>() &#123;</span><br><span class="line">        Logger::<span class="built_in">getInstance</span>().<span class="built_in">log</span>(<span class="string">&quot;Service destroyed.&quot;</span>); <span class="comment">// 在析构时记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 main 函数中，使用全局变量 globalService 和 globalLogger，其中 globalService 是一个全局 Service 实例，globalLogger 是一个 Logger 单例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Service globalService; <span class="comment">// 全局Service实例</span></span><br><span class="line">Logger&amp; globalLogger = Logger::<span class="built_in">getInstance</span>(); <span class="comment">// 全局Logger实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行这个程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -g -fno-omit-frame-pointer -o main main.cpp</span></span><br></pre></td></tr></table></figure><p>运行后 assert 断言<strong>大概率会失败</strong>。我们知道<strong>在单个编译单元(这里是 main.cpp)中，全局变量按照出现的顺序来初始化，然后按照相反的顺序来析构</strong>。这里 globalLogger 会先析构，然后是 globalService，在 globalService 的析构函数中会调用 Logger 的 log 函数，但这时 globalLogger 已经被析构，isAlive 被置为 false，所以大概率会触发断言失败。之所以说大概率是因为，globalLogger 对象析构后，其占用的内存空间可能还<strong>未被操作系统回收或用于其他目的</strong>，对其成员变量 isAlive 的访问可能仍能“正常”。下面是我运行的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">main: logger.h:22: void Logger::log(const string&amp;): Assertion `isAlive&#x27; failed.</span><br><span class="line">[1]    1017435 abort      ./main</span><br></pre></td></tr></table></figure><p>其实这里如果不加 isAlive 相关逻辑，运行的话输出大概率如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">Log: Service destroyed.</span><br></pre></td></tr></table></figure><p>从输出可以看到和前面一样 globalLogger 先析构，lobalService 后析构。只是这里进程大概率不会 crash 掉，这是因为 globalLogger 被析构后，<strong>虽然其生命周期已结束，但是对成员函数的调用仍可能“正常”执行</strong>。这里成员函数的执行通常依赖于类的代码（位于代码段），只要代码段内容没有被重新写，并且方法不依赖于已经被破坏或改变的成员变量，它可能仍能运行而不出错。</p><p>当然就算这里没有触发程序崩溃，使用已析构对象的行为在 C++ 中是<a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">未定义的（Undefined Behavior）</a>。未定义行为意味着程序可能崩溃、可能正常运行，或者产生不可预期的结果。此类行为的结果可能在不同的系统或不同的运行时有所不同，我们在开发中一定要避免这种情况的发生。</p><p>其实就 LevelDB 这里的实现来说，BytewiseComparatorImpl 是一个平凡可析构 <a href="https://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor">trivially destructible</a> 对象，它不依赖其他全局变量，因此它本身析构不会有问题。如果用它生成一个静态局部的单例对象，然后在其他静态局部对象或者全局对象中使用，那么在这些对象析构时，会调用 BytewiseComparatorImpl 的析构函数。而根据前面的分析，这里 BytewiseComparatorImpl 本身是一个静态局部对象，<strong>在进程结束资源回收时，可能早于使用它的对象被被析构</strong>。这样就会导致重复析构，产生未定义行为。</p><p>更多关于静态变量析构的解释也可以参考 <a href="https://ppwwyyxx.com/blog/2023/Safe-Static-Initialization-No-Destruction/">Safe Static Initialization, No Destruction</a> 这篇文章，作者详细讨论了这个问题。</p>]]></content>
    
    
    <summary type="html">深入探讨LevelDB源码中的 NoDestructor 模板类，揭示其禁止对象析构的实现原理和背后动机。分析C++静态局部变量析构顺序问题，介绍NoDestructor的设计细节、测试用例及实际应用场景。适合C++开发者和对底层系统感兴趣的程序员阅读，助您掌握高级C++编程技巧。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  <entry>
    <title>Creating Games Using Free Claude3.5 with Artifacts</title>
    <link href="https://selfboot.cn/en/2024/06/22/claude35_artifacts/"/>
    <id>https://selfboot.cn/en/2024/06/22/claude35_artifacts/</id>
    <published>2024-06-22T13:47:28.000Z</published>
    <updated>2024-08-20T02:06:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>Anthropic has <strong>quietly</strong> released the <a href="https://www.anthropic.com/news/claude-3-5-sonnet">Claude 3.5 model</a>, which not only improves model performance but also supports Artifacts. After initial experience, I feel this is what the future of AI should look like, even more impressive than the previous GPT4-o.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_artifacts.png" alt="Coding in the Artifacts workspace"></p><p>Before Artifacts, if you wanted to use ChatGPT or other LLMs to help implement program functionality, you needed to first provide the functional requirements, then copy the AI’s code into your own environment to run. If it didn’t meet expectations, you had to ask again, modify the code, and run it again. This process needed to be repeated until satisfaction or giving up (some complex code is still not well written by AI currently).</p><span id="more"></span><p>Now with Artifacts, after providing specific functional requirements, Claude creates a <strong>workspace</strong>, where AI can view and edit code in real-time during the subsequent dialogue process. This way, Claude has transformed from an ordinary conversational generation AI into a <strong>collaborative work environment</strong>. Perhaps in the near future, we can incorporate Claude into our own projects, allowing it to participate in development like a regular team member.</p><p>The vision is certainly beautiful, but Artifacts is still a beta feature at present. How does it perform? Let’s try and see.</p><h2 id="AI-Implementation-of-Gomoku-Game"><a href="#AI-Implementation-of-Gomoku-Game" class="headerlink" title="AI Implementation of Gomoku Game"></a>AI Implementation of Gomoku Game</h2><p>First, I tried to let Claude implement a web version of the Gomoku game. My prompt was also very simple:</p><blockquote><p>I want to write a web Gomoku game, please provide the complete implementation code</p></blockquote><p>Then, I saw the Artifacts workspace, which already had a code file and was automatically generating code.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_gobang_code.png" alt="Artifacts generating Gomoku code file"></p><p>After the code was generated, it directly jumped to a preview page where I could see the Gomoku interface. I originally thought this preview page was static, but surprisingly, I could interact on this page. Clicking on positions on the board would alternately place black and white pieces.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_gobang_preview.png" alt="Artifacts generated Gomoku interface preview"></p><p>Since it could place pieces, I wondered if it had implemented the rules of Gomoku. So I played a bit and found that AI had indeed implemented the rules of Gomoku, and even had win&#x2F;loss judgment.</p><p>This <strong>completely exceeded expectations</strong>!!! With just one sentence, really just one sentence, <strong>AI implemented a fairly complete Gomoku game, with a beautiful interface, rule judgment, and win&#x2F;loss determination. It’s already completely playable</strong>.</p><p>The key is that AI also gave some suggestions for further improving the game, such as:</p><ul><li>Adding an undo function</li><li>Implementing a timer</li><li>Adding sound effects</li><li>Implementing an AI opponent</li><li>Optimizing the experience on mobile devices</li></ul><p>It feels like this is not an AI, but a flesh-and-blood, opinionated, experienced front-end engineer.</p><h3 id="Gomoku-Game-Demo"><a href="#Gomoku-Game-Demo" class="headerlink" title="Gomoku Game Demo"></a>Gomoku Game Demo</h3><p>You can experience the AI-written Gomoku game at the <a href="#Gomoku-Game-Demo">demo address</a> in the blog post.</p><div id="game-container">    <div id="board"></div>    <p id="status">Black's turn</p>    <button onclick="resetGame()">Restart</button></div><p>After showing the Gomoku effect generated by Claude3.5 to a friend, they were a bit skeptical about where AI got the code from. After all, Gomoku implementations are everywhere on the internet, and AI might have learned someone else’s code and used it. This makes sense, so we can only upgrade the difficulty to see how Claude3.5 performs.</p><h2 id="AI-Implementation-of-Tetris"><a href="#AI-Implementation-of-Tetris" class="headerlink" title="AI Implementation of Tetris"></a>AI Implementation of Tetris</h2><p>Next, let’s try a more complex game, Tetris. Also starting with a simple prompt, AI generated an initial Python version. To run it directly in the blog, I asked it to change to a web version. The first version generated, when embedded in the blog, found that the border was gone, and when using the up and down keys to switch shapes, the webpage would scroll along. So I asked Claude to solve this problem, and unexpectedly, it gave perfect code in one go.</p><p>As you can see from the image below, after re-prompting, Claude provided a second version of the file, and then the preview page was a complete Tetris game, controllable by keyboard to move and rotate blocks.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_tetris.png" alt="Artifacts generated Tetris interface preview"></p><p>Here, through <strong>continuous dialogue prompts</strong>, some functions were modified, and by the 5th version, we got a very good functional prototype. Throughout the conversation process, Claude3.5’s <strong>understanding ability was quite good</strong>, not very different from GPT4, and the final implementation effect also exceeded expectations.</p><h3 id="Tetris-Demo"><a href="#Tetris-Demo" class="headerlink" title="Tetris Demo"></a>Tetris Demo</h3><p>I’ve directly embedded the AI-generated code into the blog, and you can experience the Tetris game in the <a href="###Tetris-Demo">demo below</a>.</p><div id="tetrisContainer">    <canvas id="tetrisCanvas" width="300" height="600"></canvas>    <button id="startButton">Start Game</button>    <div id="gameOverMessage">        Game Over!<br>        Your score is: <span id="finalScore"></span><br>        <button id="restartButton">Restart</button>    </div></div><p>Judging from the continuous modification process of Tetris here, AI’s understanding ability and coding skills are quite strong, probably on par with GPT4.</p><h2 id="Everyone-Using-AI-to-Write-Programs"><a href="#Everyone-Using-AI-to-Write-Programs" class="headerlink" title="Everyone Using AI to Write Programs"></a>Everyone Using AI to Write Programs</h2><p>From the simple games written above, Anthropic’s performance is quite impressive. In fact, I also tried to use it to do some algorithm Web visualizations, and Claude3.5 provided very good examples. For instance, I asked it to implement a token bucket rate limiting algorithm, where you can set the token bucket capacity and rate, as well as the token consumption speed, and then have it draw a request monitoring curve.</p><p>After setting the parameters each time, it would dynamically generate a monitoring curve. Then you could pause at any time, reset the parameters, and continue to generate new monitoring curves. After setting a few parameters and running, I got the following result:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240622_claude35_artifacts_token_bucket.png" alt="Artifacts generated token bucket rate limiting algorithm interface preview"></p><p>For people without front-end development experience, being able to quickly implement a visualized algorithm demonstration is truly magical. With Anthropic’s help, everyone can break out of their circle, <strong>no longer limited by their own technical experience, and quickly implement some of their ideas</strong>.</p><p>Especially for people who want to learn programming, in the past, you basically had to first study books, learn skills, and then gradually apply them to projects. Now you can have a conversation with AI with questions, let AI help implement, and if you have any problems in between, you can communicate with AI at any time. <strong>This learning process is more interesting</strong>. After all, if you ask me to first learn a bunch of front-end syntax and then stumble to implement a Tetris game, I would give up very quickly. But if I can generate a complete, runnable game with just one sentence, and then discuss the implementation process and code details with AI, it would be much more interesting and give a greater sense of achievement.</p><h2 id="Anthropic’s-Shortcomings"><a href="#Anthropic’s-Shortcomings" class="headerlink" title="Anthropic’s Shortcomings"></a>Anthropic’s Shortcomings</h2><p>Of course, the current Anthropic is only a beta version and still has many shortcomings. The article title mentions using free Claude3.5, but there are quite a few limitations in the free version. First, there’s a <a href="https://support.anthropic.com/en/articles/7996848-how-large-is-claude-s-context-window">limit on conversation length</a>. If the content is a bit long, adding attachments will prompt:</p><blockquote><p>Your message will exceed the length limit for this chat. Try attaching fewer or smaller files or starting a new conversation. Or consider upgrading to Claude Pro.</p></blockquote><p>Even without attachments, too many conversation turns will prompt:</p><blockquote><p>Your message will exceed the length limit for this chat. Try shortening your message or starting a new conversation. Or consider upgrading to Claude Pro.</p></blockquote><p>Moreover, the free version <strong>has a limit on the number of messages that can be sent per hour</strong>, which is easily triggered. However, these are all minor issues that can be solved by upgrading to Pro. In my opinion, Anthropic’s <strong>biggest flaw currently is that the workspace functionality is too limited</strong>, still quite far from being truly practical.</p><p>Currently (as of 2024.06.22), the code in the workspace can only be generated by AI, <strong>it cannot be edited by yourself</strong>, nor can you upload your own code. If you want to make some simple modifications based on AI code, it’s very difficult. Additionally, in each conversation, the content generated in the workspace is all put together, <strong>you can’t generate multiple files like in a file system</strong>.</p><p>For example, if I want to use Python to implement a web backend service, using the FastAPI framework, implementing APIs with authentication functionality, and requiring convenient Docker deployment. Claude3.5 <strong>only generated one file</strong> in the workspace, and put main.py, Dockerfile, requirements.txt, and other content in it. If I want to use it, I still need to create folders locally, copy the contents into different files separately, and then initialize the environment to run.</p><p>If Anthropic’s workspace <strong>could create folders and then put the entire project’s code in it</strong>, and provide a function to download the entire project, it would be much more convenient. Going even further, Anthropic could provide a Python runtime environment, <strong>allowing users to run and debug code directly in the workspace</strong>. In this way, Anthropic could become a true collaborative work environment, not just a code generation tool.</p><p>Ideally, the future Anthropic should be able to generate and manage multiple folders or files in the workspace, allow us to manually modify parts of the code, and debug code in the workspace. Then Anthropic can discover problems during debugging and fix them. In other words, <strong>AI can understand the entire project code and participate in every process of development together with humans</strong>.</p><p>Perhaps such an Anthropic will be born soon.</p><!-- Tetris --><style>    #tetrisContainer {        position: relative;        width: 300px;        height: 600px;        margin: 20px auto;    }    #tetrisCanvas {        border: 2px solid #333;    }    #startButton {        position: absolute;        top: 50%;        left: 50%;        transform: translate(-50%, -50%);        padding: 10px 20px;        font-size: 16px;        cursor: pointer;    }    #gameOverMessage {        position: absolute;        top: 50%;        left: 50%;        transform: translate(-50%, -50%);        background-color: rgba(0, 0, 0, 0.7);        color: white;        padding: 20px;        text-align: center;        display: none;        width: 80%;        box-sizing: border-box;    }    #restartButton {        margin-top: 15px;        padding: 10px 20px;        font-size: 16px;        cursor: pointer;    }</style><script>    const canvas = document.getElementById('tetrisCanvas');    const ctx = canvas.getContext('2d');    const startButton = document.getElementById('startButton');    const restartButton = document.getElementById('restartButton');    const gameOverMessage = document.getElementById('gameOverMessage');    const finalScoreSpan = document.getElementById('finalScore');    const ROWS = 20;    const COLS = 10;    const BLOCK_SIZE = 30;    const SHAPES = [        [[1, 1, 1, 1]],        [[1, 1], [1, 1]],        [[1, 1, 1], [0, 1, 0]],        [[1, 1, 1], [1, 0, 0]],        [[1, 1, 1], [0, 0, 1]],        [[1, 1, 0], [0, 1, 1]],        [[0, 1, 1], [1, 1, 0]]    ];    const COLORS = [        '#00FFFF', '#FFFF00', '#FF00FF', '#FF0000',        '#00FF00', '#0000FF', '#FFA500'    ];    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));    let currentPiece = null;    let score = 0;    let gameActive = false;    let gameLoop;    function createPiece() {        const shapeIndex = Math.floor(Math.random() * SHAPES.length);        const colorIndex = Math.floor(Math.random() * COLORS.length);        return {            shape: SHAPES[shapeIndex],            color: COLORS[colorIndex],            x: Math.floor(COLS / 2) - Math.floor(SHAPES[shapeIndex][0].length / 2),            y: 0        };    }    function drawBlock(x, y, color) {        ctx.fillStyle = color;        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);        ctx.strokeStyle = '#000';        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);    }    function drawBoard() {        board.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    drawBlock(x, y, value);                }            });        });    }    function drawPiece() {        currentPiece.shape.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    drawBlock(currentPiece.x + x, currentPiece.y + y, currentPiece.color);                }            });        });    }    function isValidMove(piece, x, y) {        return piece.shape.every((row, dy) => {            return row.every((value, dx) => {                let newX = x + dx;                let newY = y + dy;                return (                    value === 0 ||                    (newX >= 0 && newX < COLS && newY < ROWS && (newY < 0 || board[newY][newX] === 0))                );            });        });    }    function rotatePiece() {        let rotated = currentPiece.shape[0].map((_, i) =>            currentPiece.shape.map(row => row[i]).reverse()        );        if (isValidMove({...currentPiece, shape: rotated}, currentPiece.x, currentPiece.y)) {            currentPiece.shape = rotated;        }    }    function movePiece(dx, dy) {        if (isValidMove(currentPiece, currentPiece.x + dx, currentPiece.y + dy)) {            currentPiece.x += dx;            currentPiece.y += dy;            return true;        }        return false;    }    function mergePiece() {        currentPiece.shape.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;                }            });        });    }    function clearLines() {        let linesCleared = 0;        for (let y = ROWS - 1; y >= 0; y--) {            if (board[y].every(cell => cell !== 0)) {                board.splice(y, 1);                board.unshift(Array(COLS).fill(0));                linesCleared++;            }        }        if (linesCleared > 0) {            score += linesCleared * 100;        }    }    function gameOver() {        return board[0].some(cell => cell !== 0);    }    function updateGame() {        if (!movePiece(0, 1)) {            mergePiece();            clearLines();            if (gameOver()) {                endGame();            } else {                currentPiece = createPiece();            }        }        drawGame();    }    function drawGame() {        ctx.clearRect(0, 0, canvas.width, canvas.height);        drawBoard();        if (currentPiece) {            drawPiece();        }    }    function startGame() {        board = Array(ROWS).fill().map(() => Array(COLS).fill(0));        score = 0;        currentPiece = createPiece();        gameActive = true;        startButton.style.display = 'none';        gameOverMessage.style.display = 'none';        drawGame();        gameLoop = setInterval(updateGame, 500); // 每500毫秒更新一次游戏状态    }    function endGame() {        gameActive = false;        clearInterval(gameLoop);        finalScoreSpan.textContent = score;        gameOverMessage.style.display = 'block';    }    startButton.addEventListener('click', startGame);    restartButton.addEventListener('click', startGame);    document.addEventListener('keydown', event => {        if (!gameActive) return;        event.preventDefault();        switch (event.keyCode) {            case 37: // 左箭头                movePiece(-1, 0);                break;            case 39: // 右箭头                movePiece(1, 0);                break;            case 40: // 下箭头                movePiece(0, 1);                break;            case 38: // 上箭头                rotatePiece();                break;        }        drawGame();    });    drawGame();</script><script>    const boardSize = 15;    let currentPlayer = 'black';    let gameBoard = [];    function createBoard() {        const board = document.getElementById('board');        for (let i = 0; i < boardSize; i++) {            const row = document.createElement('div');            row.className = 'row';            gameBoard[i] = [];            for (let j = 0; j < boardSize; j++) {                const cell = document.createElement('div');                cell.className = 'cell';                cell.onclick = () => placePiece(i, j);                row.appendChild(cell);                gameBoard[i][j] = '';            }            board.appendChild(row);        }    }    function placePiece(row, col) {        if (gameBoard[row][col] !== '') return;        const cell = document.getElementById('board').children[row].children[col];        const piece = document.createElement('div');        piece.className = `piece ${currentPlayer}`;        cell.appendChild(piece);        gameBoard[row][col] = currentPlayer;        if (checkWin(row, col)) {            document.getElementById('status').textContent = `${currentPlayer === 'black' ? 'Black' : 'White'} Wins！`;            disableBoard();        } else {            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';            document.getElementById('status').textContent = `${currentPlayer === 'black' ? 'Black' : 'White'}'s Turn`;        }    }    function checkWin(row, col) {        const directions = [            [1, 0], [0, 1], [1, 1], [1, -1]        ];        for (const [dx, dy] of directions) {            let count = 1;            count += countDirection(row, col, dx, dy);            count += countDirection(row, col, -dx, -dy);            if (count >= 5) return true;        }        return false;    }    function countDirection(row, col, dx, dy) {        let count = 0;        let x = row + dx;        let y = col + dy;        while (x >= 0 && x < boardSize && y >= 0 && y < boardSize && gameBoard[x][y] === currentPlayer) {            count++;            x += dx;            y += dy;        }        return count;    }    function disableBoard() {        const cells = document.getElementsByClassName('cell');        for (const cell of cells) {            cell.onclick = null;        }    }    function resetGame() {        const board = document.getElementById('board');        board.innerHTML = '';        gameBoard = [];        currentPlayer = 'black';        document.getElementById('status').textContent = 'Black\'s turn';        createBoard();    }    createBoard();</script><style>    #game-container {        text-align: center;    }    #board {        display: inline-block;        background-color: #d4a36a;        padding: 10px;        border: 2px solid #8b4513;    }    .row {        display: flex;    }    .cell {        width: 30px;        height: 30px;        border: 1px solid #000;        display: flex;        justify-content: center;        align-items: center;        cursor: pointer;    }    .piece {        width: 26px;        height: 26px;        border-radius: 50%;    }    .black {        background-color: #000;    }    .white {        background-color: #fff;    }</style>]]></content>
    
    
    <summary type="html">This article explores Anthropic&#39;s newly released Claude 3.5 model and its Artifacts feature, showcasing its exceptional code generation and problem-solving capabilities through the rapid implementation of Gomoku and Tetris games. It also discusses some limitations of the current version, such as restrictions on workspace functionality, and looks ahead to the future direction of AI-assisted programming.</summary>
    
    
    
    <category term="Artificial Intelligence" scheme="https://selfboot.cn/categories/Artificial-Intelligence/"/>
    
    
    <category term="LLM" scheme="https://selfboot.cn/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>免费版 Claude3.5 配合 Artifacts，一句话就能写个游戏</title>
    <link href="https://selfboot.cn/2024/06/22/claude35_artifacts/"/>
    <id>https://selfboot.cn/2024/06/22/claude35_artifacts/</id>
    <published>2024-06-22T13:47:28.000Z</published>
    <updated>2024-08-20T02:06:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>Anthropic <strong>不声不响</strong>地发布了 <a href="https://www.anthropic.com/news/claude-3-5-sonnet">Claude 3.5 模型</a>，除了模型效果提升，还支持了 Artifacts。初步体验后，感觉这才是未来 AI 的样子，比之前 GPT4-o 更让我震撼。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_artifacts.png" alt="Artifacts 工作空间内写代码"></p><p>在 Artifacts 之前，如果想用 ChatGPT 等 LLM 来帮忙实现程序功能，需要先提功能需求，然后复制 AI 的代码到自己的环境中运行。如果和预期不符合，要再追问、再修改代码运行。需要重复这个过程，直到满意或者放弃（有些复杂代码目前 AI 还是写不太好）。</p><span id="more"></span><p>现在有了 Artifacts，提供具体功能需求后，Claude 会创建一个<strong>工作空间</strong>，后续对话过程中，AI 可以在这个动态工作空间中实时查看、编辑代码。这样，Claude 就从普通的对话式生成 AI 变成了一个<strong>协作工作环境</strong>，或许在不久的将来，可以将 Claude 引入到我们自己的项目中，让它像普通团队成员一样参与到开发。</p><p>愿景当然很美好，不过目前的 Artifacts 还只是 beta 功能，表现如何呢？下面来试试看。</p><h2 id="AI-实现五子棋游戏"><a href="#AI-实现五子棋游戏" class="headerlink" title="AI 实现五子棋游戏"></a>AI 实现五子棋游戏</h2><p>先试着让 Claude 实现一个 web 版五子棋游戏，我的提示词也很简单：</p><blockquote><p>我想写一个网页五子棋游戏，给出完整的实现代码</p></blockquote><p>然后，就看到了 Artifacts 的工作空间，里面已经有了一个代码文件，并且在自动生成代码。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_gobang_code.png" alt="Artifacts 生成五子棋代码文件中"></p><p>代码生成之后，直接跳到了一个预览页面，可以看到五子棋的界面。本来以为这个预览页面是静态的，没想到还可以在这个页面上进行交互，点击棋盘上的位置，会轮流下黑白子。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_gobang_preview.png" alt="Artifacts 生成五子棋界面预览"></p><p>既然能下子，那么到底有没有实现五子棋的规则呢？于是玩了下，发现 AI 确实实现了五子棋的规则，而且还有胜负判断。</p><p><strong>完全超出预期了</strong>！！！一句话，真的只要一句话，<strong>AI 就实现了一个还算完整的五子棋游戏，有美观的界面，有规则判断，还有胜负判定，已经完全可以拿来玩了</strong>。</p><p>关键是 AI 还接着给出了一些继续完善游戏的建议，比如：</p><ul><li>添加悔棋功能</li><li>实现计时器</li><li>添加音效</li><li>实现AI对手</li><li>优化移动设备上的体验</li></ul><p>感觉这不是一个 AI，而是一个有血有肉，有自己想法，经验丰富的前端工程师了。</p><h3 id="五子棋游戏演示"><a href="#五子棋游戏演示" class="headerlink" title="五子棋游戏演示"></a>五子棋游戏演示</h3><p>大家可以在博客文章中的<a href="#%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F%E6%BC%94%E7%A4%BA">演示地址</a>体验下 AI 写的五子棋游戏。</p><div id="game-container">    <div id="board"></div>    <p id="status">黑方回合</p>    <button onclick="resetGame()">重新开始</button></div><p>跟朋友展示了 Claude3.5 生成的五子棋效果后，朋友有点怀疑 AI 是从哪里抄的代码。毕竟五子棋的实现网上到处都是，AI 学到的别人的代码并拿来用。这样说也不是没道理，那就只能升级下难度，来看看 Claude3.5 的表现如何。</p><h2 id="AI-实现俄罗斯方块"><a href="#AI-实现俄罗斯方块" class="headerlink" title="AI 实现俄罗斯方块"></a>AI 实现俄罗斯方块</h2><p>接着再来一个复杂点的游戏，俄罗斯方块。也是从一句简单的提示开始，AI 生成了一个初始的 python 版本。为了在博客里直接跑，就让它换成 web 版的。开始生成的第一个版本，嵌入到博客后，发现边框没有了，并且上下键切换形状的时候，网页会跟随滚动。于是让 Claude 解决这个问题，没想到一次就给出了完美的代码。</p><p>从下图也可以看到，重新提示后，Claude 给出可第 2 版本的文件，然后预览页面就是一个完整的俄罗斯方块游戏，可以通过键盘控制方块的移动和旋转。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_tetris.png" alt="Artifacts 生成俄罗斯方块界面预览"></p><p>这里后续又<strong>通过不断的对话提示</strong>，对一些功能进行了修改，第 5 个版本，就拿到了一个很不错的功能雏形了。整个对话过程感觉 Claude3.5 的<strong>理解能力还是很不错的</strong>，和 GPT4 差别不是很大，最后实现的效果也是超出预期。</p><h3 id="俄罗斯方块演示"><a href="#俄罗斯方块演示" class="headerlink" title="俄罗斯方块演示"></a>俄罗斯方块演示</h3><p>我把 AI 生成的代码直接嵌入到博客中，大家可以在<a href="###%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%E6%BC%94%E7%A4%BA">下面的演示</a>中体验俄罗斯方块游戏。</p><div id="tetrisContainer">    <canvas id="tetrisCanvas" width="300" height="600"></canvas>    <button id="startButton">开始游戏</button>    <div id="gameOverMessage">        游戏结束！<br>        你的得分是：<span id="finalScore"></span><br>        <button id="restartButton">重新开始</button>    </div></div><p>从这里俄罗斯方块的不断修改过程来看，AI 的理解能力和代码能力还是很强的，和 GPT4 应该在一个段位。</p><h2 id="人人用-AI-写程序"><a href="#人人用-AI-写程序" class="headerlink" title="人人用 AI 写程序"></a>人人用 AI 写程序</h2><p>从上面写的简单游戏来看，Anthropic 表现很不错。其实我还尝试用它来做一些算法的 Web 可视化演示，Claude3.5 给出的示例也很可以。比如我让它实现了一个令牌桶限频算法，可以设置令牌桶的容量和速率，以及消耗令牌速度，然后让它绘制一个请求监控曲线。</p><p>每次设置好参数后，会动态生成监控曲线。然后可以随时暂停，重新设置参数，再继续生成新的监控曲线。设置几个参数，并运行后，就得到了下面结果：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240622_claude35_artifacts_token_bucket.png" alt="Artifacts 生成令牌桶限频算法界面预览"></p><p>对于没有前端开发经验的人来说，能够很快实现一个可视化的算法演示，真的是神奇。在 Anthropic 的帮助下，每个人都可以破圈，<strong>不再受限于自己的技术经验，快速实现自己的一些想法</strong>。</p><p>特别是对于想学习编程的人来说，以前基本要先啃书，学习技能，然后逐步应用在项目中。现在可以带着问题和 AI 对话，让 AI 帮忙实现，中间有任何问题，可以随时和 AI 沟通，<strong>这样的学习过程更加有趣</strong>。毕竟，如果让我先学习一堆前端语法，然后磕磕碰碰去实现一个俄罗斯方块，我很快就会放弃。而如果我一句话，就生成了一个完整可运行的游戏，然后可以和 AI 一起交流实现的过程和代码细节，就会有趣很多，也会有更多的成就感。</p><h2 id="Anthropic-不足"><a href="#Anthropic-不足" class="headerlink" title="Anthropic 不足"></a>Anthropic 不足</h2><p>当然，目前的 Anthropic 只是一个 beta 版本，还有很多不足之处。文章标题写着使用免费 Claude3.5，不过这里免费版限制也比较多，首先是<a href="https://support.anthropic.com/en/articles/7996848-how-large-is-claude-s-context-window">对话长度有限制</a>，内容稍微长一点，添加附件就会提示：</p><blockquote><p>Your message will exceed the length limit for this chat. Try attaching fewer or smaller files or starting a new conversation. Or consider upgrading to Claude Pro.</p></blockquote><p>就算没附件，对话轮次太多也会提示：</p><blockquote><p>Your message will exceed the length limit for this chat. Try shortening your message or starting a new conversation. Or consider upgrading to Claude Pro.</p></blockquote><p>此外，免费版<strong>每小时可以发的消息条数也是有限制的</strong>，很容易触发限制。不过这些都还是小问题，升级 Pro 之后，都能解决。在我看来，目前 Anthropic <strong>最大的缺陷在于工作空间功能太受限</strong>，离真正实用还差不少距离。</p><p>目前(2024.06.22)工作空间中的代码只能是 AI 生成，<strong>不能自己编辑</strong>，也不能上传自己的代码。如果想在 AI 代码基础上做一些简单改动，就很困难。另外，每个对话中，工作空间里生成的内容都放在一起，<strong>不能像在文件系统里一样，生成多个文件</strong>。</p><p>比如我想用 python 实现一个 web 后端服务，用 fastapi 框架，实现带鉴权功能的 api，要求方便用 docker 部署。Claude3.5 在工作空间<strong>只生成了一个文件</strong>，然后在里面放了 main.py，Dockfile，requirements.txt 等内容。我想拿来用的话，还需要在本地创建文件夹，把里面的内容单独拷贝到不同文件，然后再初始化环境运行。</p><p>如果 Anthropic 的工作空间，<strong>能够创建文件夹，然后在里放入整个项目的代码</strong>，并提供下载整个项目的功能，就方便很多。甚至更进一步，Anthropic 可以提供 Python 的运行环境，<strong>让用户直接在工作空间里运行并调试代码</strong>。这样的话，Anthropic 就可以成为一个真正的协作工作环境，而不仅仅是一个代码生成工具。</p><p>理想状况下，未来的 Anthropic 应该可以在工作空间生成并管理多个文件夹或者文件，允许我们人工修改部分代码，并在工作空间调试代码。然后 Anthropic 可以在调试过程中发现问题，并进行修复。也就是说，<strong>AI 可以了解整个项目代码，并和人一起，参与到开发的每个过程中去</strong>。</p><p>或许这样的 Anthropic 很快就会诞生吧。</p><!-- 俄罗斯方块 --><style>    #tetrisContainer {        position: relative;        width: 300px;        height: 600px;        margin: 20px auto;    }    #tetrisCanvas {        border: 2px solid #333;    }    #startButton {        position: absolute;        top: 50%;        left: 50%;        transform: translate(-50%, -50%);        padding: 10px 20px;        font-size: 16px;        cursor: pointer;    }    #gameOverMessage {        position: absolute;        top: 50%;        left: 50%;        transform: translate(-50%, -50%);        background-color: rgba(0, 0, 0, 0.7);        color: white;        padding: 20px;        text-align: center;        display: none;        width: 80%;        box-sizing: border-box;    }    #restartButton {        margin-top: 15px;        padding: 10px 20px;        font-size: 16px;        cursor: pointer;    }</style><script>    const canvas = document.getElementById('tetrisCanvas');    const ctx = canvas.getContext('2d');    const startButton = document.getElementById('startButton');    const restartButton = document.getElementById('restartButton');    const gameOverMessage = document.getElementById('gameOverMessage');    const finalScoreSpan = document.getElementById('finalScore');    const ROWS = 20;    const COLS = 10;    const BLOCK_SIZE = 30;    const SHAPES = [        [[1, 1, 1, 1]],        [[1, 1], [1, 1]],        [[1, 1, 1], [0, 1, 0]],        [[1, 1, 1], [1, 0, 0]],        [[1, 1, 1], [0, 0, 1]],        [[1, 1, 0], [0, 1, 1]],        [[0, 1, 1], [1, 1, 0]]    ];    const COLORS = [        '#00FFFF', '#FFFF00', '#FF00FF', '#FF0000',        '#00FF00', '#0000FF', '#FFA500'    ];    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));    let currentPiece = null;    let score = 0;    let gameActive = false;    let gameLoop;    function createPiece() {        const shapeIndex = Math.floor(Math.random() * SHAPES.length);        const colorIndex = Math.floor(Math.random() * COLORS.length);        return {            shape: SHAPES[shapeIndex],            color: COLORS[colorIndex],            x: Math.floor(COLS / 2) - Math.floor(SHAPES[shapeIndex][0].length / 2),            y: 0        };    }    function drawBlock(x, y, color) {        ctx.fillStyle = color;        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);        ctx.strokeStyle = '#000';        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);    }    function drawBoard() {        board.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    drawBlock(x, y, value);                }            });        });    }    function drawPiece() {        currentPiece.shape.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    drawBlock(currentPiece.x + x, currentPiece.y + y, currentPiece.color);                }            });        });    }    function isValidMove(piece, x, y) {        return piece.shape.every((row, dy) => {            return row.every((value, dx) => {                let newX = x + dx;                let newY = y + dy;                return (                    value === 0 ||                    (newX >= 0 && newX < COLS && newY < ROWS && (newY < 0 || board[newY][newX] === 0))                );            });        });    }    function rotatePiece() {        let rotated = currentPiece.shape[0].map((_, i) =>            currentPiece.shape.map(row => row[i]).reverse()        );        if (isValidMove({...currentPiece, shape: rotated}, currentPiece.x, currentPiece.y)) {            currentPiece.shape = rotated;        }    }    function movePiece(dx, dy) {        if (isValidMove(currentPiece, currentPiece.x + dx, currentPiece.y + dy)) {            currentPiece.x += dx;            currentPiece.y += dy;            return true;        }        return false;    }    function mergePiece() {        currentPiece.shape.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;                }            });        });    }    function clearLines() {        let linesCleared = 0;        for (let y = ROWS - 1; y >= 0; y--) {            if (board[y].every(cell => cell !== 0)) {                board.splice(y, 1);                board.unshift(Array(COLS).fill(0));                linesCleared++;            }        }        if (linesCleared > 0) {            score += linesCleared * 100;        }    }    function gameOver() {        return board[0].some(cell => cell !== 0);    }    function updateGame() {        if (!movePiece(0, 1)) {            mergePiece();            clearLines();            if (gameOver()) {                endGame();            } else {                currentPiece = createPiece();            }        }        drawGame();    }    function drawGame() {        ctx.clearRect(0, 0, canvas.width, canvas.height);        drawBoard();        if (currentPiece) {            drawPiece();        }    }    function startGame() {        board = Array(ROWS).fill().map(() => Array(COLS).fill(0));        score = 0;        currentPiece = createPiece();        gameActive = true;        startButton.style.display = 'none';        gameOverMessage.style.display = 'none';        drawGame();        gameLoop = setInterval(updateGame, 500); // 每500毫秒更新一次游戏状态    }    function endGame() {        gameActive = false;        clearInterval(gameLoop);        finalScoreSpan.textContent = score;        gameOverMessage.style.display = 'block';    }    startButton.addEventListener('click', startGame);    restartButton.addEventListener('click', startGame);    document.addEventListener('keydown', event => {        if (!gameActive) return;        event.preventDefault();        switch (event.keyCode) {            case 37: // 左箭头                movePiece(-1, 0);                break;            case 39: // 右箭头                movePiece(1, 0);                break;            case 40: // 下箭头                movePiece(0, 1);                break;            case 38: // 上箭头                rotatePiece();                break;        }        drawGame();    });    drawGame();</script><!-- 五子棋游戏 --><script>    const boardSize = 15;    let currentPlayer = 'black';    let gameBoard = [];    function createBoard() {        const board = document.getElementById('board');        for (let i = 0; i < boardSize; i++) {            const row = document.createElement('div');            row.className = 'row';            gameBoard[i] = [];            for (let j = 0; j < boardSize; j++) {                const cell = document.createElement('div');                cell.className = 'cell';                cell.onclick = () => placePiece(i, j);                row.appendChild(cell);                gameBoard[i][j] = '';            }            board.appendChild(row);        }    }    function placePiece(row, col) {        if (gameBoard[row][col] !== '') return;        const cell = document.getElementById('board').children[row].children[col];        const piece = document.createElement('div');        piece.className = `piece ${currentPlayer}`;        cell.appendChild(piece);        gameBoard[row][col] = currentPlayer;        if (checkWin(row, col)) {            document.getElementById('status').textContent = `${currentPlayer === 'black' ? '黑' : '白'}方获胜！`;            disableBoard();        } else {            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';            document.getElementById('status').textContent = `${currentPlayer === 'black' ? '黑' : '白'}方回合`;        }    }    function checkWin(row, col) {        const directions = [            [1, 0], [0, 1], [1, 1], [1, -1]        ];        for (const [dx, dy] of directions) {            let count = 1;            count += countDirection(row, col, dx, dy);            count += countDirection(row, col, -dx, -dy);            if (count >= 5) return true;        }        return false;    }    function countDirection(row, col, dx, dy) {        let count = 0;        let x = row + dx;        let y = col + dy;        while (x >= 0 && x < boardSize && y >= 0 && y < boardSize && gameBoard[x][y] === currentPlayer) {            count++;            x += dx;            y += dy;        }        return count;    }    function disableBoard() {        const cells = document.getElementsByClassName('cell');        for (const cell of cells) {            cell.onclick = null;        }    }    function resetGame() {        const board = document.getElementById('board');        board.innerHTML = '';        gameBoard = [];        currentPlayer = 'black';        document.getElementById('status').textContent = '黑方回合';        createBoard();    }    createBoard();</script><style>    #game-container {        text-align: center;    }    #board {        display: inline-block;        background-color: #d4a36a;        padding: 10px;        border: 2px solid #8b4513;    }    .row {        display: flex;    }    .cell {        width: 30px;        height: 30px;        border: 1px solid #000;        display: flex;        justify-content: center;        align-items: center;        cursor: pointer;    }    .piece {        width: 26px;        height: 26px;        border-radius: 50%;    }    .black {        background-color: #000;    }    .white {        background-color: #fff;    }</style>]]></content>
    
    
    <summary type="html">深入探讨 Anthropic 新发布的 Claude 3.5 模型及其 Artifacts 功能，通过五子棋和俄罗斯方块游戏的快速实现，展示了代码生成和问题解决方面的卓越能力。还讨论了当前版本的一些局限性，如工作空间功能的限制，并展望了未来 AI 辅助编程的发展方向。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="LLM" scheme="https://selfboot.cn/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>How an Async Thread Pool Exception Caused Service Chaos</title>
    <link href="https://selfboot.cn/en/2024/06/13/async_pool_block_problem/"/>
    <id>https://selfboot.cn/en/2024/06/13/async_pool_block_problem/</id>
    <published>2024-06-13T20:01:55.000Z</published>
    <updated>2024-08-20T02:06:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>Recently, I encountered a very strange service restart issue in our business, and the troubleshooting process was quite complex. This article will review the process. The problem involves multiple aspects such as C++ thread pools, integer overflow, exception catching, and blocking, which is quite interesting.</p><p>Next, I will organize the content of this article according to the <strong>problem investigation process</strong>, starting with an introduction to the problem background, then listing the initial troubleshooting ideas and methods for locating abnormal requests. Then, through code analysis and some simple use cases to reproduce the problem, we will unveil the mystery of the service restart.</p><span id="more"></span><h2 id="Problem-Background"><a href="#Problem-Background" class="headerlink" title="Problem Background"></a>Problem Background</h2><p>We have a module A that provides RPC services externally, and the main caller B calls A’s services. Module A’s service is divided into two processes: the mesh process and the business process, both of which are multi-threaded. The mesh process functions similarly to a <a href="https://istio.io/latest/docs/reference/config/networking/sidecar/">Sidecar</a>, assigning a worker thread to handle each RPC request received from the main caller. The worker sends the request package to the business process through a Unix socket and then waits for the business process to process it before replying to the main caller. The business process is specifically used for business logic, processing the request package and sending the response package to the worker in the mesh process. The overall process is shown in the following diagram:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_bg.png" alt="Service divided into mesh process and business process"></p><p>Recently, the main caller B discovered through monitoring that there were several instances each day where it couldn’t connect to module A’s service port. Each instance didn’t last long and automatically recovered after a while.</p><p>A brief look at module A’s logs revealed that at the corresponding time points, <strong>the monitoring script failed to probe A’s service and thus restarted the service</strong>. The monitoring script here probes module A’s liveness detection RPC (which simply replies with a “hello”) at fixed intervals to check if the service is normal. If several consecutive probes fail, it considers the service to have a problem and attempts to restart it. This occasional restart of module A was due to the monitoring script being unable to get a reply from the liveness detection RPC, thus restarting the service.</p><p>So <strong>when did this problem start to occur?</strong> Extending the monitoring time for module A, we found that occasional mysterious restarts only started 7 days ago. Each server of module A experienced restarts, but the restart frequency was very low, so module A didn’t trigger any alarms.</p><p>Based on experience, probe failures are usually due to the service process crashing, such as the process exiting due to a coredump or being killed by the system due to an OOM (Out Of Memory) error. However, checking module A’s logs, we found it wasn’t either of these two situations. Module A didn’t show any coredump-related logs, and memory usage was normal during the restart periods. Could it be that there’s <strong>an infinite loop in the code causing the worker thread to be occupied and unable to release</strong>? Looking at the CPU usage during the restart periods, it was also at normal levels. Of course, if there’s a constant sleep in the infinite loop, the CPU usage wouldn’t be high, but there wasn’t anything using sleep in the business logic, so we initially ruled out an infinite loop.</p><p>This was a bit strange. Let’s continue to carefully examine the service logs for troubleshooting.</p><h2 id="Initial-Investigation"><a href="#Initial-Investigation" class="headerlink" title="Initial Investigation"></a>Initial Investigation</h2><p>We found a machine that had recently restarted and first looked at the service process logs at the restart time point. The mesh process in module A is a C++ multi-threaded service with N worker threads concurrently processing business RPC requests. The framework prints logs at intervals, recording how many of the current workers are idle and how many are busy processing requests. Under normal circumstances, in the printed logs, most threads are idle, with only a few busy.</p><p>However, before the process restart, we found that the number of worker threads in the logs was a bit abnormal, with <strong>idle threads decreasing rapidly within 1 minute until reaching 0</strong>. Assuming a total of 200 workers, the relevant logs before the restart were roughly as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">worker idle 100, busy 100;</span><br><span class="line">worker idle 40, busy 160;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>No wonder the monitoring script would fail to probe. At this moment, all of the service’s workers were occupied, with no idle workers to handle new incoming requests. All new requests would queue up waiting for a worker until timing out and failing.</p><p>So what caused the workers to be continuously occupied without being released? The service only recently started experiencing this issue, so we first thought it might be related to recent changes. We looked at the recent code changes but didn’t find any problems.</p><p>Next, there were actually two troubleshooting approaches. The first was to wait for the service process to get stuck again, then use gdb to attach to the process or use gcore to dump a coredump file. This would allow us to examine the call stack of the worker threads and see what function was causing the workers to be continuously occupied. We first ruled out gdb attach because the occurrence probability was quite low, and the monitoring script would restart the service in a very short time, making it difficult to find the right moment. Additionally, it’s not very suitable to attach to a production service for troubleshooting. As for gcore, it would require modifying the monitoring script to save the process coredump file when there’s a problem with the probe. However, considering that we needed to modify the monitoring script and that the coredump file might not necessarily reveal the problem, we didn’t adopt this approach for now.</p><p>The second approach was to find a request that could reproduce the problem and locate the issue through reproduction. After all, <strong>if a problem can be consistently reproduced, it’s as good as half solved</strong>. This is actually based on the assumption that <strong>intermittent problems are usually caused by certain special requests triggering some boundary conditions</strong>.</p><p>For our RPC module, if a special request causes a worker to be continuously occupied, then this request must be one that doesn’t receive a response. Therefore, we can <strong>print relevant logs when the module receives a request package and when it gives a response package</strong>. Then, during the time period when the service gets stuck, we can filter out those RPC requests in the logs that have requests but no responses.</p><p>After adding logs and deploying them, coincidentally, another service restart occurred. Through the logs, we finally found the suspicious request. Combined with this suspicious request, we discovered a problematic piece of code, which became the breakthrough point for solving the problem.</p><h2 id="Problematic-Code-Analysis"><a href="#Problematic-Code-Analysis" class="headerlink" title="Problematic Code Analysis"></a>Problematic Code Analysis</h2><p>Let’s first look at this problematic code. After simplification and hiding key information, it’s roughly as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gramCount = <span class="number">3</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; posVec;</span><br><span class="line"><span class="comment">// GetPosVec(posVec);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt; posVec.<span class="built_in">size</span>() - gramCount; ++i) &#123;</span><br><span class="line">posVec[i] = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As smart as you are, you must have noticed the problem with this code.</p><p>Here, i is an unsigned integer, and <code>posVec.size()</code> also returns an unsigned integer type size_t. When posVec.size() is less than gramCount, <code>posVec.size() - gramCount</code> will <strong>overflow</strong>, becoming a very large positive integer. Then in the loop, this very large positive integer will be used to traverse posVec, leading to <strong>array out of bounds</strong>. When using operator[] to access the array here, out-of-bounds access is <a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">undefined behavior</a>, which generally causes the program to crash. I wrote a simple test code and found that it indeed resulted in a segmentation fault. It’s worth adding that if <a href="https://cplusplus.com/reference/array/array/at/">at is used to access the array</a>, out-of-bounds access will throw an out_of_range exception, which will definitely crash if the exception is caught.</p><p>However, this code in module A didn’t crash, but instead caused the worker thread to be continuously occupied. Why is this? One suspicious point is that the above code is actually running in a newly opened thread pool. To add some background here, after module A receives an RPC request, it processes the business logic in a worker thread. Some business logic is quite time-consuming, so <strong>to improve processing speed, the time-consuming parts are put into an additional thread pool for concurrent execution</strong>.</p><p>The implementation of this thread pool is a bit complex, but the basic idea is <strong>a task queue + N pre-configured worker threads</strong>. The task queue is used to store tasks that need to be executed, and worker threads fetch tasks from the task queue to execute. The thread pool provides an interface <code>RunTask(concur, max_seq, task);</code> where concur is the number of threads for concurrent execution, max_seq is the total number of tasks, and task is the task function. RunTask will use concur threads to concurrently execute this task function task until all max_seq tasks are completed.</p><p>Before the task starts, RunTask defines a pipe to synchronize messages between the main thread and the task thread pool. Once all threads complete their tasks, the last exiting thread will write a character to the pipe to notify the main thread. The main thread will wait for the character in the pipe and then return.</p><p>The code with integer overflow above is placed in this additional thread pool for execution. Could the problem be caused by the thread pool? To quickly verify this hypothesis, I wrote a simple test script, putting the above code into the thread pool for execution, and the process indeed got stuck without response. The first guess was, could it be that the threads in the thread pool crashed due to array out of bounds, failed to write to the pipe, causing the main thread to block indefinitely on the pipe read operation?</p><p>Let’s verify this below.</p><h2 id="Multithreading-thread"><a href="#Multithreading-thread" class="headerlink" title="Multithreading: thread"></a>Multithreading: thread</h2><p>To verify the above hypothesis, I wrote a simple test program to simulate the workflow of the business thread pool. Here, C++11’s thread is used to start 5 new threads, and these threads sleep for a period of time to simulate task execution. When all threads have completed their tasks, the last completed thread writes a character to the pipe, and the main thread blocks on reading from the pipe. The test code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">completedThreads</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCurrentTimeAndThread</span><span class="params">(<span class="type">const</span> std::string&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_c), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot; Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>], <span class="type">int</span> totalThreads)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// Simulate some work</span></span><br><span class="line">    <span class="type">int</span> finished = ++completedThreads;</span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// The last completed thread writes to the pipe</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction, fds, totalThreads);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// Main thread blocks here waiting for pipe write</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// What happens if we comment this out?</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread finished&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After running, we found that this behaves as expected. 5 threads execute concurrently for 1s, and the main thread waits for the last thread to complete, then reads the result from the pipe and continues execution. The result is as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140358584862528 - 2024-06-12 11:40:51</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140358568072960 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358559680256 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358551287552 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358584858368 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358576465664 - 2024-06-12 11:40:52</span><br><span class="line">Main thread finished Thread ID: 140358584862528 - 2024-06-12 11:40:52</span><br></pre></td></tr></table></figure><p>Now, let’s <strong>make the last child thread directly throw an exception and see if the main thread blocks</strong>. We make the following changes based on the above code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Out of range exception&quot;</span>); <span class="comment">// Simulate at out-of-bounds array access, throw exception</span></span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// The last completed thread writes to the pipe</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>After recompiling and running, we found that the entire process crashed directly. The result is as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140342189496128 - 2024-06-12 11:46:23</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140342189491968 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342181099264 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342172706560 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342164313856 - 2024-06-12 11:46:24</span><br><span class="line">terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span><br><span class="line">  what():  Out of range exception</span><br><span class="line">[1]    2622429 abort      ./thread_test2</span><br></pre></td></tr></table></figure><p>It seems the previous guess was wrong! In a multi-threaded environment, a single thread throwing an exception caused the entire process to abort. Why is this? We have to mention <strong>C++’s exception handling mechanism</strong> here.</p><h3 id="C-Exception-Handling"><a href="#C-Exception-Handling" class="headerlink" title="C++ Exception Handling"></a>C++ Exception Handling</h3><p>In C++, when a program encounters a problem it can’t resolve on its own, it can throw an exception. Exceptions are usually objects derived from the standard exception class, such as std::runtime_error. When programming, you can put code that might throw exceptions inside a try block, followed by one or more catch blocks to catch and handle specific types of exceptions.</p><p>If an exception is not caught in the current scope, <strong>it will be propagated to higher levels of the try-catch structure in the call stack</strong> until a suitable catch block is found. If no suitable catch block is found throughout the entire call stack, <a href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate()</a> will be called, with the specific execution operation specified by std::terminate_handler, which by default calls <a href="https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a>. If no signal handler is set to catch the SIGABRT signal, the program will be abnormally terminated.</p><p>For the example multi-threaded code above, the last thread throws an exception, but there’s nowhere to catch it, so std::abort() is ultimately called to terminate the entire process. From the output above, we can see that the last line is abort.</p><p>C++ is designed this way because an uncaught exception usually means the program has entered an unknown state, and continuing to run could lead to more serious errors, such as data corruption or security vulnerabilities. Therefore, <strong>immediately terminating the program is considered a safe failure mode</strong>.</p><h3 id="Thread-Object-Lifecycle"><a href="#Thread-Object-Lifecycle" class="headerlink" title="Thread Object Lifecycle"></a>Thread Object Lifecycle</h3><p>There’s another point to mention here. In the example program above, the main thread calls thread.join() on each child thread’s thread object at the end. What happens if we comment this out and run the program? The process will still crash, and it’s also calling terminate(). Why is this?</p><p>Actually, the terminate documentation mentioned earlier states that terminate will be called in the following situation:</p><blockquote><ol start="10"><li>A joinable std::thread is destroyed or assigned to.</li></ol></blockquote><p>Continuing to look at the std::thread::joinable documentation, we find the following explanation:</p><blockquote><p>A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</p></blockquote><p>We know that child threads automatically exit after executing their related code. However, this doesn’t mean that the std::thread object associated with that thread will automatically handle all the resources and states of this thread. In C++, the ending of an operating system thread and the lifecycle management of a std::thread object are two related but relatively independent concepts:</p><ul><li><strong>Operating system thread</strong>: When a thread finishes executing code, it automatically stops, and the thread’s system resources (such as thread descriptors and stack) are usually reclaimed by the operating system.</li><li><strong>std::thread object management</strong>: Although the thread has ended, the std::thread object still needs to correctly update its state to <strong>reflect that the thread is no longer active</strong>. This is mainly achieved through the <a href="https://en.cppreference.com/w/cpp/thread/thread/join">join()</a> or detach() methods. If these methods are not called, when the std::thread object is destroyed, it will detect that it still “owns” an active thread, which will lead to calling std::terminate().</li></ul><p>In the example code above, when the main thread calls the join() method, it will block waiting for the child thread to finish executing (in this example, writing a character to the pipe has already ensured completion), and then mark the std::thread object state as “inactive”.</p><p>So, returning to the previous question, <strong>why does the main thread get stuck when a thread in the thread pool throws an exception in the business code</strong>? Upon closer inspection of the thread pool implementation code, we found that it doesn’t use thread to create threads, but uses <a href="https://en.cppreference.com/w/cpp/thread/async">std::async</a>. What is async? How does it work, and could the thread getting stuck be related to async?</p><p>Let’s continue to verify together.</p><h2 id="Multithreading-async"><a href="#Multithreading-async" class="headerlink" title="Multithreading: async"></a>Multithreading: async</h2><p>C++11 introduced std::async, which is a high-level tool for <strong>simplifying concurrent programming</strong>. It can <strong>run a function or callable object in an asynchronous execution context and return a std::future object</strong> to access the return value or exception state of that function.</p><p>Haha, after reading this introduction, are you confused and bewildered? Don’t worry, let’s set these aside and look at the code first. We’ll make some slight modifications based on the previous thread example code, using async for concurrent execution. The complete code is as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">completedThreads</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCurrentTimeAndThread</span><span class="params">(<span class="type">const</span> std::string&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_c), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot; Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>], <span class="type">int</span> totalThreads)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// Simulate some work</span></span><br><span class="line">    <span class="type">int</span> finished = ++completedThreads;</span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Out of range exception&quot;</span>); <span class="comment">// Simulate at out-of-bounds array access, throw exception</span></span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// The last completed thread writes to the pipe</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">        futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, threadFunction, fds, totalThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// Main thread blocks here waiting for pipe write</span></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread finished&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After running, we found that the main thread got stuck!! The running result is as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140098007660352 - 2024-06-12 21:06:00</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140097990870784 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140097974085376 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140097999263488 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140098007656192 - 2024-06-12 21:06:01</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>We have successfully reproduced the problem in the business. Before continuing with deeper analysis, let’s first look at how async is used, mainly as follows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">    futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, threadFunction, fds, totalThreads));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The above code uses the std::async function to start a group of asynchronous tasks, defined by threadFunction. Each task is configured to execute on a new thread when created, and uses the std::launch::async strategy to ensure they start immediately. The execution results (or states) of these tasks are encapsulated in std::future<void> objects and stored in the futures std::vector. That’s enough to understand for now, let’s continue to analyze why the main thread gets stuck.</p><h3 id="GDB-Analysis"><a href="#GDB-Analysis" class="headerlink" title="GDB Analysis"></a>GDB Analysis</h3><p>Let’s use GDB to see what happens during the process execution. After running here, we can see that 5 new threads are created to execute async tasks, then 4 threads print task output, and then all 5 threads are destroyed by the system. After that, the GDB console will get stuck. At this point, use Ctrl+C to pause program execution, and then you can use the GDB console.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_gdb.png" alt="GDB troubleshooting blocked process"></p><p>After the process gets stuck, looking at the stack, we find it’s blocked on the read in the main function of the main thread. At this point, only the main thread remains in the process, which can be confirmed using info threads. Here, 0x7ffff7a9e740 is actually the hexadecimal of Thread ID: 140737348495168 printed at the beginning of the process. From the GDB results, we can see that the last child thread throws an exception before it’s about to write, then exits directly without writing a character to the pipe, and the main thread keeps blocking on the read of the pipe.</p><p>The question arises, shouldn’t the entire process abort and terminate? In the previous <a href="#Multithreading:-thread">thread example</a>, when the thread’s thrown exception wasn’t caught, it caused the process to abort, and the main thread also ended as a result. But here, the <strong>exception thrown by the thread created by async seems to have disappeared, with no place to catch it, and it didn’t trigger the process to abort</strong>. Why is this?</p><h3 id="Async-Exception-Handling"><a href="#Async-Exception-Handling" class="headerlink" title="Async Exception Handling"></a>Async Exception Handling</h3><p>Let’s first see if the <a href="https://en.cppreference.com/w/cpp/thread/async">async</a> documentation says anything about how exceptions are handled.</p><blockquote><p>If the function f returns a value or throws an exception, it is stored in the shared state accessible through the std::future that std::async returns to the caller.</p></blockquote><p>We can see that if a thread started by std::async throws an exception, <strong>these exceptions will be caught and stored in the returned std::future object</strong>. Looking further at the future documentation, we find that <a href="https://en.cppreference.com/w/cpp/thread/future/get">future::get</a> can be used to get the execution result of the task. If the task throws an exception, calling get will re-throw the exception.</p><blockquote><p>If an exception was stored in the shared state referenced by the future (e.g. via a call to std::promise::set_exception()) then that exception will be thrown.</p></blockquote><p>At this point, we’ve found the reason why the above example program didn’t abort, which lies in async’s exception handling mechanism. <strong>In async, exceptions thrown by threads are stored in std::future objects, rather than directly causing the process to abort. After the child thread throws an exception, it doesn’t write a character to the pipe, so the main thread keeps blocking on read waiting, causing the entire process to appear stuck</strong>.</p><p>Here, we can call get before read in the example program to catch the exception and print it out for verification.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; future : futures) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        future.<span class="built_in">get</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// Main thread blocks here waiting for pipe write</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>We can see that an out_of_range exception is indeed caught here.</p><h3 id="Advantages-of-Async"><a href="#Advantages-of-Async" class="headerlink" title="Advantages of Async"></a>Advantages of Async</h3><p>Regarding async, let’s add a bit more thought. What advantages does async introduced in C++11 have compared to traditional thread?</p><p>First, std::async provides a <strong>simpler way to create and execute asynchronous tasks</strong> compared to directly using std::thread. It automatically handles thread creation and management, allowing developers to focus on business logic rather than the details of thread management. std::async can automatically manage the lifecycle of tasks, including timely starting and terminating threads. Using std::async doesn’t require explicitly calling join() or detach().</p><p>Additionally, as mentioned earlier, tasks started using std::async can throw exceptions during execution, and these exceptions are caught and stored in the returned std::future object. By calling std::future::get(), these exceptions can be caught and handled in the main thread.</p><p>Furthermore, calling std::async allows specifying the launch mode (std::launch::async or std::launch::deferred), where std::launch::async forces the task to run immediately in a new thread, while std::launch::deferred delays the execution of the task until std::future::get() or std::future::wait() is called.</p><p>Generally speaking, when tasks need to be executed in parallel and have no dependencies on each other, using std::async without concerning about thread management will be much simpler. Or if you need to get the execution results of parallel tasks at some future point, combining std::async with std::future will also be much more convenient.</p><h2 id="Production-Service-Review"><a href="#Production-Service-Review" class="headerlink" title="Production Service Review"></a>Production Service Review</h2><p>Alright, now let’s return to the discussion of the production service. Through the previous analysis, we can now determine the source of the problem, but there are still a few details related to the production service that need to be clarified. The first is that the problematic code here had been online for a long time, so why did the problem only occur recently? Going back to the example in the <a href="#Problematic-Code-Analysis">Problematic Code Analysis</a> section, if the array size is greater than or equal to gramCount, there would be no overflow and it wouldn’t cause a crash. Recently, the length of the array here changed, which is why the above problem occurred.</p><p>The second question is, each time abnormal data is encountered, it only blocks the current 1 working worker, and there shouldn’t be many abnormal request data in a short time. But when we observed the logs during the <a href="#Initial-Investigation">Initial Investigation</a>, <strong>all workers were exhausted in an extremely short time</strong>. Why is this?</p><p>As mentioned in the <a href="#Problem-Background">Problem Background</a>, both the mesh process and the business process are multi-threaded. The rapidly decreasing idle workers seen in the logs in a short time were from the mesh process. The actual business logic is handled in the business process, where all threads in the business process share a global thread pool implemented as an async singleton. The async-implemented thread pool specifies how many threads there are in total when creating the singleton object, and these threads are used by all business process worker threads. The overall structure is shown in the following diagram:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_worker.png" alt="Business thread architecture"></p><p>Whenever there is an abnormal data, it will cause 1 thread in the async thread pool to exit, while simultaneously blocking 1 thread in the business process. As time progresses, after accumulating enough abnormal data, two situations will occur:</p><ol><li><p>All threads in the async thread pool exit due to exceptions. At this point, any business threads that haven’t been blocked will be blocked on read when using the thread pool to process data, regardless of whether the data is abnormal or not, because there are no async threads to compute. This situation occurs when the number of threads in the business process is greater than the number of threads in the async thread pool.</p></li><li><p>There are still working threads in the async thread pool, but all threads in the business process are blocked on read due to previously occurring abnormal data. This situation occurs when the number of threads in the business process is less than the number of threads in the async thread pool.</p></li></ol><p>In either case, <strong>at some point, due to the last abnormal request data, all working threads in the business process will be blocked, unable to handle requests coming from mesh</strong>. From this moment on, every time mesh receives a request, one worker in the mesh process will be occupied. The accumulation of requests in a short time leads to all workers in the mesh process being occupied, and thus unable to handle new incoming requests, ultimately causing the monitoring script to detect service anomalies.</p><p>At this point, the reason for the restart has been revealed, and the fix method is also clear. The simplest method is to add a try-catch block when executing business functions in async threads. If an exception is caught, directly call abort to terminate the entire business process. This way, if there’s a bug in the code that causes an exception to be thrown, once triggered after going online, the process will immediately terminate. Problems will be discovered early, and it’s also convenient to analyze the problem from the coredump file.</p>]]></content>
    
    
    <summary type="html">This article provides a detailed analysis of a service restart issue caused by C++ thread pools, integer overflow, and exception handling. It explores the differences in exception handling between std::thread and std::async, revealing the potential chain reaction of unhandled exceptions in async-implemented thread pools. Through log analysis, code review, and GDB debugging, it gradually locates the root cause of the problem and provides a fix. The article also summarizes key points in multi-threaded programming, exception handling, and thread pool design, offering valuable experience and references for developers.</summary>
    
    
    
    <category term="Programming" scheme="https://selfboot.cn/categories/Programming/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>溢出、异常、线程池、阻塞，奇怪的服务重启问题定位</title>
    <link href="https://selfboot.cn/2024/06/13/async_pool_block_problem/"/>
    <id>https://selfboot.cn/2024/06/13/async_pool_block_problem/</id>
    <published>2024-06-13T20:01:55.000Z</published>
    <updated>2024-08-20T02:06:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>最近在业务中遇见一个很奇怪的服务重启问题，定位过程比较有曲折，本文来复盘下。这个问题涉及到 C++ 线程池、整数溢出、异常捕获、阻塞等多个方面，还是挺有意思的。</p><p>接下来我会按照<strong>问题排查的过程</strong>来组织本文内容，会先介绍问题背景，接着列出初步的排查思路，定位异常请求的方法。然后，通过代码分析，以及复现问题的一些简单用例，来揭开服务重启的神秘面纱。</p><span id="more"></span><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>我们有个模块 A 对外提供 RPC 服务，主调方 B 会调用 A 的服务。模块 A 的服务分为 2 个进程，mesh 进程和业务进程，这两个进程都是多线程的。mesh 进程类似 <a href="https://istio.io/latest/docs/reference/config/networking/sidecar/">Sidecar</a> 的作用，每当接收到主调方发来的 1 个 rpc 请求，就分配一个 worker 线程负责该请求。worker 会通过 unix socket 把请求包发给业务进程，然后等业务进程处理完后回复主调方。业务进程则专门用来做业务逻辑，拿到请求包处理完成后，把响应包给 mesh 进程里的 worker。整体如下图所示：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_bg.png" alt="服务分mesh进程和业务进程"></p><p>最近，主调方 B 通过监控发现每天会有几次连不上模块 A 的服务端口，每次持续时间也不长，过一会就自动恢复了。</p><p>简单看了下模块 A 的日志，发现在对应时间点，<strong>监控脚本拨测 A 服务失败，于是重启服务</strong>。这里的监控脚本每隔固定时间，会拨测模块 A 的 存活探测 rpc(就是简单回复一个 hello)，来检测服务是否正常。如果连续的几次拨测都失败，则认为服务有问题，就尝试重启服务。这次模块 A 的偶现重启，就是脚控脚本发现一直没法拿到存活探测 rpc 的回复，于是重启服务。</p><p>那么<strong>什么时候开始出现这个问题呢？</strong>把模块 A 的监控时间拉长，发现 7 天前才开始有偶现的诡异重启。模块 A 的每台服务器都有重启，重启频次很低，所以模块 A 也没有告警出来。</p><p>按照经验，拨测失败一般是服务进程挂了，比如进程 coredump 退出或者内存泄露导致 OOM 被系统杀了。但是查了下模块 A 的日志，发现并不是上面两种情况。模块 A 没看到 coredump 相关的日志，内存使用在重启时间段都是正常的。那会不会是代码中有<strong>死循环导致 worker 线程被占着一直没法释放呢</strong>？看了下重启时间段的 CPU 使用率，也是正常水平。当然如果死循环中一直 sleep，那么 CPU 使用率也不高，不过业务中并没有什么地方用到 sleep，所以这里初步排查不是死循环。</p><p>这就有点奇怪了，接着仔细看服务日志来排查吧。</p><h2 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h2><p>找了一台最近有重启的机器，先看看重启时间点服务进程的日志。模块 A 里 mesh 进程是一个 C++ 多线程服务，一共有 N 个 worker 线程并发处理业务的 RPC 请求。框架每隔一段时间，会打印日志，记录当前 worker 中有多少是空闲(idle)的，多少正在处理请求(busy)。正常情况下，打印出来的日志中，大部分线程是 idle 的，只有少部分是 busy。</p><p>但是在进程重启前，发现日志中的 worker 线程数有点异常，<strong>1 分钟内 idle 线程越来越少，直到为 0</strong>。假设总 worker 数为 200，重启前的相关日志大概如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">worker idle 100, busy 100;</span><br><span class="line">worker idle 40, busy 160;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>怪不得监控脚本会拨测失败，此刻服务的所有 worker 都被占用，没有空闲 worker 处理新来的请求，所有新来的请求都会排队等待 worker 直到超时失败。</p><p>那么是什么原因导致 worker 一直被占用没有释放出来呢？服务是最近才出现这个问题的，所以首先想到可能和最近的变更有关。把最近的代码变更看了下，没发现什么问题。</p><p>接下来其实有两个排查思路，第一个是等服务进程再次卡住的时候，通过 gdb attach 进程，或者 gcore 转储 coredump 文件，这样就可以查看 worker 线程的调用栈，看看是什么函数导致 worker 一直被占用。首先排除掉 gdb attach，第一是出现概率比较低，监控脚本会很短时间内重启服务，不太好找到时机，并且现网服务也不太适合 attach 上去排查问题。gcore 的话，需要改动下监控脚本，在拨测有问题的时候，保存下进程 coredump 文件。不过当时考虑到需要改监控脚本，并且通过 coredump 文件不一定能发现问题，所以暂时没采用。</p><p>第二个思路就是找到可以复现的请求，通过复现问题来定位，毕竟<strong>如果一个问题能稳定复现，相当于已经解决了一大半</strong>。这里其实基于这样一个假设，<strong>一般偶发的问题，都是由某类特殊的请求触发了一些边界条件导致</strong>。</p><p>对于我们的 RPC 模块来说，如果有一个特殊的请求导致 worker 一直被占用，那么这个请求一定是没有回包的。因此，我们可以在模块<strong>接收到请求包以及给出响应包的时候，分别打印出相关日志</strong>。然后在服务卡住的时间段，就可以过滤出日志中那些只有请求没有响应的 RPC 请求。</p><p>加了日志上线后，刚好又一次出现了服务重启，通过日志，终于找到了可疑请求。结合这个可疑请求，发现了一段有问题的代码，正是这段有问题的代码，成为解决问题的突破口。</p><h2 id="问题代码分析"><a href="#问题代码分析" class="headerlink" title="问题代码分析"></a>问题代码分析</h2><p>我们先来看下这段有问题的代码，简化后并隐去关键信息，大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gramCount = <span class="number">3</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; posVec;</span><br><span class="line"><span class="comment">// GetPosVec(posVec);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt; posVec.<span class="built_in">size</span>() - gramCount; ++i) &#123;</span><br><span class="line">posVec[i] = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聪明如你，一定发现这段代码的问题了吧。</p><p>这里 i 是无符号整数，<code>posVec.size()</code> 返回的也是无符号整数类型 size_t。当 posVec.size() 小于 gramCount 时，<code>posVec.size() - gramCount</code> 会<strong>溢出</strong>，变成一个很大的正整数。接着在循环中，会用这个很大的正整数来遍历 posVec，就会导致<strong>数组越界</strong>。这里用 operator[] 访问数组的时候，当下标越界就是<a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">未定义行为</a>，一般会导致程序 crash 掉。写了一个简单测试代码，发现确实 segmentation fault 了。这里补充说下，如果是用 <a href="https://cplusplus.com/reference/array/array/at/">at 访问数组</a>的话，下标越界会抛出 out_of_range 异常，如果被捕获异常，肯定会 crash。</p><p>但是模块 A 中这里的代码却没有 crash，而是导致 worker 线程一直被占用，这又是为什么呢？一个可疑的地方就是，上面的代码其实是在一个新开的线程池中跑的。再补充说下这里的背景，模块 A 收到 RPC 请求后，会在一个 worker 线程中处理业务逻辑。有部分业务逻辑比较耗时，<strong>为了提高处理速度，会把耗时的部分放到一个额外的线程池来并发执行</strong>。</p><p>这里线程池的实现稍微有点复杂，大致思路就是<strong>一个任务队列 + 配置好的 N 个 worker 线程</strong>。任务队列用来存放需要执行的任务，worker 线程从任务队列中取任务执行。线程池对外提供了一个接口 <code>RunTask(concur, max_seq, task);</code> 其中 concur 是并发执行的线程数，max_seq 是任务总数，task 是任务函数。RunTask 会用 concur 个线程并发执行这个任务函数 task，直到 max_seq 个任务全部完成。</p><p>在任务开始前，RunTask 里面定义了一个管道，用来在主线程和任务线程池之间同步消息。一旦所有线程完成任务，最后一个退出的线程会向管道写入一个字符以通知主线程。主线程会等待管道中的字符，然后返回。</p><p>上面有整数溢出的代码，就是放在这个额外的线程池执行的，难道是线程池导致的问题？为了快速验证猜想，写了个简单的测试脚本，把上面代码放到线程池执行，进程果真卡住没反应了。首先猜想，会不会是线程池中的线程因为数组越界导致 crash 掉，没有写 pipe，导致主线程一直阻塞在 pipe 的读操作上呢？</p><p>下面来验证下。</p><h2 id="多线程：thread"><a href="#多线程：thread" class="headerlink" title="多线程：thread"></a>多线程：thread</h2><p>为了验证上面的猜想，写了一个简单的测试程序，模拟业务中线程池的工作流程。这里用 C++11 的 thread 来开启 5 个新线程，并且让这些线程 sleep 一段时间模拟执行任务。当所有线程都执行完任务后，最后一个完成的线程向管道写入一个字符，主线程阻塞在管道读取上。测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">completedThreads</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCurrentTimeAndThread</span><span class="params">(<span class="type">const</span> std::string&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_c), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot; Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>], <span class="type">int</span> totalThreads)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="type">int</span> finished = ++completedThreads;</span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 最后一个完成的线程写入管道</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction, fds, totalThreads);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 主线程阻塞在这里等待管道写入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里注释掉会发生什么呢？</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread finished&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后发现这里是符合预期的，5 个线程并发执行 1s，主线程等最后一个线程执行完，就会从管道中读到结果继续往下执行。结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140358584862528 - 2024-06-12 11:40:51</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140358568072960 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358559680256 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358551287552 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358584858368 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358576465664 - 2024-06-12 11:40:52</span><br><span class="line">Main thread finished Thread ID: 140358584862528 - 2024-06-12 11:40:52</span><br></pre></td></tr></table></figure><p>现在让<strong>最后一个子线程直接抛出异常，来看看主线程是否阻塞</strong>。在上面代码基础上改动如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Out of range exception&quot;</span>); <span class="comment">// 模拟 at 越界访问数组，抛出异常</span></span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 最后一个完成的线程写入管道</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重新编译运行发现整个进程直接 crash 掉了，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140342189496128 - 2024-06-12 11:46:23</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140342189491968 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342181099264 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342172706560 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342164313856 - 2024-06-12 11:46:24</span><br><span class="line">terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span><br><span class="line">  what():  Out of range exception</span><br><span class="line">[1]    2622429 abort      ./thread_test2</span><br></pre></td></tr></table></figure><p>看来前面的猜想失败了！在多线程下，单个线程抛出异常导致整个进程 abort 掉了。为什么会这样？这里不得不提一下<strong>C++ 的异常处理机制了</strong>？</p><h3 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++ 异常处理"></a>C++ 异常处理</h3><p>在 C++ 中，当程序遇到一个无法自行解决的问题时，它可以抛出（throw）一个异常。异常通常是一个从标准异常类派生的对象，如 std::runtime_error。编程时，可以把可能抛异常的代码放到 try 块里面，然后在后面跟一个或多个 catch 块，用来捕获和处理特定类型的异常。</p><p>如果在当前作用域内没有捕获异常，<strong>异常将被传递到调用栈中较高层的 try-catch 结构中</strong>，直到找到合适的 catch 块。如果整个调用栈都没有找到合适的 catch 块，会调用 <a href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate()</a>，具体执行操作由 std::terminate_handler 指定，默认下是调用 <a href="https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a>。如果没有设置信号处理程序捕获 SIGABRT 信号，那么程序就会被异常终止。</p><p>对于上面的示例多线程代码来说，最后一个线程抛出异常，但是没有地方捕获，所以最终调用 std::abort() 终止整个进程。从上面的输出也可以看到，最后一行是 abort。</p><p>其实 C++ 之所以这样设计，是因为一个未捕获的异常通常意味着程序已经进入一个未知的状态，继续运行可能会导致更严重的错误，如数据损坏或安全漏洞。因此，<strong>立即终止程序被认为是一种安全的失败模式</strong>。</p><h3 id="thread-对象生命周期"><a href="#thread-对象生命周期" class="headerlink" title="thread 对象生命周期"></a>thread 对象生命周期</h3><p>这里再提一个地方，上面示例程序，主线程最后会对每个子线程的 thread 对象调用 thread.join()，如果把这里注释掉，运行程序会发生什么呢？进程还是会 crash 掉，并且也是调用的 terminate()。这又是为什么呢？</p><p>其实前面 terminate 的文档里有提到，下面这种情况也会调用 terminate：</p><blockquote><ol start="10"><li>A joinable std::thread is destroyed or assigned to.</li></ol></blockquote><p>接着继续查看 std::thread::joinable 的文档，发现如下解释：</p><blockquote><p>A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</p></blockquote><p>我们知道，子线程在执行完相关代码后会自动退出。但是，这并不意味着与该线程相关联的 std::thread 对象会自动处理这个线程的所有资源和状态。在 C++ 中，操作系统线程的结束和 std::thread 对象的生命周期管理是两个相关但又相对独立的概念：</p><ul><li><strong>操作系统的线程</strong>：当线程执行完代码后会自动停止，此时线程的系统资源（如线程描述符和堆栈）通常会被操作系统回收。</li><li><strong>std::thread 对象的管理</strong>：虽然线程已经结束，但是 std::thread 对象依然需要正确地更新其状态来<strong>反映线程已经不再活跃</strong>。这一点主要是通过 <a href="https://en.cppreference.com/w/cpp/thread/thread/join">join()</a> 或 detach() 方法来实现的。如果没有调用这些方法，std::thread 对象在被销毁时将检测到它仍然“拥有”一个活跃的线程，这将导致调用 std::terminate()。</li></ul><p>前面示例代码中主线程调用 join() 方法，会阻塞等待子线程执行完(其实就这里的例子来说，管道写入字符已经确保执行完了的)，然后标记 std::thread 对象状态为“非活跃”。</p><p>那么回到前面的问题，为啥<strong>业务代码中线程池中的线程抛出异常，主线程会卡住呢</strong>？接着仔细看了下线程池的实现代码，发现这里并不是用 thread 来创建线程，而是用的 <a href="https://en.cppreference.com/w/cpp/thread/async">std::async</a>。async 是什么？它是怎么工作的，这里线程卡死会和 async 有关吗？</p><p>接着一起来验证吧。</p><h2 id="多线程：async"><a href="#多线程：async" class="headerlink" title="多线程：async"></a>多线程：async</h2><p>C++11 引入了 std::async，这是一个用于<strong>简化并发编程</strong>的高级工具，它可以在<strong>异步的执行上下文中运行一个函数或可调用对象，并返回一个 std::future 对象</strong>来访问该函数的返回值或异常状态。</p><p>哈哈，看完这里的介绍，是不是一头雾水、不知所云？没事，先抛开这些，直接看代码先。我们在前面 thread 示例代码的基础上，稍加改动，用 async 来并发执行，完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">completedThreads</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCurrentTimeAndThread</span><span class="params">(<span class="type">const</span> std::string&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_c), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot; Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>], <span class="type">int</span> totalThreads)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="type">int</span> finished = ++completedThreads;</span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Out of range exception&quot;</span>); <span class="comment">// 模拟 at 越界访问数组，抛出异常</span></span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 最后一个完成的线程写入管道</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">        futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, threadFunction, fds, totalThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 主线程阻塞在这里等待管道写入</span></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread finished&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后发现，主线程卡住了！！运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140098007660352 - 2024-06-12 21:06:00</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140097990870784 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140097974085376 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140097999263488 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140098007656192 - 2024-06-12 21:06:01</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功复现了业务中的问题。在继续深入分析前，先来看看 async 的用法，主要如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">    futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, threadFunction, fds, totalThreads));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码用 std::async 函数来启动一组异步任务，这些任务由 threadFunction 定义。每个任务在创建时都被配置为在新线程上执行，并且使用 std::launch::async 策略来确保它们会立即启动。这些任务的执行结果（或状态）被封装在 std::future<void> 对象中，并存储在 futures 这个 std::vector 中。先了解这么多就够了，接下来我们继续分析为什么主线程会卡住。</p><h3 id="GDB-分析"><a href="#GDB-分析" class="headerlink" title="GDB 分析"></a>GDB 分析</h3><p>我们用 GDB 来看看进程运行过程发生了啥。这里 run 之后，可以看到新创建了 5 个线程来执行 async 任务，接着有 4 个线程都打印了任务输出，然后 5 个线程又全部被系统销毁。之后 GDB 控制台会卡住，这时候用 Ctrl+C 来暂停程序执行，然后就可以用 GDB 控制台了。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_gdb.png" alt="GDB 排查阻塞进程"></p><p>进程卡住后看堆栈，发现阻塞在主线程 main 函数的 read 上。这时候进程只剩下主线程，可以用 info threads 确认，这里 0x7ffff7a9e740 其实就是进程开始打印出的 Thread ID: 140737348495168 的十六进制。从 GDB 的结果来看，最后一个子线程在要 write 前抛出异常，然后直接退出，没有往管道写入字符，主线程一直阻塞在管道的 read 中。</p><p>问题来了，整个进程不是应该 abort 终止吗？在前面 <a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9Athread">thread 的示例</a> 中，线程抛出的异常没被捕获导致进程 abort 掉，主线程也随之结束。而这里 async 创建的<strong>线程抛出的异常似乎不见了，没看到有捕获的地方，也没有触发进程 abort</strong>，这是为什么呢？</p><h3 id="async-异常处理"><a href="#async-异常处理" class="headerlink" title="async 异常处理"></a>async 异常处理</h3><p>先来看看 <a href="https://en.cppreference.com/w/cpp/thread/async">async</a> 的文档里有没有说是怎么处理异常的吧。</p><blockquote><p>If the function f returns a value or throws an exception, it is stored in the shared state accessible through the std::future that std::async returns to the caller.</p></blockquote><p>可以看到，使用 std::async 启动的线程如果抛出了异常，这些<strong>异常会被捕获并存储在返回的 std::future 对象中</strong>。再查看 future 的文档，发现可以用 <a href="https://en.cppreference.com/w/cpp/thread/future/get">future::get</a> 来拿到任务的执行结果，如果任务抛出异常，调用 get 的时候会重新抛出异常。</p><blockquote><p>If an exception was stored in the shared state referenced by the future (e.g. via a call to std::promise::set_exception()) then that exception will be thrown.</p></blockquote><p>至此上面示例程序没有 abort 的原因找到了，就在于 async 的异常处理机制。<strong>在 async 中，线程抛出的异常会被存储在 std::future 对象中，而不会直接导致进程 abort。子线程抛出异常后没有往管道写入字符，主线程就一直阻塞在 read 上等待，导致整个进程看起来就跟卡住一样</strong>。</p><p>这里我们可以在示例程序 read 前调用 get 来捕获异常，然后打印出来验证下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; future : futures) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        future.<span class="built_in">get</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 主线程阻塞在这里等待管道写入</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>可以看到这里确实捕获到了一个 out_of_range 异常。</p><h3 id="async-的优势"><a href="#async-的优势" class="headerlink" title="async 的优势"></a>async 的优势</h3><p>关于 async 再补充一点思考，C++11 引入的 async 和传统的 thread 比有什么优点呢？</p><p>首先 std::async 提供了一种比直接使用 std::thread <strong>更简单的方法来创建并执行异步任务</strong>。它自动处理线程的创建和管理，使得开发者可以专注于业务逻辑而非线程管理的细节。std::async 可以自动管理任务的生命周期，包括适时地启动和终止线程。使用 std::async 不需要显式地调用 join() 或 detach()。</p><p>另外，如前面所述，使用 std::async 启动的任务可以在执行中抛出异常，这些异常会被捕获并存储在返回的 std::future 对象中。通过调用 std::future::get()，可以在主线程中捕获和处理这些异常。</p><p>此外，调用 std::async 可以指定启动模式（std::launch::async 或 std::launch::deferred），其中 std::launch::async 强制立即在新线程中运行任务，而 std::launch::deferred 则延迟任务的执行直到调用 std::future::get() 或 std::future::wait()。</p><p>一般来说，当需要并行执行且彼此之间没有依赖关系的任务时，用 std::async 不需要关注线程的管理，会简单很多。或者需要在将来的某个时间点获取并行任务的执行结果，可以将 std::async 与 std::future 结合起来用，也会方便很多。</p><h2 id="现网服务复盘"><a href="#现网服务复盘" class="headerlink" title="现网服务复盘"></a>现网服务复盘</h2><p>好了，现在回到现网服务的讨论，通过前面分析已经能确定问题所在了，不过还有几个和现网服务相关的细节这里也需要搞清楚。第一个就是这里出问题的代码早就上线了，为什么最近才出问题？回到<a href="##%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">问题代码分析</a>这里的示例，如果数组大小大于等于 gramCount，就不会溢出，也不会导致 crash。最近这里数组的长度有了变化，所以才出现上面的问题。</p><p>第二个疑问就是，每次遇到异常的数据，只会卡住当前的 1 个工作 worker，短时间也不会有很多异常请求数据。但是前面<a href="#%E5%88%9D%E6%AD%A5%E6%8E%92%E6%9F%A5">初步排查</a>的时候观察日志，在<strong>极短时间内，所有 worker 都耗尽</strong>。这又是为什么呢？</p><p>前面<a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF">问题背景</a>有提到过，mesh 进程和业务进程都是多线程，日志中看到短时间极速减少的 idle worker，是 mesh 进程的。实际业务逻辑在业务进程处理，业务进程中的所有线程共用一个 async 单例实现的全局线程池。async 实现的线程池在创建单例对象的时候会指定一共有多少个线程，这些线程供所有业务进程 worker 线程使用。整体如下图所示：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_worker.png" alt="业务线程架构"></p><p>每当有一个异常数据，就会导致 async 线程池中的 1 个线程退出，同时阻塞业务进程中的 1 个线程。随着时间推移，积累足够多异常数据后，会出现下面 2 种情况：</p><ol><li>async 线程池中的线程因为异常全部退出，这时候还没有阻塞的业务线程只要使用线程池处理数据，不管数据是否异常，都会阻塞在 read 上，因为根本没有 async 线程来计算。这种情况发生在业务进程的线程数大于 async 线程池中的线程数时。</li><li>async 线程池中还有可以工作的线程，不过业务进程中所有线程都因为曾经出现的异常数据导致阻塞在 read 上。这种情况发生在业务进程的线程数小于 async 线程池中的线程数时。</li></ol><p>不管是哪种情况，<strong>都会在某一刻，因为最后的一个异常请求数据，导致业务进程所有工作线程阻塞，无法处理 mesh 来的请求</strong>。从这一刻起，每当 mesh 接收到一个请求，mesh 进程的一个 worker 就会被占用，短时间内的请求积压，导致 mesh 进程所有 worker 被占用，也就无法处理新来的请求，最终导致监控脚本检测到服务异常。</p><p>至此，整个重启的原因水落石出，修复方法也跃然纸上了。最简单的方法就是在 async 线程中执行业务函数时，加上 try-catch 块，如果捕获到异常，直接调用 abort 来中止整个业务进程。这样如果代码中有导致抛出异常的 bug，上线后一旦触发进程就会立马终止，出问题早发现，也方便从 coredump 文件中分析问题。</p>]]></content>
    
    
    <summary type="html">本文详细分析了一个由 C++ 线程池、整数溢出和异常处理引发的服务重启问题。探讨了 std::thread 和 std::async 在异常处理上的差异，揭示了 async 实现的线程池中未处理异常可能导致的连锁反应。通过日志分析、代码审查和 GDB 调试，逐步定位问题根源，并提供了修复方案。文章还总结了多线程编程、异常处理和线程池设计的关键点，为开发者提供了宝贵的经验和参考。</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>谁主张谁举证，吵架时也用得到的法律知识</title>
    <link href="https://selfboot.cn/2024/06/06/who_asserts_must_prove/"/>
    <id>https://selfboot.cn/2024/06/06/who_asserts_must_prove/</id>
    <published>2024-06-06T21:55:28.000Z</published>
    <updated>2024-08-20T02:06:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>一个晴朗的周末，你去超市购物。突然保安把你拦下来，说你偷了东西。<strong>你需要要证明你没偷东西吗</strong>？如果要证明，<strong>你又怎么证明呢</strong>？</p><p>又或者，你把自己的伞忘在了茶水间，过了会去找发现不见了。通过查监控，发现是另一个同事拿走了你的伞，于是想找这个同事拿回来。结果拿伞的同事<strong>让你证明这是你的伞，问你要购物记录和发票</strong>，你需要提供吗？</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240606_who_asserts_must_prove_cover_new.png" alt="谁主张谁举证，举证责任倒置"></p><span id="more"></span><p>生活中类似的例子数不胜数。遇到胡搅蛮缠、强词夺理的人，有时候我们可能会陷入自我怀疑，我是不是真的要自证啊？其实大可不必，记住这六个字，“<span style='color: red'><strong>谁主张谁举证</strong></span>”。这不仅是民事诉讼中的基本原则，也是我们应对各种纠纷时的法宝。</p><p>接下来<a href="https://selfboot.cn/links">小盛律师</a>和大家详细聊聊民事诉讼中的“谁主张谁举证”以及“举证责任倒置”，希望能帮大家理清思路，遇到类似情况时能够做到心中有数，游刃有余。</p><h2 id="谁主张谁举证"><a href="#谁主张谁举证" class="headerlink" title="谁主张谁举证"></a>谁主张谁举证</h2><p>“谁主张谁举证”是民事诉讼中的一项基本原则。当事人在民事诉讼中<strong>对自己所主张的事实，有责任提供证据加以证明</strong>。也就是说，如果一方提出了某个主张，那么这一方就需要承担提供证据的责任，以证明其主张的事实是真实存在的。如果这一方没有足够的证据来支持其主张，那么法院可能不会接受这个主张。这里主要依据<a href="https://www.faxin.cn/lib/zyfl/zyflcontent.aspx?gid=A310972&nid=45205">《中华人民共和国民事诉讼法》</a>：</p><blockquote><p>第六十七条　当事人对自己提出的主张，有责任提供证据。<br>　　当事人及其诉讼代理人因客观原因不能自行收集的证据，或者人民法院认为审理案件需要的证据，人民法院应当调查收集。<br>　　人民法院应当按照法定程序，全面地、客观地审查核实证据。</p></blockquote><p>直接看法律条文可能有点难懂，我找几个案例，咱们通过案例来理解一下。</p><h3 id="夫妻离心小三得利？"><a href="#夫妻离心小三得利？" class="headerlink" title="夫妻离心小三得利？"></a>夫妻离心小三得利？</h3><p>(2022)粤民初42**号：原告和被告是夫妻关系，原告婚后在家照顾家中老人、孩子，发现被告刘某在婚姻存续期间与被告万某保持不正常男女关系长达5、6年。还发现被告刘某在婚姻期间用夫妻共同财产为被告万某购买了房和车，还给被告刘某 27 万元。</p><p>原告认为被告万某没有工作的，根本没有经济能力购买上述的房产和车辆。被告刘某的行为明显属于在婚姻期间恶意转移夫妻共同财产，请求法院判令被告刘某返还 27 万元，并判令被告万某返还房产和车辆。</p><p>法院怎么认定的呢？首先原告提供的证据，<strong>尚不足以证实被告刘某与万某之间存在婚外情关系，二被告亦不确认存在婚外情关系</strong>。对于 27 万，原告提交的证据<strong>不足以证实刘某已实际支付给万某</strong>，二被告亦不确认张某的主张，张某的该项主张缺乏事实基础。所以法院最后认定，原告关于被告刘某与万某存在婚外情并转移夫妻共同财产的主张，无事实依据，不予支持。</p><p>其实很多类似的案例，夫妻一方怀疑对方有外遇，转移财产给第三人，但是没有足够的证据证明这一点。按照“谁主张谁举证”的原则，法院在没有证据的情况下，并不会支持原告的主张。</p><h3 id="民间借贷朋友反目"><a href="#民间借贷朋友反目" class="headerlink" title="民间借贷朋友反目"></a>民间借贷朋友反目</h3><p>(2024)桂民初13**号：本案是一个典型的民间借贷案件，<strong>借了钱最后朋友也没得做了</strong>。背景是这样的，被告周某因资金周转困难为由，向原告借 6000 元。原告作为朋友，<strong>基于朋友之间的信任</strong>，也没有要借条，当天直接通过现金和微信转账等方式借给了被告 6000 元。然后过了快 1 年，原告需要钱的时候，多次催被告还钱，但是被告周某<strong>拒绝履行还款义务</strong>，于是原告起诉要求被告还款。</p><p>原告主张，<strong>王某作为被告周某的老婆，也应该承担债务</strong>。法院认定，<strong>原告没有提供证据证实两被告为夫妻关系</strong>，根据谁主张谁举证的原则，应由原告承担<strong>举证不能的法律后果</strong>，所以最后没有支持王某对周某的债务承担共同偿还责任。</p><p>这两个常见的真实案例，是不是让你对“谁主张谁举证”有了一点深入的理解呢？</p><h2 id="举证责任倒置"><a href="#举证责任倒置" class="headerlink" title="举证责任倒置"></a>举证责任倒置</h2><p>谁主张谁举证这个大家应该很好理解，也符合常识。不过有时候会有<span style='color: red'><strong>举证责任倒置</strong></span>，这又是怎么回事呢？</p><p>举证责任倒置，也称举证责任反转，是指在某些特定情形下，<strong>原本应由一方当事人承担的举证责任，转由另一方当事人承担</strong>。这通常发生在一些特殊类型的案件中，如环境污染、产品责任等，由于举证困难等原因，法律为了平衡双方当事人的举证能力，特别规定将举证责任转移给另一方。</p><p>在<a href="https://www.gov.cn/xinwen/2020-06/01/content_5516649.htm">《中华人民共和国民法典》</a> 中有多个条款都有举证责任倒置相关说明。这里列举 2 个：</p><blockquote><p>第一千二百三十条 因污染环境、破坏生态发生纠纷，行为人应当就法律规定的不承担责任或者减轻责任的情形及其行为与损害之间不存在因果关系承担举证责任。</p><p>第一千二百五十四条　禁止从建筑物中抛掷物品。从建筑物中抛掷物品或者从建筑物上坠落的物品造成他人损害的，由侵权人依法承担侵权责任；经调查难以确定具体侵权人的，<strong>除能够证明自己不是侵权人的外，由可能加害的建筑物使用人给予补偿</strong>。可能加害的建筑物使用人补偿后，有权向侵权人追偿。</p></blockquote><p>下面还是先看案例吧。</p><h3 id="高空坠物飞来横祸"><a href="#高空坠物飞来横祸" class="headerlink" title="高空坠物飞来横祸"></a>高空坠物飞来横祸</h3><p>(2023)湘民终4**号：背景先介绍下，这是一个代位求偿权纠纷案件，保险公司向责任方物业公司追偿。一审中，车主将小轿车停在被告所管理的小区，小区<strong>外墙玻璃脱落砸到轿车</strong>，致使该车辆严重受损。车主投保的保险公司起诉要求被告赔偿损失。一审法院认为，物业服务企业承担的是<strong>无过错责任</strong>，<strong>适用的是举证责任倒置原则</strong>，不管该玻璃是受太阳暴晒、还是受风雨影响导致玻璃爆裂，被告对受损车辆均具有不可推卸的赔偿责任。被告不服，提起上诉。</p><p>二审认为对于物件脱落、坠落造成他人人身财产损害的，建筑物的所有人、管理人应当承担侵权责任，归责原则<strong>适用过错推定原则</strong>，即法律推定加害人有过错，从而实现举证责任倒置，由<strong>加害人证明自己没有过错</strong>。如果其能够证明自己没有过错，就不承担民事责任，否则就认定其有过错并结合其他构成要件承担相应的民事责任。</p><p>本案上诉单位作为小区的服务企业，<strong>提供的证据不足以证明其对于被上诉人车辆受损害的事实没有过错</strong>，因此，应推定上诉人对其服务的小区<strong>建筑物存在维护、管理瑕疵</strong>，应当承担相应的赔偿责任。不过小车没停放在指定的停车位，<strong>具有一定的过错</strong>，需对损失承担 30% 的责任，物业公司未履行安全管理义务，承担 70% 的责任。</p><p>这里小盛律师再展开聊下高空坠物，假设张三在小区走路，被楼上扔下来的菜刀砸中。警察调查半天，没找到是哪一户扔的菜刀，这时候整栋楼所有住户都有可能是加害人。根据举证责任倒置，<strong>除非能够证明自己没有扔菜刀，比如那个时段家里没人，否则都需要承担侵权责任</strong>。这样的规定是为了保护受害人的合法权益，避免因为举证困难而导致受害人无法获得赔偿。</p><h3 id="猪粪污水毒死鱼蟹"><a href="#猪粪污水毒死鱼蟹" class="headerlink" title="猪粪污水毒死鱼蟹"></a>猪粪污水毒死鱼蟹</h3><p>(2024)吉民终1**号：原告闫某承包了一个大坝，用于养殖鱼蟹，春季水库解冻后，发现水库出现死鱼。闫某顺着水流追溯到董某、钱某承包的养殖场，发现该养殖场冬季猪粪及排水物堆积，春季解冻后粪水流入水道，而后流入水库。闫某认为粪水对水质造成严重污染，导致鱼类死亡，于是找到董某、钱某要求赔偿，但沟通数次未达成赔偿协议，遂诉至法院。</p><p>一审法院认定董某、钱某承担赔偿责任，董某、钱某不服，提起上诉。上诉的一个核心观点是，<strong>之前闫某申请的鉴定结果不对，并不能证明猪粪尿水与其鱼蟹死亡之间存在因果关系</strong>，所以董某、钱某不应承担赔偿责任。</p><p>二审法院认为本案为水污染责任纠纷，<strong>因果关系举证责任倒置</strong>。所以这里<strong>因果关系的举证责任应由董某、钱某承担</strong>。董某、钱某虽主张闫某鱼塘内鱼蟹死亡是因鱼塘上游农田排放农药和居民生活垃圾导致，但<strong>二人对此并未举证加以证明</strong>，且二人<strong>也未对侵权行为与损害结果之间不存在因果关系进行举证</strong>，所以一审法院的结果并无不当。</p><p>本案是一个环境污染案，这里因果关系的举证责任倒置，所以被告需要证明猪粪尿水与鱼蟹死亡之间<strong>没有因果关系</strong>才行。对原告来说，虽然主张被告侵权，但不需要证明因果关系，只需要举证关联关系即可。这里关联关系其实根据生活常识，猪粪尿水流入水库，导致水质污染，鱼蟹死亡，是可以认为有关联的。 </p><p>不过值得注意的是，举证责任倒置并非普遍适用的原则，而是针对特定案件类型所作的特别规定。在具体案件中是否适用举证责任反转，需根据相关法律法规及案件具体情况来判断。这里不再展开，如有具体法律需求，可以咨询小盛律师。</p><h2 id="生活中的建议"><a href="#生活中的建议" class="headerlink" title="生活中的建议"></a>生活中的建议</h2><p>前面介绍了法律中的举证责任，可以看到还是有点复杂的。不过对于咱们大部分人来说，日常生活中用好“谁主张谁举证”就足够了。</p><p>回到文章开头的小场景：</p><ol><li>如果保安说你偷东西，你<strong>不需要证明自己没偷</strong>，应该先让保安调监控或者用其他方式证明你偷了。或者直接报警，让警察介入来调查就好了。</li><li>如果“拿”你伞的人要你提供购物记录，<strong>你没必要提供</strong>。从监控来看，是你先放那里，按照生活常识这伞就是你的，她后来拿走的行为是盗窃。如果她说是自己的伞，那么也是要她来证明这伞是她的才行。</li></ol><p>下次再遇见类似纠纷，知道怎么做了吧！</p><hr><p>我是 <a href="https://selfboot.cn/links">小盛律师</a>，欢迎关注我获取更多法律科普。如果有法律纠纷，欢迎付费咨询。</p><div class="pure-g">  <div class="pure-u-1 pure-u-md-1-3" style="width: auto;">    <img src="https://slefboot-1251736664.file.myqcloud.com/20230914_wx_qrcode_2.png" style="height: 200px; margin-right: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  </div>  <div class="pure-u-1 pure-u-md-1-3" style="width: auto;">    <img src="https://slefboot-1251736664.file.myqcloud.com/20230914_xhs_qrcode_2.png" style="height: 200px; margin-right: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  </div>  <div class="pure-u-1 pure-u-md-1-3" style="width: auto;">    <img src="https://slefboot-1251736664.file.myqcloud.com/20230914_dy_qrcode.png" style="height: 200px; margin-right: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  </div></div>]]></content>
    
    
    <summary type="html">遇到被指责偷窃、被指错误等纠纷时，很多人会下意识自证清白。但&quot;谁主张谁举证&quot;是民事诉讼的基本原则，即提出指控的一方应提供证据证实，而非被指控方需自证清白。本文通过多个生动案例，阐释了谁主张谁举证原则及例外情况下的举证责任倒置规则，帮助读者理清思路，在生活中遇到纠纷时能正确认识举证责任，避免自证的错误做法，维护自身合法权益。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="法律" scheme="https://selfboot.cn/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>Understand Web Stream Output Implementation with Examples</title>
    <link href="https://selfboot.cn/en/2024/05/19/stream_sse_chunk/"/>
    <id>https://selfboot.cn/en/2024/05/19/stream_sse_chunk/</id>
    <published>2024-05-19T21:42:37.000Z</published>
    <updated>2024-08-20T02:06:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>If you’ve used large language models like ChatGPT, you may have noticed that the AI’s output text appears in “bursts” during chat conversations. This is known as <strong>stream output</strong>. How is this effect achieved in the browser?</p><p>This article will introduce 4 common methods to implement stream output effects, each demonstrated with practical examples. The choice of method in business applications depends on specific requirements and scenarios.</p><ol><li><strong>Client-side polling</strong>: The client sends requests to the backend service at regular intervals (e.g., every few seconds) to retrieve new data.</li><li><strong>Chunked transfer</strong>: Supported by HTTP&#x2F;1.1, the server can send only part of the response content at a time, and the client can start processing as soon as it receives partial data.</li><li><strong>Server-Sent Events</strong>: The server pushes information to the browser. The browser creates a one-way connection to the server, through which the server can send multiple messages.</li><li><strong>WebSocket</strong>: Establishes a persistent, full-duplex connection, allowing real-time, two-way communication between the server and client.</li></ol><span id="more"></span><h2 id="Simple-Polling"><a href="#Simple-Polling" class="headerlink" title="Simple Polling"></a>Simple Polling</h2><p>First is the simplest polling method, where the client sends requests to the server at regular intervals to retrieve new data. When implementing polling, the client and server need to <strong>agree on how to indicate data updates or completion</strong> using HTTP request parameters and response. For example, a simple request field ‘cnt’ can be used to indicate which request this is, and a 400 error code in the response can indicate the end of polling.</p><p>Below is a simple example using Python’s FastAPI, where each request carries an index to request content from a text, and if it exceeds the text length, it returns a 400 error.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">polling</span>(<span class="params">cnt: <span class="built_in">int</span> = <span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> cnt &gt;= <span class="built_in">len</span>(message) <span class="keyword">or</span> cnt &lt; <span class="number">0</span>:  <span class="comment"># Check if cnt is valid</span></span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;Invalid index&quot;</span>)</span><br><span class="line">    data = &#123;<span class="string">&quot;message&quot;</span>: message[cnt]&#125;</span><br><span class="line">    <span class="keyword">return</span> JSONResponse(content=data)</span><br></pre></td></tr></table></figure><div id="anchorPolling"></div><p><a href="#anchorPolling">Here</a> is an interactive demonstration of polling:</p><div class="data-container">    <div id="pollingData" class="data-block"></div>    <div class="button-container">        <button onclick="fetchData()" class="action-button">Start</button>        <button onclick="stopPolling()" class="action-button">End</button>    </div></div><p>After clicking start, you can see the data continuously updating until it ends. If you open the console, you’ll see the browser making an HTTP request every 100ms, with the parameter ‘cnt’ indicating which request it is.</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240519_stream_sse_chunk_polling.png" alt="View polling requests in the console"></p><p>The advantage of this method is that it’s easy to understand and implement. However, the disadvantages are also obvious: <strong>frequent HTTP requests</strong> increase server load and network transmission overhead. With <code>HTTP/1.1</code>, each request needs to establish a TCP connection, increasing overhead even more. Additionally, the polling interval is difficult to control. If it’s too short, data might not have updated, wasting requests. If it’s too long, user experience suffers.</p><h2 id="Chunked-Transfer-Encoding"><a href="#Chunked-Transfer-Encoding" class="headerlink" title="Chunked Transfer Encoding"></a>Chunked Transfer Encoding</h2><p>The disadvantages of the polling mechanism above are evident, mainly due to the need for many HTTP connections to update data. In fact, HTTP&#x2F;1.1 offers a better way: <strong>chunked transfer encoding</strong>. Chunked transfer encoding implements stream output more efficiently. The client only needs to request once, and the server <strong>responds in multiple “chunks” until all data is sent</strong>. Chunked transfer is suitable for situations where the response body is very large or its size is unknown due to real-time content generation, common in large file downloads, video streams, or real-time data streams. Currently, if you want to implement stream output in WeChat Mini Programs, chunked encoding is the most convenient method.</p><p>The chunked transfer encoding protocol is slightly more complex. The response header uses <code>Transfer-Encoding: chunked</code> to indicate that the response will be sent in chunks. Before each chunk, the server sends a line containing the size of the current chunk, followed by a carriage return and line feed (CRLF), then the actual chunk data, followed by another CRLF. When the transmission ends, the server sends a chunk of size 0, indicating no more data chunks, usually followed by a CRLF.</p><p>Implementing the chunked encoding protocol with Python’s FastAPI is also relatively simple. Below is a simple example that outputs content every 100ms and transmits it using chunked encoding:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@stream_app.get(<span class="params"><span class="string">&quot;/chunked&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">chunked_transfer</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_large_data</span>():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">f&quot;<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> StreamingResponse(generate_large_data(), media_type=<span class="string">&quot;text/plain&quot;</span>)</span><br></pre></td></tr></table></figure><div id="anchorChunked"></div><p><a href="#anchorChunked">Here</a> is an interactive demonstration of chunked transfer encoding:</p><div class="data-container">    <div id="chunkedData" class="data-block"></div>    <div class="button-container">        <button onclick="startChunked()" class="action-button">Start</button>        <button onclick="stopChunked()" class="action-button">End</button>    </div></div><p>After clicking start, you can similarly see the data continuously updating until all content is printed. If you open the console, you’ll see the browser only sends one HTTP request, and the response header contains <code>Transfer-Encoding: chunked</code>. The size of the response data keeps updating over time. Below is an animated GIF:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240519_stream_sse_chunk_chunked.gif?noresize=true" alt="Animated GIF of chunked transfer encoding"></p><p>It’s worth noting that chunked transfer encoding is only supported in HTTP&#x2F;1.1. In HTTP&#x2F;2, the concept of chunked transfer encoding no longer exists, mainly because HTTP&#x2F;2 works very differently. HTTP&#x2F;2 introduced new mechanisms such as multiplexing, binary framing, and stream prioritization to improve efficiency and performance. In HTTP&#x2F;2, all communication occurs through frames on a single TCP connection. Data frames are used to transmit message body data. The server can continuously send multiple data frames as needed, with each frame carrying a portion of the message content. The client reassembles these frames in the order received to reconstruct the complete message.</p><p>However, in my example here, stream output still works under HTTP&#x2F;2. This is because the frontend uses the <code>Fetch API</code> and stream processing <code>response.body.getReader().read()</code>, which provide a consistent interface for handling stream data, regardless of whether the underlying protocol is HTTP&#x2F;1.1 or HTTP&#x2F;2. When calling an HTTP&#x2F;2 interface, it can still read data normally from the data frames.</p><h2 id="Server-Sent-Events"><a href="#Server-Sent-Events" class="headerlink" title="Server-Sent Events"></a>Server-Sent Events</h2><p>OpenAI doesn’t use the two methods above in its chat tool ChatGPT, but instead uses <code>Server-Sent Events (SSE)</code> to implement stream output. SSE allows servers to proactively push events to browsers or other clients. SSE is designed primarily to simplify unidirectional real-time data streams from server to client, particularly suitable for Web applications that require fast, continuous data updates, such as real-time news updates, stock quotes, or social media real-time messages.</p><p>SSE is based on the HTTP protocol and uses standard HTTP requests to initiate connections. First, the client initiates a standard HTTP GET request to start an SSE connection. The request header usually includes <code>Accept: text/event-stream</code>, telling the server that the client wants to open an SSE connection. The server responds to this request and <strong>keeps the connection open</strong>, with the Content-Type of the response set to <code>text/event-stream</code>. Subsequently, the server can send <strong>event streams in plain text form</strong>. Each event consists of an optional event name and a required data field. Events start with <code>data:</code>, followed by the specific message data, with events separated by two newline characters <code>\n\n</code>. Throughout the process, the HTTP connection remains open, allowing the server to send new events at any time, with the client processing the data upon receiving each event. Once an SSE connection is established, the server can continuously send data updates to the client until the connection is closed.</p><p>Implementing SSE with Python’s FastAPI is relatively simple. Below is a simple example that returns content to the client every 100ms, and the server ends the connection after all content is output:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@stream_app.get(<span class="params"><span class="string">&quot;/events&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_events</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">event_stream</span>():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">f&quot;data: <span class="subst">&#123;i&#125;</span>\n\n&quot;</span>  <span class="comment"># Note the data format</span></span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">f&quot;data: END\n\n&quot;</span> </span><br><span class="line">    <span class="keyword">return</span> StreamingResponse(event_stream(), media_type=<span class="string">&quot;text/event-stream&quot;</span>)</span><br></pre></td></tr></table></figure><div id="anchorSSE"></div><p><a href="#anchorSSE">Here</a> is an interactive demonstration of SSE:</p><div class="data-container">    <div id="sseData" class="data-block"></div>    <div class="button-container">        <button onclick="startSSE()" class="action-button">Start</button>        <button onclick="stopSSE()" class="action-button">End</button>    </div></div><p>After clicking start, you can see the data continuously updating until all content is printed. If you open the console, you’ll see the browser only sends one HTTP request, and the response header contains <code>Content-Type: text/event-stream</code>. The size of the response data keeps updating over time. Below is an animated GIF of the entire process:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240519_stream_sse_chunk_sse.gif?noresize=true" alt="Animated GIF of Server-Sent Events"></p><p>Most modern browsers support SSE, which provides a good user experience and is very resource-efficient. However, SSE has one drawback: it only allows <strong>unidirectional transmission from server to client</strong>, and the client cannot send data to the server. If bidirectional communication is needed, WebSocket should be used.</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>The three methods mentioned above are all based on the HTTP protocol, mainly to solve the problem of pushing data from server to client. WebSocket, on the other hand, is an independent protocol that allows <strong>real-time, bidirectional communication</strong> between client and server, effectively supporting complex interactive applications such as online games, trading platforms, and collaboration tools.</p><p>WebSocket is also implemented based on the TCP protocol, with the specific protocol defined by IETF’s <a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a>. First is the handshake phase, where a WebSocket connection is initiated through the HTTP protocol. The client needs to send a special HTTP request including the <code>Upgrade: websocket</code> and <code>Connection: Upgrade</code> headers, requesting the server to switch to the WebSocket protocol. If the server supports WebSocket, it will return an HTTP response code <code>101 Switching Protocols</code>, indicating agreement to switch to WebSocket.</p><p>Once the handshake is successful, the connection is upgraded to WebSocket, and both parties can start sending data through frames. The WebSocket protocol defines various frame types for transmitting data, closing connections, ping&#x2F;pong, etc. The WebSocket protocol <strong>supports both text and binary messages</strong>, allowing messages to be sent in a single frame or in fragments.</p><p>Here’s how to implement a WebSocket server using Python’s FastAPI:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@stream_app.websocket(<span class="params"><span class="string">&quot;/ws&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">websocket_endpoint</span>(<span class="params">websocket: WebSocket</span>):</span><br><span class="line">    <span class="keyword">await</span> websocket.accept()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">        <span class="keyword">await</span> websocket.send_text(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>) </span><br><span class="line">    <span class="keyword">await</span> websocket.close()</span><br></pre></td></tr></table></figure><div id="anchorWS"></div><p><a href="#anchorWS">Here</a> is an interactive demonstration of WebSocket:</p><div class="data-container">    <div id="wsData" class="data-block"></div>    <div class="button-container">        <button onclick="startWebSocket()" class="action-button">Start</button>        <button onclick="stopWebSocket()" class="action-button">End</button>    </div></div><p>After starting here, you can see the data transmitted in the WebSocket in the console. Chrome’s developer tools have a message status bar where you can see the data content throughout the full-duplex communication process. Below is an animated GIF of the entire process:</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240519_stream_sse_chunk_websocket.gif?noresize=true" alt="Animated GIF of WebSocket"></p><p>Of course, the WebSocket protocol is more complex compared to HTTP, requiring both the server and client to implement more logic.</p><p>This article has introduced 4 common methods for implementing stream output, each with its own advantages and disadvantages, suitable for different scenarios. Here are some suggestions:</p><ol><li>For simple unidirectional push scenarios, such as real-time news updates or stock quotes, consider using Server-Sent Events. It’s simple to implement, supported by mainstream browsers, and can effectively save server resources.</li><li>For interactive scenarios requiring bidirectional communication, such as instant messaging, collaborative office work, or online games, WebSocket is a more suitable choice. It offers full-duplex communication, supports text and binary data, and has low latency. However, it requires both client and server to implement WebSocket protocol logic.</li><li>If latency requirements are not too high, consider using polling or chunked transfer encoding. Polling is the simplest to implement, but frequent requests increase server load. Chunked transfer encoding is more efficient and doesn’t require frequent connection establishment.</li><li>For applications that need to support older browsers, polling might be the only option, as older browser versions may not support WebSocket or Server-Sent Events.</li></ol><p>Overall, stream output has been increasingly widely used in modern Web applications. Especially after the rise of large language models, almost all text generation applications use stream output to enhance user experience.</p><style>.data-container {    margin-bottom: 20px;}.data-block {    min-height: 100px;    overflow: auto;    border: 1px solid #ccc;    padding: 5px;    white-space: pre-wrap;    word-wrap: break-word;    width: 100%;}.button-container {    display: flex;    justify-content: end; /* 按钮靠右对齐 */    margin-top: 10px;}.action-button {    margin-left: 10px; /* 按钮之间的水平间隔 */    padding: 5px 10px;}.action-button:disabled {    opacity: 0.5; /* 禁用按钮时的样式 */    cursor: not-allowed; /* 鼠标样式表明按钮不可点击 */}</style><script>let count = 0;let pollingTimer; // 用于取消轮询的定时器function fetchData() {    document.getElementById('pollingData').innerHTML = '';    count = 0;    fetchPolling(); // 开始轮询}function fetchPolling() {    fetch('https://api.selfboot.cn/stream/polling?cnt=' + count)        .then(response => {            if (!response.ok && response.status === 400) {                throw new Error('Server returned 400 error');            }            return response.json();        })        .then(data => {            document.getElementById('pollingData').innerText += data.message;            count++;            pollingTimer = setTimeout(fetchPolling, 100);  // 安排下一次请求        })        .catch(error => {            console.error('Polling stopped: ', error);        });}function stopPolling() {    clearTimeout(pollingTimer); // 取消定时器，停止轮询    document.getElementById('pollingData').innerHTML = ''; // 清空数据区}let reader; // 用于Chunked传输的readerfunction startChunked() {    document.getElementById('chunkedData').innerHTML = '';    fetch('https://api.selfboot.cn/stream/chunked')        .then(response => {            reader = response.body.getReader();            readChunked();        })        .catch(console.error);}function readChunked() {    reader.read().then(({done, value}) => {        if (!done) {            const text = new TextDecoder().decode(value);            document.getElementById('chunkedData').innerText += text;            readChunked();        }    });}function stopChunked() {    if (reader) {        reader.cancel(); // 取消读取操作，终止流    }    document.getElementById('chunkedData').innerHTML = '';}let eventSource; // 用于SSE的EventSource对象function startSSE() {    document.getElementById('sseData').innerHTML = '';    eventSource = new EventSource('https://api.selfboot.cn/stream/events');    eventSource.onmessage = function(event) {        if (event.data === "END") {            eventSource.close();        } else if (event.data === "") {            document.getElementById('sseData').innerHTML += '<br>';        } else {            document.getElementById('sseData').innerHTML += event.data;        }    };    eventSource.onerror = function(event) {        console.error("SSE failed:", event);    };}function stopSSE() {    if (eventSource) {        eventSource.close(); // 关闭SSE连接    }    document.getElementById('sseData').innerHTML = '';}let websocket;function startWebSocket() {    document.getElementById('wsData').innerHTML = '';    websocket = new WebSocket('wss://api.selfboot.cn/stream/ws');    websocket.onopen = function() {        console.log('WebSocket connection opened');    };    websocket.onmessage = function(event) {        document.getElementById('wsData').innerHTML += event.data;    };    websocket.onerror = function(event) {        console.error('WebSocket error observed:', event);    };    websocket.onclose = function(event) {        console.log('WebSocket connection closed');    };}function stopWebSocket() {    if (websocket) {        websocket.send('stop'); // 发送停止信号        websocket.close(); // 关闭连接    }    document.getElementById('wsData').innerHTML = '';}</script>]]></content>
    
    
    <summary type="html">Through interaction and console screenshots, this article details four common methods for implementing stream output in the browser. Polling is simple but inefficient. Chunked transfer utilizes HTTP/1.1 features, allowing servers to respond with multiple data chunks, improving efficiency. Server-Sent Events, based on HTTP, enable servers to proactively push event streams to clients, suitable for unidirectional real-time data transmission scenarios. WebSocket is an independent protocol supporting full-duplex communication, ideal for interactive web applications.</summary>
    
    
    
    <category term="Programming" scheme="https://selfboot.cn/categories/Programming/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Web" scheme="https://selfboot.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>结合实例理解流式输出的几种实现方法</title>
    <link href="https://selfboot.cn/2024/05/19/stream_sse_chunk/"/>
    <id>https://selfboot.cn/2024/05/19/stream_sse_chunk/</id>
    <published>2024-05-19T21:42:37.000Z</published>
    <updated>2024-08-20T02:06:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>如果有用过 ChatGPT 等大语言模型，可能就会发现在聊天对话中，AI 的输出文本是一批批“蹦出来”的，这就是所谓的<strong>流式输出</strong>。在浏览器上，是怎么实现这种效果呢？</p><p>本篇文章会介绍 4 种常见方法来实现流式输出效果，每种方法都会结合实际例子来演示。在业务中选择哪种方法，取决于具体的需求和场景。</p><ol><li><strong>客户端轮询</strong>：客户端定时（如每几秒）发送请求到后端服务，获取新的数据。</li><li><strong>分块传输</strong>：HTTP&#x2F;1.1 支持，服务器一次可以只发送部分响应内容，客户端接收到部分数据后就可以开始处理。</li><li><strong>Server-Sent Events</strong>：服务器向浏览器推送信息，浏览器创建一个到服务器的单向连接，服务器通过这个连接可以发送多个消息。</li><li><strong>Web Socket</strong>：建立一个持久的、全双工的连接，允许服务器和客户端之间进行实时、双向的通信。</li></ol><span id="more"></span><h2 id="简单轮询"><a href="#简单轮询" class="headerlink" title="简单轮询"></a>简单轮询</h2><p>首先是最简单的轮询方法，客户端每隔一段时间向服务器发送请求，获取新的数据。实现轮询的时候，客户端和服务器需要用 HTTP 请求参数和回包<strong>约定数据更新或者结束</strong>的方式。比如简单的用一个请求字段 cnt 来约定这是第几次请求，返回中用 400 错误码来约定本次轮询结束。</p><p>下面用 Python 的 FastAPI 写一个简单示例，每次带一个下标来请求一段文本中的内容，如果超过文本长度，就返回 400。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">polling</span>(<span class="params">cnt: <span class="built_in">int</span> = <span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> cnt &gt;= <span class="built_in">len</span>(message) <span class="keyword">or</span> cnt &lt; <span class="number">0</span>:  <span class="comment"># 检查cnt是否有效</span></span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;Invalid index&quot;</span>)</span><br><span class="line">    data = &#123;<span class="string">&quot;message&quot;</span>: message[cnt]&#125;</span><br><span class="line">    <span class="keyword">return</span> JSONResponse(content=data)</span><br></pre></td></tr></table></figure><div id="anchorPolling"></div><p><a href="#anchorPolling">这里</a>是轮询的交互式展示：</p><div class="data-container">    <div id="pollingData" class="data-block"></div>    <div class="button-container">        <button onclick="fetchData()" class="action-button">开始</button>        <button onclick="stopPolling()" class="action-button">结束</button>    </div></div><p>点击开始后，即可看到数据不断更新，直到结束。如果打开控制台，就能看到浏览器每隔100ms发起一个 HTTP 请求，同时用参数 cnt 表示这是第几次请求。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240519_stream_sse_chunk_polling.png" alt="控制台查看轮询的请求过程"></p><p>这种方式的优点就是比较容易理解，实现起来比较简单。但是缺点也很明显，就是<strong>频繁的 HTTP 请求</strong>，会增加服务器的负担，同时也会增加网络传输的开销。如果是 <code>HTTP/1.1</code> 的话，每次请求都需要建立 TCP 连接，开销会更大。另外轮询的时间间隔也不太好控制，如果时间间隔太短，可能数据还没更新，白白浪费多次请求。如果时间间隔太长，用户体验又不好。</p><h2 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h2><p>上面轮询机制的缺点显而易见，主要是因为需要很多 HTTP 连接来更新数据。其实在 HTTP&#x2F;1.1 中，还有一种更好的方式，就是利用<strong>分块传输编码</strong>。分块传输编码实现流式输出更加高效，客户端只用请求一次，服务器<strong>以多个“块”的形式响应，直到所有数据都发送完毕</strong>。分块传输适用于响应体很大或由于内容是实时生成的而无法预知大小的情况，常见于大文件下载、视频流或实时数据流的传输。目前如果想在微信小程序中实现流式输出，最方便就是分块编码。</p><p>分块传输编码的协议稍微复杂一点，在响应头中用 <code>Transfer-Encoding: chunked</code> 表明响应将以分块的形式发送。每个块开始前，服务器发送一行包含当前块大小的数据，后跟一个回车换行（CRLF），紧接着是实际的块数据，再后面是一个CRLF。传输结束时，服务器发送一个大小为0的块，表示没有更多的数据块，通常后跟一个 CRLF。</p><p>在 Python 中用 FastAPI 实现分块编码协议也比较简单，下面是一个简单的示例，隔 100ms 输出内容然后分块编码传输：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@stream_app.get(<span class="params"><span class="string">&quot;/chunked&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">chunked_transfer</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_large_data</span>():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">f&quot;<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> StreamingResponse(generate_large_data(), media_type=<span class="string">&quot;text/plain&quot;</span>)</span><br></pre></td></tr></table></figure><div id="anchorChunked"></div><p><a href="#anchorChunked">这里</a>是分块传输编码的交互式展示：</p><div class="data-container">    <div id="chunkedData" class="data-block"></div>    <div class="button-container">        <button onclick="startChunked()" class="action-button">开始</button>        <button onclick="stopChunked()" class="action-button">结束</button>    </div></div><p>点击开始后，同样可以看到数据不断更新，直到所有内容打印出来。如果打开控制台，看到浏览器只发送了一个 HTTP 请求，这个请求的响应中 Header 中有 <code>Transfer-Encoding: chunked</code>，响应数据大小随着时间不断更新。下面是动态图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240519_stream_sse_chunk_chunked.gif?noresize=true" alt="分块传输编码的动态图"></p><p>值得注意的是，分块传输编码只在 HTTP&#x2F;1.1 中支持。在 HTTP&#x2F;2 中，分块传输编码的概念已经不存在了，这主要是因为 HTTP&#x2F;2 的工作方式有很大的不同。HTTP&#x2F;2 引入了多路复用（multiplexing）、二进制帧（binary framing）和流控制（stream prioritization）等新的机制来提高效率和性能。 在 HTTP&#x2F;2 中，所有通信都在单一的 TCP 连接上通过帧进行。数据帧（DATA frames）被用来传输消息体数据。服务器可以根据需要连续发送多个数据帧，每个帧携带一部分消息内容。客户端按接收顺序重新组装这些帧来重建完整的消息。</p><p>不过我这里的示例，在 HTTP&#x2F;2 下仍然是流式输出的，这是因为这里前端用的 <code>Fetch API</code> 和流处理 <code>response.body.getReader().read()</code>，它提供了一致的接口来处理流数据，不论底层协议是 HTTP&#x2F;1.1 还是 HTTP&#x2F;2。当调用的是 HTTP&#x2F;2 接口时，也能正常从数据帧中读取数据。</p><h2 id="Server-Sent-Events"><a href="#Server-Sent-Events" class="headerlink" title="Server-Sent Events"></a>Server-Sent Events</h2><p>OpenAI 在聊天工具 ChatGPT 中没有使用上面两种方式，而是用了 <code>Server-Sent Events（SSE）</code>来实现流式输出。SSE 允许服务器主动向浏览器或其他客户端推送事件。SSE的设计主要是为了简化从服务器到客户端的单向实时数据流，尤其适用于需要快速、持续更新数据的Web应用，如实时新闻更新、股票行情、或社交媒体实时消息等。</p><p>SSE 基于 HTTP 协议，使用标准的HTTP请求来开始连接。首先客户端发起标准的 HTTP GET 请求开始一个SSE连接。请求的头部通常包含<code>Accept: text/event-stream</code>，这告诉服务器客户端希望开启一个SSE连接。服务器响应这个请求，并<strong>保持连接打开</strong>，响应的 Content-Type 被设置为<code>text/event-stream</code>。随后，服务器可以发送<strong>形式为纯文本的事件流</strong>。每个事件以一个可选的事件名和必须的数据字段组成。事件以<code>data:</code>开始，后跟具体的消息数据，事件之间以两个换行符<code>\n\n</code>分隔。整个过程中 HTTP 连接保持打开状态，服务器可以随时发送新事件，客户端在接收到每个事件后处理数据。SSE连接一旦建立，服务器可以持续不断地发送数据更新到客户端，直到连接被关闭。</p><p>在 Python 中用 FastAPI 实现 SSE 比较简单，下面是一个简单的示例，隔 100ms 向客户端返回内容，等所有内容输出完，服务器结束本次连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@stream_app.get(<span class="params"><span class="string">&quot;/events&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_events</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">event_stream</span>():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">f&quot;data: <span class="subst">&#123;i&#125;</span>\n\n&quot;</span>  <span class="comment"># 注意数据格式</span></span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">f&quot;data: END\n\n&quot;</span> </span><br><span class="line">    <span class="keyword">return</span> StreamingResponse(event_stream(), media_type=<span class="string">&quot;text/event-stream&quot;</span>)</span><br></pre></td></tr></table></figure><div id="anchorSSE"></div><p><a href="#anchorSSE">这里</a>是 SSE 的交互式展示：</p><div class="data-container">    <div id="sseData" class="data-block"></div>    <div class="button-container">        <button onclick="startSSE()" class="action-button">开始</button>        <button onclick="stopSSE()" class="action-button">结束</button>    </div></div><p>点击开始后，可以看到数据不断更新，直到所有内容打印出来。如果打开控制台，看到浏览器只发送了一个 HTTP 请求，这个请求的响应中 Header 中有 <code>Content-Type: text/event-stream</code>，响应数据大小随着时间不断更新。下面是整个过程动态图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240519_stream_sse_chunk_sse.gif?noresize=true" alt="Server-Sent Events 的动态图"></p><p>大多数现代浏览器都支持SSE，使用 SSE 用户体验比较好，也十分节省资源。不过 SSE 有一个缺点，就是<strong>只能从服务器到客户端单向传输</strong>，客户端不能向服务器发送数据。如果需要双向通信，就需要使用 Web Socket。</p><h2 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h2><p>前面的三种方法都是基于 HTTP 协议的，主要是为了解决服务器向客户端推送数据的问题。而 Web Socket 是一种独立的协议，它是一种<strong>全双工通信</strong>协议，允许客户端和服务器之间<strong>进行实时、双向的通信</strong>，从而有效地支持复杂的交互式应用，例如在线游戏、交易平台和协作工具。</p><p>WebSocket 也是基于 TCP 协议实现，具体的协议由 IETF 的 <a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a> 定义。首先是握手阶段，WebSocket 连接首先通过 HTTP 协议发起，需要客户端发送一个特殊的 HTTP 请求，包含 <code>Upgrade: websocket </code> 和 <code>Connection: Upgrade</code> 头部，请求服务器切换到 WebSocket 协议。如果服务器支持 WebSocket，它会返回一个HTTP响应码 <code>101 Switching Protocols</code>，表示同意切换到 WebSocket。</p><p>一旦握手成功，连接就升级到 WebSocket，双方就可以开始通过帧来发送数据。WebSocket协议定义了多种帧类型，用于传输数据、关闭连接、ping&#x2F;pong等。WebSocket协议<strong>支持文本和二进制消息</strong>，允许消息在一个帧内发送完或者分片发送。</p><p>在 Python 中用 FastAPI 实现 Web Socket 服务端如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@stream_app.websocket(<span class="params"><span class="string">&quot;/ws&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">websocket_endpoint</span>(<span class="params">websocket: WebSocket</span>):</span><br><span class="line">    <span class="keyword">await</span> websocket.accept()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">        <span class="keyword">await</span> websocket.send_text(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>) </span><br><span class="line">    <span class="keyword">await</span> websocket.close()</span><br></pre></td></tr></table></figure><div id="anchorWS"></div><p><a href="#anchorWS">这里</a>是 Web Socket 的交互式展示：</p><div class="data-container">    <div id="wsData" class="data-block"></div>    <div class="button-container">        <button onclick="startWebSocket()" class="action-button">开始</button>        <button onclick="stopWebSocket()" class="action-button">结束</button>    </div></div><p>这里开始后，在控制台可以看到 WebSocket 中传输的数据。Chrome 的开发者工具，有个 message 状态栏，可以看到整个全双工通信过程中的数据内容。下面是整个过程动态图：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240519_stream_sse_chunk_websocket.gif?noresize=true" alt="Web Socket 的动态图"></p><p>当然，WebSocket 协议相对 HTTP 更复杂，需要服务器和客户端都实现更多的逻辑。</p><p>本文结合具体的例子，介绍了 4 种常见的实现流式输出的方法，每种方法都有自己的优缺点，适用于不同的场景。以下是一些建议:</p><ol><li>针对简单的单向推送场景，如新闻实时更新、股票行情等，可以考虑使用 Server-Sent Events。实现简单，支持主流浏览器，且能有效节省服务器资源。</li><li>对于需要双向通信的交互场景，如即时通讯、协作办公、在线游戏等，WebSocket 是更合适的选择。全双工通信，支持文本和二进制数据，延迟较低。但需要客户端和服务器端均实现 WebSocket 协议逻辑。</li><li>如果对延迟要求不太高，可以考虑使用轮询或分块传输编码。轮询实现最简单，但频繁请求会增加服务器负担。分块传输编码效率更高,无需频繁建立连接。</li><li>对于需要向老旧浏览器提供支持的应用，轮询可能是唯一可选方案，因为旧版本浏览器可能不支持 WebSocket 或 Server-Sent Events。</li></ol><p>总的来说，流式输出在现代 Web 应用中得到了越来越广泛的应用。特别是大语言模型兴起之后，几乎所有的文本生成应用，都是用流式输出来提升用户体验。</p><style>.data-container {    margin-bottom: 20px;}.data-block {    min-height: 100px;    overflow: auto;    border: 1px solid #ccc;    padding: 5px;    white-space: pre-wrap;    word-wrap: break-word;    width: 100%;}.button-container {    display: flex;    justify-content: end; /* 按钮靠右对齐 */    margin-top: 10px;}.action-button {    margin-left: 10px; /* 按钮之间的水平间隔 */    padding: 5px 10px;}.action-button:disabled {    opacity: 0.5; /* 禁用按钮时的样式 */    cursor: not-allowed; /* 鼠标样式表明按钮不可点击 */}</style><script>let count = 0;let pollingTimer; // 用于取消轮询的定时器function fetchData() {    document.getElementById('pollingData').innerHTML = '';    count = 0;    fetchPolling(); // 开始轮询}function fetchPolling() {    fetch('https://api.selfboot.cn/stream/polling?cnt=' + count)        .then(response => {            if (!response.ok && response.status === 400) {                throw new Error('Server returned 400 error');            }            return response.json();        })        .then(data => {            document.getElementById('pollingData').innerText += data.message;            count++;            pollingTimer = setTimeout(fetchPolling, 100);  // 安排下一次请求        })        .catch(error => {            console.error('Polling stopped: ', error);        });}function stopPolling() {    clearTimeout(pollingTimer); // 取消定时器，停止轮询    document.getElementById('pollingData').innerHTML = ''; // 清空数据区}let reader; // 用于Chunked传输的readerfunction startChunked() {    document.getElementById('chunkedData').innerHTML = '';    fetch('https://api.selfboot.cn/stream/chunked')        .then(response => {            reader = response.body.getReader();            readChunked();        })        .catch(console.error);}function readChunked() {    reader.read().then(({done, value}) => {        if (!done) {            const text = new TextDecoder().decode(value);            document.getElementById('chunkedData').innerText += text;            readChunked();        }    });}function stopChunked() {    if (reader) {        reader.cancel(); // 取消读取操作，终止流    }    document.getElementById('chunkedData').innerHTML = '';}let eventSource; // 用于SSE的EventSource对象function startSSE() {    document.getElementById('sseData').innerHTML = '';    eventSource = new EventSource('https://api.selfboot.cn/stream/events');    eventSource.onmessage = function(event) {        if (event.data === "END") {            eventSource.close();        } else if (event.data === "") {            document.getElementById('sseData').innerHTML += '<br>';        } else {            document.getElementById('sseData').innerHTML += event.data;        }    };    eventSource.onerror = function(event) {        console.error("SSE failed:", event);    };}function stopSSE() {    if (eventSource) {        eventSource.close(); // 关闭SSE连接    }    document.getElementById('sseData').innerHTML = '';}let websocket;function startWebSocket() {    document.getElementById('wsData').innerHTML = '';    websocket = new WebSocket('wss://api.selfboot.cn/stream/ws');    websocket.onopen = function() {        console.log('WebSocket connection opened');    };    websocket.onmessage = function(event) {        document.getElementById('wsData').innerHTML += event.data;    };    websocket.onerror = function(event) {        console.error('WebSocket error observed:', event);    };    websocket.onclose = function(event) {        console.log('WebSocket connection closed');    };}function stopWebSocket() {    if (websocket) {        websocket.send('stop'); // 发送停止信号        websocket.close(); // 关闭连接    }    document.getElementById('wsData').innerHTML = '';}</script>]]></content>
    
    
    <summary type="html">通过交互和控制台截图，详细介绍了在浏览器端实现流式输出的4种常见方法。轮询方式简单但效率低下。分块传输利用HTTP/1.1特性，服务器可分多个数据块响应，提高效率。Server-Sent Events 基于HTTP，服务器可主动向客户端推送事件流，应用于单向实时数据传输场景。WebSocket是独立协议，支持全双工通信，适合交互式Web应用。</summary>
    
    
    
    <category term="项目实践" scheme="https://selfboot.cn/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="方法" scheme="https://selfboot.cn/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
</feed>
