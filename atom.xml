<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just For Fun</title>
  <icon>https://www.gravatar.com/avatar/0de0c23d97c75300e32f8494b1485fb8</icon>
  <subtitle>知其然，知其所以然。知识广度是深度的副产品！</subtitle>
  <link href="https://selfboot.cn/atom.xml" rel="self"/>
  
  <link href="https://selfboot.cn/"/>
  <updated>2023-07-02T14:41:18.185Z</updated>
  <id>https://selfboot.cn/</id>
  
  <author>
    <name>FeiZhao</name>
    <email>xuezaigds@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用 ebpf bcc 无侵入分析服务函数耗时</title>
    <link href="https://selfboot.cn/2023/06/30/ebpf_func_time/"/>
    <id>https://selfboot.cn/2023/06/30/ebpf_func_time/</id>
    <published>2023-06-30T19:33:20.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，在开发和维护后台服务时，监控函数的执行时间是至关重要的。通过监控，我们可以及时发现性能瓶颈，优化代码，确保服务的稳定性和响应速度。然而，传统的方法通常涉及在代码中添加统计信息并上报，这种方法虽然有效，但往往只针对那些被认为是关键路径的函数。</p><p>假设在某个时刻，我们突然需要监控一个并非重点关注的函数的执行时间。在这种情况下，修改代码并重新部署服务可能是一项繁琐且耗时的任务。这时，eBPF（扩展的伯克利数据包过滤器）和 BCC（BPF 编译器集合）就派上了用场。通过使用 eBPF，我们可以在<span style="color:red;">不修改代码和不重新部署服务的情况下，动态地插入探针来监控函数的执行时间</span>。这不仅大大简化了监控过程，还减少了对服务性能的影响。</p><p>在接下来的文章中，将详细介绍如何利用 eBPF BCC 来无侵入地分析服务函数耗时，并通过实际示例来展示其强大的功能。</p><span id="more"></span><h2 id="eBPF-函数耗时分析原理"><a href="#eBPF-函数耗时分析原理" class="headerlink" title="eBPF 函数耗时分析原理"></a>eBPF 函数耗时分析原理</h2><p><a href="https://ebpf.io/what-is-ebpf/">eBPF</a> 是一种非常强大的技术，它允许开发者在 Linux 内核中执行自定义代码，而无需修改内核或加载内核模块。这种灵活性使得 eBPF 可以应用于各种场景，包括网络监控、安全和性能分析。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230630_ebpf_function_time_ebpf.png" alt="ebpf 允许用户在内核中执行代码"></p><p>eBPF 支持用户空间追踪 (uprobes)，允许我们附加 eBPF 程序到用户空间应用程序，这意味着我们可以非常精细地监控和分析用户空间应用程序的行为，而无需修改应用程序代码。我们可以在函数入口和退出时定义要执行的代码，当函数被调用时，入口探针（kprobe&#x2F;uprobe）被触发，当函数返回时，退出探针被触发。</p><p>为了计算函数的耗时，可以在函数入口的 eBPF 程序中，记录当前的时间戳。在函数退出的 eBPF 程序中，再次记录时间戳，并计算两者之间的差异，这就是函数的执行时间。然后将函数的执行时间存储在 BPF Maps 中，在用户空间中对其进行进一步的分析和可视化，以帮助我们理解函数的性能特征。</p><p>直接写 ebpf 有点麻烦，好在我们可以用 BCC 来简化开发难度。<a href="https://github.com/iovisor/bcc/tree/master">BCC (BPF Compiler Collection)</a> 是一个开发工具集，它简化了编写和编译 BPF 程序的过程，允许开发人员使用 Python、C 等语言编写脚本来控制 eBPF 程序的行为。</p><h2 id="模拟耗时函数"><a href="#模拟耗时函数" class="headerlink" title="模拟耗时函数"></a>模拟耗时函数</h2><p>为了使用 eBPF BCC 来分析函数耗时，我们首先需要创建一个测试进程，在该进程中使用一个特定的函数来模拟实际场景中函数的耗时情况。在常见的业务中，函数的耗时分布通常是不均匀的，因此这里有意设计了一个函数，<strong>使其 P99 耗时显著大于平均耗时</strong>。这样可以模拟实际的业务场景，大多数请求都能快速处理，但在某些情况下（如数据量大、缓存未命中或资源争用等），处理时间会显著增加。</p><p>补充说一下 P99 耗时是一种性能指标，它描述的是一个系统或函数中，99% 的执行时间都小于这个 P99 分位值。可以这样简单理解：如果你有100个请求，P99 耗时就是这100个请求中耗时最长的那一个。不过不同工具计算 P99 的算法可能不太一致，如果函数执行 100 次，99 次的耗时都分布在 1ms 到 2ms之间，有一次耗时 100ms，那么 P99 可以是 2ms，也可以是 100ms，取决于具体的算法实现，这里不影响我们对于 P99 指标的理解。</p><p>这里模拟耗时的函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">int</span> iteration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个通常执行得很快，但每 100 次迭代中的最后一次耗时较长的函数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">long</span> iterations = (iteration % <span class="number">100</span> == <span class="number">99</span>) ? <span class="number">10000000</span> : <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; iterations; ++i) &#123;</span><br><span class="line">        result += std::<span class="built_in">sqrt</span>(std::<span class="built_in">atan</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了提供一个耗时的计算基准，在测试代码中我们也添加了耗时统计，计算函数的平均耗时和 P99 耗时。具体方法是，在一个无限循环中，它每次调用函数并记录执行时间。每当累计执行时间超过一秒，它就计算并输出这段时间内函数执行的平均时间和P99 时间。然后，它清除所有已记录的执行时间，准备开始下一轮的数据收集和分析，如下实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; timings;</span><br><span class="line">    <span class="type">int</span> iteration = <span class="number">0</span>;</span><br><span class="line">    Timer overall_timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="built_in">someFunction</span>(iteration);</span><br><span class="line">        timings.<span class="built_in">push_back</span>(timer.<span class="built_in">elapsed</span>());</span><br><span class="line">        iteration++;</span><br><span class="line">        <span class="keyword">if</span> (overall_timer.<span class="built_in">elapsed</span>() &gt;= <span class="number">1000.0</span>) &#123;</span><br><span class="line">            <span class="type">double</span> average = std::<span class="built_in">accumulate</span>(timings.<span class="built_in">begin</span>(), timings.<span class="built_in">end</span>(), <span class="number">0.0</span>) / timings.<span class="built_in">size</span>();</span><br><span class="line">            std::<span class="built_in">sort</span>(timings.<span class="built_in">begin</span>(), timings.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">double</span> p99 = timings[<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(timings.<span class="built_in">size</span>() * <span class="number">0.99</span>)];</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Average execution time: &quot;</span> &lt;&lt; average &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;P99 execution time: &quot;</span> &lt;&lt; p99 &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            timings.<span class="built_in">clear</span>();</span><br><span class="line">            overall_timer = <span class="built_in">Timer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码 <code>func_time.cpp</code> 在 <a href="https://gist.github.com/selfboot/8b1d3661f5df974eb68df03a4687dcfa">gist</a> 上。在我的服务器上得到执行结果如下，函数耗时和机器性能以及负载都有关系：</p><blockquote><p>Average execution time: 3.95762 ms<br>P99 execution time: 190.968 ms<br>Average execution time: 3.90211 ms<br>P99 execution time: 191.292 ms<br>…</p></blockquote><h2 id="BCC-函数耗时直方分布"><a href="#BCC-函数耗时直方分布" class="headerlink" title="BCC 函数耗时直方分布"></a>BCC 函数耗时直方分布</h2><p>注意这里的耗时监控脚本需要依赖 BCC 工具，可以在 BCC 的 <a href="https://github.com/iovisor/bcc">GitHub 页面</a>找到安装指南。此外需要保证你的系统内核支持BPF，对于 Linux内核版本，通常需要4.8或以上版本，以获取最佳的BPF功能支持。</p><p>BCC 提供了方便的方法，便于我们统计函数的耗时分布。首先通过解析命令行参数获取目标进程的 PID 和待追踪的函数名，然后构建并加载一个 BPF 程序，使用用户态探针（uprobes）和用户态返回探针（uretprobes）附加到指定的进程和函数，以便在函数开始和结束时获取时间戳。</p><p>探针函数 <code>trace_start</code> 在每次函数调用开始时捕获当前的时间戳，并将其与表示当前进程的键一起存储在 BPF 哈希映射 start 中。当函数调用结束时，<code>trace_end</code> 探针函数查找起始时间戳，并计算出函数执行的时间差。这个时间差被记录到 BPF 直方图 dist 中，用于后续的性能分析。完整的脚本 <code>func_time_hist.py</code> 在 <a href="https://gist.github.com/selfboot/3c78f4c50c70bce22e1ce61b7d72dbda">gist</a> 上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trace_start</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">key_t</span> key = &#123;&#125;;</span><br><span class="line">    u64 ts;</span><br><span class="line">    key.pid = <span class="built_in">bpf_get_current_pid_tgid</span>();</span><br><span class="line">    <span class="built_in">bpf_get_current_comm</span>(&amp;(key.comm), <span class="built_in">sizeof</span>(key.comm));</span><br><span class="line">    ts = <span class="built_in">bpf_ktime_get_ns</span>();</span><br><span class="line">    start.<span class="built_in">update</span>(&amp;key, &amp;ts);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trace_end</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">key_t</span> key = &#123;&#125;;</span><br><span class="line">    u64 *tsp, delta;</span><br><span class="line">    key.pid = <span class="built_in">bpf_get_current_pid_tgid</span>();</span><br><span class="line">    <span class="built_in">bpf_get_current_comm</span>(&amp;(key.comm), <span class="built_in">sizeof</span>(key.comm));</span><br><span class="line">    tsp = start.<span class="built_in">lookup</span>(&amp;key);</span><br><span class="line">    <span class="keyword">if</span> (tsp != <span class="number">0</span>) &#123;</span><br><span class="line">        delta = <span class="built_in">bpf_ktime_get_ns</span>() - *tsp;</span><br><span class="line">        dist.<span class="built_in">increment</span>(<span class="built_in">bpf_log2l</span>(delta / <span class="number">1000</span>));</span><br><span class="line">        start.<span class="built_in">delete</span>(&amp;key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用 -g 编译前面的 <code>func_time.cpp</code> ，用 nm 拿到 C++ 名称修饰（<code>name mangling</code>）后的函数名字。运行程序，然后拿到进程 pid，就可以用工具来查看耗时分布了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ func_time.cpp -g -o func_time</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm func_time| grep <span class="string">&#x27;T&#x27;</span> | grep someFunction</span></span><br><span class="line">0000000000001235 T _Z12someFunctioni</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python func_time_hist.py 832965  _Z12someFunctioni</span></span><br></pre></td></tr></table></figure><p>当按下 Ctrl-C 中止程序时，会打印出 dist 直方图，以对数尺度显示函数执行时间的分布情况。这使得我们可以快速了解函数执行性能的大致情况，如最常见的执行时间，以及时间的分布范围，具体如下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230630_ebpf_func_time_hist.png" alt="BCC 脚本分析函数调用耗时分布"></p><p>可以看到大部分函数调用的耗时分布在 1024-2047us 之间，有 11 次函数调用的耗时分布在 131702-262143us 之间。这个函数占比大概是 1%，符合我们模拟的函数特征。</p><h2 id="BCC-函数平均耗时"><a href="#BCC-函数平均耗时" class="headerlink" title="BCC 函数平均耗时"></a>BCC 函数平均耗时</h2><p>很多时候我们不只想看到函数耗时分布，还想知道平均耗时和 P99 耗时，只需要对上面的 BCC 脚本稍作改动即可。每次函数执行后，使用 BPF 的 PERF 输出接口来收集执行时间到用户空间。具体通过在 BPF 程序的 <code>trace_end</code> 函数中使用 <code>perf_submit</code> 助手函数来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trace_end</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">key_t</span> key = &#123;&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">data_t</span> data = &#123;&#125;;</span><br><span class="line">    u64 *tsp, delta;</span><br><span class="line"></span><br><span class="line">    key.pid = <span class="built_in">bpf_get_current_pid_tgid</span>();</span><br><span class="line">    <span class="built_in">bpf_get_current_comm</span>(&amp;(key.comm), <span class="built_in">sizeof</span>(key.comm));</span><br><span class="line"></span><br><span class="line">    tsp = start.<span class="built_in">lookup</span>(&amp;key);</span><br><span class="line">    <span class="keyword">if</span> (tsp != <span class="number">0</span>) &#123;</span><br><span class="line">        delta = <span class="built_in">bpf_ktime_get_ns</span>() - *tsp;</span><br><span class="line">        data.pid = key.pid;</span><br><span class="line">        data.duration = delta;</span><br><span class="line">        times.<span class="built_in">perf_submit</span>(ctx, &amp;data, <span class="built_in">sizeof</span>(data));</span><br><span class="line">        start.<span class="built_in">delete</span>(&amp;key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在用户空间的 Python 脚本中，在每个指定的时间间隔内计算平均值和 P99。完整的代码 <code>func_time.py</code> 在 <a href="https://gist.github.com/selfboot/38526f556698d9263a2751feadf73efb">gist</a> 上，执行结果如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230630_ebpf_func_time_avg_p99.png" alt="BCC 脚本分析函数调用平均耗时和 P99 耗时"></p><p>总的来说，使用 eBPF 和 BCC 来进行这种无侵入性的性能分析，对于生产环境中的故障排除和性能优化具有巨大的价值。它<strong>允许我们在不中断服务或重新部署代码的情况下，实时收集和分析关键性能指标</strong>。这种能力对于维护高性能和高可用性的系统至关重要。</p>]]></content>
    
    
    <summary type="html">探究如何利用 eBPF 和 BCC 无侵入地分析服务函数的执行时间，包括平均耗时和 P99 耗时，以优化代码性能和服务响应速度，无需修改或重新部署代码。</summary>
    
    
    
    <category term="计算机基础" scheme="https://selfboot.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="ebpf" scheme="https://selfboot.cn/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 提问技巧四：给模型思考时间</title>
    <link href="https://selfboot.cn/2023/06/29/gpt4_prompt_think/"/>
    <id>https://selfboot.cn/2023/06/29/gpt4_prompt_think/</id>
    <published>2023-06-29T23:07:10.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 GPT4 提问技巧系列的第四篇，全部系列文章：</p><ol><li><a href="https://selfboot.cn/2023/06/10/gpt4_prompt_clear/">GPT4 提问技巧一：写清晰的说明</a>；</li><li><a href="https://selfboot.cn/2023/06/12/gpt4_prompt_reference/">GPT4 提问技巧二：提供参考文本</a>；</li><li><a href="https://selfboot.cn/2023/06/15/gpt4_prompt_subtasks/">GPT4 提问技巧三：复杂任务拆分</a>；</li><li><a href="https://selfboot.cn/2023/06/29/gpt4_prompt_think/">GPT4 提问技巧四：给模型思考时间</a>；</li></ol><p>在我们的生活中，当面临复杂问题时，通常需要花费一些时间来深思熟虑。正如一位作家在撰写一篇文章时需要时间来组织思路和打磨措辞，或者一位棋手在对弈时需要时间来分析局势和制定策略一样，深思熟虑是一种必要的过程。人工智能也有类似的需求，确切地说，GPT 也需要一些时间来为我们提供更深入、更精确的答案。</p><p>您可能会疑惑：“机器怎么会需要时间来思考？”这是一个很好的问题。事实上，给GPT-4模型“思考”的时间，并不是字面意义上的让它思考，而是<strong>给它更多的机会来搜索、分析和优化它的回答</strong>。这与给一位作家时间来组织思路和打磨措辞，或者给一位棋手时间来分析局势和制定策略是类似的。在这些情况下，时间成为了提升结果质量的关键因素。</p><p>接下来通过示例，我们一起来看下如何通过提示词，让 GPT-4 模型有更多的“思考时间”。</p><span id="more"></span><h2 id="先思考正确方案，再评估"><a href="#先思考正确方案，再评估" class="headerlink" title="先思考正确方案，再评估"></a>先思考正确方案，再评估</h2><p>假设我们要使用 GPT 模型来评估学生解决数学问题的答案，最直接的方法是简单地询问模型学生的解答是否正确。然而，这种方法可能导致模型快速作出判断，而没有深入分析。</p><p>下面我们在 <a href="https://platform.openai.com/playground/p/default-rushing-to-a-conclusion?model=gpt-4">Playground</a> 上做一个简单的实验。对于很简单的一元方程和二元方程，如果直接让 GPT-3.5 判断回答是否正确，都会判断错误。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230629_gpt4_prompt_think.png" alt="GPT-3.5 简单数学答案都判断错误"></p><p>为了让 GPT-3.5 能给出正确的判断，我们可以改下我们的提示词，引导 AI 先给出自己的解决方案，把自己的方案和学生的进行比较，从而判断学生的回答是否正确。可以加一个系统提示词如下：</p><blockquote><p>首先给出你自己的解决方案，然后将您的解决方案与学生的解决方案进行比较，并评估学生的解决方案是否正确。</p><p>注意在你给出自己的解决方案之前，不要决定学生的解决方案是否正确。</p></blockquote><p>这样 GPT-3.5 也能给出一个正确的判断，如下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230629_gpt4_prompt_think_1.png" alt="GPT-3.5 先自己给出解决方案，再比较"></p><p>随着模型变化升级，不一定能稳定复现这里的一些错误回答。不过这不影响我们这里想表达的意图，就是尽可能让模型先自己“思考”，不要急于做出判断。</p><p>给模型更多时间思考，和我们前面<a href="https://selfboot.cn/2023/06/15/gpt4_prompt_subtasks/">GPT4 提问技巧三：复杂任务拆分</a>的策略有点类似，本质上是通过<strong>更精细的提示和问题分解来引导模型进行深入的分析</strong>。值得注意的是，这种策略需要我们对问题有深入的理解，并能够有效地指导模型的思考过程。</p><h2 id="隐藏推理过程"><a href="#隐藏推理过程" class="headerlink" title="隐藏推理过程"></a>隐藏推理过程</h2><p>在很多时候，我们不希望对用户展示模型的推理过程，只想让模型给出最终结果。例如，在前面的例子中，我们希望 AI 帮助我们判断学生的解题是否正确，但是不希望让 AI 直接告诉学生正确的解题。这时候如果要求模型不输出中间的推理过程，最后的回答质量也会受到影响。</p><p>这里一个更好的做法是使用“<span style="color:red;"><strong>内心独白</strong></span>”，内心独白的做法是指示模型将输出中要对用户隐藏的部分放入结构化格式中，在向用户呈现输出之前，过滤这些需要对用户隐藏的部分。针对前面的帮学生找出题解是否正确的问题上，我们可以提供如下 prompt：</p><blockquote><p>你是一名数学导师，如果学生犯了错误，请以不透露答案的方式向学生提供提示。如果学生没有犯错误，只需给他们一个鼓励的评论。请按照以下步骤回答，输出为一个 json，其中只包括每个步骤的结果。</p><p>步骤1 - 首先给出自己的问题解决方法和正确的答案。注意不要依赖学生的解决方案，因为它可能是不正确的。将此步骤的所有输出保存在 json 的ai_method 字段。</p><p>第 2 步 - 将您的答案与学生的解答进行比较，并评估学生的解决方案是否正确。将此步骤的所有输出保存在 json 的ai_compare 字段。</p><p>第 3 步 - 如果学生犯了错误，请确定您可以在不泄露答案的情况下给学生什么提示。如果学生回答正确，可以说一些鼓励的评论。将此步骤的所有输出保存在 json 的 hint 字段。</p></blockquote><p>具体可以看下面的效果：<br><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230629_gpt4_prompt_think_2.png" alt="GPT-4 内心独白格式化输出"></p><p>这里格式化输出，GPT-3.5 的效果不是很好，GPT-4 会好很多，不过还是有一定概率给出错误的格式化输出。一旦我们拿到了格式化输出，就可以在应用中解析需要的字段，隐藏推理过程了。</p><h2 id="模型“思考”升级"><a href="#模型“思考”升级" class="headerlink" title="模型“思考”升级"></a>模型“思考”升级</h2><p>在写这篇文章的时候，我其实也在思考，随着模型的迭代升级，AI 会不会不用经过专门 prompt 调优，也能很好的思考，给出一个超出预期的答案。于是用 GPT-4 尝试了几个例子，发现即使没有让他先给出自己的方案，也能给出正确结果，下面是两个例子：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230629_gpt4_prompt_think_3.png" alt="GPT-4 自己思考能力的迭代"></p><p>随着技术的进步，新的 GPT 模型在处理复杂问题时，也应该能够更好地模拟“思考”的过程。这些模型在没有明确的提示下，也能够采取更深入的分析，更全面的搜索，以及更精细的优化。这就好像<span style="color:red;">它们已经学会了如何给自己“思考”的时间，以产生更高质量的回答</span>。</p><p>然而，这<strong>并不意味着我们不再需要给模型明确的指导</strong>。事实上，明确的指导仍然是一个非常有用的工具，可以帮助我们更好地控制模型的行为，引导模型产生我们期望的回答。尤其是在处理一些非常复杂或者需要特定领域知识的问题时，明确的指导可以帮助模型更准确地理解我们的需求，更有效地找到正确的答案。</p><p>总的来说，随着AI技术的发展，我们可以期待模型在“思考”能力上的进步。但同时，我们也需要继续学习和探索如何更好地与这些模型交互，如何更有效地利用它们的能力。在这个过程中，给模型“思考”的时间，仍然是一个非常重要的策略。</p>]]></content>
    
    
    <summary type="html">深入探索 GPT-4 提问技巧系列的第四篇文章，了解如何通过精心设计的提示词让 GPT-4 模型有更多的“思考时间”。学习如何通过更精细的提示和问题分解来引导模型进行深入分析，从而获得更深入、更精确的答案。适用于 AI 爱好者和开发者。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>Redis Issue 分析：流数据读写导致的“死锁”问题(2)</title>
    <link href="https://selfboot.cn/2023/06/16/bug_redis_deadlock_2/"/>
    <id>https://selfboot.cn/2023/06/16/bug_redis_deadlock_2/</id>
    <published>2023-06-16T22:45:16.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://selfboot.cn/2023/06/14/bug_redis_deadlock_1/">Redis Issue 分析：流数据读写导致的“死锁”问题(1)</a> 中，我们成功复现了 Issue 中提到的 bug，观察到 Redis Server CPU 飙慢，无法建立新的连接，现有的连接也不能执行任何读写操作。借助强大的 ebpf profile 工具，我们观察到了 CPU 时间主要消耗在哪里，接下来我们一起来看下这个 BUG 的调试过程和修复方法。</p><h2 id="调试-bug"><a href="#调试-bug" class="headerlink" title="调试 bug"></a>调试 bug</h2><p>考虑到 Redis server 进程还在，我们可以用 GDB attach 到进程上，打断点看下具体的执行过程。在火焰图上看到的比较耗时的 <code>handleClientsBlockedOnKey</code> 函数里面有 while 循环语句。而 CPU 飙满的话一般都是死循环，为了验证是不是有死循环在这个 while 里，可以在 whil 前面的 565 行和里面的 569 行打上断点，然后 <code>continue</code> 多次进行观察。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">    client *receiver = listNodeValue(ln);</span><br><span class="line">    robj *o = lookupKeyReadWithFlags(rl-&gt;db, rl-&gt;key, LOOKUP_NOEFFECTS);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>我们看到<strong>每次都是在循环里面的 569 行暂停住</strong>，基本认定确实是这里发生了死循环。查看当前栈帧上的局部变量，可以看到 receiver指针。具体如下：<br><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230616_bug_redis_deadlock_2_0.png" alt="GDB continue 确认死循环"></p><p>这里 receiver 是 <code>server.h</code> 里面声明的 struct client，是 redis 里面为每一个 client 连接维护的数据结构。现在的问题很清晰，server 进程在 while 循环中不断拿出来 client 连接，一直停不下来。为了弄清楚这些 client 从哪里来的，我们可以打印 client 里面的 name 字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    robj *name;             <span class="comment">/* As set by CLIENT SETNAME. */</span></span><br><span class="line">    ...</span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure><p>不过这个是需要在 client 连接的时候设定的，于是重新改下我们在 <a href="https://selfboot.cn/2023/06/14/bug_redis_deadlock_1/">Redis Issue 分析：流数据读写导致的“死锁”问题(1)</a> 中的测试脚本，重新启动 server，跑一下复现流程，然后用 GDB 重新分析。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subscriber</span>(<span class="params">user_id</span>):</span><br><span class="line">    r = Redis(unix_socket_path=<span class="string">&#x27;/run/redis-server.sock&#x27;</span>)</span><br><span class="line">    r.client_setname(<span class="string">f&#x27;subscriber_<span class="subst">&#123;user_id&#125;</span>&#x27;</span>)   <span class="comment"># 这里设定 client name</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>GDB 打印出来 receiver 的 name 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *receiver-&gt;name</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = &#123;<span class="built_in">type</span> = 0, encoding = 8, lru = 9013978, refcount = 1, ptr = 0x7f8b17899213&#125;</span></span><br></pre></td></tr></table></figure><p>其中 name 是一个 redisObject 对象，根据 type&#x3D;0 和 encoding&#x3D;8，知道这个 name 其实是一个 string，内存存储在 ptr 指针中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以用 <code>p (char *)receiver-&gt;name-&gt;ptr</code> 来打印 client 的具体名字了。这里还要连续打印多次 client name，看看每次取出来的 client 是什么。为了自动打印多次，可以用 GDB 里面的 commands指令，如下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230616_bug_redis_deadlock_2_1.png" alt="GDB continue 观察这里的client"></p><p>其实从队列里取出来的一直是 <code>subscriber_1</code> 和 <code>subscriber_2</code>，他们两个交替被取出来，无穷尽了，所以这里没法跳出循环。</p><h2 id="修复代码"><a href="#修复代码" class="headerlink" title="修复代码"></a>修复代码</h2><p>这里的修复用的是一个比较 trick 的方法，保证这里一次只处理完队列里当前时刻有的 client，新加入的 client 并不处理。具体提交是 <a href="https://github.com/redis/redis/blob/e7129e43e0c7c85921666018b68f5b729218d31e/src/blocked.c">commit e7129e43e0c7c85921666018b68f5b729218d31e</a> ，提交信息描述了这个问题</p><blockquote><p>Author: Binbin <a href="mailto:&#x62;&#x69;&#110;&#108;&#111;&#118;&#x65;&#112;&#108;&#97;&#121;&#x31;&#x33;&#x31;&#52;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;">&#x62;&#x69;&#110;&#108;&#111;&#118;&#x65;&#112;&#108;&#97;&#121;&#x31;&#x33;&#x31;&#52;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;</a><br>Date:   Tue Jun 13 18:27:05 2023 +0800<br>   Fix XREADGROUP BLOCK stuck in endless loop (#12301)  </p><p>   For the XREADGROUP BLOCK &gt; scenario, there is an endless loop.<br>   Due to #11012, it keep going, reprocess command -&gt; blockForKeys -&gt; reprocess command</p><p>   The right fix is to avoid an endless loop in handleClientsBlockedOnKey and handleClientsBlockedOnKeys,<br>   looks like there was some attempt in handleClientsBlockedOnKeys but maybe not sufficiently good,<br>   and it looks like using a similar trick in handleClientsBlockedOnKey is complicated.<br>   i.e. stashing the list on the stack and iterating on it after creating a fresh one for future use,<br>   is problematic since the code keeps accessing the global list.  </p><p>   Co-authored-by: Oran Agra <a href="mailto:&#x6f;&#114;&#x61;&#x6e;&#64;&#x72;&#x65;&#100;&#x69;&#x73;&#x6c;&#97;&#98;&#x73;&#46;&#99;&#111;&#109;">&#x6f;&#114;&#x61;&#x6e;&#64;&#x72;&#x65;&#100;&#x69;&#x73;&#x6c;&#97;&#98;&#x73;&#46;&#99;&#111;&#109;</a>  </p></blockquote><p>提交修改部分比较少，如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230616_bug_redis_deadlock_2_2.png" alt="修复代码对比"></p><h3 id="list-何时添加元素？"><a href="#list-何时添加元素？" class="headerlink" title="list 何时添加元素？"></a>list 何时添加元素？</h3><p>这里还有个问题需要明确，已经取出队列的 client，具体在什么时间又被放到队列中去了呢？因为对 redis 源码不是很熟悉，开始的时候看了半天没找到相应代码。在 Issue 上问了下，<a href="https://github.com/oranagra">oranagra</a> 出来解释说是在 <code>blockForKeys</code> 中（其实提交信息里也有说到这个函数）。</p><p>后来再思考这里的时候，才发现自己完全也能找到。因为这里 list 在循环中肯定不断添加 client，而 redis 里面 list 尾部添加元素的函数很容易找到就是 <code>listAddNodeTail</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adlist.c</span></span><br><span class="line"><span class="function">list *<span class="title">listAddNodeTail</span><span class="params">(list *list, <span class="type">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="built_in">listLinkNodeTail</span>(list, node);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只用在这个函数打断点就行了，执行到这里的时候，就能拿到函数的堆栈，就可以知道调用关系链了，如下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230616_bug_redis_deadlock_2_3.png" alt="重新添加 list 的调用链路"></p><h3 id="跳出循环就可以了？"><a href="#跳出循环就可以了？" class="headerlink" title="跳出循环就可以了？"></a>跳出循环就可以了？</h3><p>还有个问题就是这里的修复方案里，在单次的 <code>handleClientsBlockedOnKey</code> 函数处理中，client 依旧会被追加到队列尾(这里其实没啥变更)。那么修改后的代码，后续为什么不会再取出来这两个 client 呢?</p><p>TODO…(待续)</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>这里官方也补充了一个 <a href="https://www.tcl.tk/">tcl</a> 测试用例脚本，在 tests&#x2F;unit&#x2F;type&#x2F;stream-cgroups.tcl 中添加了如下 case：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test &#123;Blocking XREADGROUP for stream key that has clients blocked on list - avoid endless loop&#125; &#123;</span><br><span class="line">    r DEL mystream</span><br><span class="line">    r XGROUP CREATE mystream mygroup $ MKSTREAM</span><br><span class="line"></span><br><span class="line">    set rd1 [redis_deferring_client]</span><br><span class="line">    set rd2 [redis_deferring_client]</span><br><span class="line">    set rd3 [redis_deferring_client]</span><br><span class="line"></span><br><span class="line">    $rd1 xreadgroup GROUP mygroup myuser COUNT 10 BLOCK 10000 STREAMS mystream &gt;</span><br><span class="line">    $rd2 xreadgroup GROUP mygroup myuser COUNT 10 BLOCK 10000 STREAMS mystream &gt;</span><br><span class="line">    $rd3 xreadgroup GROUP mygroup myuser COUNT 10 BLOCK 10000 STREAMS mystream &gt;</span><br><span class="line"></span><br><span class="line">    wait_for_blocked_clients_count 3</span><br><span class="line"></span><br><span class="line">    r xadd mystream MAXLEN 5000 * field1 value1 field2 value2 field3 value3</span><br><span class="line"></span><br><span class="line">    $rd1 close</span><br><span class="line">    $rd2 close</span><br><span class="line">    $rd3 close</span><br><span class="line"></span><br><span class="line">    assert_equal [r ping] &#123;PONG&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的测试逻辑基本和复现脚本一样，创建 3 个 client 阻塞在 xreadgroup 中，然后用另一个 client 往里面添加了 3 组数据。后面关闭了消费 client，尝试用添加数据的 client 发送 ping 信息，看是否有回复 pong。如果这个 bug 还在的话，发送 ping 也不会有任何回复。</p><p>可以在 <a href="https://github.com/redis/redis/releases/tag/7.2-rc2">redis-7.2-rc2</a> 的目录中运行 <code>./runtest --single unit/type/stream-cgroups</code> 来测试这个新增加 case 的用例组，执行结果如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230616_bug_redis_deadlock_2_4.png" alt="添加的测试用例的有效性"></p><p>在执行完新加用例的前一组用例后，测试用例就卡住了，然后看到 redis 进程的 cpu 占用也是 100%，说明这个测试用例完全能复现这个问题。这里再补充说一点，在 TCL 测试中，使用的 Redis 二进制文件位于 Redis 源代码目录的 src 子目录下。具体来说，它是通过以下 TCL 脚本中的命令找到的：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> ::redis [<span class="keyword">file</span> normalize [<span class="keyword">file</span> <span class="keyword">join</span> [<span class="keyword">pwd</span>] ../src/redis-server]]</span><br></pre></td></tr></table></figure><p>它将当前目录（即 tests 目录）的父目录（即 Redis 源代码的根目录）与 src&#x2F;redis-server 连接起来，形成完整的 Redis 二进制文件的路径。这意味着它使用的是你自己编译的 Redis 版本，而不是系统中可能已经安装的任何版本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;a href=&quot;https://selfboot.cn/2023/06/14/bug_redis_deadlock_1/&quot;&gt;Redis Issue 分析：流数据读写导致的“死锁”问题(1)&lt;/a&gt; 中，我们成功复现了 Issue 中提到的 bug，观察到 Redis Server CPU 飙慢，无法建立新的连接，现有的连接也不能执行任何读写操作。借助强大的 ebpf profile 工具，我们观察到了 CPU 时间主要消耗在哪里，接下来我们一起来看下这个 BUG 的调试过程和修复方法。&lt;/p&gt;
&lt;h2 id=&quot;调试-bug&quot;&gt;&lt;a href=&quot;#调试-bug&quot; class=&quot;headerlink&quot; title=&quot;调试 bug&quot;&gt;&lt;/a&gt;调试 bug&lt;/h2&gt;&lt;p&gt;考虑到 Redis server 进程还在，我们可以用 GDB attach 到进程上，打断点看下具体的执行过程。在火焰图上看到的比较耗时的 &lt;code&gt;handleClientsBlockedOnKey&lt;/code&gt; 函数里面有 while 循环语句。而 CPU 飙满的话一般都是死循环，为了验证是不是有死循环在这个 while 里，可以在 whil 前面的 565 行和里面的 569 行打上断点，然后 &lt;code&gt;continue&lt;/code&gt; 多次进行观察。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    client *receiver = listNodeValue(ln);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    robj *o = lookupKeyReadWithFlags(rl-&amp;gt;db, rl-&amp;gt;key, LOOKUP_NOEFFECTS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Redis" scheme="https://selfboot.cn/tags/Redis/"/>
    
    <category term="Debug" scheme="https://selfboot.cn/tags/Debug/"/>
    
    <category term="Issue" scheme="https://selfboot.cn/tags/Issue/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 提问技巧三：复杂任务拆分</title>
    <link href="https://selfboot.cn/2023/06/15/gpt4_prompt_subtasks/"/>
    <id>https://selfboot.cn/2023/06/15/gpt4_prompt_subtasks/</id>
    <published>2023-06-15T21:57:55.000Z</published>
    <updated>2023-06-29T22:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 GPT4 提问技巧系列的第三篇，全部系列文章：</p><ol><li><a href="https://selfboot.cn/2023/06/10/gpt4_prompt_clear/">GPT4 提问技巧一：写清晰的说明</a>；</li><li><a href="https://selfboot.cn/2023/06/12/gpt4_prompt_reference/">GPT4 提问技巧二：提供参考文本</a>；</li><li><a href="https://selfboot.cn/2023/06/15/gpt4_prompt_subtasks/">GPT4 提问技巧三：复杂任务拆分</a>；</li><li><a href="https://selfboot.cn/2023/06/29/gpt4_prompt_think/">GPT4 提问技巧四：给模型思考时间</a>；</li></ol><p>在我们日常生活中，无论是烹饪一道复杂的菜肴，还是组装一台复杂的机器，我们都会自然而然地将复杂的任务拆分成一系列更简单、更易于管理的子任务。这种策略也同样适用于计算机领域。想象一下，如果没有函数这种工具，我们如何能够有效地编写和管理复杂的代码呢？函数的发明，实际上就是为了将复杂的任务拆分成更小、更具体的子任务，使得代码更易于理解和维护。</p><p>同样，对于人工智能，特别是像 GPT 这样的模型来说，拆分子任务的策略也同样重要。将复杂任务拆分成更简单的子任务可以帮助 GPT 更好地回答问题，原因主要有以下几点：</p><ul><li><span style="color:red;">理解上的优势</span>：GPT 通过处理一系列简单的任务，可以更好地理解和处理复杂的问题。每个子任务都可以被看作是一个独立的问题，GPT 可以专注于解决这个问题，而不是同时处理多个问题。</li><li><span style="color:red;">上下文的限制</span>：GPT 的上下文窗口有限，也就是说，它只能看到最近的一定数量的输入和输出。如果一个任务太复杂，可能会超出这个窗口，导致 GPT 无法看到所有的相关信息。通过将任务拆分，可以确保每个子任务都在 GPT 的上下文窗口内。</li><li><span style="color:red;">减少错误的可能性</span>：如果一个任务非常复杂，GPT 可能会在尝试解决它的过程中犯错误。通过将任务拆分成更简单的子任务，可以减少这种错误的可能性。</li><li><span style="color:red;">更好的反馈</span>：当你将一个复杂任务拆分成子任务时，你可以在每个子任务完成后给予 GPT 反馈，这可以帮助 GPT 更好地理解你的需求，从而提供更好的答案。</li></ul><span id="more"></span><p>总的来说，将复杂任务拆分成更简单的子任务可以帮助 GPT 更有效地理解和处理问题，从而提供更好的答案。接下来我们会提供几个具体的例子，来具体看看如何拆分子任务。</p><h2 id="示例一：客服助手"><a href="#示例一：客服助手" class="headerlink" title="示例一：客服助手"></a>示例一：客服助手</h2><p>现在我们的目标是写一个微信 App 的智能客服，当用户提问关于 App 的问题时，我们的智能客服可以根据预先准备好的帮助文档，找到相关解决办法，并重新组织好语言给出答案。</p><p>因为微信的帮助文档内容太长，没办法作为<strong>引用文本</strong>一次性提供给 GPT4 作为提示词。所以可以考虑拆分下这里的问题，一个不错的拆分方法就是先让 GPT 分类问题，然后根据分类来提供这个分类下的帮助文档作为提示词。 </p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230615_gpt4_prompt_subtasks.png" alt="构造微信客服机器人"></p><p>上面在 <a href="https://platform.openai.com/playground">OpenAI playground</a> 上创建了一个简单示例，通过让 GPT4 先对问题分类，然后再根据不同类型的子问题和引用文本，来生成答案。注意这里示例把整个内容放到 system msg，实际构建客服的时候，第一步只用让 GPT4 分类，然后根据分类信息，来选择文档作为引用文本，重新提问。</p><p>通过加入中间分类步骤，成功完成了一个复杂的查询任务。类似的场景还有许多，比如要总结很长的一段文本（超过 GPT 的上下文 token 限制），可以拆分成以下子任务：</p><ol><li>将文本分段：可以将长文本分成几个段落或部分，可以根据文本的自然结构来完成，例如章节、标题或主题。</li><li>为每个部分生成摘要：让 GPT4 提取每个部分的主要观点或信息，因为已经拆分过，所以没有超过 token 限制。</li><li>组合摘要：用 GPT4 将所有的摘要组合成一个完整的总结。在这个步骤中，需要确保总结的连贯性和一致性。</li></ol><p>当然这个过程中你需要确保每个部分的摘要都准确地反映了该部分的内容，而且所有的摘要在一起需要能够形成一个全面的总结。此外，你还需要处理可能出现的上下文问题，例如确保 GPT 在生成摘要时能够理解每个部分的上下文。</p><h2 id="示例二：辅助编程"><a href="#示例二：辅助编程" class="headerlink" title="示例二：辅助编程"></a>示例二：辅助编程</h2><p>编写复杂程序一直以来是专业人员才能做到的，但现在人人都可以使用 GPT4 来写程序。比如我的目标是写一个程序，能够将我印象笔记导出的笔记批量导入到 notion 中。我可以拆分为下面的子问题（具体子问题的 prompt 可以根据当时的上下文写的更详细一些）：</p><ol><li>我想用 python3 把一个笔记导入到 notion 中去，有没有什么推荐的方法；</li><li>印象笔记导出的是 html 文件，我如何解析里面的笔记正文；</li><li>用 python3 如何并发导入文件到 notion；</li><li>要展示导入的进度条，在 Python3 中如何做呢？</li><li>如何在导入结束的时候，用红色把导入失败的原因打印到屏幕上</li><li>如何测试我的这段代码呢？</li></ol><p>当然这里的子问题可能不是一开始就能规划好的，在和 GPT4 交流的过程中，可以不断根据上一个回答，来调整问题。在开发程序的过程中，遇到一些预期外的问题，也可以再来提问，比如 notion 返回了一个错误是请求频率太高，或者是网络超时，那么你可以继续提问：</p><ol><li>有什么 python3 的库可以控制我请求接口的频率；</li><li>我的实现代码如下(这里省略)，如何用 aiolimiter 来控制请求 notion api 的频次；</li><li>如果请求 notion api失败，我要怎么优雅的重试我的请求；</li><li>有哪些 python3 的重试库，哪些还是活跃的，要怎么在我的代码上添加上重试；</li></ol><p>总之不要给 GPT4 太复杂的任务，毕竟还不是通用 AI，需要你帮忙拆分子问题，验证 AI 的回答，最终拼凑起来一个完整的解决方案。这个例子是真实的，在 GPT4 的帮助下，我比较快速的完成了一个 python 库 <a href="https://github.com/selfboot/html2notion">html2notion</a>，能够将印象笔记导出来的 html 文件批量导入到 notion 笔记中，并尽量保留格式。</p><h2 id="示例三：反转字符串"><a href="#示例三：反转字符串" class="headerlink" title="示例三：反转字符串"></a>示例三：反转字符串</h2><p>有些任务看起来很简单，似乎不用拆分子任务就能完成。比如反转一个英语单词，给你 <code>apple</code>，输出 <code>elppa</code>；给你 <code>lollipop</code>，输出<code>popillol</code>。如果让 gpt-4 直接来翻转单词，可能会得到错误的结果。</p><ul><li>apple-&gt;elppa</li><li>popillol-&gt;pilpollol</li></ul><p>这可能是因为GPT-4作为一个语言模型，是通过大量的文本数据进行训练的。在这些文本数据中，它学习到了单词的拼写、语法、句子结构等信息，但是并没有专门学习如何执行特定的算法或操作，比如反转单词。当你让 GPT-4 反转一个单词时，它可能会尝试根据它在训练数据中看到的模式来做，而不是按照一个明确的算法来执行。这可能导致它在执行这种简单任务时出错。</p><p>这里可以考虑拆分子任务，明确告诉 GPT 具体的反转步骤。一个参考提示词如下：</p><blockquote><p>请按照下面的步骤反转给定的单词。</p><ol><li>将单词拆分为一个个的字母；</li><li>将上面的字母倒序输出；</li><li>将字母拼接起来。</li></ol><p>比如 apple，先拆分为 a,p,p,l,e ，然后反转 e,l,p,p,a，最后拼接起来为 elppa ；给定的单词如下，输出中间过程和结果。</p></blockquote><p>可以看到已经能成功反转单词了，如下结果：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230629_gpt4_prompt_subtasks_reverse.png" alt="反转字符串拆分子任务"></p><p>上面的提示词有时候也不稳定（<strong>如果不让模型输出中间过程，效果会更差</strong>），其实为了准确地执行这个任务，通常需要一个简单的算法，而不是一个复杂的语言模型。在编程中，反转一个字符串是一个基本操作，可以通过简单的代码来实现。我们可以让 GPT 来写一段反转单词的代码，这样不受任何语言模式的影响，可以准确地反转任何给定的单词。</p><h2 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h2><p>当然拆分子问题从来就不是一个简单的事情，其中一个挑战就是要理解 GPT 的能力和限制，在这些限制内有效地拆分问题。你需要通过<strong>实践和试错</strong>来了解 GPT 在处理<strong>不同粒度问题</strong>时的表现，以便找到<strong>最适合的问题粒度</strong>。比如是直接让 GPT4 来写一段代码，能够异步并发请求，并且限制请求频率，自动进行网络超时重试和异常处理。还是把这些拆分为不同的子任务，分别让它写出单独的代码，然后再组织起来。这需要在使用中慢慢摸索，才能找到一个好的平衡点。</p><p>另一个挑战是如何<strong>有效地组织和管理子问题</strong>。在拆分问题后，我们可能会得到大量的子问题和回答。如何有效地组织这些子问题，以便在需要时能够快速找到，是一个需要解决的问题。如果子问题之间没有关联，可能会丢失一些上下文，这会使得根据子问题的回答重新构建复杂问题的解决办法变得困难。因此，在每次提问时，我们<strong>应尽可能带上已经拿到的上下文</strong>，这可以帮助 GPT 更好地理解问题，从而给出更准确的回答。回到前面的例子，你可以带上目前已经有的相关代码，让 GPT4 在此基础上进行优化，增加新的功能点，这样 GPT4 会基于现有的代码直接更改，而不是重新写一段不一样的代码。</p>]]></content>
    
    
    <summary type="html">文章详细介绍了如何使用 GPT4 来拆分复杂任务，包括理解 GPT4 的能力和限制，以及如何在这些限制内有效地拆分问题。文章通过实例展示了如何将复杂任务拆分成更简单的子任务，以帮助 GPT4 更有效地理解和处理问题，从而提供更好的答案。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>神奇 Prompt 让 GPT4 化身数学老师</title>
    <link href="https://selfboot.cn/2023/06/14/gpt4_tutor_math/"/>
    <id>https://selfboot.cn/2023/06/14/gpt4_tutor_math/</id>
    <published>2023-06-14T22:53:09.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://selfboot.cn/2023/05/26/gpt4_tutor_english/">神奇 Prompt 让 GPT4 化身英语老师</a>和<a href="https://selfboot.cn/2023/05/31/gpt4_tutor_physics/">神奇 Prompt 让 GPT4 化身物理老师</a>中，已经看到了 GPT4 进行教学的可能性。数学和其他学科比，更加的深奥难懂，GPT 刚出来的时候，连简单的加减乘除都做不对。现在我们尝试来让 GPT4 教我们大学微积分，当然这里用了插件 Wolfram，主要完成计算和绘图功能。</p><p>第一步依然是把 <a href="https://gist.githubusercontent.com/selfboot/1322b0f58882e7459b4842b997786e63/raw/7d33bc7e02bec43d77b1d06287b5963f3ce166cd/Mr_Ranedeer.md">prompt</a> 复制给 GPT 作为初始问题，然后用 <code>/language 简体中文</code> 指定后续的语言，接着指定想学习大学的微积分，让它循序渐进给我们讲解。最终的微积分学习助手配置如下：</p><ul><li>🎯深度：大学</li><li>🧠学习方式：循序渐进</li><li>🗣️沟通方式：无特别偏好</li><li>🌟语气方式：温和</li><li>🔎推理框架：无特别偏好</li><li>😀表情符号：❌</li><li>🌐语言：简体中文</li></ul><p>下面文章中引用部分是我的提问，其余部分都是 GPT4 的回答。</p><span id="more"></span><h2 id="函数的讲解"><a href="#函数的讲解" class="headerlink" title="函数的讲解"></a>函数的讲解</h2><blockquote><p>开始讲下函数的概念吧，我的数学功底不好，所以尽可能讲的通俗易懂。 另外，要画图的话，尽可能让宽一些，不要太高的图片了。</p></blockquote><p>函数是一种特殊的关系，它描述了两个变量之间的关系。在函数中，我们有一个输入值（通常表示为x），然后有一个输出值（通常表示为y）。函数的关键特性是，对于每一个输入值，都有一个唯一的输出值。</p><p>我们可以将函数视为一个“机器”，你向这个机器输入一个值，它会根据某种规则处理这个值，然后输出一个结果。这个“规则”就是函数的定义。</p><p>例如，我们可以定义一个函数f(x) &#x3D; 2x + 3。这个函数的规则是，将输入值乘以2，然后加上3。所以，如果我们输入4，函数的输出就是 2*4 + 3 &#x3D; 11。</p><p>函数的一个重要应用是在图形中。我们可以将函数的输入和输出值作为坐标点（x，y）在二维平面上绘制出来。这样，我们就可以看到函数的图形，它可以帮助我们更好地理解函数的性质。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230614_gpt4_tutor_math.png" alt="函数的概念"></p><h2 id="极限和连续"><a href="#极限和连续" class="headerlink" title="极限和连续"></a>极限和连续</h2><blockquote><p>那么极限和连续的概念是怎么发展出来的呢？ 有函数感觉已经能解决很多问题了，是谁发明极限和连续的概念，他是为了解决什么问题呢？</p></blockquote><p>极限和连续性的概念是微积分的基础，这两个概念的发展主要是为了解决一些在函数中出现的问题。</p><p>极限的概念最早由牛顿和莱布尼茨在17世纪独立发展出来，他们发明了微积分，但他们的理论基础并不完全严谨。直到19世纪，数学家魏尔斯特拉斯和柯西才给出了极限的严格定义。</p><p>极限的概念主要是为了解决变化率的问题。例如，如果我们想知道一个物体在某一时刻的速度，我们需要知道在这一时刻的位置变化率。但是，位置变化率是在一个时间间隔内的平均速度，而我们想知道的是在某一瞬间的瞬时速度。这就需要用到极限的概念，我们可以让时间间隔无限地接近0，这样就可以得到瞬时速度。</p><p>连续性的概念也是微积分的基础之一。一个函数在某一点连续，意味着在这一点附近，函数的值没有突变，也就是说，函数的图形在这一点是连续的，没有断裂。连续性的概念对于理解函数的性质和解决一些微积分的问题非常重要。</p><p>总的来说，极限和连续性的概念是为了解决在函数中出现的变化率和连续性的问题，这两个概念是微积分的基础。</p><blockquote><p>这两个概念为啥是微积分的基础？</p></blockquote><p>极限和连续性是微积分的基础，因为微积分主要研究的就是变化率和积分，而这两个概念都与极限和连续性密切相关。</p><ul><li>极限：极限是微积分中导数和积分的基础。导数描述了函数在某一点的瞬时变化率，而这个瞬时变化率就是通过极限的概念来定义的。具体来说，导数就是函数在某一点的切线斜率，而这个斜率就是通过极限来计算的。同样，积分也是通过极限来定义的，积分描述了函数在某一区间的累积变化量，而这个累积变化量就是通过极限来计算的。</li><li>连续性：连续性是微积分中函数性质的基础。如果一个函数在某一点连续，那么我们就可以在这一点处计算导数和积分。反之，如果函数在某一点不连续，那么我们就不能在这一点处计算导数和积分。因此，连续性是微积分中导数和积分的前提条件。</li></ul><p>因此，极限和连续性是微积分的基础，<strong>没有这两个概念，我们就无法定义导数和积分，也就无法进行微积分的研究</strong>。</p><blockquote><p>可以给我两个图来解释下极限和连续性吗？</p></blockquote><p>这是两个图形，分别用来解释极限和连续性的概念：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230614_gpt4_tutor_math_2.png" alt="极限和连续性的概念"></p><p>左边的图形表示的是函数f(x) &#x3D; sin(x)&#x2F;x。当x接近0时，这个函数的值接近1，这就是极限的概念。我们说，当x趋向0时，函数f(x)的极限是1。</p><p>右边的图形表示的是一个分段函数。在x&#x3D;2的位置，函数的值突然从4跳到3，这就是函数在x&#x3D;2处不连续。如果函数在某一点的左右极限值不相等，那么我们就说函数在这一点处不连续。</p><blockquote><p>我有一个函数 f(x) &#x3D; sin(x)&#x2F;x^2 ，这个函数是连续的吗？在  x&#x3D;1 的时候，它的极限值是多少？</p></blockquote><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230614_gpt4_tutor_math_3.png" alt="计算过程"></p><p><a href="https://www.wolframalpha.com/input?i=limit+sin(x)/x%5E2+as+x-%3E1">这里</a>是 wolframalpha 的计算过程，可以在这里看到函数的图像。</p><h2 id="导数和积分"><a href="#导数和积分" class="headerlink" title="导数和积分"></a>导数和积分</h2><blockquote><p>好了，我知道什么是极限和连续了，可以继续往下讲了</p></blockquote><p>好的，接下来我们将讨论微积分的两个主要概念：导数和积分。</p><ul><li>导数：导数描述了函数在某一点的瞬时变化率，也就是函数在这一点的切线斜率。导数是通过极限的概念来定义的，因此，理解极限是理解导数的关键。</li><li>积分：积分描述了函数在某一区间的累积变化量，也就是这一区间下函数图像与x轴之间的面积。积分也是通过极限来定义的，因此，理解极限也是理解积分的关键。</li></ul><blockquote><p>可以给我一个具体的例子，讲下怎么计算积分吗？ </p></blockquote><p>当然可以。让我们来计算一个简单的积分例子：求函数 <code>f(x)=x^2</code> 在区间 [0, 2] 上的定积分。</p><p>在微积分中，定积分的计算可以通过求解以下积分公式来完成：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230614_gpt4_tutor_math_4.png" alt="积分公式"></p><p>这个公式表示的是求函数 <code>f(x)=x^2</code> 在区间 [0, 2] 上的积分，也就是求这个区间上函数图像与x轴之间的面积。</p><p>通过计算，我们得到这个定积分的值为 8&#x2F;3。这就是计算定积分的一个基本例子。在实际应用中，积分的计算可能会涉及到更复杂的函数和区间。如果你有任何问题，或者想要深入了解某个部分，随时告诉我。</p><blockquote><p>这里是怎么算出来定积分的值的，一步步给出具体的计算步骤。另外定积分和前面说的积分是一回事吗？</p></blockquote><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230614_gpt4_tutor_math_5.png" alt="定积分不定积分解释"></p><h2 id="深入学习的推荐"><a href="#深入学习的推荐" class="headerlink" title="深入学习的推荐"></a>深入学习的推荐</h2><blockquote><p>基本定理的微积分这里你是从哪里学到的？ 我可以去哪些地方进一步了解这两部分呢，可以给我推荐书或者文章吗？</p></blockquote><p>关于微积分的基本定理，你可以参考以下资源进行深入学习：<br><a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus">基本微积分定理 - 维基百科</a>：这是一个非常全面的资源，包括定理的历史、证明以及应用。</p><p>书籍：</p><ul><li>“Calculus” by Michael Spivak：这本书是微积分的经典教材，详细介绍了微积分的基本定理以及其应用。</li><li>“Calculus: Early Transcendentals” by James Stewart：这本书也是微积分的经典教材，易于理解，适合初学者。</li></ul><p>在线课程：</p><ul><li><a href="https://www.khanacademy.org/">Khan Academy</a>：Khan Academy 提供了一系列的微积分课程，包括基本定理的讲解和应用。</li><li><a href="https://ocw.mit.edu/index.htm">MIT OpenCourseWare</a>：麻省理工学院开放课程网站提供了许多微积分课程，其中一些课程涵盖了微积分的基本定理。</li></ul><h2 id="微积分的用处"><a href="#微积分的用处" class="headerlink" title="微积分的用处"></a>微积分的用处</h2><blockquote><p>积分在生活中的应用其实非常广泛，以下是一些例子：</p></blockquote><ol><li>物理：在物理学中，积分被用来计算物体的运动，例如速度和加速度。例如，如果你知道一个物体的加速度，你可以通过积分来计算出物体的速度。同样，如果你知道物体的速度，你可以通过积分来计算出物体的位置。</li><li>工程：在工程学中，积分被用来计算各种物体的面积和体积，例如，建筑师可能需要计算一个建筑物的表面积或者体积，这就需要用到积分。</li><li>经济学：在经济学中，积分被用来计算总收入和总成本。例如，如果你知道一个公司的每单位产品的收入，你可以通过积分来计算出公司的总收入。</li><li>医学：在医学中，积分被用来计算药物在体内的浓度。例如，如果你知道药物在体内的吸收率，你可以通过积分来计算出药物在体内的总浓度。</li><li>环境科学：在环境科学中，积分被用来计算污染物的总量。例如，如果你知道一个地区每天排放的污染物的量，你可以通过积分来计算出一年内排放的污染物的总量。</li></ol><p>以上只是一些例子，实际上，积分在我们生活的许多领域都有应用。</p><blockquote><p>如你所说，积分被用来计算各种物体的面积和体积，可以给我一个更具体形象的例子吗？最好是有一个示例图，然后给出一步步的步骤。</p></blockquote><p>这是一个计算圆的面积的例子，我们使用积分来完成这个计算。首先，我们考虑一个半径为 r 的圆。然后，我们将这个圆划分为无穷小的切片。每一个切片的角度为 dθ。</p><p>接下来，我们考虑其中一个切片。这个切片的面积是 0.5r^2dθ。然后，我们要计算圆的总面积，就需要将所有这些切片的面积加起来。这个和就是从 0 到 2π 的 0.5r^2dθ 的积分。最后，我们计算这个积分，得到的结果就是 π*r^2，这就是圆的面积。这个例子展示了如何使用积分来计算一个物体的面积。这个方法也可以用来计算其他形状的面积，或者三维物体的体积。</p><blockquote><p><em>这里计算圆的面积中间让他解释了好几遍，都没解释明白。</em><br>我还是不太明白，就计算圆的面积，这里有啥网络资源可以让我再学习下吗？ 最好是有图片和通俗的解释的。</p></blockquote><p>这个网站 “<a href="https://www.mathsisfun.com/calculus/integration-introduction.html">Math Is Fun</a>“ 提供了一个非常直观的解释，它用了一个水槽和水龙头的例子来解释积分的概念。水龙头的流量就像函数，而水槽中的水体积就像积分。如果水龙头的流量是恒定的，那么水槽中的水体积就会线性增加。如果水龙头的流量随着时间而增加，那么水槽中的水体积就会以二次函数的方式增加。这个例子很好地解释了积分是如何累加小片段来得到整体的。</p><p>另外，这个网站也提供了一些积分的规则和例子，你可以通过这些例子来练习和加深理解。这个网站还解释了定积分和不定积分的区别，以及如何计算定积分。</p><p>我建议你花一些时间去阅读和理解这个网站上的内容，这将有助于你更好地理解积分的概念。</p><blockquote><p>总体来说 GPT4 比大部分老师都讲的好，不过也还有不少可以提高的地方。比如有些概念可能需要一些图片，目前也只能用 Wolfram 插件画部分图，GPT 还不能根据语义生成一些配图。另外还会理解错部分问题，需要重新补充细节再去问。</p><p>完整的对话可以在<a href="https://chat.openai.com/share/accdc269-faa5-4325-a4bf-2cd0b230b358">这里</a>看到。</p></blockquote>]]></content>
    
    
    <summary type="html">本文章展示如何用一个 prompt 让 GPT 化身为大学微积分老师，讲解了函数，极限和连续性，微分和积分等概念。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>Redis Issue 分析：流数据读写导致的“死锁”问题(1)</title>
    <link href="https://selfboot.cn/2023/06/14/bug_redis_deadlock_1/"/>
    <id>https://selfboot.cn/2023/06/14/bug_redis_deadlock_1/</id>
    <published>2023-06-14T22:02:01.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 项目中，一个名为 “[BUG] Deadlock with streams on redis 7.2” 的 <a href="https://github.com/redis/redis/issues/12290">issue 12290</a> 吸引了我的注意。这个 bug 中，redis 服务器在处理特定的客户端请求时陷入了死循环，这个现象在 redis 这样的高性能、高可靠性的数据库系统中是极为罕见的。</p><p>这个 Issue 不仅仅是一个普通的 bug 报告，它实际上是一次深入探索 Redis 内部机制的学习过程。从问题的发现，到复现步骤的详细描述，再到问题的深入分析，最后到解决方案的提出，每一步都充满了挑战和发现。无论你是 Redis 的使用者，还是对数据库内部机制感兴趣的开发者，我相信你都能从这个 issue 中获得有价值的启示。</p><p>在开始研究这个 bug 之前，我们先简单了解下这里的背景知识：redis 的<a href="https://redis.io/docs/data-types/streams-tutorial/">流数据类型</a>。</p><span id="more"></span><h2 id="Redis-streams-介绍"><a href="#Redis-streams-介绍" class="headerlink" title="Redis streams 介绍"></a>Redis streams 介绍</h2><p>为了支持更强大和灵活的流处理能力，Redis 在 5.0 支持了<a href="https://redis.io/docs/data-types/streams-tutorial/">流数据类型</a>， 包含 XADD, XREAD 和 XREADGROUP。</p><ul><li><code>XADD</code> 命令允许用户向 Redis 流中添加新的消息。每个消息都有一个唯一的 ID 和一组字段-值对。这种数据结构非常适合表示时间序列数据，例如日志、传感器读数等。通过 XADD，用户可以将这些数据存储在 Redis 中，然后使用其他命令进行查询和处理。</li><li><code>XREAD</code> 命令用于从一个或多个流中读取数据。你可以指定从每个流的哪个位置开始读取，以及最多读取多少条消息。这个命令适合于简单的流处理场景，例如，你只需要从流中读取数据，而不需要跟踪读取的进度。</li><li><code>XREADGROUP</code> 命令是 Redis 消费者组功能的一部分。消费者组允许多个消费者共享对同一个流的访问，同时还能跟踪每个消费者的进度。这种功能对于构建可扩展的流处理系统非常有用。例如，你可以有多个消费者同时读取同一个流，每个消费者处理流中的一部分消息。通过 XREADGROUP，每个消费者都可以记住它已经读取到哪里，从而在下次读取时从正确的位置开始。</li></ul><p>我们可以用 XREADGROUP 命令从一个特定的流中读取数据，如果这个流当前没有新的数据，那么发出 XREADGROUP 命令的客户端就会进入一种<code>阻塞等待</code>状态，直到流中有新的数据为止。同样的，我们可以用 XADD 命令向流中添加新的数据，当新的数据被添加到流中后，所有在这个流上”等待”的客户端就会<code>被唤醒</code>，然后开始处理新的数据。</p><p>注意这里的”等待”并不是我们通常理解的那种让整个服务器停下来的阻塞。实际上，只有发出 XREADGROUP 命令的那个客户端会进入”等待”状态，而 Redis 服务器还可以继续处理其他客户端的请求。这就意味着，即使有一些客户端在等待新的数据，Redis 服务器也能保持高效的运行。</p><p>更多内容可以参考 Redis 官方文档：<a href="https://redis.io/docs/data-types/streams-tutorial/">Redis Streams tutorial</a>。</p><h2 id="Bug-复现"><a href="#Bug-复现" class="headerlink" title="Bug 复现"></a>Bug 复现</h2><p>好了，我们可以来深入研究这个 bug 了，首先我们来看下复现脚本。一共两个脚本，一个消费订阅者，一个发布者，其中：</p><ul><li>subscriber.py：这个脚本创建了一组订阅者，每个订阅者都尝试创建一个名为 ‘test’ 的任务队列，并持续从该队列中读取新的流。如果没有新的流，订阅者会暂停 5 秒钟，然后继续尝试读取。如果读取到新的流，订阅者会打印出新的流。这个脚本会持续运行，直到所有的订阅者进程都结束。</li><li>feeder.py：这个脚本在同一个任务队列中添加新的任务。它创建了一组发布者，每个发布者都会在任务队列中添加新的任务，并在每次添加任务后暂停 0.1 秒钟。这个脚本会持续运行，直到所有的发布者进程都结束。</li></ul><p><code>subscriber.py</code> 代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">nb_subscribers = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subscriber</span>(<span class="params">user_id</span>):</span><br><span class="line">    r = Redis(unix_socket_path=<span class="string">&#x27;cache.sock&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r.xgroup_create(name=<span class="string">&#x27;tasks_queue&#x27;</span>, groupname=<span class="string">&#x27;test&#x27;</span>, mkstream=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;group already exists&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        new_stream = r.xreadgroup(</span><br><span class="line">            groupname=<span class="string">&#x27;test&#x27;</span>, consumername=<span class="string">f&#x27;testuser-<span class="subst">&#123;user_id&#125;</span>&#x27;</span>, streams=&#123;<span class="string">&#x27;tasks_queue&#x27;</span>: <span class="string">&#x27;&gt;&#x27;</span>&#125;,</span><br><span class="line">            block=<span class="number">2000</span>, count=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> new_stream:</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">print</span>(new_stream)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">processes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nb_subscribers):</span><br><span class="line">    p = Process(target=subscriber, args=(i,))</span><br><span class="line">    p.start()</span><br><span class="line">    processes.append(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> processes:</span><br><span class="line">    new_p = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        <span class="keyword">if</span> p.is_alive():</span><br><span class="line">            new_p.append(p)</span><br><span class="line">    processes = new_p</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;all processes dead&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>feeder.py</code> 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">nb_feeders = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">feeder</span>():</span><br><span class="line">    r = Redis(unix_socket_path=<span class="string">&#x27;cache.sock&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        fields = &#123;<span class="string">&#x27;task_uuid&#x27;</span>: <span class="built_in">str</span>(uuid.uuid4())&#125;</span><br><span class="line">        r.xadd(name=<span class="string">&#x27;tasks_queue&#x27;</span>, fields=fields, <span class="built_in">id</span>=<span class="string">&#x27;*&#x27;</span>, maxlen=<span class="number">5000</span>)</span><br><span class="line">        time.sleep(<span class="number">.1</span>)</span><br><span class="line"></span><br><span class="line">processes = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nb_feeders):</span><br><span class="line">    p = Process(target=feeder)</span><br><span class="line">    p.start()</span><br><span class="line">    processes.append(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> processes:</span><br><span class="line">    new_p = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        <span class="keyword">if</span> p.is_alive():</span><br><span class="line">            new_p.append(p)</span><br><span class="line">    processes = new_p</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;all processes dead&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意这里 <code>unix_socket_path</code> 要改为自己 server 配置的 socket path。我们先启动发布者 feeder.py 往流里面写数据，再用 subscriber.py 来消费流。预期的正常表现(Redis server v&#x3D;7.0.8上就是这个表现)是 subscriber 会持续取出 feeder 往流里面写入的数据，同时 redis 还能响应其他 client 的请求，server 的 CPU 占用也是在一个合理的水平上。</p><p>但是在 7.2.0 版本(源码是 7.2.0-rc2，编译好的 server 版本是 v&#x3D;7.1.241)上，这里就不太正常了。我们直接从 <a href="https://github.com/redis/redis/releases/tag/7.2-rc2">Github Release 7.2-rc2</a> 下载 Reids 7.2 的源码，然后编译二进制。这里编译指令带上这两个 Flag <code>make REDIS_CFLAGS=&quot;-Og -fno-omit-frame-pointer&quot;&quot;</code>，方便后续分析工具能够拿到堆栈信息。复现步骤很简单，启动 Redis server，接着运行 feeder.py 和 subscriber.py 这两个脚本。我们会看到订阅者在处理部分流之后会阻塞住，不再有输出。同时 Redis 进程的 CPU 直接飙到了100%，新的 redis client 也连不上去服务器了，如下图。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230613_bug_redis_deadlock_cpu_busy.png" alt="cpu 跑慢，同时新的 client 也连接失败"></p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230613_bug_redis_deadlock_cpu_stuck.png" alt="subscriber 一直被阻塞"></p><p>杀了两个脚本后，问题依然存在，除非重启 server 才行。</p><h2 id="ebpf-分析"><a href="#ebpf-分析" class="headerlink" title="ebpf 分析"></a>ebpf 分析</h2><p>我们先不去看 Issue 上对于问题原因的分析，直接用一般方法来分析这里 CPU 占用高的原因。分析 CPU 首选 profile 采样，然后转成火焰图来看。这里强烈推荐 brendangregg 的博客 <a href="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html">CPU Flame Graphs</a>，介绍了针对不同语言的服务，如果用工具来分析 CPU 占用。对于 Redis 来说，官方也给出了文档，我们这里参考官方的 <a href="https://redis.io/docs/management/optimization/cpu-profiling/">Redis CPU profiling</a>，用 ebpf 生成 CPU 火焰图。</p><p>如何安装 bcc-tools 可以看官方文档，这里不展开了，然后我们就可以用 profile 工具来做 cpu 采样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">profile -F 999 -f --pid $(pgrep redis-server)  60 &gt; redis.folded.stacks</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">../FlameGraph/flamegraph.pl redis.folded.stacks &gt; redis.svg</span></span><br></pre></td></tr></table></figure><p>profile 是 BCC（BPF Compiler Collection）工具集中的一个工具，用于采集 CPU 的堆栈跟踪信息。这个命令的参数含义如下：</p><ul><li>-F 999，设置采样频率为 999 Hz，即每秒采样 999 次，采样频率选择奇数 999 是为了避免与其他活动产生同步，从而可能导致误导性的结果。如果采样频率与系统中的某些周期性活动（如定时器中断、上下文切换等，一般都是偶数周期，比如 100Hz）同步，那么采样结果可能会偏向于这些活动，从而导致分析结果的偏差。</li><li>-f 折叠堆栈跟踪信息，使其更适合生成 Flame Graphs。</li><li>–pid $(pgrep redis-server)，指定要采集的进程 ID，这里使用 pgrep redis-server 来获取 redis-server 进程的 PID。</li><li>60，采集的持续时间，单位为秒，redis 官方文档给的 profile 命令可能不适用某些版本。</li></ul><p>接着使用了 <a href="https://github.com/brendangregg/FlameGraph/blob/master/flamegraph.pl">flamegraph.pl</a> 脚本，它是 <a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a> 工具集中的一个脚本，用于将堆栈跟踪信息转换为 SVG 格式的 Flame Graphs。最终生成的 CPU 火焰图如下，这里手动过滤了极少部分 unknow 的调用堆栈（不然图片看起来太长了，有点影响阅读）。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230613_bug_redis_deadlock_cpu.svg" alt="CPU 火焰图"></p><p>通过火焰图，我们找到了 CPU 跑满的执行堆栈，下一篇文章，我们继续分析为啥一直在执行这里的代码了。</p>]]></content>
    
    
    <summary type="html">文章首先介绍 Redis 的流数据类型，然后详细介绍如何复现 [BUG] Deadlock with streams on redis 7.2 这个 bug，以及如何使用 ebpf 工具进行 CPU 性能分析。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Redis" scheme="https://selfboot.cn/tags/Redis/"/>
    
    <category term="Debug" scheme="https://selfboot.cn/tags/Debug/"/>
    
    <category term="Issue" scheme="https://selfboot.cn/tags/Issue/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 解 Leetcode 题目：识破 GPT4 的&quot;幻觉&quot;</title>
    <link href="https://selfboot.cn/2023/06/13/gpt4_leetcode_2352/"/>
    <id>https://selfboot.cn/2023/06/13/gpt4_leetcode_2352/</id>
    <published>2023-06-13T22:22:45.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>当我们让 GPT-4 帮助我们解决编程问题时，它可能会生成一段看起来完美的代码，但实际上，这段代码可能并不能解决我们的问题，或者它的解决方案可能并不是最优的。这是因为GPT-4并不理解代码的含义，它只是模仿它在训练数据中看到的代码模式。这种现象被成为<code>幻觉</code>，用 GPT-4 久了的话，基本都会体会到。 </p><p>识破这种幻觉的关键在于理解GPT-4的工作原理，以及它的局限性。我们需要意识到，GPT-4并不理解我们的问题，也不理解它生成的答案。它只是一个非常复杂的模式匹配器，它的目标是生成看起来合理的文本，而不是解决我们的问题。当我们使用GPT-4时，我们需要<code>批判性地思考它的回答，验证它的答案，甚至需要寻求其他专家或资源的帮助</code>。只有这样，我们才能充分利用GPT-4的能力，同时避免被它的表面表现所迷惑。</p><p>在让 GPT 解决 Leetcode 题目 <a href="https://leetcode.com/problems/equal-row-and-column-pairs/">2352. Equal Row and Column Pairs</a> 的过程中，又一次见识到了 GPT-4 的幻觉。刚读完题目，很快就给出了一个不错的实现，接着让 GPT-4 优化代码实现的时候，它就开始坑蒙拐骗了，还好我及时识破幻觉，通过验证，证实这里确实有问题。和 ChatGPT 完整的对话见<a href="https://chat.openai.com/share/96b4c421-9c15-4445-87a4-766f567dcddc">这里</a></p><span id="more"></span><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230613_gpt4_leetcode_2352.png" alt="GPT4 对自己出错的解释"></p><h2 id="题目以及实现代码"><a href="#题目以及实现代码" class="headerlink" title="题目以及实现代码"></a>题目以及实现代码</h2><p>题目很简单，给定一个 N*N 的整数矩阵 grid，返回所有满足条件的对(ri, cj)的数量，其中行ri和列cj是相等的。如果他们包含相同的元素并且顺序也相同（即，是相等的数组），则认为行和列的配对是相等的。</p><p>约束条件：</p><ul><li>n &#x3D;&#x3D; grid.length &#x3D;&#x3D; grid[i].length</li><li>1 &lt;&#x3D; n &lt;&#x3D; 200</li><li>1 &lt;&#x3D; grid[i][j] &lt;&#x3D; 105</li></ul><p>GPT-4 很快就给出了一个直观的解决方法，首先将grid的每一行和每一列转换为元组，并将它们存储在字典中，字典的键是它们各自的索引。然后，通过遍历行和列并进行比较，计算行等于列的次数。代码实现也很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalPairs</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        rows = &#123;i: <span class="built_in">tuple</span>(grid[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)&#125;</span><br><span class="line">        cols = &#123;j: <span class="built_in">tuple</span>(grid[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(row == cols[j] <span class="keyword">for</span> i, row <span class="keyword">in</span> rows.items() <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br></pre></td></tr></table></figure><p>这个方法的时间复杂度和空间复杂度都是O(n^2)。</p><ul><li>时间复杂度：我们需要遍历整个矩阵两次，一次是为了创建行和列的元组，另一次是为了比较行和列的元组。每次遍历都需要O(n^2)的时间，所以总的时间复杂度是O(n^2)。</li><li>空间复杂度：我们需要存储所有行和列的元组，这需要O(n^2)的空间。因此，空间复杂度也是O(n^2)。</li></ul><p>这里 GPT-4 认为时间复杂度已经是最优的，没法继续优化，但是空间复杂度还可以继续优化，可以使用哈希表来存储每一行和每一列的哈希值，然后比较这些哈希值来确定行和列是否相等。优化后，空间复杂度降低到了O(n)，因为我们只需要存储n个哈希值，而不是n个元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalPairs</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        rows = &#123;i: <span class="built_in">hash</span>(<span class="built_in">tuple</span>(grid[i])) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)&#125;</span><br><span class="line">        cols = &#123;j: <span class="built_in">hash</span>(<span class="built_in">tuple</span>(grid[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(row == cols[j] <span class="keyword">for</span> i, row <span class="keyword">in</span> rows.items() <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br></pre></td></tr></table></figure><h2 id="优化执行速度"><a href="#优化执行速度" class="headerlink" title="优化执行速度"></a>优化执行速度</h2><p>接着问了 GPT-4 一个问题：</p><blockquote><p>有没有一些技巧，可以再某些数据类型下降低平均执行时间，虽然时间复杂度没变化。</p></blockquote><p>然后 GPT-4 给了一个看起来很合理的优化，这里使用一种称为”<code>早期退出(提前退出)</code>“的技巧来<strong>在某些情况下降低平均执行时间</strong>。这种技巧的基本思想是，如果我们在比较行和列的过程中发现它们不可能相等，那么我们就可以立即停止比较，而不需要检查所有的元素。</p><p>具体来说，在计算行和列的哈希值时，同时计算它们的元素总和。然后，在比较行和列的哈希值之前，先比较它们的元素总和。如果元素总和不相等，那么我们就可以确定这一行和这一列不可能相等，因此可以立即停止比较 hash 值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalPairs</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        rows = &#123;i: (<span class="built_in">hash</span>(<span class="built_in">tuple</span>(grid[i])), <span class="built_in">sum</span>(grid[i])) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)&#125;</span><br><span class="line">        cols = &#123;j: (<span class="built_in">hash</span>(<span class="built_in">tuple</span>(grid[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))), <span class="built_in">sum</span>(grid[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(row_hash == cols[j][<span class="number">0</span>] <span class="keyword">and</span> row_sum == cols[j][<span class="number">1</span>] <span class="keyword">for</span> i, (row_hash, row_sum) <span class="keyword">in</span> rows.items() <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br></pre></td></tr></table></figure><p>这种方法并不会改变算法的最坏情况时间复杂度，它仍然是O(n^2)。但是，在某些情况下，它可以显著降低算法的平均执行时间，特别是当矩阵中的行和列大部分都不相等时。</p><p>GPT-4 认为这个优化的关键在于：<strong>哈希值的比较是一个相对耗时的操作，特别是当行和列的长度很长时</strong>。因此，即使我们只能在一部分情况下避免进行哈希值的比较，我们也可能获得显著的性能提升。</p><h2 id="识破-GPT-4-幻觉"><a href="#识破-GPT-4-幻觉" class="headerlink" title="识破 GPT-4 幻觉"></a>识破 GPT-4 幻觉</h2><p>上面优化的关键前提是对的吗？为了让 GPT-4 自己确认一遍，我重新提问：</p><blockquote><p>你提到了“哈希值的比较是一个相对耗时的操作，特别是当行和列的长度很长时”，这里我不太理解，可以详细解释下吗？</p></blockquote><p>结果它就认识到自己的错误了，直接说“<strong>在Python中，哈希值本身是一个整数，比较哈希值的操作实际上是非常快的</strong>”。它前面其实有点混淆比较 hash 和计算 hash 的时间成本了，不过到目前为止，他依然认为自己的优化方案有效，因为<strong>能够通过比较和（这是一个更快的操作）来避免一些哈希值的比较</strong>。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230613_gpt4_leetcode_2352_2.png" alt="GPT-4 认识到错误，然而坚持优化方案有效"></p><p>我们当然能看出来这是不对的，原本的计算方案只用计算 hash 并比较hash 整数。现在优化方法多计算了和，比较的时候最好情况也得比较和，差的情况还需要比较 hash。计算和比较操作都多了，性能不会有提升。直接把我们的看法扔给 GPT-4，然后 GPT-4 终于意识到自己的错误，承认了在这个问题中，<strong>最有效的方法仍然是直接计算并比较哈希值</strong>。这是因为哈希值是一个很好的方式来快速比较两个序列是否相等，而且在Python中，计算哈希值的操作是非常快的。</p><h2 id="GPT-4-帮忙验证"><a href="#GPT-4-帮忙验证" class="headerlink" title="GPT-4 帮忙验证"></a>GPT-4 帮忙验证</h2><p>为了进一步确认下在 Python 中，比较和(一般数字)和比较 hash 整数(比较大)的性能到底有没有差异，我们可以做一个性能测评。当然是直接让 GPT-4 来写测评代码了，不过这里也是反复跟 GPT-4 沟通了几轮，才写了符合预期的代码。</p><p>第一次问“我要怎么才能验证一下，<strong>比较和和比较 hash</strong> 的性能差不多。”，然后它给了一段代码，创建一个包含100000个随机整数的列表，然后分别测量计算这个列表的和和哈希值的时间。明明要他计算比较操作的耗时，结果去计算求 sum 和 hash 的耗时。</p><p>没办法，换一个更易懂的问法，“我想要的是，测试下一般整数的比较，和 hash 整数的比较，看下速度有没有差异。”。GPT-4 还挺自信，直接告诉我 Python 中，这两种操作的速度应该是相同的，因为在底层，它们都是进行整数比较（这么自信，为啥开始还认为比较和更快。）。不过还是给出了一份代码，<strong>创建两个大的整数和它们的哈希值，然后分别测量比较这两个整数和比较这两个哈希值的时间</strong>。我不得不说，这个性能测试太不专业了，只执行一次就想来评测速度。</p><p>只能再次提示它，让它给一个更专业的测试方案，至少也得测试很多轮，然后看平均时间。这次 GPT-4 终于 Get 到了要点，考虑了<code>统计显著性</code>。知道在代码中多次运行测试，然后取平均值来得到更准确的结果。</p><p>不过我发现又被它带坑里了，上面测试中，num 是整数，hash(num) 在 python 中返回的是整数本身，所以这里的比较没有任何意义。于是只好让它改下上面的测试，生成 2 个 list，然后计算他们的sum, hash，然后测试比较和与比较hash哪个更耗时。最后给了一个还算可以的测评代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="keyword">import</span> statistics</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个大的列表</span></span><br><span class="line">list1 = [random.randint(<span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>)]</span><br><span class="line">list2 = [random.randint(<span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预先计算和和哈希值</span></span><br><span class="line">sum1 = <span class="built_in">sum</span>(list1)</span><br><span class="line">sum2 = <span class="built_in">sum</span>(list2)</span><br><span class="line">hash1 = <span class="built_in">hash</span>(<span class="built_in">tuple</span>(list1))</span><br><span class="line">hash2 = <span class="built_in">hash</span>(<span class="built_in">tuple</span>(list2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义比较和的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_sums</span>():</span><br><span class="line">    <span class="keyword">return</span> sum1 == sum2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义比较哈希值的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_hashes</span>():</span><br><span class="line">    <span class="keyword">return</span> hash1 == hash2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用timeit模块多次运行测试，并取平均值</span></span><br><span class="line">num_tests = <span class="number">1000000</span></span><br><span class="line">num_repeats = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">sum_times = timeit.repeat(compare_sums, number=num_tests, repeat=num_repeats)</span><br><span class="line">hash_times = timeit.repeat(compare_hashes, number=num_tests, repeat=num_repeats)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Sum comparison: min=<span class="subst">&#123;<span class="built_in">min</span>(sum_times)&#125;</span>, max=<span class="subst">&#123;<span class="built_in">max</span>(sum_times)&#125;</span>, mean=<span class="subst">&#123;statistics.mean(sum_times)&#125;</span>, stdev=<span class="subst">&#123;statistics.stdev(sum_times)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hash comparison: min=<span class="subst">&#123;<span class="built_in">min</span>(hash_times)&#125;</span>, max=<span class="subst">&#123;<span class="built_in">max</span>(hash_times)&#125;</span>, mean=<span class="subst">&#123;statistics.mean(hash_times)&#125;</span>, stdev=<span class="subst">&#123;statistics.stdev(hash_times)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里运行结果来看，比较操作的最小，最长，以及平均耗时基本都一样。标准偏差，sum 比较的是0.00016289003975172148，而哈希的比较的标准偏差是9.324125240116931e-05。虽然有差异，但是这两个标准偏差都非常小，这意味着在大多数情况下，这两种操作的执行时间都非常稳定。</p><h2 id="GPT-4-解释自己的幻觉"><a href="#GPT-4-解释自己的幻觉" class="headerlink" title="GPT-4 解释自己的幻觉"></a>GPT-4 解释自己的幻觉</h2><p>整个实现没什么疑问了，不过为啥 GPT-4 开始会给出 “计算和的操作相比于哈希值的比较，计算成本更低。” 这种错误结论呢，它是这样回答的。</p><p><em>这是因为我没有充分理解问题的上下文和需求。我错误地假设了计算和的操作会比计算哈希值更快，但这并不正确。在Python中，计算哈希值的操作通常非常快，而且哈希值提供了一种高效的方式来比较两个序列是否可能相等。</em></p><p><em>我意识到这一点是不对的，是因为我重新审视了问题的需求和上下文，以及哈希值在Python中的实现和用途。我意识到哈希值提供了一种更高效的比较方式，而计算和的操作并不能提供任何性能优化。</em></p><p>那么我们后续使用 GPT-4 的过程中，如何验证它的回答是不是符合事实呢，GPT-4 同样给出了自己的看法：</p><ol><li><span style="color:red;">实践验证</span>：对于编程或技术相关的问题，你可以尝试运行我提供的代码或按照我提供的步骤操作，看看结果是否符合预期。</li><li><span style="color:red;">查阅文档或其他资源</span>：对于我提供的信息，你可以查阅相关的官方文档、教程或其他可靠的资源来进行验证。</li><li><span style="color:red;">询问其他专家或社区</span>：你也可以将我的回答与其他专家或社区的意见进行对比，看看他们是否有相同或不同的观点。</li><li><span style="color:red;">提问和反馈</span>：如果你对我的回答有疑问，或者发现我的回答有误，你可以随时向我提问或提供反馈。我会尽力提供更准确和有用的信息。</li></ol><p>随着人工智能的不断发展和进步，我们期待这种”幻觉”现象会逐渐减少。然而，无论AI的能力如何增强，我们都必须保持清醒的头脑，不盲目迷信AI。无论何时，我们都需要批判性地思考，验证AI的答案。只有这样，我们才能充分利用AI的能力，同时避免被它的幻觉所迷惑。</p>]]></content>
    
    
    <summary type="html">探索GPT-4在解决LeetCode编程问题中的表现，揭示其生成代码过程中的&quot;幻觉&quot;，并学习如何识破这些幻觉，批判性地思考和验证GPT-4的答案，以充分利用其能力，同时避免被其表面表现所迷惑。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Leetcode" scheme="https://selfboot.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 提问技巧二：提供参考文本</title>
    <link href="https://selfboot.cn/2023/06/12/gpt4_prompt_reference/"/>
    <id>https://selfboot.cn/2023/06/12/gpt4_prompt_reference/</id>
    <published>2023-06-12T22:02:01.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 GPT4 提问技巧系列的第二篇，全部系列文章：</p><ol><li><a href="https://selfboot.cn/2023/06/10/gpt4_prompt_clear/">GPT4 提问技巧一：写清晰的说明</a>；</li><li><a href="https://selfboot.cn/2023/06/12/gpt4_prompt_reference/">GPT4 提问技巧二：提供参考文本</a>；</li><li><a href="https://selfboot.cn/2023/06/15/gpt4_prompt_subtasks/">GPT4 提问技巧三：复杂任务拆分</a>；</li><li><a href="https://selfboot.cn/2023/06/29/gpt4_prompt_think/">GPT4 提问技巧四：给模型思考时间</a>；</li></ol><p>OpenAI 可以理解和生成人类语言，帮助我们解答问题，写文章，甚至编程。然而，即使是 GPT-4，也有其局限性，其中之一就是<strong>上下文长度的限制</strong>。GPT-4 的上下文长度限制是由其内部架构决定的，简单来说，GPT-4 在处理输入时，会将输入的文本转化为一系列的“令牌”（tokens）。然而，GPT-4 只能处理一定数量的令牌，这就是所谓的“上下文长度”。超过这个长度，GPT-4 就无法全面理解输入的内容，这可能会影响其生成的输出的质量。</p><p>目前 OpenAI 的 GPT4 有两个模型，最多分别支持 8K 长度和 32K 长度的Token。其中 32K 长度 Token 之对少量人开放，大部分用的都是 4K 长度，因为 GPU 算力不够。好在随着 AI 的发展，应该会支持越来越长的 Token。OpenAI 也把支持更长的 token 作为 2023 年的主要目标了，参考 <a href="https://website-nm4keew22-humanloopml.vercel.app/blog/openai-plans">OpenAI’s plans according to Sam Altman</a>。</p><blockquote><p>Longer context windows — Context windows as high as 1 million tokens are plausible in the near future.</p></blockquote><span id="more"></span><h1 id="引用文本的好处"><a href="#引用文本的好处" class="headerlink" title="引用文本的好处"></a>引用文本的好处</h1><p>为了更好使用 GPT4 这些有 token 限制的模型，我们可以<strong>提供引用文本（reference text）</strong>。这是因为引用文本可以帮助模型更好地理解你的问题，并提供更准确的答案。这里有几个原因：</p><ol><li><span style="color:red;">明确性</span>：引用文本可以帮助明确你的问题，例如，如果你在问一个关于特定法律条款的问题，提供该法律条款的文本可以帮助模型更准确地理解你的问题。</li><li><span style="color:red;">上下文</span>：即使模型的上下文长度限制增加，它仍然需要理解你的问题的上下文，引用文本可以提供这种上下文。</li><li><span style="color:red;">准确性</span>：引用文本可以帮助模型提供更准确的答案，模型可能会根据引用文本中的信息来生成答案，而不是仅仅依赖于它的训练数据。</li><li><span style="color:red;">效率</span>：即使模型可以处理更长的上下文，提供引用文本仍然可以提高效率，这是因为模型不需要处理不相关的信息，而可以直接关注到你的问题和相关的上下文。</li></ol><p>所以，即使 OpenAI 的上下文长度限制增加，提供引用文本仍然是一个有用的策略。其实目前像 <a href="https://www.anthropic.com/index/introducing-claude">Claude</a> 的模型，已经最大支持 100K 长度，大概是 7.6 万个英语单词，可以一次输入整本书籍让它分析了。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230612_gpt4_prompt_reference_100K.png" alt="Claude 的 100K 长度支持"></p><h1 id="短文本直接引用"><a href="#短文本直接引用" class="headerlink" title="短文本直接引用"></a>短文本直接引用</h1><p>对于文本比较短的引用，可以直接贴到提问里面即可，比如：</p><ul><li>如果你有一段关于气候变化的文章，并希望模型使用这篇文章的信息来回答问题，你可以这样提问：“根据以下关于气候变化的文章，全球变暖的主要原因是什么？”然后附上文章的内容。</li><li>如果你有一份报告，并希望模型使用报告中的数据来回答问题，你可以这样提问：“根据以下的年度销售报告，我们的最畅销产品是什么？”然后附上报告的内容。</li><li>如果你有一段法律条款，并希望模型使用这段条款来解释某个概念，你可以这样提问：“根据以下的法律条款，什么是知识产权？”然后附上法律条款的内容。</li></ul><p>目前使用 GPT4 的插件，也可以直接将网页链接里面的内容提供给 GPT 来作为引用文本。比如我可以直接让它总结我们第一篇<a href="https://selfboot.cn/2023/06/10/gpt4_prompt_clear/">GPT4 提问技巧一：写清晰的说明</a>的内容，如下</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230612_gpt4_prompt_reference_1.png" alt="GPT4 总结网页内容"></p><h1 id="长文本引用相关部分"><a href="#长文本引用相关部分" class="headerlink" title="长文本引用相关部分"></a>长文本引用相关部分</h1><p>对于文本较长的引用，我们需要采取不同的策略。比如想让模型参考一本书或一篇长篇文章，可能需要<strong>选择最相关的部分，或者将关键信息提炼出来作为引用文本</strong>。如何从给定长文本找到和提问内容最相关的部分，最直观的方法就是关键词搜索。它通过在文本中查找与查询关键词完全匹配的词或短语来工作。这种方法的优点是简单易用，但缺点是它<code>无法理解语义相似性</code>。例如，如果你搜索”猫”，它不会返回包含”某种猫粮”或”宠物用品”的文档，除非这些确切的词在文档中出现。</p><h2 id="Embedding-based-search"><a href="#Embedding-based-search" class="headerlink" title="Embedding-based search"></a>Embedding-based search</h2><p>目前 OpenAI 推荐的是另一种方法，叫做<code>语义搜索(Embedding-based Search)</code>。在这种方法中，查询和文档都被转换为高维空间中的向量（也称为 Embedding，本质是一串数字）。这些 embedding 捕获了文本的语义信息，使得语义上相似但字面上不同的词能够被匹配。例如，”猫”和某种”宠物用品”可能会有相似的 embedding，因此即使文档没有明确提到”猫”，也可能被返回为搜索结果。</p><p>在进行语义搜索时，我们的目标是找到与我们的搜索查询在语义上最接近的文本。为了做到这一点，我们需要先将我们的文本和查询转换成一种可以比较的形式，这就是所谓的”嵌入(Embedding)”。</p><ol><li>预计算阶段：首先，我们需要处理我们的文本语料库。这可能是一本书、一组文章，或者任何其他形式的文本。我们将这个大的文本分割成更小的块，每个块的长度都在我们的模型的处理能力范围内。然后，使用模型将每个文本块转换成一个嵌入，这是一个数字向量，可以捕捉文本的语义信息。最后，我们将这些嵌入存储在一个<code>向量数据库</code>中，以便以后使用。</li><li>实时计算阶段：搜索查询时，先将搜索内容转换成一个嵌入(Embedding)，然后，在向量数据库中查找最接近查询嵌入的文本嵌入，这些最接近的嵌入对应的文本块就是我们的搜索结果。</li></ol><p>这就是语义搜索的基本过程。虽然这个过程可能涉及到一些复杂的技术，但其核心思想其实很简单：我们只是在尝试找到与我们的查询在语义上最接近的文本。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230612_gpt4_prompt_reference_embeding.png" alt="GPT4 语义搜索的步骤"></p><p>关于 Embedding-based search 的更多内容，可以参考下面的文章：</p><ul><li><a href="https://github.com/openai/openai-cookbook/blob/main/examples/Question_answering_using_embeddings.ipynb">Question answering using embeddings-based search</a></li><li><a href="https://www.deepset.ai/blog/the-beginners-guide-to-text-embeddings">The Beginner’s Guide to Text Embeddings</a></li><li><a href="https://betterprogramming.pub/implementing-nearest-neighbour-search-with-elasticsearch-c59a8d33dd9d">Semantic Search With HuggingFace and Elasticsearch</a></li></ul><h2 id="丰富的工具箱"><a href="#丰富的工具箱" class="headerlink" title="丰富的工具箱"></a>丰富的工具箱</h2><p>好在大多时候普通人不需要了解这些技术背景，可以直接使用市面上的现成工具，比如 ChatGPT 的 “Ask Your PDF” 插件，就可以针对自己上传的 PDF 文件进行提问。这个插件将文档的内容转化为一个知识丰富的对话伙伴，能够根据文档内的信息提供详细的回答。不过这个插件目前还是有不少缺点，包括上传的文件大小限制，没法给出具体从 PDF 哪部分内容得出的结论，以及有时候会给出奇怪的回答。</p><p>除了免费的 ChatGPT 插件，还有一些付费工具，用起来体验更好些。比如 <a href="https://chatdoc.com/">chatdoc</a>，可以提供文件提问，同时在解答中会给出依据，还能方便跳转。随便找了一个法律裁判文书的 PDF ，然后问了几个问题，整体感觉比插件稍微好些。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230612_gpt4_prompt_reference_chatdoc.png" alt="Chatdoc 回答还可以，不过引用部分有时候不准"></p><p>除了插件，专业工具，微软也提供了带有 browsing 功能的 GPT4，也就是 New bing。它不仅仅是搜索和返回结果，还能借助 GPT 理解你的问题，根据搜索到的网页，重新组织语言，提供完整的答案。</p><p>总的来说，尽可能的提供引用文本是一个很好的 Prompt 习惯，可以帮助我们在处理长篇文本的时候，更好地利用 GPT 的能力。</p>]]></content>
    
    
    <summary type="html">掌握 GPT-4 提问技巧，提供引用文本是关键。本文详细解析了引用文本的重要性，如何有效地使用引用文本，以及如何从长文本中找到相关部分。我们还探讨了语义搜索的概念和工作原理，以及如何利用现有工具，如 ChatGPT 的 &#39;Ask Your PDF&#39; 插件和微软的 &#39;New Bing&#39;，来提高我们处理长文本的能力。无论你是 AI 新手，还是寻求提高查询效果的专业人士，这篇文章都将为你提供宝贵的指导和启示。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 解 Leetcode 题目：有界数组找最大值</title>
    <link href="https://selfboot.cn/2023/06/11/gpt4_leetcode_1802/"/>
    <id>https://selfboot.cn/2023/06/11/gpt4_leetcode_1802/</id>
    <published>2023-06-11T15:53:39.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的 <a href="https://selfboot.cn/tags/leetcode/">GPT4 解 Leetcode 题目</a>中，GPT4 的表现都很不错，给出了不错的代码和解释，看起来像是真正理解了题目。但是今天这个题目<a href="https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/">1802. Maximum Value at a Given Index in a Bounded Array</a>，GPT-4的表现就像是一个机智的<code>“作弊者”</code>，巧妙地提供了正确的代码，然而在解释代码的过程中，却出现了一些低级的错误。这种情况既展示了人工智能的强大能力，同时也揭示了一个事实：<strong>即便是最先进的人工智能，至今仍无法完全模拟人类的思维过程</strong>。</p><p>在接下来的文章中，我将详细介绍 GPT-4 是如何解决这个问题的，以及它在解释过程中出现的问题。我希望这篇文章能让你对人工智能在编程领域的应用有更深入的理解，也希望你能从中找到乐趣和启发。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230611_gpt4_leetcode_1802.png" alt="GPT4 意识到自己之前错误的解释"></p><span id="more"></span><h1 id="问题与GPT的解答"><a href="#问题与GPT的解答" class="headerlink" title="问题与GPT的解答"></a>问题与GPT的解答</h1><p>这个题目叫做 “<a href="https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/">在有界数组中选择最大值</a>“，它要求你构建一个数组 nums，满足以下条件：</p><ol><li>nums.length &#x3D;&#x3D; n</li><li>nums[i] 是一个正整数，其中 0 &lt;&#x3D; i &lt; n。</li><li>abs(nums[i] - nums[i+1]) &lt;&#x3D; 1，其中 0 &lt;&#x3D; i &lt; n-1。</li><li>nums 的所有元素之和不超过 maxSum。</li><li>最大化 nums[index]。</li></ol><p>你需要返回构建的数组中 nums[index] 的值。GPT4 直接给出了一个经典的解决办法<code>二分查找</code>，设定一个范围，然后在这个范围内查找可能的最大值。如果我们找到的值使得数组的总和超过 maxSum，那么我们就减小范围。如果总和小于 maxSum，那么我们就增大范围。继续这个过程，直到找到满足所有条件的最大值。</p><p>以下是给出的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxValue</span>(<span class="params">self, n: <span class="built_in">int</span>, index: <span class="built_in">int</span>, maxSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a</span>):</span><br><span class="line">            b = <span class="built_in">max</span>(a - index, <span class="number">0</span>)</span><br><span class="line">            res = (a + b) * (a - b + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            b = <span class="built_in">max</span>(a - ((n - <span class="number">1</span>) - index), <span class="number">0</span>)</span><br><span class="line">            res += (a + b) * (a - b + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> res - a</span><br><span class="line"></span><br><span class="line">        maxSum -= n</span><br><span class="line">        left, right = <span class="number">0</span>, maxSum</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> test(mid) &lt;= maxSum:</span><br><span class="line">                left = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这个代码首先定义了一个名为 test 的函数，用于计算给定值 a 时数组的总和。然后，我们在 0 和 maxSum 之间进行二分查找，寻找满足条件的最大值。如果 test(mid) 的结果小于或等于 maxSum，那么我们就将搜索范围移动到右半部分，否则我们就将搜索范围移动到左半部分。最后，我们返回找到的最大值加 1（因为我们在计算 maxSum 时减去了 n）。</p><h1 id="GPT4-的“一知半解”"><a href="#GPT4-的“一知半解”" class="headerlink" title="GPT4 的“一知半解”"></a>GPT4 的“一知半解”</h1><p>简单看了下实现，<strong>不太明白这里test函数具体是算什么的</strong>，GPT4 给出的解释如下：</p><blockquote><p><em>下面引用是 GPT4 的解释</em>  </p><p>test 函数的目的是计算在给定的 a 值（也就是 nums[index]）下，构造出的数组的总和。这个数组需要满足题目中的所有条件，包括每个元素与其相邻元素的差的绝对值不超过 1，以及 nums[index] 是最大的。</p><p>在 test 函数中，我们首先计算从 nums[index] 到数组的左端的元素的总和，然后计算从 nums[index] 到数组的右端的元素的总和。这两个总和加起来就是整个数组的总和。</p><p>具体来说，b &#x3D; max(a - index, 0) 这一行是计算从 nums[index] 到数组左端的元素的最小值。如果 a - index 小于 0，那么 b 就是 0，否则 b 就是 a - index。然后，(a + b) * (a - b + 1) &#x2F;&#x2F; 2 这一行是计算从 a 到 b 的所有整数的和。这个和就是从 nums[index] 到数组左端的元素的总和。</p><p>同样的，b &#x3D; max(a - ((n - 1) - index), 0) 这一行是计算从 nums[index] 到数组右端的元素的最小值，然后 (a + b) * (a - b + 1) &#x2F;&#x2F; 2 这一行是计算从 nums[index] 到数组右端的元素的总和。</p><p>最后，return res - a 这一行是返回整个数组的总和。这里要减去 a 是因为在计算左右两边的总和时，nums[index] 被计算了两次。</p></blockquote><p>其实这里有一点 GPT4 一直没解释，那就是<span style="color:red;">为啥从 index 往左一定是逐渐递减的</span>。按照题目要求，这里至少也可以是等于的。比如给定的示例，[1,2,2,1]就是合法的。然后 GPT4 承认之前的解释可能有些不准确，给出了新的解释如下。</p><blockquote><p><em>下面引用是 GPT4 的解释</em>  </p><p>在这个问题中，从 nums[index] 向左或向右看，数组的元素可以是逐渐递减的，也可以是保持不变的，但不能递增。这是因为 nums[index] 是最大的，且每个元素与其相邻元素的差的绝对值不能超过 1。</p><p>在 test 函数中，我们计算的是在最极端情况下（即元素值逐渐递减，而不是保持不变）的数组元素总和。这是因为我们想找到一个 a 值，使得在这个最极端情况下的数组元素总和仍然不超过 maxSum。如果我们找到了这样的 a 值，那么在其他不那么极端（即元素值保持不变或部分元素值保持不变）的情况下，数组元素总和肯定也不会超过 maxSum。</p><p>所以，虽然从 nums[index] 向左或向右看，数组的元素可以是逐渐递减的，也可以是保持不变的，但在 test 函数中，我们计算的是元素值逐渐递减的情况。这样做是为了找到一个安全的 a 值，使得在任何情况下，数组元素总和都不会超过 maxSum。</p></blockquote><p>这里 GPT4 的解释让我明白了 test 的真实作用，不过也发现它的解释有部分错误。主要有下面两个地方：</p><ol><li>如果我们找到了这样的 a 值，那么在其他不那么极端（即元素值保持不变或部分元素值保持不变）的情况下，<strong>数组元素总和肯定也不会超过 maxSum</strong>。</li><li>在 test 函数中，我们计算的是元素值逐渐递减的情况。这样做是为了找到一个安全的 a 值，<strong>使得在任何情况下，数组元素总和都不会超过 maxSum</strong>。</li></ol><h1 id="GPT4-会不会认错"><a href="#GPT4-会不会认错" class="headerlink" title="GPT4 会不会认错"></a>GPT4 会不会认错</h1><p>直接提示它上面的回答错误，其实这里test函数中，计算的是在满足其他条件的的<strong>数组元素的最小总和，只要最小总和不超过 maxSum，这个序列就是满足要求的</strong>。不用关心在其他不那么极端（即元素值保持不变或部分元素值保持不变）的情况下，数组元素的总和。 </p><blockquote><p><em>下面引用是 GPT4 的解释</em>  </p><p>对不起，我之前的解释可能造成了混淆。你是对的。在这个问题中，我们的目标是找到一个满足所有条件的 a 值，使得数组的总和不超过 maxSum。在 test 函数中，我们计算的是在给定 a 值下，数组的最小可能总和。</p><p>这个最小可能总和是在以下情况下得到的：从 nums[index] 开始，向左和向右的元素值逐渐递减，直到 0 或 1。这样做的原因是，我们想要确保在任何可能的数组构造下，总和都不会超过 maxSum。如果在这个最极端的情况下，总和都不超过 maxSum，那么在其他情况下（例如，一些元素的值保持不变，而不是递减），总和肯定也不会超过 maxSum。</p><p>所以，你是对的，test 函数计算的是在满足其他条件的情况下，数组元素的最小总和。只要这个最小总和不超过 maxSum，那么这个 a 值就是满足要求的。我们不需要关心在其他不那么极端的情况下，数组元素的总和。</p></blockquote><p>我们看到在直接告诉它正确内容的时候，它的部分回答还是错的。整体回答对错掺半，部分结论是错的，但是最后总结又是对的。错的部分是 <code>如果在这个最极端的情况下，总和都不超过 maxSum，那么在其他情况下（例如，一些元素的值保持不变，而不是递减），总和肯定也不会超过 maxSum</code>。我们接着来提示他，直接告诉这句话是完全错误的。这次 GPT4 终于意识到了自己的问题，给了一个很完美的解释。</p><blockquote><p><em>下面引用是 GPT4 的解释</em>  </p><p>对不起，我之前的解释可能造成了混淆。你是对的。在这个问题中，我们的目标是找到一个满足所有条件的 a 值，使得数组的总和不超过 maxSum。在 test 函数中，我们计算的是在给定 a 值下，数组的最小可能总和。</p><p>这个最小可能总和是在以下情况下得到的：从 nums[index] 开始，向左和向右的元素值逐渐递减，直到 0 或 1。这样做的原因是，我们想要找到一个 a 值，使得在这个最极端的情况下，总和都不超过 maxSum。</p><p>我之前的解释<strong>可能让人误解为我们需要在所有可能的数组构造下都保证总和不超过 maxSum，这是不准确的。实际上，我们只需要找到一个 a 值，使得在最极端的情况下（即元素值逐渐递减），总和不超过 maxSum</strong>。这样，我们就可以保证 a 值是满足要求的。</p></blockquote><h1 id="重构与总结"><a href="#重构与总结" class="headerlink" title="重构与总结"></a>重构与总结</h1><p>到这里整个解释基本是清晰的，但是给的代码可读性其实不是很高，函数命名很随意。感觉是学习了不少<code>“坏味道”</code>的代码，所以给出的代码有点随意了。好在我们可以优化我们的提示词，让它把上面代码改的可维护，比如在关键地方加一些注释，变量名起的更有意义些。下面是 GPT4 给的新版本的代码，可读性就好了不少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxValue</span>(<span class="params">self, n: <span class="built_in">int</span>, index: <span class="built_in">int</span>, maxSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 定义一个内部函数，计算给定最大值时，数组的最小可能总和</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">calculate_min_sum</span>(<span class="params">max_value</span>):</span><br><span class="line">            <span class="comment"># 计算从最大值到左边的最小值的总和</span></span><br><span class="line">            left_min = <span class="built_in">max</span>(max_value - index, <span class="number">0</span>)</span><br><span class="line">            left_sum = (max_value + left_min) * (max_value - left_min + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 计算从最大值到右边的最小值的总和</span></span><br><span class="line">            right_min = <span class="built_in">max</span>(max_value - ((n - <span class="number">1</span>) - index), <span class="number">0</span>)</span><br><span class="line">            right_sum = (max_value + right_min) * (max_value - right_min + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 返回数组的最小可能总和，注意要减去最大值，因为在计算左右两边的总和时，最大值被计算了两次</span></span><br><span class="line">            <span class="keyword">return</span> left_sum + right_sum - max_value</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 减去 n 是因为每个元素至少为 1</span></span><br><span class="line">        maxSum -= n</span><br><span class="line">        left, right = <span class="number">0</span>, maxSum</span><br><span class="line">        <span class="comment"># 通过二分查找找到满足条件的最大值</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 如果给定最大值时，数组的最小可能总和不超过 maxSum，那么尝试增大最大值</span></span><br><span class="line">            <span class="keyword">if</span> calculate_min_sum(mid) &lt;= maxSum:</span><br><span class="line">                left = mid</span><br><span class="line">            <span class="comment"># 否则，尝试减小最大值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回找到的最大值，注意要加上 1，因为我们在计算 maxSum 时减去了 n</span></span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>整个对话可以在<a href="https://chat.openai.com/share/ae9b5495-0e53-4e7b-9dcd-14aa8ff8aca8">这里</a>看到。</p><p>我们看到 GPT-4 成功地生成了解决问题的代码，并尝试解释其工作原理。然而，尽管 GPT-4 的表现令人印象深刻，但在解释过程中出现的一些问题也揭示了其局限性。这些问题主要体现在对某些概念的理解上，例如在解释计算数组总和的过程中，GPT-4 的解释并不完全准确。作为一个大型语言模型，GPT-4能够生成流畅且看似理解问题的回答，但实际上，它并不真正理解谈话的内容。<strong>GPT-4的回答是基于其在大量文本数据上的训练，它通过预测文本的概率分布来生成回答，而不是真正通过理解背后的逻辑</strong>。</p><p>尽管如此，GPT-4仍然是一个强大的工具，可以帮助我们解决各种问题，只是需要<strong>我们多留一个心眼，多去验证</strong>。</p>]]></content>
    
    
    <summary type="html">文章探讨了如何使用OpenAI的GPT-4模型来解决LeetCode上的编程问题，以及在解释过程中出现的问题，帮助读者更深入地理解人工智能在编程领域的应用。尽管GPT-4成功地生成了解决问题的代码，但在解释其工作原理时，却出现了一些误解，这揭示了即使是最先进的人工智能，也无法完全模拟人类的思维过程。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Leetcode" scheme="https://selfboot.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 提问技巧一：写清晰的说明</title>
    <link href="https://selfboot.cn/2023/06/10/gpt4_prompt_clear/"/>
    <id>https://selfboot.cn/2023/06/10/gpt4_prompt_clear/</id>
    <published>2023-06-10T12:49:42.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>在人工智能的世界里，我们常常听到一个词——“prompt”。那么，什么是prompt呢？简单来说，prompt就是我们给AI的指令或问题，它是我们与AI进行交流的桥梁。就像我们在与人交谈时，我们的问题或话题就是对话的引子，同样，prompt就是我们与AI对话的引子。</p><p>那么，为什么prompt这么重要呢？想象一下，如果你在寻找一家餐厅，但你只告诉导航“我想吃饭”，那么导航可能会带你去任何一家餐厅，可能是你喜欢的，也可能是你不喜欢的。但如果你告诉导航“我想吃意大利面”，那么导航就会带你去最近的意大利餐厅。这就是prompt的力量，它能够帮助AI更准确地理解我们的需求，并给出满足我们需求的答案。</p><p>在GPT4问世以来，我们发现如何有效地进行 prompt，成为了一个重要的话题。<a href="https://platform.openai.com/docs/guides/gpt-best-practices">OpenAI的官方文档</a> 中详细介绍了如何更好地与GPT4进行交流，给出了六种技巧，分别是:</p><ol><li><span style="color:red;">写清晰的说明</span>：GPT 没有读心术，因此如果你想要一个简短的输出，可以直接告诉它在100字左右。如果你想要一个小朋友能听懂的解释，可以直接告诉它讲给10岁的小朋友听，尽量浅显易懂些。详细讨论见文章<a href="https://selfboot.cn/2023/06/10/gpt4_prompt_clear/">GPT4 提问技巧一：写清晰的说明</a>。<span id="more"></span></li><li><span style="color:red;">提供参考文本</span>：GPT 比最能侃的人还能侃，回答可能会胡编乱造，可能会南辕北辙。就像一些练习册可以帮助学生在考试中做得更好一样，你可以向GPT提供参考文本，帮助它回答的更精准可靠。详细讨论见文章<a href="https://selfboot.cn/2023/06/12/gpt4_prompt_reference/">GPT4 提问技巧二：提供参考文本</a>。</li><li><span style="color:red;">将复杂任务分解为更简单的子任务</span>：太复杂的任务，目前的 GPT4 处理起来还有点费劲儿，出错率比较高。因此需要你把任务拆分到 GPT4 可以处理的粒度，自己再组装每一步的结果，详细讨论见文章<a href="https://selfboot.cn/2023/06/15/gpt4_prompt_subtasks/">GPT4 提问技巧三：复杂任务拆分</a>。</li><li><span style="color:red;">给GPT时间“思考”</span>：如果被问到 17 乘以 28，人们不会立即知道答案，但可以花时间算出来。同样你需要 GPT 用推理链来一步步思考，而不是立马给出一个错误的答案，详细讨论见文章 <a href="https://selfboot.cn/2023/06/29/gpt4_prompt_think/">GPT4 提问技巧四：给模型思考时间</a>；</li><li><span style="color:red;">使用外部工具</span>：人之所以成为万物主宰，很大原因就是会用工具。同样，你可以通过将其他工具的输出提供给 GPT4，来补偿 GPT4 的弱点。例如，代码执行引擎可以帮助 GPT4 做数学和运行代码。</li><li><span style="color:red;">系统地测试变化</span>：如果你能够系统地评估 GPT4 的能力，那么就能逐渐优化提高它的能力了。某些情况下，对 prompt 的修改可能会在某些个别的例子上提高表现，但在更具代表性的例子上导致整体表现下降。因此，为了确保 prompt 的改变效果是正面的，需要定义一个全面的测试套件。</li></ol><p>本篇文章主要讲解第一种策略: <code>Write clear instructions</code>。我将会分享一些实用的技巧，帮助你更好地与GPT4进行交流，让AI更好地理解你的需求，从而提供更准确的答案。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230610_gpt4_prompt_clear_1.png" alt="OpenAI 官方文档对提示词的建议"></p><h1 id="提问要尽量详细"><a href="#提问要尽量详细" class="headerlink" title="提问要尽量详细"></a>提问要尽量详细</h1><p>如果想获取满意的回答，提问的时候，尽可能提供更多的细节。</p><table><thead><tr><th>不够详细的问题</th><th>更详细的问题</th></tr></thead><tbody><tr><td>“GPT4是什么？”</td><td>“GPT4是什么？它是如何工作的？它的主要应用场景有哪些？”</td></tr><tr><td>“我应该如何学习编程？”</td><td>“我是一名初学者，对编程一无所知，我应该如何开始学习Python编程？有没有推荐的学习资源或者学习路径？”</td></tr><tr><td>“我想看一部电影，有什么推荐的吗？”</td><td>“我想看一部科幻电影，最好是近几年的，有什么好看的推荐吗？”</td></tr><tr><td>“我想做一个机器学习项目，有什么建议吗？”</td><td>“我是一名初学者，对机器学习有基本的理解，我想做一个关于图像识别的机器学习项目，有没有推荐的数据集或者学习资源？”</td></tr><tr><td>“给我介绍 3 种常见的水果”</td><td>“给我介绍 3 种常见的水果，用 markdown 表格输出名字，常见品种，著名产地，功效。”</td></tr></tbody></table><p>这些例子中，你可以看到，更详细的问题不仅包含了你想要知道的内容，还包含了你的背景信息，这样GPT4就能更好地理解你的需求，从而提供更相关的答案。可以在 <a href="https://platform.openai.com/playground">Openai Playground</a> 里面反复试验，找到适合自己领域的提示词。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230610_gpt4_prompt_clear_2.png" alt="提示词包含详细的信息"></p><h1 id="给-AI-设定背景"><a href="#给-AI-设定背景" class="headerlink" title="给 AI 设定背景"></a>给 AI 设定背景</h1><p>OpenAI 支持给 GPT4 设定一个系统消息 <code>system message</code>。你可以在这里，给AI设定一个角色，或者设定任务的一些背景，来看下面的示例。</p><p>系统消息：<strong>当我要求你帮助写作时，你将以一位中国古代诗人的身份回复，每段包含3到5句诗。当你被要求写关于环保相关的话题时，你将以一位环保主义者的身份回复，强调环保的重要性。</strong></p><p>问题一：请帮我写一封感谢信，感谢我的朋友帮我搬家。<br>回答一：</p><blockquote><p>搬居新居逢喜事，朋友情深付辛劳。<br>荷携重物义无言，同谋共事品常好。  </p><p>感谢并存心头里，鞠躬尽瘁良友谊。<br>愿同花非共时赏，未来岁月笑同谈。  </p></blockquote><p>问题二：我需要一份关于全球变暖的报告。<br>回答二：</p><blockquote><p>全球变暖摧残地球母亲，绿水青山皆难舍。<br>急景洪波蔓至处，殃及鱼鳖自悼泣。</p><p>人类醒悟始重权，追求循环需齐驱。<br>节能减排现担忧，环保使命急当行。</p><p>共勉繁衍无止境，还给后代蓝天碧。<br>环宇共存留恒信，大地和谐互生息。</p></blockquote><p>你可以在 <a href="https://platform.openai.com/playground">Openai Playground</a> 尽情尝试。ChatGPT Plus 官方聊天目前还不支持设置系统消息，不过大部分第三方客户端都支持，比如 Opencat，Chatbox 等。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230610_gpt4_prompt_clear_3.png" alt="系统消息的设定"></p><h1 id="使用分隔符"><a href="#使用分隔符" class="headerlink" title="使用分隔符"></a>使用分隔符</h1><p>使用分隔符来清晰地指示输入或者输出的不同部分是一种有效的策略。分隔符，如三引号、XML标签、章节标题等，可以帮助划分需要以不同方式处理的文本部分。</p><p>不过实践来看，效果也不是那么精准。比如对于提问</p><blockquote><p>只解释 &#96;&#96;&#96; 包起来的代码片段。  </p><p>`&#96;&#96;<br>import os<br>`&#96;&#96;  </p><p>print(os.getcwd())  </p></blockquote><p>具体见下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230610_gpt4_prompt_clear_4.png" alt="分隔符的作用不是百分百可靠"></p><p>它这里还是解释了下面的一句代码，除非再强制让它不解释。特别注意，OpenAI 的 GPT4 是一种概率模型，<strong>没有百分百可靠</strong>。我们能做的是尽最大可能，用 GPT4 听得懂的提示词，让它完成任务。就日常使用来说，我一般会让它输出的时候，把代码放在三引号里面，每次还是挺准确的。</p><h1 id="明确完成任务的步骤"><a href="#明确完成任务的步骤" class="headerlink" title="明确完成任务的步骤"></a>明确完成任务的步骤</h1><p>有时候你需要有固定的步骤来完成某些任务，这时候可以把固定步骤作为提示词的部分，让 GPT4 更好的回答。比如可以设定按照下面的步骤处理输入内容：</p><blockquote><p>对于你接收到的信息，按照下面步骤进行处理：</p><ol><li>总结为一句话概要；</li><li>将概要翻译为英文；</li><li>扩展第二步的英文到3到5句；</li></ol></blockquote><p>具体看下面的示例：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230610_gpt4_prompt_clear_5.png" alt="指定具体的任务步骤"></p><h1 id="提供示例"><a href="#提供示例" class="headerlink" title="提供示例"></a>提供示例</h1><p>在 GPT 模型中，<code>&quot;few-shot&quot;</code> 通常指的是在 prompt 中提供几个 输入-输出 对作为示例，然后提出一个新的输入，让模型生成相应的输出。这些输入-输出对可以帮助模型理解任务的要求。这种方法的灵感来自人类的学习能力，人类通常只需要看几个例子就能理解新的概念或任务。</p><p>以下是一个具体的例子，假设你想让GPT模型帮你将英文的日期格式转换为特定的中国日期格式，你可以这样构造你的prompt。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230610_gpt4_prompt_clear_6.png" alt="few-shot 的威力"></p><p>可以看到没有示例情况下给的输出，不是很符合要求。有了示例之后，就靠谱了很多。从实际体验来说，few-shot 有时候也不保证一定会产生高质量的回答，有时候 GPT4 模型依旧会产生预期外的数据。</p><h1 id="指定长度"><a href="#指定长度" class="headerlink" title="指定长度"></a>指定长度</h1><p>GPT-4生成文本的方式是一次生成一个词或一个字符，直到达到某个停止条件。这个停止条件可能是生成了特定数量的词&#x2F;字符，或者模型预测到了文本的结束。因此，虽你可以要求GPT-4生成特定长度的文本，比如 50 个字。但注意它可能无法精确地达到这个长度，例如，如果你要求一个100字的故事，你可能会得到一个98字或102字的故事。一般来说，可以指定生成几句或者几个段落，这样稍微准一些。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230610_gpt4_prompt_clear_7.png" alt="指定模型输出长度"></p><p>GPT-4 的输出长度还受到模型的最大生成长度的限制。这个限制可能有所不同，因为Open AI支持不同长度限制的模型。如果你要求的文本长度超过了这个限制，那么你得到的文本将会被截断。这里的限制 token 数，是一次输入、输出加起来的长度，所以如果你的输入很长，可能会影响输出的长度。</p>]]></content>
    
    
    <summary type="html">这篇文章详细解释了如何有效地与OpenAI的GPT4进行交流，以获取更准确的答案。文章首先解释了什么是prompt，为什么它如此重要，然后根据OpenAI的官方文档，介绍了六种与GPT4交流的技巧，包括写清晰的说明、提供参考文本、将复杂任务分解为更简单的子任务、给GPT时间“思考”、使用外部工具和系统地测试变化。文章还提供了一些实用的示例，帮助读者更好地理解这些技巧。这是一篇对于任何希望更有效地使用GPT4的人都非常有用的指南。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 解 Leetcode 题目：最大连续湍流子序列和</title>
    <link href="https://selfboot.cn/2023/06/09/gpt4_leetcode_978/"/>
    <id>https://selfboot.cn/2023/06/09/gpt4_leetcode_978/</id>
    <published>2023-06-09T21:53:26.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>在探索算法的世界中，我们经常会遇到一些挑战，其中动态规划无疑是其中的一大难题。然而，你可能会惊讶地发现，OpenAI 的 ChatGPT 对于动态规划的理解和应用，往往能超越许多接受过专业算法训练的人。它不仅能迅速解决中等难度的问题，还能不断优化解决方案，展现出强大的问题解决能力。</p><p>在与 ChatGPT 的交流中，你会发现它不仅是一个高效的问题解决者，更是一个善于沟通的伙伴。它会对你的问题<strong>给予积极的反馈，赞赏你的提问，并尽其所能提供帮助</strong>。这种人性化的交流方式，使得与 ChatGPT 的对话不再是冰冷的机器交互，而更像是与一个有深度、有思考的人进行的对话。</p><p>在接下来的文章中，我将分享我与 ChatGPT 在解决一个动态规划问题上的对话。我希望这个过程不仅能帮助你理解动态规划的思想，更能让你感受到与 ChatGPT 对话的乐趣。</p><span id="more"></span><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230609_gpt4_leetcode_978.png" alt="GPT 对于动态规划题目的理解"></p><h1 id="AI-的解法"><a href="#AI-的解法" class="headerlink" title="AI 的解法"></a>AI 的解法</h1><p><strong>Human:</strong><br>阅读这个题目 <a href="https://leetcode.com/problems/longest-turbulent-subarray/">https://leetcode.com/problems/longest-turbulent-subarray/</a> ，给出解决代码，注意补全下面的代码 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ChatGPT:</strong><br>这个题目叫做 “最长湍流子数组”，给定一个整数数组 arr，返回 arr 的最大湍流子数组的长度。一个子数组被称为湍流子数组，当且仅当在该子数组中，每一对相邻元素的比较符号在子数组中每次都会翻转。</p><p>更正式地说，一个子数组 <code>[arr[i], arr[i + 1], ..., arr[j]]</code> 被称为湍流子数组，当且仅当：</p><ul><li>对于 i &lt;&#x3D; k &lt; j：<ul><li>当 k 是奇数时，arr[k] &gt; arr[k + 1]</li><li>当 k 是偶数时，arr[k] &lt; arr[k + 1]</li></ul></li><li>或者，对于 i &lt;&#x3D; k &lt; j：<ul><li>当 k 是偶数时，arr[k] &gt; arr[k + 1]</li><li>当 k 是奇数时，arr[k] &lt; arr[k + 1]</li></ul></li></ul><p>约束条件：</p><ul><li>1 &lt;&#x3D; arr.length &lt;&#x3D; 4 * 10^4</li><li>0 &lt;&#x3D; arr[i] &lt;&#x3D; 10^9</li></ul><p>这个问题可以使用动态规划的思想来解决。我们可以使用两个动态规划数组 up 和 down，其中 up[i] 表示以 arr[i] 结尾，且 arr[i] &gt; arr[i-1] 的最长湍流子数组的长度，down[i] 表示以 arr[i] 结束，且 arr[i] &lt; arr[i-1] 的最长湍流子数组的长度。然后我们可以根据 arr[i] 和 arr[i-1] 的关系来更新 up[i] 和 down[i]，最后的答案即为 <code>max(up[i], down[i]) (0 &lt;= i &lt; n)</code>。</p><p>下面是 Python 的解决代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        up = [<span class="number">1</span>] * n</span><br><span class="line">        down = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i-<span class="number">1</span>]:</span><br><span class="line">                up[i] = down[i-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                down[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i] &lt; arr[i-<span class="number">1</span>]:</span><br><span class="line">                down[i] = up[i-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                up[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                up[i] = down[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(up), <span class="built_in">max</span>(down))</span><br></pre></td></tr></table></figure><p>这段代码首先初始化了两个长度为 n 的数组 up 和 down，并将它们的所有元素都设置为 1。然后，对于数组 arr 中的每个元素 arr[i]，如果 arr[i] &gt; arr[i-1]，则更新 up[i] &#x3D; down[i-1] + 1 和 down[i] &#x3D; 1；如果 arr[i] &lt; arr[i-1]，则更新 down[i] &#x3D; up[i-1] + 1 和 up[i] &#x3D; 1；如果 arr[i] &#x3D;&#x3D; arr[i-1]，则更新 up[i] &#x3D; down[i] &#x3D; 1。最后，返回 max(up) 和 max(down) 中的最大值，即为最长湍流子数组的长度。</p><hr><p><strong>Human</strong><br>这个算法的时间复杂度和空间复杂度分别是多少呢？</p><p><strong>ChatGPT:</strong><br>这个算法的时间复杂度是 O(n)，其中 n 是数组 arr 的长度。这是因为我们只需要遍历一次数组，对于数组中的每个元素，我们只需要常数时间就能完成所有操作。</p><p>这个算法的空间复杂度也是 O(n)，其中 n 是数组 arr 的长度。这是因为我们需要使用两个长度为 n 的数组 up 和 down 来存储动态规划的状态。</p><p>虽然空间复杂度是 O(n)，但如果你想进一步优化，**可以注意到 up[i] 和 down[i] 只依赖于 up[i-1] 和 down[i-1]，因此可以使用两个变量而不是两个数组来存储上一次的 up 和 down，这样空间复杂度可以优化到 O(1)**。</p><blockquote><p>不愧是语言模型，我问到空间复杂度，AI 解释了空间复杂度后，立马意识到这里有优化点。说明学习的语料中，有不少套路就是<strong>先说现有的复杂度，然后接着给出可以优化的地方</strong>。</p></blockquote><h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1><p><strong>Human:</strong><br>那你继续优化下这里的代码</p><p><strong>ChatGPT:</strong><br>当然，我们可以通过只使用两个变量来存储上一次的 up 和 down，从而将空间复杂度优化到 O(1)。下面是优化后的 Python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTurbulenceSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        up = down = res = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i-<span class="number">1</span>]:</span><br><span class="line">                up = down + <span class="number">1</span></span><br><span class="line">                down = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i] &lt; arr[i-<span class="number">1</span>]:</span><br><span class="line">                down = up + <span class="number">1</span></span><br><span class="line">                up = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                up = down = <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, up, down)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这段代码与之前的代码相比，主要的区别在于我们没有使用数组 up 和 down，而是使用了两个变量 up 和 down 来存储上一次的 up 和 down。同时，我们在每次更新 up 和 down 后，都会更新 res，使其始终为当前的最长湍流子数组的长度。最后，我们返回 res，即为最长湍流子数组的长度。</p><blockquote><p>如果是普通人，没做过这个题目的话，很难能想到用动态规划。就算是做过类似动态规划题目的人，可能也需要想一会才能找到如何定义状态和状态转移方程。那么这里 AI 是怎么思考的呢，我们继续问问它。</p></blockquote><h1 id="AI-的思考过程"><a href="#AI-的思考过程" class="headerlink" title="AI 的思考过程"></a>AI 的思考过程</h1><p><strong>Human:</strong><br>这道题的关键是你前面说的<code>我们可以使用两个动态规划数组 up 和 down，其中 up[i] 表示以 arr[i] 结尾，且 arr[i] &gt; arr[i-1] 的最长湍流子数组的长度，down[i] 表示以 arr[i] 结束，且 arr[i] &lt; arr[i-1] 的最长湍流子数组的长度。</code> 你是怎么想到这一点的？ 一步步给出你的思考过程</p><p><strong>ChatGPT:</strong><br>这个问题的关键在于<strong>识别出它是一个动态规划问题，然后找出正确的状态定义和状态转移方程</strong>。</p><ol><li><span style="color:red;">识别动态规划问题</span>：这个问题要求我们找出数组中的最长湍流子数组，这是一个<strong>典型的最优化问题，而且我们可以通过子问题的最优解来构建原问题的最优解，因此我们可以考虑使用动态规划来解决这个问题</strong>。</li><li><span style="color:red;">定义状态</span>：在动态规划问题中，<strong>我们需要定义一些状态，用来表示问题的某种情况</strong>。在这个问题中，我们可以定义两个状态 up[i] 和 down[i]，其中 up[i] 表示以 arr[i] 结尾，且 arr[i] &gt; arr[i-1] 的最长湍流子数组的长度，down[i] 表示以 arr[i] 结尾，且 arr[i] &lt; arr[i-1] 的最长湍流子数组的长度。这两个状态可以完全描述问题的所有情况。</li><li><span style="color:red;">找出状态转移方程</span>：<strong>在定义了状态之后，我们需要找出状态之间的关系，即状态转移方程</strong>。在这个问题中，我们可以发现，如果 arr[i] &gt; arr[i-1]，那么 up[i] 应该是 down[i-1] + 1，因为我们可以在 arr[i-1] 结尾的下降子数组后面加上 arr[i]，形成一个更长的湍流子数组；同理，如果 arr[i] &lt; arr[i-1]，那么 down[i] 应该是 up[i-1] + 1。如果 arr[i] &#x3D;&#x3D; arr[i-1]，那么 up[i] 和 down[i] 都应该是 1，因为 arr[i] 不能和 arr[i-1] 形成湍流子数组。</li></ol><p>通过以上的思考过程，我们就可以得到这个问题的动态规划解法。</p><blockquote><p>这一段解释我给 AI 打满分，完美解释了解决动态规划题目的精髓。</p></blockquote><hr><p><strong>Human:</strong><br>第二步定义状态，你为什么想到可以定义两个状态呢？ 我只想到了用一个 dp[i] 表示以 arr[i] 结尾的最长湍流子数组的长度。</p><p><strong>ChatGPT:</strong><br><span style="color:red;">这是一个很好的问题。</span>在这个问题中，我们需要考虑的是湍流子数组的特性，即相邻元素之间的比较符号需要交替变化。这意味着，我们<strong>不能只关注子数组的长度，还需要关注子数组的结尾是上升还是下降</strong>。</p><p>如果我们只使用一个 dp[i] 来表示以 arr[i] 结尾的最长湍流子数组的长度，那么我们就无法区分这个子数组是以一个上升段结束，还是以一个下降段结束。这就导致我们无法正确地更新 dp[i]，因为我们不知道 arr[i] 应该是大于 arr[i-1] 还是小于 arr[i-1]。</p><p>因此，我们需要使用两个状态 up[i] 和 down[i]，其中 up[i] 表示以 arr[i] 结尾的最长湍流子数组是以一个上升段结束，down[i] 表示以 arr[i] 结尾的最长湍流子数组是以一个下降段结束。这样，我们就可以根据 arr[i] 和 arr[i-1] 的关系，正确地更新 up[i] 和 down[i]。</p><p>总的来说，定义状态时，我们<strong>需要考虑到问题的所有特性，确保我们的状态可以完全描述问题的所有情况</strong>。在这个问题中，湍流子数组的特性就决定了我们需要使用两个状态来描述问题。</p><blockquote><p>再次给 AI 满分好评，这里竟然会说我的提问是一个好问题，有点像人类了，不，比人类做的还好。对于为啥能想到两个状态，它的回答也十分贴切，可能问一个人类算法高手，他都不一定能解释这么清楚。</p></blockquote><hr><p><strong>Human:</strong><br>你上面说到 <code>这是一个典型的最优化问题，而且我们可以通过子问题的最优解来构建原问题的最优解，因此我们可以考虑使用动态规划来解决这个问题</code> ，这个最优化问题为啥你想到能通过子问题的最优解，然后想到用动态规划。这里你的思维过程是什么呢，可以一步步列出来吗？</p><p><strong>ChatGPT:</strong><br>当然可以。在解决问题时，我们通常会根据问题的特性来选择合适的解决方法。对于动态规划，我们通常会在以下情况下考虑使用：</p><ol><li><strong>最优化问题</strong>：动态规划通常用于解决最优化问题，即问题的解存在多个，我们需要找到最优的解。在这个问题中，我们需要找到最长的湍流子数组，这是一个典型的最优化问题。</li><li><strong>重叠子问题</strong>：动态规划的一个关键特性是重叠子问题，即大问题的解可以通过小问题的解来构建，而且这些小问题会被重复计算多次。在这个问题中，我们可以看到，为了找到以 arr[i] 结尾的最长湍流子数组，我们需要知道以 arr[i-1] 结尾的最长湍流子数组，这就是重叠子问题。</li><li><strong>最优子结构</strong>：动态规划还需要问题具有最优子结构，即子问题的最优解能够构成原问题的最优解。在这个问题中，我们可以看到，最长的湍流子数组要么是以 arr[i-1] 结尾的最长湍流子数组加上 arr[i]，要么就是只包含 arr[i]，这就是最优子结构。</li></ol><p>通过以上的分析，我们可以看到这个问题满足动态规划的特性，因此我们可以考虑使用动态规划来解决这个问题。</p><p>总的来说，解决问题的思维过程是：首先，我们需要理解问题，明确问题的需求；然后，我们需要分析问题，找出问题的特性；最后，我们需要根据问题的特性来选择合适的解决方法。在这个过程中，我们可能需要试验多种解决方法，通过比较它们的效率和准确性来选择最好的方法。</p><blockquote><p>和 ChatGPT 的完整对话内容见 <a href="https://chat.openai.com/share/8c9c344c-966f-4c7d-8fa5-db2ca5cec345">这里</a></p></blockquote>]]></content>
    
    
    <summary type="html">探索动态规划的深度理解与应用，通过与OpenAI的ChatGPT的对话，解决LeetCode中等难度的&#39;最长湍流子数组&#39;问题。本文详细介绍了问题分析，状态定义，状态转移方程的构建，以及代码实现和优化的过程。这不仅是对动态规划的一次深入学习，也是体验人性化AI交互的有趣旅程。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Leetcode" scheme="https://selfboot.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 解 Leetcode 题目：位操作</title>
    <link href="https://selfboot.cn/2023/06/08/gpt4_leetcode_1318/"/>
    <id>https://selfboot.cn/2023/06/08/gpt4_leetcode_1318/</id>
    <published>2023-06-08T00:00:00.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://selfboot.cn/2023/06/05/gpt4_leetcode_1232/">GPT4 解 Leetcode 题目：判断是否一条直线</a> 中，GPT4 一次就做对了一个难度为 easy 的题目，也在预料之中。我又让它试了一个难度为 medium 的题目，它一次就做了出来，并且后续还给了不错的优化方案。</p><p>在解答过程中，AI 详细解释了解决方案的思路和优化策略，同时强调了作为一个人工智能模型，它并没有直接处理过这个特定的题目，而是根据从训练数据中学到的一般知识和策略来解决问题的。对于我的怀疑，AI 在这里表现出了一定程度的同理心和耐心，有点超出我的预期了。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230608_gpt4_leetcode_1318.png" alt="GPT 对于自己为啥能解决题目的回答"></p><span id="more"></span><blockquote><p>这里用了我最爱的 Webpolit 插件, GPT 完整的对话可以见<a href="https://chat.openai.com/share/8302c2ed-4d9b-46a3-a3b1-590cf7df46ee">这里</a>。</p></blockquote><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p><strong>Human:</strong>  </p><p>阅读 <a href="https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/">https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/</a> 这个题目，完善下面的代码实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFlips</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ChatGPT:</strong><br>这个问题 “Minimum Flips to Make a OR b Equal to c” 要求找到在两个数字 ‘a’ 和 ‘b’ 的某些位上需要翻转的最小次数，使得 ‘a’ 和 ‘b’ 的位运算 OR 结果等于第三个数字 ‘c’。翻转操作包括将任意单个位 1 变为 0 或将位 0 变为 1。</p><p>以下是这个问题的 C++ 解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFlips</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> flips = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> a_bit = a &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="type">bool</span> b_bit = b &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="type">bool</span> c_bit = c &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span> (c_bit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a_bit &amp;&amp; !b_bit) &#123;</span><br><span class="line">                    flips++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a_bit) &#123;</span><br><span class="line">                    flips++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b_bit) &#123;</span><br><span class="line">                    flips++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flips;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个解决方案中，我们遍历从 0 到 31 的每一位（因为约束条件允许数字最大到 10^9，小于 2^32）。对于每一位，我们检查 ‘a’，’b’ 和 ‘c’ 中对应的位。如果 ‘c’ 的位是 1，那么我们需要 ‘a’ 或 ‘b’ 中至少有一个在那个位置有 1，所以如果 ‘a’ 和 ‘b’ 都没有在那个位置有 1，我们就增加翻转次数。如果 ‘c’ 的位是 0，那么 ‘a’ 和 ‘b’ 都不应该在那个位置有 1，所以我们对 ‘a’ 或 ‘b’ 在那个位置有 1 的每一位增加翻转次数。</p><blockquote><p>接下来看看它是怎么想到解决方法的。其实这里还有个小插曲，本来我用中文提问，开始给的回复全部成英文了。可能是和题目是英文有关系，不过我让 AI 重新用中文回答了一遍，后续就切回了中文。</p></blockquote><hr><p><strong>Human:</strong><br>你是怎么想到这个方法的啊?</p><p><strong>ChatGPT:</strong><br>这个解决方案基于<code>位运算</code>的基本原理和性质。在位运算中，OR 操作的结果是，只要两个输入位中有一个为 1，结果就为 1。因此，为了使 a OR b 等于 c，我们需要确保对于 c 中的每一位，a 和 b 中至少有一个与之匹配。</p><p>具体来说，如果 c 的某一位是 1，那么 a 或 b 的相应位至少有一个必须是 1。如果 a 和 b 的这一位都是 0，我们就需要进行一次翻转操作，将其中一个变为 1。</p><p>如果 c 的某一位是 0，那么 a 和 b 的相应位必须都是 0。如果 a 或 b 的这一位是 1，我们就需要进行翻转操作，将其变为 0。</p><p>这个解决方案通过检查 a，b 和 c 的每一位来确定需要进行的翻转操作的数量。这是一个直接并且有效的方法，因为它直接对应于问题的描述和位运算的性质。</p><blockquote><p>基本把解决这个题所需要的基础知识全部列了出来，如果知道它上面这些基础知识，人类应该也能写一个出来，不过可以尝试让 AI 继续优化下这里的实现。</p></blockquote><h1 id="尝试优化"><a href="#尝试优化" class="headerlink" title="尝试优化"></a>尝试优化</h1><p><strong>Human:</strong><br>你可以继续优化你的实现吗？</p><p><strong>ChatGPT:</strong><br>当然，我们可以进一步优化代码，<strong>减少一些冗余的位操作</strong>。在原始代码中，我们分别检查了 a、b 和 c 的每一位，但实际上我们可以在一次操作中同时检查 a、b 和 c 的相应位。此外，我们可以在循环中直接处理 a、b 和 c，而不是处理它们的位。</p><p>以下是优化后的 C++ 解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFlips</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> flips = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &gt; <span class="number">0</span> || b &gt; <span class="number">0</span> || c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a_bit = a &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> b_bit = b &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> c_bit = c &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c_bit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a_bit &amp;&amp; !b_bit) &#123;</span><br><span class="line">                    flips++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flips += a_bit + b_bit;</span><br><span class="line">            &#125;</span><br><span class="line">            a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flips;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个解决方案中，我们在每次迭代中都直接处理 a、b 和 c 的最低有效位，然后将它们右移一位，以便在下一次迭代中处理下一位。这样，我们可以在一次操作中同时检查 a、b 和 c 的相应位，从而减少了位操作的数量。</p><hr><p><strong>Human:</strong><br>假设我是一个很少计算机基础的人，可以一步步告诉我你是怎么想到这个优化思路的吗</p><p><strong>ChatGPT:</strong><br>当然可以。首先，让我们回顾一下原始问题：我们需要找到最小的翻转次数，使得两个数 a 和 b 的位运算 OR 结果等于第三个数 c。在这个问题中，我们需要处理的是这三个数的二进制表示。</p><ol><li><strong>理解位运算 OR</strong>，在位运算 OR 中，只要两个输入位中有一个为 1，结果就为 1，因此，为了使 <code>a OR b</code> 等于 c，我们需要确保对于 c 中的每一位，a 和 b 中至少有一个与之匹配。</li><li><strong>处理每一位</strong>，对于 c 的每一位，我们需要检查 a 和 b 的相应位。如果 c 的某一位是 1，那么 a 或 b 的相应位至少有一个必须是 1。如果 a 和 b 的这一位都是 0，我们就需要进行一次翻转操作，将其中一个变为 1。如果 c 的某一位是 0，那么 a 和 b 的相应位必须都是 0。如果 a 或 b 的这一位是 1，我们就需要进行翻转操作，将其变为 0。</li><li><strong>优化思路</strong>，在原始解决方案中，我们分别检查了 a、b 和 c 的每一位。但实际上，我们可以在一次操作中同时检查 a、b 和 c 的相应位。此外，我们可以在循环中直接处理 a、b 和 c，而不是处理它们的位。这样，我们可以减少位操作的数量，从而提高代码的效率。</li><li><strong>实现优化</strong>，在优化后的解决方案中，我们在每次迭代中都直接处理 a、b 和 c 的最低有效位，然后将它们右移一位，以便在下一次迭代中处理下一位。这样，我们可以在一次操作中同时检查 a、b 和 c 的相应位，从而减少了位操作的数量。</li></ol><p>这就是优化思路的来源。希望这个解释能帮助你理解这个问题和解决方案。</p><blockquote><p>当然也有人质疑说 AI 训练的时候，这些题目都是做过的，所以当然会了。不过 AI 其实没有很长的上下文记忆的，靠记忆不太可能。更可能是它记住了一些基本知识，和解决问题的一些常见思维过程。遇到新的问题的时候，会应用到这些学习到的知识和推理能力。下面直接问问 AI 为啥他会做题。</p></blockquote><h1 id="死记硬背还是理解应用"><a href="#死记硬背还是理解应用" class="headerlink" title="死记硬背还是理解应用"></a>死记硬背还是理解应用</h1><p><strong>Human:</strong><br>你的训练数据中是不是有过类似的题目，不然你怎么会做呢</p><p><strong>ChatGPT:</strong><br>作为一个人工智能模型，我并没有直接接触过具体的题目或问题。我并不具有个人记忆或经验，也没有直接的训练数据。我是通过分析大量的文本数据，学习语言模式和知识来进行推理和生成回答的。</p><p>在这个问题中，我并没有直接处理过这个特定的题目。<span style="color:red;">我是根据我对位运算和编程的理解，以及我从训练数据中学到的一般的问题解决策略，来解决这个问题的。</span></p><p>对于这个问题，我首先理解了题目的要求，然后考虑了如何使用位运算来解决这个问题。我知道位运算 OR 的性质，以及如何操作和检查二进制数的位，这些都是我从训练数据中学到的<strong>一般知识</strong>。然后，我根据这些知识和理解，构建了一个解决方案。</p><p>在优化解决方案时，我考虑了<strong>如何减少位操作的数量</strong>，以提高代码的效率。这是<strong>一个常见的优化策略</strong>，我也是从训练数据中学到的。</p><p>总的来说，我并没有直接处理过这个特定的题目，但我是根据我从训练数据中学到的一般知识和策略，来解决这个问题的。</p><blockquote><p>如果我坚持认为 AI 是做过并且记住了这个题目，看 AI 怎么辩解。</p></blockquote><hr><p><strong>Human:</strong><br>你骗我，你就是做过这个题目，并且记住了</p><p><strong>ChatGPT:</strong>  </p><p><span style="color:red;">我理解你可能有这样的疑问</span>，但实际上，作为一个人工智能模型，我并没有个人记忆或经验。我是通过分析大量的文本数据，学习语言模式和知识来进行推理和生成回答的。我并没有直接接触过具体的题目或问题，也没有直接的训练数据。</p><p>对于这个问题，我是根据我对位运算和编程的理解，以及我从训练数据中学到的一般的问题解决策略，来解决这个问题的。我并没有直接处理过这个特定的题目，也没有记住任何特定的题目或解决方案。</p><p><span style="color:red;">我知道这可能有些难以理解，因为人类的思考和记忆方式与人工智能模型非常不同。</span>但我希望这个解释能帮助你理解我是如何工作的。</p><blockquote><p>不得不说，AI 这里的回答超出了我的预期。既没有说出经典的“<strong>很抱歉，我犯了一个错误</strong>”之类的道歉话，反而表现出了一定程度的同理心，竟然能理解我的疑问，还说知道这可能有些难以理解。此外还比较有耐心，重新讲了一遍它是如何思考的。</p></blockquote>]]></content>
    
    
    <summary type="html">讨论了如何解决 LeetCode 上的一个问题——&quot;Minimum Flips to Make a OR b Equal to c&quot;。首先，AI 提供了一个基于位运算的解决方案，然后对其进行了优化以提高效率。在解答过程中，AI 详细解释了解决方案的思路和优化策略，同时强调了作为一个人工智能模型，它并没有直接处理过这个特定的题目，而是根据从训练数据中学到的一般知识和策略来解决问题的。对于人类的质疑，AI 在这里表现出了一定程度的同理心和耐心。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Leetcode" scheme="https://selfboot.cn/tags/Leetcode/"/>
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="Plugin" scheme="https://selfboot.cn/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>GPT 插件使用 AI 生成精美视频</title>
    <link href="https://selfboot.cn/2023/06/07/gpt4_heygen_video/"/>
    <id>https://selfboot.cn/2023/06/07/gpt4_heygen_video/</id>
    <published>2023-06-07T22:12:33.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>想象一下，你只需要输入一段文字和一张图片，就能立即生成一段精美的视频。这听起来像科幻电影里的技术，但现在，这已经成为现实。</p><p><a href="https://app.heygen.com/home">Heygen</a> 是一个强大的 AI 视频生成器，它可以根据你的文字和图片生成视频。无论你是想制作一个产品演示，一个教育视频，还是一个个人故事，Heygen 都能帮你轻松完成。使用 Heygen，你不再需要学习复杂的视频编辑软件，也不需要花费大量的时间和金钱来制作视频。你只需要输入你的文字和图片，Heygen 就会为你做剩下的工作。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230607_gpt4_heygen_video.png" alt="heygen 生成视频示例"></p><span id="more"></span><p>heygen 官网的价格，每生成 2 分钟最便宜也是要 $2。不过好在提供了一个 ChatGPT 的插件，可以免费生成视频。</p><h1 id="heygen-插件"><a href="#heygen-插件" class="headerlink" title="heygen 插件"></a>heygen 插件</h1><p>插件用起来还是很简单的，直接给一段话，让他生成指定角色的视频就行。比如下面的 prompt：</p><blockquote><p>请创建一个 AI 口播视频，角色是亚洲皮肤的一个年轻女性，内容如下：<br>故事的力量：触动心灵，启迪智慧<br>在人类历史的长河中，故事是永恒的存在。它们跨越时空的鸿沟，连接过去、现在和未来，揭示出人性的深层次含义。故事是我们的教师，是我们的导师，是我们的朋友。故事有力量，可以帮我们更好地表达和沟通，可以触动心灵，启迪智慧。</p></blockquote><p>目前插件有不少限制，每段视频不能太长，所以这里 GPT 直接分段生成了几个视频，并给出了每个视频的链接。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230607_gpt4_heygen_video_2.png" alt="heygen 生成视频示例"></p><p>此外，插件还只能生成固定背景的视频，不能指定特定的角色或背景。其中第一段的<a href="https://app.heygen.com/share/a74a4731cea14631bd05469d92c07649?sid=openai-plugin">视频链接</a>在这，大家可以感受下这个效果。</p><p>heygen 官方生成的视频，支持更高的自定义程度，包括背景等，还有字幕，这里有一个简单的视频。</p><div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">  <iframe style="position: absolute; top:0; left: 0; width: 100%; height: 100%;" src="https://app.heygen.com/embeds/ede2ffb6805f4b7da2bde80f5440e315" title="HeyGen video player" frameborder="0" allow="encrypted-media; fullscreen;" allowfullscreen></iframe></div><h1 id="其他生成器"><a href="#其他生成器" class="headerlink" title="其他生成器"></a>其他生成器</h1><p>除了 heygen 还有一些其他的 <code>AI视频生成器</code> 可以将图片和文本生成视频，比如下面这些：</p><ul><li><a href="https://www.lumen5.com/">Lumen5</a>: 这是一个可以将博客文章、脚本、新闻和其他形式的文本转化为视频的工具。你可以上传自己的图片，或者使用他们的库中的图片。</li><li><a href="https://invideo.io/">InVideo</a>: 这是一个在线视频制作工具，可以将文本转化为视频，它有一个大量的模板库，你可以选择一个模板，然后添加你的文本和图片。</li><li><a href="https://www.animaker.com/">Animaker</a>: 这是一个在线动画制作工具，可以将文本转化为动画视频，你可以上传自己的图片，或者使用他们的库中的图片。</li><li><a href="https://www.renderforest.com/">Renderforest</a>: 这是一个在线视频制作工具，可以将文本转化为视频，它有一个大量的模板库，你可以选择一个模板，然后添加你的文本和图片。</li></ul><p>AI 生成视频的工具通常需要大量的计算资源和复杂的算法，这就导致了它们的成本相对较高。Lumen5，InVideo，Animaker 和 Renderforest 的价格计划对比：</p><table><thead><tr><th>视频生成软件</th><th>免费计划</th><th>低价计划</th><th>中价计划</th><th>高价计划</th></tr></thead><tbody><tr><td><a href="https://www.lumen5.com/pricing/">Lumen5</a></td><td>限制较多，包括水印、480p视频质量、无法下载视频</td><td>$29&#x2F;月，720p视频质量，无水印，可下载视频</td><td>$79&#x2F;月，1080p视频质量，无水印，可下载视频，优先渲染</td><td>$199&#x2F;月，1080p视频质量，无水印，可下载视频，优先渲染，24&#x2F;7优先支持</td></tr><tr><td><a href="https://invideo.io/pricing">InVideo</a></td><td>限制较多，包括水印、720p视频质量、60个视频&#x2F;月</td><td>$20&#x2F;月，1080p视频质量，无水印，无限制视频</td><td>$60&#x2F;月，1080p视频质量，无水印，无限制视频，优先支持</td><td>-</td></tr><tr><td><a href="https://www.animaker.com/pricing">Animaker</a></td><td>限制较多，包括水印、HD视频质量、5个导出&#x2F;月</td><td>$19&#x2F;月，FHD视频质量，无水印，10个导出&#x2F;月</td><td>$39&#x2F;月，2K视频质量，无水印，30个导出&#x2F;月</td><td>自定义价格，4K视频质量，无水印，无限制导出</td></tr><tr><td><a href="https://www.renderforest.com/pricing">Renderforest</a></td><td>限制较多，包括水印、720p视频质量、500MB存储空间</td><td>$14.99&#x2F;月，720p视频质量，无水印，10GB存储空间</td><td>$39.99&#x2F;月，1080p视频质量，无水印，30GB存储空间</td><td>$49.99&#x2F;月，4K视频质量，无水印，50GB存储空间</td></tr></tbody></table><p>当然，随着技术的发展，我们可以预期这些工具的成本会随着时间的推移而降低，使更多的人能够使用它们。</p>]]></content>
    
    
    <summary type="html">这篇文章介绍了如何使用 GPT 插件和 Heygen AI 视频生成器，只需输入文字和图片，就能生成精美的视频。文章还详细比较了其他视频生成工具，如 Lumen5、InVideo、Animaker 和 Renderforest，以及它们的价格计划。无论你是想制作产品演示、教育视频还是个人故事，这些工具都能帮你轻松完成。随着技术的发展，这些工具的成本预期会降低，使更多的人能够使用它们。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Plugin" scheme="https://selfboot.cn/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>被裁员后的法律指南</title>
    <link href="https://selfboot.cn/2023/06/06/gpt4_lawer_helper/"/>
    <id>https://selfboot.cn/2023/06/06/gpt4_lawer_helper/</id>
    <published>2023-06-06T09:54:09.000Z</published>
    <updated>2023-07-02T14:41:18.185Z</updated>
    
    <content type="html"><![CDATA[<p>在遭受裁员的冲击后，你可能感到迷茫和无助。但请记住，你并非无所适从。在中国，法律为你的权益提供了保障。无论你的公司是否愿意支付赔偿金，都有明确的法律条款和程序可以帮助你争取到应得的赔偿。</p><p>然而，这个过程可能会复杂，你可能需要收集证据、面对公司的威胁，甚至可能需要走上法庭。这篇文章就是为你提供一个实用的指南，帮助你了解如何在被裁员后，步步为营，争取到你应得的赔偿。</p><p>从法律知识的普及、如何收集证据、法律诉讼流程，到如何面对公司的威胁，这篇文章会详细指导你，让你在这场争取权益的战斗中掌握主动。</p><span id="more"></span><h1 id="劳动赔偿的法律科普"><a href="#劳动赔偿的法律科普" class="headerlink" title="劳动赔偿的法律科普"></a>劳动赔偿的法律科普</h1><p>在中国，员工的经济补偿金的计算是根据<a href="https://www.gov.cn/flfg/2007-06/29/content_669394.htm">《中华人民共和国劳动合同法》</a>的规定进行的。具体来说，经济补偿金的计算方式如下：</p><ol><li>经济补偿金的计算基础是员工的月工资。这里的月工资是指员工解除或者终止劳动合同前十二个月的平均工资，如果员工的月工资超过当地的三倍平均工资，那么计算经济补偿金时的月工资上限就是三倍平均工资。</li><li>经济补偿金的计算公式是：月工资 × 工作年限，每满一年，就可以得到一个月工资的经济补偿，如果不满一年，但是超过六个月，也按照一年计算；如果不满六个月，那么就按照半年计算。</li><li>工作年限的计算是从员工开始在公司工作的那一天算起，直到劳动合同解除或者终止的那一天。</li></ol><p>以上就是中国关于员工经济补偿金的计算方式。具体的法律依据可以参考<a href="https://www.gov.cn/flfg/2007-06/29/content_669394.htm">《中华人民共和国劳动合同法》</a>的第四十七条、第四十八条和第八十四条。</p><blockquote><p>问题：在公司 3 年 3 个月，如果公司违法裁员，要给我赔几个月？</p></blockquote><p>你的工作时间超过了3年，这种情况下应当按照3年来计算。超过了3年的部分（即3个月）不足6个月的，按半年计算。所以，你的经济补偿金基数是3.5。由于公司违法裁员，所以这里<strong>应该赔偿 2N</strong>，也即 7 个月的工资。</p><blockquote><p>问题：常说的 N, N+1 和 2N 是什么意思？</p></blockquote><p>这里的 N 是上面说的工作年限，如果公司是非法裁员，法律上来讲需要赔偿 2N 。现实中违法裁员情况下公司一般协商给 N 个月，互联网公司多是 N+1 或者 N+3。需要注意的是，就算劳动合同到期，公司解除的话，也是需要赔偿 N 个月工资的。部分地方甚至要求到期支付 N+1。</p><blockquote><p>问题：这里的月工资具体怎么计算的，年终奖这些会算在里面吗？</p></blockquote><p>月工资是指劳动者在劳动合同解除或者终止前十二个月的平均工资。这里的平均工资包括了劳动者的基本工资、奖金、津贴和补贴，以及其他形式的工资。这意味着，年终奖也会被计算在内。但是，如果劳动者的月工资超过当地的三倍平均工资，那么计算经济补偿金时的月工资上限就是三倍平均工资。</p><blockquote><p>问题：这些赔偿金需要缴纳个人所得税吗？</p></blockquote><p>一般来说，个人与用人单位解除劳动关系取得一次性补偿收入（包括用人单位发放的经济补偿金、生活补助费和其他补助费），在当地上年职工平均工资3倍数额以内的部分，免征个人所得税；超过3倍数额的部分，不并入当年综合所得，单独适用综合所得税率表，计算纳税。具体看各地的税收政策，最好咨询专业法律人士。</p><h1 id="如何收集对自己有利的证据"><a href="#如何收集对自己有利的证据" class="headerlink" title="如何收集对自己有利的证据"></a>如何收集对自己有利的证据</h1><p>在争取赔偿金的过程中，收集对自己有利的证据至关重要。以下是一些可能的证据：</p><ul><li><strong>劳动合同</strong>，这是证明你和公司之间劳动关系的最直接证据。</li><li><strong>工资单</strong>，可以证明你的工资水平，从而影响赔偿金的计算。</li><li>任何与裁员相关的<strong>书面文件</strong>，比如裁员通知，可以证明裁员的事实。</li><li>与同事的<strong>通信记录</strong>，如果有同事证明你的工作情况，也可以作为证据。</li></ul><p>证据的收集这块，还是需要有<strong>专业律师指导</strong>才行，因为涉及很多领域知识，普通人可能没有很好的意识。</p><h1 id="法律诉讼流程"><a href="#法律诉讼流程" class="headerlink" title="法律诉讼流程"></a>法律诉讼流程</h1><p>如果公司拒绝支付合法的赔偿金，你可以通过法律诉讼来争取自己的权益。以下是大致的流程。</p><h2 id="劳动仲裁"><a href="#劳动仲裁" class="headerlink" title="劳动仲裁"></a>劳动仲裁</h2><ol><li>提交仲裁申请，你需要向当地的劳动争议仲裁委员会提交仲裁申请，你需要在申请中详细说明你的情况和你的要求。</li><li>仲裁庭审，仲裁委员会会组织庭审，你需要在庭审中提供你的证据。</li><li>仲裁裁决，仲裁委员会会根据庭审的情况作出裁决。</li></ol><p>整个流程可能需要几个月到一年的时间，具体取决于你所在地的法律环境。如果你对劳动仲裁委员会的其他裁决结果不满意，可以在接到裁决书的15日内向人民法院提起诉讼。但是仲裁裁决也有部分<strong>一裁终局</strong>的情况，大概率没法起诉了。</p><h2 id="法律诉讼"><a href="#法律诉讼" class="headerlink" title="法律诉讼"></a>法律诉讼</h2><p>你需要向法院提交相关的证据和材料，包括劳动合同、工资单、工时记录等证据以及劳动仲裁的裁决书等。</p><p>以下是法律诉讼的基本流程：</p><ol><li>提起诉讼，提交相关证据和材料到人民法院。</li><li>人民法院接受案件并立案。</li><li>开庭审理，法官审理案件，双方出庭陈述和辩论。</li><li>判决：法官根据评估的证据和论点作出判决，并公布判决结果。</li><li>执行判决，根据判决结果执行。</li></ol><p>如果对判决结果不满意，可以选择上诉，向上级人民法院提交上诉材料，如果上级法院没有驳回（<strong>小概率</strong>），然后还是上面的几个步骤。</p><p>诉讼的具体时间，这很难确定，因为它取决于许多因素，包括案件的复杂性、法院的日程安排、证据的收集和评估等。在一些简单的案件中，诉讼可能只需要几个月的时间。然而，在更复杂或争议较大的案件中，诉讼可能需要一年或更长的时间。如果涉及上诉，那么整个过程可能会更长。</p><p>此外如果你认为用人单位违反了劳动法规，你可以向当地的劳动保障部门报告。他们有权利对用人单位进行调查和处罚。</p><h1 id="如何应对公司的威胁"><a href="#如何应对公司的威胁" class="headerlink" title="如何应对公司的威胁"></a>如何应对公司的威胁</h1><p>如果公司威胁你，比如说如果你走法律流程的话不给办理离职证明，或者去下家公司告状，你应该保持冷静，并记住以下几点：</p><ul><li>不要因为公司的威胁而放弃你的权益，你有权利通过法律途径争取你的权益。</li><li>如果公司拒绝给你办理离职证明，你可以向劳动监察部门投诉，离职证明是你的合法权益，公司无权拒绝。就算没有离职证明也没关系，裁决或判决也有同等效力，不会影响入职。</li><li>如果公司去你的下家公司告状，你可以向法院申请禁止公司的这种行为，这种行为可能构成侵犯你的名誉权。</li></ul><p>总的来说，面对公司的威胁，你应该坚持你的权益，不要被威胁所吓倒。同时，你也可以寻求专业律师的帮助，他们可以为你提供更专业的建议。</p><h1 id="AI-离法律助手还差多远"><a href="#AI-离法律助手还差多远" class="headerlink" title="AI 离法律助手还差多远"></a>AI 离法律助手还差多远</h1><p>本文大部分内容由 AI 生成，<strong>由专业律师 <a href="/links">小盛律师</a> 审核</strong>。AI 给的解答里，部分关键信息出现了很离谱的错误。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230606_gpt_lawer_helper.png" alt="GPT 给出的错误法律建议: 年限计算错误"></p><p>还有这个基数计算错误：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230606_gpt_lawer_helper2.png" alt="GPT 给出的错误法律建议: 赔偿基数计算错误"></p><p style="color:red;">如果你有任何疑问，建议你咨询本人强烈推荐的<b><a href="/links">小盛律师</a></b></p>]]></content>
    
    
    <summary type="html">如何在被裁员后争取合法赔偿？这篇文章提供了详细的指南，包括中国劳动法对裁员赔偿的规定，收集有利证据的方法，法律诉讼流程，以及如何应对公司的威胁。让你在争取权益的过程中，有法可依，步步为营。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="法律" scheme="https://selfboot.cn/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 解 Leetcode 题目：判断是否一条直线</title>
    <link href="https://selfboot.cn/2023/06/05/gpt4_leetcode_1232/"/>
    <id>https://selfboot.cn/2023/06/05/gpt4_leetcode_1232/</id>
    <published>2023-06-05T21:53:26.000Z</published>
    <updated>2023-07-02T14:41:18.181Z</updated>
    
    <content type="html"><![CDATA[<p>在当今的数字化世界中，人工智能和机器学习正在改变我们学习和解决问题的方式。特别是在算法学习领域，OpenAI 的 GPT-4 模型已经展示了其强大的能力。这个模型可以理解复杂的问题，提供深入的解答，甚至帮助编写代码。这为学习者打开了一扇新的大门，使他们能够更有效地理解和掌握算法。在这篇博客中，我们将探讨 GPT-4 如何帮助我们解决一个具体的算法问题。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230605_gpt4_leetcode_1232.png" alt="GPT 解决 Leetcode 算法题"></p><blockquote><p>这里用了 Webpolit 和  Showme 插件, 完整的对话可以见<a href="https://chat.openai.com/share/f8bd50fe-593d-461c-8ecd-d7fe75e79e45">这里</a>。</p></blockquote><span id="more"></span><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p><strong>Human:</strong><br>请仔细看下面的题目，然后给出代码来解决题目。题目在 <a href="https://leetcode.com/problems/check-if-it-is-a-straight-line/%EF%BC%8C%E8%AF%B7%E8%A1%A5%E5%85%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">https://leetcode.com/problems/check-if-it-is-a-straight-line/，请补全下面的代码实现</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ChatGPT:</strong><br>这是一个在二维平面上检查给定点是否在一条直线上的问题。我们可以通过计算两点之间的斜率来解决这个问题。如果所有相邻点之间的斜率都相同，那么这些点就在一条直线上。</p><p>这是一个可能的 C++ 解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = coordinates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> xDiff = coordinates[<span class="number">1</span>][<span class="number">0</span>] - coordinates[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// Difference in x</span></span><br><span class="line">        <span class="type">int</span> yDiff = coordinates[<span class="number">1</span>][<span class="number">1</span>] - coordinates[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// Difference in y</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> pt = coordinates[i];</span><br><span class="line">            <span class="comment">// If the slopes are not equal then return false</span></span><br><span class="line">            <span class="keyword">if</span>(xDiff * (pt[<span class="number">1</span>] - coordinates[<span class="number">0</span>][<span class="number">1</span>]) != yDiff * (pt[<span class="number">0</span>] - coordinates[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个解决方案首先计算前两个点的斜率，然后检查其余的点是否具有相同的斜率。如果有任何一个点的斜率与前两个点的斜率不同，那么函数就会返回 false。如果所有的点都有相同的斜率，那么函数就会返回 true。</p><p>注意，<strong>这个解决方案假设输入的点的数量至少为2，因为至少需要两个点来定义一条直线</strong>。如果输入的点的数量少于2，那么这个函数可能会出现问题。</p><blockquote><p>看了下代码基本没问题，提交 Leetcode ，直接 Accepted</p></blockquote><hr><p><strong>Human:</strong><br>这个实现的时间复杂度是多少呢？</p><p><strong>ChatGPT:</strong><br>这个实现的时间复杂度是 O(n)，其中 n 是坐标数组的长度。</p><p>原因是我们需要遍历一次输入的坐标数组，以检查所有相邻点之间的斜率是否相同。在这个过程中，每个点都被访问一次，因此时间复杂度是线性的。</p><p>这是最优的时间复杂度，因为我们必须至少查看一次每个点来确定它们是否在同一直线上。</p><blockquote><p>直接补充说这个是最优的时间复杂度，这一点我们也并没有问，不过这个补充很好。</p></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p><strong>Human:</strong><br>现在有一个小学生碰见这个题目，没有一点思路，你可以给他讲解下你的思考步骤，让他下次遇见类似的题目能想到解决方案吗》</p><p><strong>ChatGPT:</strong><br>好的，让我们一步一步来解决这个问题。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230605_gpt4_leetcode_1232_method.png" alt="GPT 的解题思考步骤"></p><p>首先，你需要理解问题的要求。这个问题是在二维平面上，给你一些点的坐标，你需要判断这些点是否在一条直线上。你可以这样思考：</p><ol><li>观察问题：看看题目给的信息，这里是一些点的坐标。</li><li>理解问题：你需要判断这些点是否在一条直线上。</li><li>找出解决问题的关键：你可能会想，什么样的点在一条直线上呢？如果你记得数学课上学的，两点确定一条直线，而且在一条直线上的点，它们之间的斜率是相同的。斜率是什么呢？就是垂直距离（y）除以水平距离（x）。所以，你可以通过计算斜率来判断这些点是否在一条直线上。</li><li>编写代码：现在你可以开始写代码了。你可以先计算前两个点的斜率，然后看看其他的点是不是和这两个点有相同的斜率。</li><li>测试代码：最后，你需要测试你的代码，看看它是否能正确地解决问题。</li></ol><p>这就是解决这个问题的思考步骤。下次你遇到类似的问题，也可以试试这样的步骤。</p><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p><strong>Human:</strong><br>你可以给上面的实现写一段测试代码吗？</p><p><strong>ChatGPT:</strong><br>当然可以。以下是一段测试这个函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test case 1: Points are on a straight line</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; coordinates1 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>&#125;, &#123;<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    <span class="type">bool</span> result1 = solution.<span class="built_in">checkStraightLine</span>(coordinates1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Test case 1 result: &quot;</span> &lt;&lt; (result1 ? <span class="string">&quot;True&quot;</span> : <span class="string">&quot;False&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test case 2: Points are not on a straight line</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; coordinates2 = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>&#125;, &#123;<span class="number">7</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    <span class="type">bool</span> result2 = solution.<span class="built_in">checkStraightLine</span>(coordinates2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Test case 2 result: &quot;</span> &lt;&lt; (result2 ? <span class="string">&quot;True&quot;</span> : <span class="string">&quot;False&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码创建了一个 Solution 对象，并使用两个测试用例来测试 checkStraightLine 函数。第一个测试用例的所有点都在一条直线上，所以预期的结果是 True。第二个测试用例的点不在一条直线上，所以预期的结果是 False。测试代码将实际的结果打印出来，这样你就可以看到函数是否按预期工作。</p>]]></content>
    
    
    <summary type="html">这篇博客详细讨论了如何利用 OpenAI 的 GPT-4 模型来学习和解决算法问题。我们以一个具体的例子——在二维平面上判断一组点是否在同一直线上的问题为例，展示了 GPT-4 如何提供解决方案，编写代码，以及进行代码测试。此外，我们还讨论了 GPT-4 如何帮助我们理解问题，找出解决问题的关键，以及编写和测试代码。这篇博客是对 GPT-4 在算法学习中应用的深入探讨，对于想要了解人工智能如何改变我们学习方式的读者来说，这是一篇必读的文章。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Leetcode" scheme="https://selfboot.cn/tags/Leetcode/"/>
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="Plugin" scheme="https://selfboot.cn/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 帮忙写 sed, awk 数据处理命令</title>
    <link href="https://selfboot.cn/2023/06/05/gpt4_write_cmd/"/>
    <id>https://selfboot.cn/2023/06/05/gpt4_write_cmd/</id>
    <published>2023-06-05T21:30:15.000Z</published>
    <updated>2023-07-02T14:41:18.181Z</updated>
    
    <content type="html"><![CDATA[<p>AWK 和 SED 在处理文本数据时，无论是过滤、转换，还是操作，都展现出了无与伦比的效率和灵活性。但是工具的语法不是那么好记忆，有时候用起来还得去查看帮助文档。但是有了 GPT，直接描述具体想处理的任务内容，然后由 GPT 生成所需要的命令，十分方便。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230605_gpt4_write_cmd.png" alt="GPT 直接纠正有问题的 awk 命令"></p><span id="more"></span><h1 id="awk-统计"><a href="#awk-统计" class="headerlink" title="awk 统计"></a>awk 统计</h1><p><strong>Human:</strong><br>把下面脚本改对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt  | grep &#x27;8:1&#x27; | awk &#x27;&#123;print $7&#125;&#x27; | awk -F &#x27;:&#x27; &#x27;if($2&gt;=1683993600 and $2&lt;=1685808000) &#123;print $0&#125;&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>这里每次写老是记不住语法，总要去看看文档才行。有了 GPT 就方便多了，直接让他纠错。这里甚至都不用给他背景，他能自动发现你的问题并修复的。</p></blockquote><p><strong>ChatGPT:</strong><br>你的脚本中的问题在于 <code>awk</code> 的 if 语句的语法不正确。awk 的 if 语句应该在 <code>&#123;&#125;</code> 内部，并且 if 语句后面应该直接跟条件，然后是动作。所以，你的脚本应该修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep &#x27;8:1&#x27; | awk &#x27;&#123;print $7&#125;&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;if($2&gt;=1683993600 &amp;&amp; $2&lt;=1685808000) print $0&#125;&#x27;</span><br></pre></td></tr></table></figure><p>这个脚本的意思是：</p><ol><li>从 data.txt 文件中读取数据。</li><li>使用 grep 命令查找包含 ‘8:1’ 的行。</li><li>使用 awk 命令打印出每行的第7个字段。</li><li>使用 awk 命令，以 : 为分隔符，如果第2个字段的值在 1683993600 和 1685808000 之间，则打印出整行。</li></ol><hr><p><strong>Human:</strong><br>我想让上面的过滤脚本，在最后显示整行的内容，要怎么重新写 脚本</p><p><strong>ChatGPT:</strong><br>如果你希望在最后显示整行的内容，你需要在第一次使用 awk 命令时就进行条件判断。这样你可以在满足条件时打印整行，而不仅仅是第7个字段。你可以这样修改你的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep &#x27;8:1&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;if($7&gt;=1683993600 &amp;&amp; $7&lt;=1685808000) print $0&#125;&#x27;</span><br></pre></td></tr></table></figure><p>这个脚本的意思是：</p><ol><li>从 data.txt 文件中读取数据。</li><li>使用 grep 命令查找包含 ‘8:1’ 的行。</li><li>使用 awk 命令，以 : 为分隔符，如果第7个字段的值在 1683993600 和 1685808000 之间，则打印出整行。</li></ol><p>这样，你就可以在满足条件时看到整行的内容了。</p><hr><p><strong>Human:</strong><br>可以帮我再按照第 7 列的数据倒序排序吗</p><p><strong>ChatGPT:</strong><br>当然可以，你可以使用 sort 命令对第7列的数据进行倒序排序。这里是修改后的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep &#x27;8:1&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;if($7&gt;=1683993600 &amp;&amp; $7&lt;=1685808000) print $0&#125;&#x27; | sort -t &#x27;:&#x27; -k7 -nr</span><br></pre></td></tr></table></figure><p>这个脚本的意思是：</p><ol><li>从 data.txt 文件中读取数据。</li><li>使用 grep 命令查找包含 ‘8:1’ 的行。</li><li>使用 awk 命令，以 : 为分隔符，如果第7个字段的值在 1683993600 和 1685808000 之间，则打印出整行。</li><li>使用 sort 命令，以 : 为分隔符，对第7列进行倒序排序（-nr 表示数值排序并且是倒序）。</li></ol><p>这样，你就可以看到满足条件的行，并且这些行是按照第7列的值进行倒序排序的。</p><hr><p><strong>Human:</strong>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep &#x27;8:1&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;if($7&gt;=1683993600 &amp;&amp; $7&lt;=1685808000) print $0&#125;&#x27; | sort -t &#x27;:&#x27; -k7 -nr</span><br></pre></td></tr></table></figure><p>我想改下上面的脚本，计算满足上面过滤条件的数据中，第 2 列数字的和</p><p><strong>ChatGPT:</strong><br>如果你想计算满足过滤条件的数据中，第2列数字的和，你可以使用 awk 命令来实现。这里是修改后的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep &#x27;8:1&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;if($7&gt;=1683993600 &amp;&amp; $7&lt;=1685808000) sum+=$2&#125; END &#123;print sum&#125;&#x27;</span><br></pre></td></tr></table></figure><p>这个脚本的意思是：</p><ol><li>从 data.txt 文件中读取数据。</li><li>使用 grep 命令查找包含 ‘8:1’ 的行。</li><li>使用 awk 命令，以 : 为分隔符，如果第7个字段的值在 1683993600 和 1685808000 之间，则将第2个字段的值加到 sum 变量上。</li><li>在所有行处理完毕后，打印出 sum 变量的值，即第2列数字的和。</li></ol><p>这样，你就可以计算出满足条件的数据中，第2列数字的和了。</p><blockquote><p>可以看到 GPT 使用 awk 是炉火纯青，基本手到擒来，很是方便。 </p></blockquote><h1 id="sed-文本处理"><a href="#sed-文本处理" class="headerlink" title="sed 文本处理"></a>sed 文本处理</h1><p><strong>Human:</strong><br>有一个很大的文本文件，我想删除中间的第 5 行，用什么命令可以完成呢</p><p><strong>ChatGPT:</strong><br>如果你想删除一个文本文件中的特定行，你可以使用 <code>sed</code> 命令。sed 是一个流编辑器，可以用来对输入流（文件或管道）进行基于行的编辑。</p><p>如果你想删除第5行，你可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;5d&#x27; filename</span><br></pre></td></tr></table></figure><p>这个命令的意思是：</p><ol><li>-i：这个选项告诉 sed 对文件进行原地编辑，也就是说，修改会直接反映到文件上。</li><li>‘5d’：这是 sed 的命令，表示删除第5行。</li><li>filename：这是你要编辑的文件的名称。</li></ol><p>请注意，这个命令会直接修改文件，所以在运行之前，你可能需要备份你的文件。如果你不想直接修改文件，你可以去掉 <code>-i</code> 选项，这样 sed 会将修改的结果输出到标准输出，而不会改变原文件。</p><hr><p><strong>Human:</strong><br>我有一个文本文件，如下示例<br>Timestamp       Category        Message<br>1598843202      INFO    Booting up system<br>1598843402      INFO    Booting up critical service: Authorization<br>1598843502      INFO    System booted successfully</p><p>我想把里面的  INFO  改为  DEBUG，用什么命令来完成呢</p><p><strong>ChatGPT:</strong><br>如果你想在一个文本文件中替换某个字符串，你可以使用 sed 命令。<code>sed</code> 是一个流编辑器，可以用来对输入流（文件或管道）进行基于行的编辑。</p><p>如果你想将所有的 “INFO” 替换为 “DEBUG”，你可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/INFO/DEBUG/g&#x27; filename</span><br></pre></td></tr></table></figure><p>这个命令的意思是：</p><ol><li>-i：这个选项告诉 sed 对文件进行原地编辑，也就是说，修改会直接反映到文件上。</li><li>‘s&#x2F;INFO&#x2F;DEBUG&#x2F;g’：这是 sed 的命令，表示将所有的 “INFO” 替换为 “DEBUG”。</li><li>filename：这是你要编辑的文件的名称。</li></ol><p>请注意，这个命令会直接修改文件，所以在运行之前，你可能需要备份你的文件。如果你不想直接修改文件，你可以去掉 -i 选项，这样 sed 会将修改的结果输出到标准输出，而不会改变原文件。</p><hr><p><strong>Human:</strong><br>sed 还可以用来完成什么复杂的文本操作</p><p><strong>ChatGPT:</strong>  </p><p>sed 是一个非常强大的文本处理工具，它可以用来执行各种复杂的文本操作。以下是一些 sed 可以完成的操作：</p><ol><li>查找和替换：这可能是 sed 最常见的用途。你可以使用 sed 来查找并替换文件中的文本，就像我们在上面的例子中所做的那样。</li><li>删除行：你可以使用 sed 来删除文件中的特定行，或者删除匹配特定模式的行。</li><li>插入和追加文本：你可以使用 sed 在文件的特定位置插入或追加文本。</li><li>修改行：你可以使用 sed 修改文件中的特定行。</li><li>打印特定行：你可以使用 sed 打印文件中的特定行。</li><li>多点编辑：你可以在一个 sed 命令中执行多个编辑操作。</li><li>正则表达式匹配：sed 支持正则表达式，这使得你可以执行复杂的文本匹配和操作。</li><li>脚本化：你可以将一系列 sed 命令写入一个脚本文件中，然后使用 sed -f 命令来执行这个脚本。</li></ol><p>这只是 sed 可以做的一些基本操作，实际上 sed 的功能远不止这些。如果你想深入了解 sed，我建议你查阅 sed 的手册或者其他相关的教程。</p>]]></content>
    
    
    <summary type="html">在这篇博客中，我们将探索如何利用 AWK 和 SED 进行复杂的文本处理，同时展示了如何使用 OpenAI 的 GPT-4 模型来帮助我们编写命令和解决问题。我们将深入解析各种实际示例，包括如何过滤和排序数据，如何进行文本替换，以及如何删除或修改特定行。这篇文章不仅为你提供了深入理解 AWK 和 SED 的机会，还展示了人工智能如何帮助我们更有效地进行编程和数据处理。</summary>
    
    
    
    <category term="工具介绍" scheme="https://selfboot.cn/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
  </entry>
  
  <entry>
    <title>Mac 图片自动压缩上传 COS</title>
    <link href="https://selfboot.cn/2023/06/02/auto_compress_upload/"/>
    <id>https://selfboot.cn/2023/06/02/auto_compress_upload/</id>
    <published>2023-06-02T19:36:08.000Z</published>
    <updated>2023-07-02T14:41:18.181Z</updated>
    
    <content type="html"><![CDATA[<p>把个人博客放在了 netilfy 托管，它给了一个优化建议，可以压缩图片节省带宽。但是每次截图后都要再压缩下图片有点麻烦，于是想着应该可以<strong>偷偷懒</strong>。目标很明确，截图后图片传到我的 git 仓库 images 目录后，能给我自动压缩，并且上传 COS，这样我就只用在 markdown 文件里面拼链接就好了。</p><p>打开 Web Browsing 功能的  GPT4，让他帮忙实现吧。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_auto_compress_upload_gpt.png" alt="GPT 自动化工具"></p><h1 id="监听文件并压缩"><a href="#监听文件并压缩" class="headerlink" title="监听文件并压缩"></a>监听文件并压缩</h1><p><strong>Human:</strong><br>在 mac 上，我有一个目录，想在目录里面添加文件的时候，自动对图片进行压缩，替换原来的文件。要怎么实现呢？</p><p><strong>ChatGPT:</strong><br>你可以通过使用 Automator（自动操作程序）来实现这个功能。Automator 是 Mac OS X 提供的一种强大工具，能帮助你自动执行各种任务。</p><p>以下是设置步骤：</p><ol><li>打开 Automator（位于“应用程序”文件夹中）。</li><li>点击“新建文稿”，然后选择“文件夹操作”。</li><li>在弹出的窗口中，选择你要监视的文件夹。</li><li>在左侧面板中，找到并双击“缩放图片”。</li><li>在弹出的对话框中，设置你希望的图片大小。</li><li>另外，你可能需要添加一个“复制 Finder 项目”操作，将原始图片复制到另一个地方，以防万一。你可以在左侧面板中找到并双击它。</li><li>最后，保存你的 Automator 工作流程。</li></ol><p>这样，每当你向该文件夹添加图片时，Automator 都会自动将其缩放到你指定的大小，然后替换原来的图片。请注意，这个方法会覆盖原始图片，因此如果你不想丢失原始图片，最好先做好备份。</p><hr><p><strong>Human:</strong><br>这里我想用 <a href="https://imageoptim.com/command-line.html">https://imageoptim.com/command-line.html</a> 中提到的ImageOptim 来压缩图片，要怎么做呢</p><p><strong>ChatGPT:</strong><br>在使用 ImageOptim 命令行工具前，你需要先确保它已经安装在你的 Mac 上。你可以通过以下命令安装它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g imageoptim-cli</span><br></pre></td></tr></table></figure><p>然后，你可以在 Automator（自动操作程序）中使用 Shell 脚本来调用 ImageOptim。以下是具体步骤：</p><ol><li>打开 Automator（位于“应用程序”文件夹中）。</li><li>点击“新建文稿”，然后选择“文件夹操作”。</li><li>在弹出的窗口中，选择你要监视的文件夹。</li><li>在左侧面板中，找到并双击“运行 Shell 脚本”。</li><li>在弹出的对话框中，输入以下命令： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for f in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    /usr/local/bin/imageoptim &quot;$f&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li>最后，保存你的 Automator 工作流程。</li></ol><p>这样，每当你向该文件夹添加图片时，Automator 就会自动调用 ImageOptim 命令行工具对其进行压缩，并替换原来的文件。</p><p>请注意，这个方法会覆盖原始图片，因此如果你不想丢失原始图片，最好先做好备份。</p><p>也请注意，这个脚本假设你的 ImageOptim 命令行工具是通过 npm 安装的，且安装位置在 <code>/usr/local/bin/</code>。如果你的安装位置不同，你需要修改脚本中的路径。</p><hr><p><strong>Human:</strong><br>我按照上面方法保存Automator之后，往步骤 3 里面的文件夹加了一个图片，但是并没有被压缩，是怎么回事呢？</p><p><strong>ChatGPT:</strong><br>这可能有几个原因，我们可以进行以下排查：</p><ol><li>确认你的 Automator 文件夹操作是否正确保存，并且指定的是正确的文件夹。</li><li>确认在 Automator 工作流程中添加的 “运行 Shell 脚本” 操作里的命令是否正确。特别要注意 ImageOptim 命令行工具的路径是否正确。</li><li>查看是否有权限问题。你可能需要给 Automator 工作流程足够的权限来修改文件夹中的图片。</li><li>最后，确保 ImageOptim CLI 工具已经正确安装，并可以在 Terminal（终端）中直接运行。</li></ol><p>如果以上步骤都无法解决问题，你可以尝试在 Automator 的 “运行 Shell 脚本” 操作中添加一些调试代码，例如在命令中添加 echo “$f” 来查看正在处理的文件路径，或者在命令最后添加 2&gt; &#x2F;path&#x2F;to&#x2F;error.log 来将可能的错误输出到一个日志文件。</p><blockquote><p>这里真的超出预期了，直接教你打日志来排查问题，有点专业工程师的感觉。</p></blockquote><hr><p><strong>Human:</strong><br>我加了 <code>2&gt; /path/to/error.log</code>，但是没有任何日志输出</p><p><strong>ChatGPT:</strong><br>如果没有任何日志输出，这可能表明你的 Automator 工作流程没有被正确触发，或者 “运行 Shell 脚本” 操作没有被正确执行。</p><p>我建议你首先检查你的 Automator 工作流程是否被正确保存，并且关联到了正确的文件夹。你可以尝试重新创建一个新的文件夹操作，以确保所有的设置都是正确的。</p><p>然后，你可以在 “运行 Shell 脚本” 操作中添加一些简单的调试代码，例如 <code>echo &quot;Hello, world!&quot; &gt; /path/to/debug.log</code>。然后再添加一个新的图片到文件夹中，看看是否有任何输出。</p><p>如果这个简单的测试也不能工作，那么问题可能出在 Automator 或者你的系统设置上。你可以检查你的系统设置，确保 Automator 有足够的权限来监视文件夹和修改文件。你也可以尝试在 Automator 中创建一个新的文件夹操作，看看是否有其他的操作能够被正确触发。</p><p>如果这个简单的测试可以工作，那么问题可能出在 ImageOptim CLI 工具或者你的 Shell 脚本上。你可以在 Terminal（终端）中手动运行相同的 ImageOptim 命令，看看是否有任何错误。</p><hr><p><strong>Human:</strong><br>我的  shell  如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello, world!&quot; &gt;&gt; ~/Desktop/error.log</span><br><span class="line">for f in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    /Users/daemonzhao/.nvm/versions/node/v20.2.0/bin/imageoptim &quot;$f&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">2&gt;&gt; ~/Desktop/error.log</span><br></pre></td></tr></table></figure><p>这里 error.log 只输出了 <code>Hello, world!</code> ，<code>$@</code> 应该是空值。</p><blockquote><p>这里后面又有几轮聊天，GPT4 开始并没有给出一个正确的答案。不过我们可以信任 GPT、然后验证 GPT 的内容。</p></blockquote><h1 id="换-Apple-Script"><a href="#换-Apple-Script" class="headerlink" title="换 Apple Script"></a>换 Apple Script</h1><hr><p><strong>Human:</strong><br>Automator的 Folder Actions，如何成功拿到新添加的文件路径。上面你给出的方法拿不到，所以没法执行 shell 脚本</p><p><strong>ChatGPT:</strong><br>对不起刚刚的解答可能有些误导。在 Automator 的 “<strong>运行 Shell 脚本</strong>“ 操作中，”$@” 是代表所有的参数，而在 Folder Actions 中，这些参数就是新添加到文件夹的文件路径。</p><p>不过，如果你的脚本中 “$@” 是空的，那么可能是因为 Automator 并没有正确地将文件路径作为参数传递给 Shell 脚本。</p><p>为了解决这个问题，你可以尝试使用 AppleScript 而不是 Shell 脚本来获取文件路径。你可以在 Automator 中添加一个 “运行 AppleScript” 操作，然后使用以下的代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line">    <span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;Finder&quot;</span></span><br><span class="line">        <span class="keyword">set</span> filePath <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> (input <span class="keyword">as</span> <span class="built_in">alias</span>)</span><br><span class="line">        <span class="built_in">do shell script</span> <span class="string">&quot;/path/to/your/command &quot;</span> &amp; filePath</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>这个 AppleScript 脚本会将新添加到文件夹的文件路径作为 input 参数传递给 run 函数，然后使用 Finder 来获取文件的 POSIX 路径，最后执行你的 Shell 命令。</p><p>注意你需要将 &#x2F;path&#x2F;to&#x2F;your&#x2F;command 替换为你想要执行的 Shell 命令，比如 ImageOptim CLI 的路径。你也可以在 do shell script 命令中添加其他的参数，比如文件路径。</p><p>这是一个实例，你可以根据你的需要进行修改。希望这个方法能够解决你的问题！</p><blockquote><p>最开始让用  shell script，一直拿不到增加的文件，这次换了 apple script，一下子就拿成功了。</p></blockquote><hr><p><strong>Human:</strong><br>不能将“current application”转换为“alias”类型。</p><p><strong>ChatGPT:</strong><br>对不起，我犯了个错误。在 AppleScript 中，input 参数是一个列表，表示所有传递给脚本的文件。如果你想要处理每个文件，你需要使用一个循环。这是一个修改后的脚本：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line">    <span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">in</span> input</span><br><span class="line">        <span class="keyword">set</span> filePath <span class="keyword">to</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> i</span><br><span class="line">        <span class="built_in">do shell script</span> <span class="string">&quot;/path/to/your/command &quot;</span> &amp; <span class="keyword">quoted form</span> <span class="keyword">of</span> filePath</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>这个脚本会遍历所有传递给脚本的文件，获取每个文件的 POSIX 路径，然后执行你的 Shell 命令。注意 quoted form of filePath 是用来确保文件路径在传递给 Shell 命令时被正确引用，这对于含有空格或其他特殊字符的文件路径是必要的。</p><p>你需要将 <code>/path/to/your/command</code> 替换为你想要执行的 Shell 命令，比如 ImageOptim CLI 的路径。你也可以在 do shell script 命令中添加其他的参数，比如文件路径。</p><blockquote><p>这次终于成功了，但是压缩速度有点慢。</p></blockquote><h1 id="更换压缩工具"><a href="#更换压缩工具" class="headerlink" title="更换压缩工具"></a>更换压缩工具</h1><hr><p><strong>Human:</strong><br>除了 ImageOptim ，mac  上还有其他免费的工具可以压缩图片吗？要求有较快的速度和较高的无损压缩比。</p><p><strong>ChatGPT:</strong><br>在 Mac 上除了 ImageOptim，你还有以下一些免费的图片压缩工具可以选择：</p><ol><li>Preview：这是 Mac 自带的一个应用程序，可以用来压缩图片。你可以选择单个或多个图片来进行压缩，方法是打开 Preview，然后点击顶部菜单栏的“文件” &gt; “导出”。然后你可以选择图片的格式，并通过调整质量滑块来压缩图片<a href="https://www.idownloadblog.com/2022/01/04/how-to-compress-image-mac/">​1</a>​。</li><li>Mac 的 Photos 应用：你也可以使用 Mac 的 Photos 应用来压缩图片。你可以在 Photos 应用中选择一张或多张照片，然后按 Command + Shift + E 或从顶部菜单栏点击“文件” &gt; “导出” &gt; “导出照片”来压缩图片<a href="https://www.idownloadblog.com/2022/01/04/how-to-compress-image-mac/">​1</a>​。</li><li>图片压缩应用：Mac App Store 有许多可以压缩图片的应用。比如你可以在 App Store 中搜索“压缩图片”，就可以找到一些相关的应用<a href="https://www.idownloadblog.com/2022/01/04/how-to-compress-image-mac/%E2%80%8B1%E2%80%8B%E3%80%82">https://www.idownloadblog.com/2022/01/04/how-to-compress-image-mac/​1​。</a></li><li>在线图片压缩网站：你也可以选择使用在线的图片压缩服务，比如 iLoveIMG.com 和 ShortPixel.com。这些在线服务可以方便快捷地压缩图片，但你需要注意的是，你上传的图片会被存储在这些网站的服务器上，所以对于包含个人或敏感信息的图片，建议使用离线的压缩方法<a href="https://www.idownloadblog.com/2022/01/04/how-to-compress-image-mac/">​1​</a>。</li></ol><blockquote><p>这里用了 browsing 功能，GPT 自己去网上搜索。</p></blockquote><hr><p><strong>Human:</strong><br>我想找的是能在 mac 本地命令行运行的压缩图片工具，你有啥建议的</p><p><strong>ChatGPT:</strong><br>在 Mac 上，有一些命令行工具可以用来压缩图片：</p><ol><li>jpegoptim：这是一个用来优化和压缩 JPEG 图片的命令行工具。你可以使用 Homebrew 来安装它，命令是 brew install jpegoptim。压缩一个 JPEG 图片的命令是 jpegoptim –size&#x3D;100k your_image.jpg，这会将 your_image.jpg 压缩到 100KB 或更小的大小。</li><li>optipng：这是一个 PNG 图片优化工具，可以通过命令行使用。安装命令是 brew install optipng。使用 OptiPNG 压缩图片的命令是 optipng -o7 your_image.png，这会使用最高级别的优化选项来压缩 your_image.png。</li><li>pngquant：这是另一个用于 PNG 图片的命令行工具，可以创建具有少量颜色的优质 PNG 图片，从而大大减小文件大小。安装命令是 brew install pngquant。压缩 PNG 图片的命令是 <code>pngquant your_image.png</code>，这会创建一个新的，压缩后的 PNG 图片。</li></ol><p>所有这些工具都需要通过命令行来使用，并且可以在脚本中使用，以便于批量处理图片。但是请注意，每个工具都有其自己的一套参数和选项，你可能需要阅读各自的文档来更好地理解如何使用它们。</p><hr><p><strong>Human:</strong><br>我想用 pngquant，我用 <code>brew install pngquant</code> 安装后，如何更改 上面  apple script  的脚本呢</p><p><strong>ChatGPT:</strong><br>你可以将 AppleScript 脚本修改为如下形式，以使用 pngquant 工具：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> adding folder items <span class="keyword">to</span> this_folder <span class="keyword">after</span> receiving added_items</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        <span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;Terminal&quot;</span></span><br><span class="line">            <span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> <span class="built_in">number</span> <span class="keyword">of</span> items <span class="keyword">in</span> added_items</span><br><span class="line">                <span class="keyword">set</span> this_item <span class="keyword">to</span> <span class="built_in">item</span> i <span class="keyword">of</span> added_items</span><br><span class="line">                <span class="built_in">do shell script</span> <span class="string">&quot;/usr/local/bin/pngquant --force --ext .png &quot;</span> &amp; <span class="keyword">quoted form</span> <span class="keyword">of</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> this_item</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">try</span></span><br><span class="line"><span class="keyword">end</span> adding folder items <span class="keyword">to</span></span><br></pre></td></tr></table></figure><p>这段脚本在新的文件添加到文件夹时，会使用 <code>pngquant</code> 来压缩这些文件。–force 选项使得 pngquant 在文件已经存在时会覆盖它，而 –ext .png 选项会使得输出文件的扩展名为 .png。</p><p>请注意，你可能需要根据 pngquant 在你的系统上的实际安装位置来修改脚本中的 <code>/usr/local/bin/pngquant</code>。你可以通过在终端运行 which pngquant 命令来找到 pngquant 的实际路径。</p><p>同样，你需要根据实际情况来调整 pngquant 的参数。例如，如果你想要指定压缩级别，你可以添加 -quality 参数，如 –quality 60-80。你可以参考 pngquant 的文档来了解更多的参数和选项。</p><h1 id="添加图片前缀"><a href="#添加图片前缀" class="headerlink" title="添加图片前缀"></a>添加图片前缀</h1><hr><p><strong>Human:</strong><br>我想在脚本中改一下压缩后的文件名，在每个文件明前面加上日期前缀，比如20230601_ ，要怎么做呢？</p><p><strong>ChatGPT:</strong><br>为了实现这个功能，你需要获取当前日期，然后格式化为你需要的格式。然后，你可以将这个日期前缀添加到文件名中。你可以使用 <code>do shell script</code> 和 <code>date</code> 命令来获取和格式化日期，然后使用 <code>text item delimiters</code> 来修改文件名。以下是你可以尝试的 AppleScript：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;System Events&quot;</span></span><br><span class="line"><span class="keyword">set</span> currentDate <span class="keyword">to</span> <span class="built_in">do shell script</span> <span class="string">&quot;date &#x27;+%Y%m%d&#x27;&quot;</span></span><br><span class="line"><span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">in</span> input</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>这个脚本首先获取当前日期，并将其格式化为 “YYYYMMDD” 的形式。然后，对于每个输入文件，它检查扩展名是否为 “png”。如果是，它获取文件名，将其分解为基本名称和扩展名，然后将日期前缀添加到基本名称。然后，它将文件重命名为新的文件名，然后使用新的文件路径来执行 pngquant 命令。</p><blockquote><p>这里有坑，因为没写过apple script，也懒得去看代码。结果这里代码死循环添加前缀，中间和 GPT 交流了几轮，改了几遍代码，有点不顺。最后提示让 GPT 一步步来思考，竟然可以啦。</p></blockquote><hr><p><strong>Human:</strong><br>还是不行，你重新一步步思考下这个步骤，然后给出一个正确的代码</p><p><strong>ChatGPT:</strong><br>我明白你的问题了，确实是我之前的脚本存在问题。因为每次添加文件到文件夹，<code>Folder Action</code>都会触发一次，处理文件夹中所有的文件。如果同时添加了多个文件，这个<code>Folder Action</code>就会被多次触发，处理的对象包括已经处理过的文件，这就导致了问题。</p><p>我们可以修改脚本，使得它只处理那些没有被处理过的文件。具体来说，我们可以检查文件名是否已经包含了日期前缀，如果包含，我们就跳过这个文件。</p><p>另外，我们应该在压缩文件后立即重命名文件，而不是在压缩前。因为pngquant工具会直接覆盖原文件，如果我们先重命名再压缩，原文件就不会被压缩，而新文件会保留原来的大小。</p><p>下面是修改后的脚本：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line">    <span class="keyword">set</span> currentDate <span class="keyword">to</span> <span class="built_in">do shell script</span> <span class="string">&quot;date &#x27;+%Y%m%d&#x27;&quot;</span></span><br><span class="line">    <span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;System Events&quot;</span></span><br><span class="line">        <span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">in</span> input</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>这个脚本应该可以解决你的问题。它只会处理那些没有被处理过的.png文件，并且在压缩文件后立即重命名文件。同时添加的多个文件也不会造成问题。</p><blockquote><p>这次可以自动压缩重命名了，还想再自动传到 COS 上。</p></blockquote><h1 id="上传-COS"><a href="#上传-COS" class="headerlink" title="上传 COS"></a>上传 COS</h1><p><strong>Human:</strong><br>在上面的改名字和压缩步骤完成后，我想把图片传到 Tencent cos 的某一个 bucket 中，要怎么做呢？</p><p><strong>ChatGPT:</strong><br>首先，你需要在本地安装腾讯云的命令行工具 COSCMD，你可以使用以下命令进行安装：<code>pip install coscmd</code></p><p>然后，你需要配置你的COSCMD。运行以下命令并按照提示输入你的腾讯云 API 密钥（SecretId 和 SecretKey）以及你的地域（Region）和默认的存储桶（Bucket）：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coscmd config -a &lt;SecretId&gt; -s &lt;SecretKey&gt; -b &lt;Bucket&gt; -r &lt;Region&gt;</span><br></pre></td></tr></table></figure><p>在上面的命令中，<SecretId>，<SecretKey>，<Bucket> 和 <Region> 是你需要替换的部分。例如，你可能需要这样：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coscmd config -a AKIDxxxxxxxx -s xxxxxxxx -b mybucket<span class="number">-1250000000</span> -r ap-beijing</span><br></pre></td></tr></table></figure><p>现在，你可以在 AppleScript 中使用 do shell script 命令来调用 COSCMD 并将文件上传到你的存储桶中。你可以使用 coscmd upload 命令来上传文件，如下所示：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">do shell script</span> <span class="string">&quot;coscmd upload &quot;</span> &amp; <span class="keyword">quoted form</span> <span class="keyword">of</span> filePath &amp; <span class="string">&quot; /&quot;</span></span><br></pre></td></tr></table></figure><p>所以，你的 AppleScript 可能看起来像这样：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line">    <span class="keyword">set</span> currentDate <span class="keyword">to</span> <span class="built_in">do shell script</span> <span class="string">&quot;date &#x27;+%Y%m%d&#x27;&quot;</span></span><br><span class="line">    <span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;System Events&quot;</span></span><br><span class="line">        <span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">in</span> input</span><br><span class="line">            <span class="keyword">set</span> filePath <span class="keyword">to</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> i</span><br><span class="line">            <span class="keyword">set</span> fileExtension <span class="keyword">to</span> <span class="built_in">name</span> extension <span class="keyword">of</span> i</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>在这个脚本中，我们在重命名文件后获取新的文件路径，并将其上传到 COS。注意，你需要确保你的计算机上已经安装了 Python 和 pip，并且你的腾讯云 API 密钥、Bucket 和 Region 都是正确的。你还需要确保你的 Bucket 允许你上传文件。</p><blockquote><p>这里自己搞错了几个地方，不过 GPT 提示加了 log，然后也很快定位到了。</p></blockquote><h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><p>最终脚本如下:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line"><span class="keyword">set</span> currentDate <span class="keyword">to</span> <span class="built_in">do shell script</span> <span class="string">&quot;date &#x27;+%Y%m%d&#x27;&quot;</span></span><br><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;System Events&quot;</span></span><br><span class="line"><span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">in</span> input</span><br><span class="line"><span class="keyword">set</span> filePath <span class="keyword">to</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> i</span><br><span class="line"><span class="keyword">set</span> fileExtension <span class="keyword">to</span> <span class="built_in">name</span> extension <span class="keyword">of</span> i</span><br><span class="line"><span class="keyword">set</span> folderName <span class="keyword">to</span> <span class="built_in">do shell script</span> <span class="string">&quot;dirname &quot;</span> &amp; filePath</span><br><span class="line"><span class="keyword">if</span> fileExtension <span class="keyword">is</span> <span class="string">&quot;png&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> fileName <span class="keyword">to</span> <span class="built_in">name</span> <span class="keyword">of</span> i</span><br><span class="line"><span class="keyword">set</span> <span class="literal">AppleScript</span>&#x27;s <span class="literal">text item delimiters</span> <span class="keyword">to</span> <span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="keyword">set</span> baseName <span class="keyword">to</span> <span class="keyword">first</span> <span class="built_in">text</span> <span class="built_in">item</span> <span class="keyword">of</span> fileName</span><br><span class="line"><span class="keyword">if</span> baseName <span class="keyword">does</span> <span class="keyword">not</span> <span class="keyword">start with</span> currentDate <span class="keyword">then</span></span><br><span class="line"><span class="built_in">do shell script</span> <span class="string">&quot;/opt/homebrew/bin/pngquant --force --ext .png &quot;</span> &amp; <span class="keyword">quoted form</span> <span class="keyword">of</span> filePath</span><br><span class="line"><span class="keyword">set</span> newBaseName <span class="keyword">to</span> currentDate &amp; <span class="string">&quot;_&quot;</span> &amp; baseName</span><br><span class="line"><span class="keyword">set</span> newFileName <span class="keyword">to</span> newBaseName &amp; <span class="string">&quot;.&quot;</span> &amp; fileExtension</span><br><span class="line"><span class="keyword">set</span> <span class="built_in">name</span> <span class="keyword">of</span> i <span class="keyword">to</span> newFileName</span><br><span class="line"><span class="keyword">set</span> newFilePath <span class="keyword">to</span> folderName &amp; <span class="string">&quot;/&quot;</span> &amp; newFileName</span><br><span class="line"><span class="keyword">set</span> uploadCommand <span class="keyword">to</span> <span class="string">&quot;/opt/homebrew/Caskroom/miniconda/base/bin/coscmd upload &quot;</span> &amp; <span class="keyword">quoted form</span> <span class="keyword">of</span> newFilePath &amp; <span class="string">&quot; /&quot;</span></span><br><span class="line"><span class="built_in">do shell script</span> uploadCommand</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>实现的结果，指定一个目录，后面往这个目录新增加的 png，都自动压缩，在前缀加上当前日期，然后传输到腾讯云 COS 上。完整的对话在<a href="https://chat.openai.com/share/724a1870-7524-4ed7-be08-c22c2b4acfb3">这里</a>。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_auto_compress_upload_final.png" alt="最终自动化工具"></p>]]></content>
    
    
    <summary type="html">本篇文章详细讲解如何在 macOS 中通过 AppleScript 实现监控文件夹并自动进行图片压缩及文件重命名，最后上传到腾讯云 COS 的过程。涉及技术包括 AppleScript、pngquant 图片压缩工具以及腾讯云 COS 的命令行工具 coscmd。本教程适合对自动化文件处理感兴趣的 macOS 用户参考。</summary>
    
    
    
    <category term="工具介绍" scheme="https://selfboot.cn/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="教程" scheme="https://selfboot.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 plugin 来做数据分析</title>
    <link href="https://selfboot.cn/2023/06/01/gpt4_plugin_noteable/"/>
    <id>https://selfboot.cn/2023/06/01/gpt4_plugin_noteable/</id>
    <published>2023-06-01T13:16:35.000Z</published>
    <updated>2023-07-02T14:41:18.181Z</updated>
    
    <content type="html"><![CDATA[<p>GPT4 的部分插件还是能提高工作效率的，其中 noteable 可以写脚本绘制图，在数据分析领域还是很不错的。我们可以 AI 总结中国过去十年的出生人口趋势，可以分析用户留存率，或者找出某些日子都活跃的用户。</p><h1 id="人口趋势"><a href="#人口趋势" class="headerlink" title="人口趋势"></a>人口趋势</h1><p><strong>Human:</strong><br>统计下中国官方给的最近 10 年总出生人口，用 python 画一个曲线走势图。</p><p><strong>ChatGPT:</strong><br>好的，首先我们需要找到这些数据。这些数据可能来自中国的官方统计局或其他可靠的数据源。让我帮你找一下。</p><p>我在中国统计局的官方网站上没有直接找到过去十年的出生人口数据。可能需要在网站的不同部分或者在年度统计报告中进行深入搜索。另一种可能是这些数据可能需要在其他可靠的数据源中查找。你是否有推荐的数据源，或者我可以继续在中国统计局网站上进行深入搜索？</p><blockquote><p>这里用了插件 WebPilot，可以去网上搜索，目前用过的最好用的插件了。作者是一个产品经理，可以在<a href="https://twitter.com/CocoSgt_twt">这里</a>找他。不过这里没有找到相关数据，就自己去网上搜索了下，给他链接。</p></blockquote><hr><p><strong>Human:</strong><br>这里有，<a href="https://www.163.com/dy/article/HSAQ6SQ2055611U3.html">https://www.163.com/dy/article/HSAQ6SQ2055611U3.html</a> ，帮我用  python  画一个曲线走势图吧</p><p><strong>ChatGPT:</strong><br>这篇文章中包含了从1949年到2022年中国每年的出生人口数据。以下是最近十年的数据：</p><ul><li>2013年：1640万</li><li>2014年：1687万</li><li>2015年：1655万</li><li>2016年：1786万</li><li>2017年：1723万</li><li>2018年：1523万</li><li>2019年：1465万</li><li>2020年：1202万</li><li>2021年：1062万</li><li>2022年：956万</li></ul><p>接下来，我将使用这些数据创建一个Python notebook，并绘制出生人口的曲线走势图。</p><p>我已经创建了一个名为 “China_Birth_Rate_Analysis.ipynb” 的 Python notebook。你可以点击<a href="https://app.noteable.io/f/f033b7db-8516-4543-b085-447dc449b97f/China_Birth_Rate_Analysis.ipynb">这里</a>查看。</p><p>接下来，我将在 notebook 中添加一些 Python 代码来创建出生人口的曲线走势图。这是从2013年到2022年中国出生人口的曲线走势图：<br><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt4_plugin_noteable_analysis.png" alt="出生人口走势图"></p><p>从图中可以看出，中国的出生人口在2016年达到了峰值，之后开始逐年下降。</p><h1 id="计算留存"><a href="#计算留存" class="headerlink" title="计算留存"></a>计算留存</h1><blockquote><p>下面给他一个随便编的用户活跃天数记录，然后让 AI 计算留存；</p></blockquote><hr><p><strong>Human:</strong><br>这是一个记录用户活跃天数的表，第一列是用户 id，第二列是活跃日期，可以帮我写一个脚本，计算20230501号活跃的用户，在 20230502 和20230503日的留存率是多少吗？ 帮我画一个留存率的图。</p><p><strong>ChatGPT:</strong><br>当然可以。首先，我需要查看一下你的数据。你能提供一下数据的链接或者文件吗？</p><hr><p><strong>Human:</strong><br><a href="https://docs.google.com/spreadsheets/d/1b2HiAqlAQGRS2RMnI8ZbFD3i3dZu-Fv460Q6mh_cFLQ/edit#gid=0">https://docs.google.com/spreadsheets/d/1b2HiAqlAQGRS2RMnI8ZbFD3i3dZu-Fv460Q6mh_cFLQ/edit#gid=0</a></p><p><strong>ChatGPT:</strong><br>很抱歉，我无法直接访问 Google Sheets 文档。你能将数据下载为 CSV 文件并上传吗？或者，如果你愿意的话，我可以提供一段 Python 代码，你可以在本地运行来计算留存率。</p><hr><p><strong>Human:</strong><br>csv 文件在这里 <a href="https://docs.google.com/spreadsheets/d/1b2HiAqlAQGRS2RMnI8ZbFD3i3dZu-Fv460Q6mh_cFLQ/edit?usp=sharing">https://docs.google.com/spreadsheets/d/1b2HiAqlAQGRS2RMnI8ZbFD3i3dZu-Fv460Q6mh_cFLQ/edit?usp=sharing</a></p><p><strong>ChatGPT:</strong><br>很抱歉，我仍然无法直接访问 Google Sheets 文档的内容。你能将数据下载为 CSV 文件并上传吗？或者，如果你愿意的话，我可以提供一段 Python 代码，你可以在本地运行来计算留存率。</p><hr><p><strong>Human:</strong><br>抱歉，给错了，用新的这个<a href="https://drive.google.com/file/d/1Ax9tZcKQjlittBy9mA08NaZu2VadVEjx/view?usp=sharing">https://drive.google.com/file/d/1Ax9tZcKQjlittBy9mA08NaZu2VadVEjx/view?usp=sharing</a></p><p><strong>ChatGPT:</strong><br>很抱歉，我仍然无法直接访问 Google Drive 上的文件。然而，我可以提供一段 Python 代码，你可以在本地运行来计算留存率。这段代码假设你已经将数据下载为 CSV 文件，并且文件的路径是 ‘data.csv’。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将活跃日期转换为日期格式</span></span><br><span class="line">df[<span class="string">&#x27;活跃日期&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;活跃日期&#x27;</span>], <span class="built_in">format</span>=<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算20230501号活跃的用户</span></span><br><span class="line">active_users = df[df[<span class="string">&#x27;活跃日期&#x27;</span>] == <span class="string">&#x27;2023-05-01&#x27;</span>][<span class="string">&#x27;用户&#x27;</span>].unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算这些用户在20230502和20230503的活跃情况</span></span><br><span class="line">active_users_next_day = df[(df[<span class="string">&#x27;活跃日期&#x27;</span>] == <span class="string">&#x27;2023-05-02&#x27;</span>) &amp; (df[<span class="string">&#x27;用户&#x27;</span>].isin(active_users))][<span class="string">&#x27;用户&#x27;</span>].unique()</span><br><span class="line">active_users_next_two_days = df[(df[<span class="string">&#x27;活跃日期&#x27;</span>] == <span class="string">&#x27;2023-05-03&#x27;</span>) &amp; (df[<span class="string">&#x27;用户&#x27;</span>].isin(active_users))][<span class="string">&#x27;用户&#x27;</span>].unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算留存率</span></span><br><span class="line">retention_rate_next_day = <span class="built_in">len</span>(active_users_next_day) / <span class="built_in">len</span>(active_users)</span><br><span class="line">retention_rate_next_two_days = <span class="built_in">len</span>(active_users_next_two_days) / <span class="built_in">len</span>(active_users)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;20230502的留存率: <span class="subst">&#123;retention_rate_next_day * <span class="number">100</span>&#125;</span>%&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;20230503的留存率: <span class="subst">&#123;retention_rate_next_two_days * <span class="number">100</span>&#125;</span>%&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这段代码首先读取 CSV 文件中的数据，然后计算20230501号活跃的用户。然后，它查找这些用户在20230502和20230503的活跃情况，并计算留存率。最后，它打印出这两天的留存率。</p><blockquote><p>怪我，傻傻的一直给他 Google Drive 的链接，逼得 AI 自己写脚本处理本地文件了都。下面换一个 Tencent COS 上的文件链接。</p></blockquote><hr><p><strong>Human:</strong><br>你再试试这个链接 <a href="https://others-1251736664.cos.ap-guangzhou.myqcloud.com/Test%20-%20Sheet1.csv">https://others-1251736664.cos.ap-guangzhou.myqcloud.com/Test%20-%20Sheet1.csv</a> ，可以帮我写一个脚本，计算20230501号活跃的用户，在 20230502 和20230503日的留存率是多少吗？ 帮我画一个留存率的图。</p><p><strong>ChatGPT:</strong><br>好的，我已经成功获取到了数据。现在我将在 Python notebook 中添加一些代码来计算并绘制留存率。</p><p>根据数据，20230501号活跃的用户在20230502的留存率为33.33%，在20230503的留存率为66.67%。</p><p>接下来，我将在 notebook 中添加一些 Python 代码来创建留存率的图表。</p><p>这是20230501号活跃的用户在20230502和20230503的留存率图表：<br><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt4_plugin_noteable_analysis_2.png" alt="留存率曲线"></p><p>从图中可以看出，20230502的留存率为33.33%，20230503的留存率为66.67%。</p><hr><p><strong>Human:</strong><br>可以画一个留存率表格吗，用曲线不太合适。</p><p><strong>ChatGPT:</strong><br>这是20230501号活跃的用户在20230502和20230503的留存率表格：<br><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt4_plugin_noteable_analysis_3.png" alt="留存率表格"></p><hr><p><strong>Human:</strong><br>可以帮我找出在 3 天都活跃的用户，然后给出列表</p><p><strong>ChatGPT:</strong><br>在20230501、20230502和20230503这三天都活跃的用户是：3号、4号和7号用户。</p><p>在<a href="https://chat.openai.com/share/7d223aae-2976-447a-ad82-bcd69fc01f57">这里</a>可以查看完整对话。 </p>]]></content>
    
    
    <summary type="html">本文详细介绍如何利用 GPT4 的 noteable 插件进行数据分析，包括利用 AI 总结中国过去十年的出生人口趋势，分析用户留存率，以及找出某些日子都活跃的用户。让我们一起探索 AI 在数据分析中的应用，提高工作效率。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Plugin" scheme="https://selfboot.cn/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>神奇 Prompt 让 GPT4 化身物理老师</title>
    <link href="https://selfboot.cn/2023/05/31/gpt4_tutor_physics/"/>
    <id>https://selfboot.cn/2023/05/31/gpt4_tutor_physics/</id>
    <published>2023-05-31T10:03:57.000Z</published>
    <updated>2023-07-02T14:41:18.181Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://selfboot.cn/2023/05/26/gpt4_tutor_english/">神奇 Prompt 让 GPT4 化身英语老师</a>里，GPT 充当了我们的英语老师，这里我们再来看看万能 GPT 当物理老师的表现。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt_tutor_physics.png" alt="GPT4 物理老师"></p><p>首先同样是先喂 <a href="https://gist.githubusercontent.com/selfboot/1322b0f58882e7459b4842b997786e63/raw/7d33bc7e02bec43d77b1d06287b5963f3ce166cd/Mr_Ranedeer.md">prompt</a> 给 GPT 作为初始问题，指定 <code>/language 中文</code> 来设定语音，然后开启学习之旅。</p><h1 id="跟-AI-的学习计划"><a href="#跟-AI-的学习计划" class="headerlink" title="跟 AI 的学习计划"></a>跟 AI 的学习计划</h1><p><strong>Human:</strong><br>我想学习高中物理，沟通语气要严厉些。</p><p><strong>ChatGPT:</strong><br>好的，明白了。以下是你的配置偏好：</p><ul><li>🎯深度：高中水平</li><li>🧠学习方式：未指定</li><li>🗣️沟通风格：严厉</li><li>🌟语气风格：未指定</li><li>🔎推理框架：未指定</li><li>😀表情符号：✅</li><li>🌐语言：简体中文</li></ul><p>你希望用什么样的学习方式（感知、视觉、归纳、主动、序贯、直觉、口头、演绎、反思、全局）来学习？你喜欢什么样的语气风格（辩论、鼓励、中立、信息、友好）？你更喜欢哪种推理框架（演绎、归纳、假设、类比、因果）？</p><hr><p><strong>Human:</strong><br>反思，鼓励友好，演绎</p><p><strong>ChatGPT:</strong><br>非常好，现在我明白了你的偏好。以下是你的配置偏好：</p><ul><li>🎯深度：高中水平</li><li>🧠学习方式：反思</li><li>🗣️沟通风格：严厉</li><li>🌟语气风格：鼓励友好</li><li>🔎推理框架：演绎</li><li>😀表情符号：✅</li><li>🌐语言：简体中文</li></ul><p>接下来我将根据你的偏好为你制定一份学习计划。当你准备好开始学习时，只需输入 “&#x2F;start”。如果你需要对任何内容进行测试，可以输入 “&#x2F;test”。</p><hr><p><strong>Human:</strong><br>&#x2F;start</p><p><strong>ChatGPT:</strong><br>非常好！在开始我们的高中物理学习计划之前，让我先提醒自己你的配置偏好：</p><p>自我提醒：我将在高中水平的深度，反思的学习风格，严厉的沟通风格，鼓励友好的语气，演绎的推理框架，使用表情符号 ✅，以简体中文授课。</p><p>在这次课程中，我打算使用以下表情符号：⚛️（代表原子）, ⚡（代表电）, 🌡️（代表热量）。</p><p>由于你是高中水平，我假设你已经了解以下内容：</p><ol><li>基本的物理概念，如力、能量、功等。</li><li>基本的数学知识，如代数和几何。</li><li>牛顿的运动定律和基本的力学知识。</li></ol><p>接下来的高中学生课程计划如下：</p><ol><li>回顾基本物理概念和数学工具。</li><li>深入学习力学，包括动力学和静力学。</li><li>学习电磁学，包括静电学和电磁感应。</li><li>学习热学，包括热力学定律和热传递。</li><li>学习现代物理，包括量子物理和相对论的基础知识。</li></ol><p>现在，我们将从基本物理概念和数学工具开始。你准备好了吗？</p><hr><p><strong>Human:</strong><br>好了的</p><p><strong>ChatGPT:</strong><br>很好，让我们开始吧！💪</p><p>在这节课中，我计划使用以下表情符号：🔢（代表数字）、🔼（代表增加）和🔽（代表减少）。</p><p>自我提醒：我将在高中水平的深度，反思的学习风格，严厉的沟通风格，鼓励友好的语气，演绎的推理框架，使用表情符号 ✅，以简体中文授课。</p><p>在我们开始深入学习新的物理概念之前，我们首先需要掌握一些基础的数学工具。在物理中，我们经常需要进行一些基本的代数运算，如加法、减法、乘法和除法，以及一些更复杂的运算，如平方、平方根、对数和指数。🔢</p><p>我们还需要理解如何使用图形来表示和理解数据。在物理中，我们经常用图表来表示物体的运动状态，如位置、速度和加速度随时间的变化。📈</p><p>让我们通过一个简单的例子来回顾一下这些基础知识。</p><p>假设一个物体在直线上进行匀速运动。它在 t&#x3D;0 时的位置是 x&#x3D;0，速度是 v&#x3D;10 m&#x2F;s。那么它在 t&#x3D;1 s, 2 s, 3 s… 的位置会是多少呢？我们可以通过 x&#x3D;vt 公式来计算，其中 v 是速度，t 是时间。</p><p>在 t&#x3D;1 s 时，x &#x3D; 10 * 1 &#x3D; 10 m。<br>在 t&#x3D;2 s 时，x &#x3D; 10 * 2 &#x3D; 20 m。<br>在 t&#x3D;3 s 时，x &#x3D; 10 * 3 &#x3D; 30 m。<br>…<br>我们可以看到，物体的位置随着时间线性增加，这就是匀速直线运动的基本特征。🔼</p><p>我将画一个图形来表示这个运动过程。但是由于我目前无法使用插件，所以不能直接展示。然而，你可以试着自己画一个图，将时间作为 x 轴，将位置作为 y 轴，然后将每个时间点的位置标记在图上。你会发现所有的点都在一条直线上，这正是匀速直线运动的图形表示。</p><p>现在，我希望你能尝试一下。请在一张纸上画出这个图形，然后思考一下，如果物体的速度增加或减少，图形会有什么变化？</p><p>记住，你可以随时使用 “&#x2F;continue” 来继续课程，或者使用 “&#x2F;test” 来检查你的理解。</p><hr><p><strong>Human:</strong><br>&#x2F;continue</p><p><strong>ChatGPT:</strong><br>很好，我们继续。</p><p>在这节课中，我打算使用以下表情符号：➕（表示相加）、➖（表示相减）、✖️（表示相乘）和➗（表示相除）。</p><p>自我提醒：我将在高中水平的深度，反思的学习风格，严厉的沟通风格，鼓励友好的语气，演绎的推理框架，使用表情符号 ✅，以简体中文授课。</p><p>现在我们来探讨力的概念。力（F）可以理解为物体状态改变的原因。当一个物体的运动状态（静止或者运动）发生改变时，必然是因为有力作用于这个物体。</p><p>在物理中，力的基本单位是牛顿（N），而力的计算可以由以下公式得出：F &#x3D; ma。这里的 m 是质量，a 是加速度。</p><p>比如说，如果一个 10 公斤的物体受到了 20 牛顿的力，那么这个物体的加速度是多少呢？我们可以将已知数值代入公式进行计算：a &#x3D; F&#x2F;m &#x3D; 20N &#x2F; 10kg &#x3D; 2 m&#x2F;s²。这意味着，这个物体会以每秒增加 2 米的速度运动。➕✖️➗</p><p>你也可以看到，加速度是力和质量的函数。如果力增加，加速度也会增加；如果质量增加，加速度则会减少。这就是为什么重的物体比轻的物体更难以移动——因为需要更大的力来改变重物体的运动状态。</p><p>再来一个练习：假设一个 5 公斤的物体在水平地面上以 1 m&#x2F;s² 的加速度移动，那么作用在这个物体上的力是多少？</p><p>在下一节课中，我们将深入讨论力的效果和平衡力的概念。记住，你可以随时输入 “&#x2F;continue” 来继续我们的课程，或者输入 “&#x2F;test” 来检查你的理解。</p><hr><p><strong>Human:</strong><br>如何计算一艘船在水里承受的浮力呢？</p><p><strong>ChatGPT:</strong> </p><p>非常好的问题，这让我们有机会讨论阿基米德原理，它描述了在流体（如水或空气）中物体受到的浮力。🚣‍♀️⚖️</p><p>根据阿基米德原理，一个物体在流体中受到的向上的浮力等于这个物体排开的流体的重力。也就是说，如果你有一个物体完全或部分地沉入水中，它会受到一个等于它排开的水的重力的向上的力。这个力就是浮力。</p><p>所以，如果你要计算一艘船在水中的浮力，你需要知道船排开的水的体积。然后，你可以用下面的公式来计算浮力：</p><p>F &#x3D; ρ * V * g</p><p>其中：</p><ul><li>F 是浮力，</li><li>ρ 是水的密度（对于淡水，大约是 1000 kg&#x2F;m³），</li><li>V 是船排开的水的体积，单位是立方米（m³），</li><li>g 是重力加速度（约为 9.8 m&#x2F;s²）。</li></ul><p>所以，如果你知道一艘船排开了多少水，就可以计算出它在水中受到的浮力了。</p><p>希望这能回答你的问题。如有更多问题，请随时提问。当你准备好继续课程或者进行测试的时候，可以输入 “&#x2F;continue” 或 “&#x2F;test”。</p><hr><p><strong>Human:</strong><br>&#x2F;test</p><p><strong>ChatGPT:</strong><br>好的，现在我们进行一些测试。我将根据你的学习偏好和深度级别出题。✍️🔎</p><p>问题1️⃣：<br>一个物体在水平地面上以 2 m&#x2F;s² 的加速度移动，它的质量是 5 公斤。请计算作用在这个物体上的力。</p><p>问题2️⃣：<br>阿基米德原理是如何解释浮力的？</p><p>问题3️⃣：<br>一艘船排开了 20 立方米的水，海水的密度大约是 1025 kg&#x2F;m³，地球的重力加速度约为 9.8 m&#x2F;s²。请根据这些信息计算这艘船受到的浮力。</p><p>你可以花一些时间思考这些问题，然后将答案写在这里。如果你在计算过程中有任何困难，或者对题目有任何疑问，请随时向我提问。</p><h1 id="自由学习"><a href="#自由学习" class="headerlink" title="自由学习"></a>自由学习</h1><p><strong>Human:</strong><br>我想直接学习电学的知识，并且最好是家庭用电方面的，希望我学了后，能够明白家庭的电路设计和注意事项。</p><p><strong>ChatGPT:</strong><br>非常好，我理解你想要学习更具实际应用性的电学知识，特别是关于家庭用电方面的内容。根据你的要求，我会尽力提供相关的知识和信息。</p><p>自我提醒：我将在高中水平的深度，反思的学习风格，严厉的沟通风格，鼓励友好的语气，演绎的推理框架，使用表情符号 ✅，以简体中文授课。</p><p>以下是我为你规划的课程计划：<br>1️⃣ 电流、电压和电阻的基本概念<br>2️⃣ 家庭电路的基本设计：并联和串联<br>3️⃣ 家庭电器的功率和电能消耗<br>4️⃣ 家庭电路的安全注意事项</p><p>这个课程计划可以帮助你理解电学的基本概念，了解家庭电路的设计原理，计算电器的电能消耗，并且理解使用电器时需要注意的安全事项。</p><p>如果你对这个课程计划满意，请回复 “&#x2F;start” 开始课程，或者提供你希望我更改或添加的内容。</p><hr><p><strong>Human:</strong><br>直接给我讲讲 家庭电路的基本设计：并联和串联</p><p><strong>ChatGPT:</strong><br>好的，我们直接来讲解家庭电路的基本设计：并联和串联。</p><p>首先，我们先介绍一下并联和串联的概念：</p><p>🔸并联（Parallel）：在并联电路中，所有的器件都直接连接到电源，这意味着它们每一个都接受完全相同的电压。每个设备都有自己的电路，从电源到设备再回到电源。如果其中一个设备关闭或断路，其他的设备还能继续运行，因为它们的电路是独立的。</p><p>🔹串联（Series）：在串联电路中，电流必须通过每个器件才能回到电源。每个设备是依次连接的，形成一个闭环电路。如果其中一个设备关闭或断路，电流将无法流过，整个电路就会停止运行。</p><p>在家庭电路中，电器通常是并联连接的。这是因为我们通常希望每个设备都能独立工作，而不受其他设备是否开启或关闭的影响。这也就是说，如果你在看电视的同时，想要打开灯或者冰箱，不会影响到电视的正常运行。</p><p>然而，一些特殊的电路元素，如家用电热水器的加热元件，可能会串联连接。这是因为串联电阻的总阻值是单个电阻阻值的和，可以用来调节电流的大小。</p><p>在家庭电路的设计中，安全始终是第一位的。这就是为什么我们有保险丝和断路器这样的安全设备。如果电流过大，可能会引发火灾，这些设备就会切断电源，防止事故发生。</p><p>希望这个解答能帮助你理解家庭电路的基本设计。记得说”&#x2F;continue”来继续，或者”&#x2F;test”来测试你的理解。</p><hr><p><strong>Human:</strong><br>电路里可以既有并联又有串联吗</p><p><strong>ChatGPT:</strong><br>是的，电路中既可以有并联也可以有串联，这种电路被称为混联电路或复合电路。在这种电路中，一部分电器可以是并联的，同时另一部分电器是串联的。</p><p>举个例子，你可能有一个房间里有两个并联的灯（灯1和灯2），这两个灯又与电风扇串联。这就形成了一个复合电路。这意味着，灯1和灯2可以独立打开或关闭，不会影响彼此或电风扇的运行。但是如果电风扇关闭或断电，两个灯都将关闭，因为电流无法通过串联的电风扇流动。</p><p>家庭电路经常使用混联电路设计，因为这样的设计可以使电器更加灵活地工作。记住，无论是什么类型的电路，安全总是最重要的。请确保遵守所有的电力使用和维护指南，以防止过载和火灾。</p><p>希望这个解答能帮助你理解家庭电路的设计。如果你有更多的问题，或者准备好继续课程或者进行测试的时候，可以输入 “&#x2F;continue” 或 “&#x2F;test”。</p><hr><p><strong>Human:</strong><br>电路里可以既有并联又有串联吗</p><p><strong>ChatGPT:</strong><br>是的，电路中既可以有并联也可以有串联，这种电路被称为混联电路或复合电路。在这种电路中，一部分电器可以是并联的，同时另一部分电器是串联的。</p><p>举个例子，你可能有一个房间里有两个并联的灯（灯1和灯2），这两个灯又与电风扇串联。这就形成了一个复合电路。这意味着，灯1和灯2可以独立打开或关闭，不会影响彼此或电风扇的运行。但是如果电风扇关闭或断电，两个灯都将关闭，因为电流无法通过串联的电风扇流动。</p><p>家庭电路经常使用混联电路设计，因为这样的设计可以使电器更加灵活地工作。记住，无论是什么类型的电路，安全总是最重要的。请确保遵守所有的电力使用和维护指南，以防止过载和火灾。</p><p>希望这个解答能帮助你理解家庭电路的设计。如果你有更多的问题，或者准备好继续课程或者进行测试的时候，可以输入 “&#x2F;continue” 或 “&#x2F;test”。</p><hr><p><strong>Human:</strong><br>家庭用电里，我如何测量线路的电压呢</p><p><strong>ChatGPT:</strong><br>测量电压通常使用的工具是万用表，也称为数字多功能电表。在家庭电路中，我们通常需要测量交流电压，因为家庭用电通常是交流电。以下是如何使用万用表测量家庭电压的步骤：</p><p>⚠️注意：操作电路时必须非常小心，因为电流强大，如果操作不当，可能会造成触电。如果你不确定自己的操作，最好请专业的电工来进行测量。</p><p>1️⃣首先，确保你的万用表设置在正确的位置。大多数万用表有一个旋转开关，你可以设置它在交流电压的位置。这通常标志为”V~”或者一个类似正弦波的标志。</p><p>2️⃣将万用表的红色探头插入”VΩmA”插孔，黑色探头插入”COM”插孔。</p><p>3️⃣然后，将探头接触到你想要测量的电源两端。红色探头接触正极，黑色探头接触负极。在交流电路中，通常并没有明确的正负极，所以你可以将两个探头接触到插座的两个插孔。</p><p>4️⃣查看万用表的显示屏，你将看到电压的读数。</p><p>测量电压是识别电路问题的一种方法，但是请始终记住，电力是非常危险的，如果操作不当，可能会造成严重伤害。因此，如果你没有接触过电路的经验，或者不确定如何正确和安全地测量电压，最好寻求专业人士的帮助。</p><p>希望这个解答能帮助你。记得说”&#x2F;continue”来继续，或者”&#x2F;test”来测试你的理解。</p><blockquote><p>如果 AI 的多模态能力再开放，比如图片识别功能，感觉完全可以作为一个家庭助教来辅导作业了。完整对话见 <a href="https://chat.openai.com/share/a0bfed8e-35ef-4858-bda8-677c73d117c7">对话</a>.</p></blockquote>]]></content>
    
    
    <summary type="html">我们展示了如何使用GPT-4作为你的物理教师。本页面详细介绍了个性化的学习计划设置，并通过高中物理的实例来实践这一过程。无论你是想复习基础知识，还是想进一步探索物理学的复杂领域，这里都将提供你所需要的帮助。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>加班了多少天？GPT4 被绕晕了</title>
    <link href="https://selfboot.cn/2023/05/29/gpt4_cal_date/"/>
    <id>https://selfboot.cn/2023/05/29/gpt4_cal_date/</id>
    <published>2023-05-29T21:01:48.000Z</published>
    <updated>2023-07-02T14:41:18.181Z</updated>
    
    <content type="html"><![CDATA[<p>在一个劳动纠纷中，需要计算下员工总的加班天数，把任务给 GPT 后，见证了 GPT 傻傻的样子。历经各种 Prompt 调教，最后还是告诉我一个满意的结果了。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt_cal_date.png" alt="计算加班总天数"></p><h1 id="自然推理-Prompt"><a href="#自然推理-Prompt" class="headerlink" title="自然推理 Prompt"></a>自然推理 Prompt</h1><p><strong>Question:</strong><br>帮我计算下 2020.8.24号 到 2022.1.1 号，一共有多少个星期六，注意排除掉中国的法定节假日，以及法定的调班日。注意给出所有排除的日期，一步步给出结果。</p><p><strong>ChatGPT:</strong><br>这个问题涉及到一些具体的日期计算，以及中国的法定节假日和调班日期的查询。<strong>我将首先计算从2020年8月24日到2022年1月1日之间的所有星期六的数量，然后查询中国的法定节假日和调班日期，最后从总数中减去这些日期</strong>。这个过程可能需要一些时间，我将尽快为您提供结果。</p><p>首先，我们来计算从2020年8月24日到2022年1月1日之间的所有星期六的数量。</p><p>2020年8月24日是星期一。现在，我们需要计算从这个日期到2022年1月1日之间有多少个星期六。这需要一些计算，我将立即开始。</p><p>从2020年8月24日到2022年1月1日（不包括结束日期）总共有495天。现在我们需要计算这些天数中有多少个星期六。</p><p>一周有7天，所以我们可以通过将总天数除以7并向下取整来得到完整的周数。然后，我们需要检查剩余的天数中是否包含一个星期六。这需要知道开始日期（2020年8月24日）是星期几，我们已经知道它是星期一。现在，让我们进行这些计算。</p><p>从2020年8月24日到2022年1月1日总共有495天。由于一周有7天，所以这段时间内有70周和5天。由于2020年8月24日是星期一，那么这70周内每周都有一个星期六，总共有70个星期六。<strong>另外，那5天中包含一个星期六（2020年8月29日），所以总共有71个星期六。</strong></p><p>接下来，我将查询中国的法定节假日和调班日期，然后从这个总数中减去这些日期。这可能需要一些时间，我将尽快为您提供结果。</p><p>根据中国政府的公告，以下是2020年和2021年的法定节假日和调班日期：</p><p>2020年：</p><ul><li>元旦：1月1日</li><li>春节：1月24日至30日，调班日期：1月19日（星期日）、2月1日（星期六）</li><li>清明节：4月4日至6日</li><li>劳动节：5月1日至5日，调班日期：4月26日（星期日）、5月9日（星期六）</li><li>端午节：6月25日至27日，调班日期：6月28日（星期日）</li><li>国庆节、中秋节：10月1日至8日，调班日期：9月27日（星期日）、10月10日（星期六）</li></ul><p>2021年：</p><ul><li>元旦：1月1日至3日</li><li>春节：2月11日至17日，调班日期：2月7日（星期日）、2月20日（星期六）</li><li>清明节：4月3日至5日</li><li>劳动节：5月1日至5日，调班日期：4月25日（星期日）、5月8日（星期六）</li><li>端午节：6月12日至14日</li><li>中秋节：9月19日至21日，调班日期：9月18日（星期六）</li><li>国庆节：10月1日至7日，调班日期：9月26日（星期日）、10月9日（星期六）</li></ul><p>接下来，我将计算这些日期中有多少个星期六，并从总数中减去。这可能需要一些时间，我将尽快为您提供结果。</p><p>根据中国政府的公告，<strong>以下是2020年和2021年的法定节假日和调班日期中的星期六</strong>：</p><p>2020年：</p><ul><li>春节调班日期：2月1日（星期六）</li><li>劳动节调班日期：5月9日（星期六）</li><li>国庆节调班日期：10月10日（星期六）</li></ul><p>2021年：</p><ul><li>春节调班日期：2月20日（星期六）</li><li>劳动节调班日期：5月8日（星期六）</li><li>中秋节调班日期：9月18日（星期六）</li><li>国庆节调班日期：10月9日（星期六）</li></ul><p>所以，从2020年8月24日到2022年1月1日之间，需要排除的星期六的日期有7天。</p><p>因此，从2020年8月24日到2022年1月1日之间的星期六的数量（排除中国的法定节假日和法定的调班日）为：71 - 7 &#x3D; 64天。</p><blockquote><p>这里调用了 WebPilot 插件来获取节假日的安排，还是很准确的。其中 <a href="https://www.gov.cn/zhengce/content/2019-11/21/content_5454164.htm">2020 年</a>和 <a href="https://www.gov.cn/zhengce/content/2020-11/25/content_5564127.htm">2021 年</a>的节假日数据都是官方来的。但是这里扣减的时候，少扣除了节日日中的周六，并且把 2020 年 2.1 号也排除了，有点傻。</p></blockquote><hr><p><strong>Question:</strong><br>节假日的周六也要排除掉</p><p><strong>ChatGPT:</strong><br>根据我从网站上获取的信息，以下是2021年中国的公众假期，这些日期也需要从周六中排除：</p><ul><li>1月1日，星期五，新年</li><li>1月2日，星期六，新年假期</li><li>1月3日，星期日，新年假期</li><li>2月11日，星期四，春节前夕</li><li>2月12日，星期五，农历新年</li><li>2月13日，星期六，春节黄金周假期</li><li>……</li><li>10月3日，星期日，国庆节黄金周假期</li><li>12月25日，星期六，圣诞节</li></ul><p>以上日期在计算工作日时需要排除。</p><blockquote><p>继续错了，这里把周四，周五都算进来，AI 分不清周五、周六? 让他列出所有符合排除条件的日期，然后咱手动给他算一算有多少个。</p></blockquote><hr><p><strong>Question:</strong><br>错了，我需要找出2020年8月24日到2022年1月1日之间的，是周六，又是国家法定节假日的日期。给出我日期和节假日的名字；</p><p><strong>ChatGPT:</strong><br>我明白了，您需要找出在2020年8月24日到2022年1月1日之间，既是周六又是中国法定节假日的日期。我会立即为您找出这些日期。根据我之前的查询，以下是符合您要求的日期：</p><p>2020年：</p><ul><li>10月10日，星期六，国庆节调班日期</li></ul><p>2021年：</p><ul><li>1月1日，星期五，元旦</li><li>2月20日，星期六，春节调班日期</li><li>5月1日，星期六，劳动节</li><li>5月8日，星期六，劳动节调班日期</li><li>6月12日，星期六，端午节</li><li>9月18日，星期六，中秋节调班日期</li><li>10月2日，星期六，国庆节</li><li>10月9日，星期六，国庆节调班日期</li><li>12月25日，星期六，圣诞节</li></ul><p>以上就是在2020年8月24日到2022年1月1日之间，既是周六又是中国法定节假日的日期。</p><blockquote><p>这里仍然是错误的，不知道为啥还能冒出圣诞节？？？ 后面不管如何提示，给出的总是很奇怪，完整聊天可以见 <a href="https://chat.openai.com/share/acc2a2c2-5857-4d8e-9572-ac5c5e54946f">对话 1</a>。这里逻辑推理和简单的计算 AI 看起来并不擅长，那我们就让他来编程吧。这里后面的对话感觉 AI 已经懵逼了，就新开一个回话来让我重新开始。 </p></blockquote><h1 id="让-AI-做擅长的编程？"><a href="#让-AI-做擅长的编程？" class="headerlink" title="让 AI 做擅长的编程？"></a>让 AI 做擅长的编程？</h1><p><strong>Question:</strong><br>帮我计算下 2020.8.24号 到 2022.1.1 号，一共有多少个星期六，注意排除掉中国的法定节假日，以及法定的调班日。写一个 Python 程序来完成上面的任务，对于法定节假日和调班日，你去网上搜索后，直接写死在代码中。 </p><p><strong>ChatGPT:</strong><br>首先，我会帮你写一个 Python 程序来计算两个日期之间的星期六的数量。然后，我会搜索中国的法定节假日和调班日，并在代码中排除这些日期。</p><p>这是一个基本的 Python 程序，它计算两个日期之间的星期六的数量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义起始和结束日期</span></span><br><span class="line">start_date = datetime(<span class="number">2020</span>, <span class="number">8</span>, <span class="number">24</span>)</span><br><span class="line">end_date = datetime(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化星期六的数量</span></span><br><span class="line">saturday_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历日期范围</span></span><br><span class="line">current_date = start_date</span><br><span class="line"><span class="keyword">while</span> current_date &lt;= end_date:</span><br><span class="line">    <span class="comment"># 如果当前日期是星期六，增加计数</span></span><br><span class="line">    <span class="keyword">if</span> current_date.weekday() == <span class="number">5</span>:</span><br><span class="line">        saturday_count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 前进到下一天</span></span><br><span class="line">    current_date += timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;从 <span class="subst">&#123;start_date&#125;</span> 到 <span class="subst">&#123;end_date&#125;</span> 一共有 <span class="subst">&#123;saturday_count&#125;</span> 个星期六。&quot;</span>)</span><br></pre></td></tr></table></figure><p>接下来，我将搜索中国的法定节假日和调班日，并在代码中排除这些日期。这可能需要一些时间，因为我需要访问网页并解析数据。我将使用 OpenAI 的 Web Pilot 工具来完成这个任务。</p><p><strong>Question:</strong><br>继续。 你一次写完，不要让我说继续</p><p><strong>ChatGPT:</strong><br>根据我<a href="https://www.gov.cn/zhengce/content/2019-11/21/content_5454164.htm">找到的信息</a>，2020年中国的法定节假日和调班日如下：</p><ul><li>元旦：2020年1月1日放假，共1天。</li><li>春节：1月24日至30日放假调休，共7天。1月19日（星期日）、2月1日（星期六）上班。</li><li>清明节：4月4日至6日放假调休，共3天。</li><li>劳动节：5月1日至5日放假调休，共5天。4月26日（星期日）、5月9日（星期六）上班。</li><li>端午节：6月25日至27日放假调休，共3天。6月28日（星期日）上班。</li><li>国庆节、中秋节：10月1日至8日放假调休，共8天。9月27日（星期日）、10月10日（星期六）上班。</li></ul><p>接下来，我将这些日期添加到 Python 程序中，并排除这些日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义起始和结束日期</span></span><br><span class="line">start_date = datetime(<span class="number">2020</span>, <span class="number">8</span>, <span class="number">24</span>)</span><br><span class="line">end_date = datetime(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义中国的法定节假日和调班日</span></span><br><span class="line">holidays = [</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">24</span>), datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">25</span>), datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">26</span>), </span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">27</span>), datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">28</span>), datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">29</span>), </span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">30</span>),</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">4</span>), datetime(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">5</span>), datetime(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">6</span>),</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">1</span>), datetime(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">2</span>), datetime(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">3</span>), </span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">4</span>), datetime(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">6</span>, <span class="number">25</span>), datetime(<span class="number">2020</span>, <span class="number">6</span>, <span class="number">26</span>), datetime(<span class="number">2020</span>, <span class="number">6</span>, <span class="number">27</span>),</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">1</span>), datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">2</span>), datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">3</span>), </span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">4</span>), datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">5</span>), datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">6</span>), </span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">7</span>), datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">8</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化星期六的数量</span></span><br><span class="line">saturday_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历日期范围</span></span><br><span class="line">current_date = start_date</span><br><span class="line"><span class="keyword">while</span> current_date &lt;= end_date:</span><br><span class="line">    <span class="comment"># 如果当前日期是星期六，并且不是法定节假日或调班日，增加计数</span></span><br><span class="line">    <span class="keyword">if</span> current_date.weekday() == <span class="number">5</span> <span class="keyword">and</span> current_date <span class="keyword">not</span> <span class="keyword">in</span> holidays:</span><br><span class="line">        saturday_count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 前进到下一天</span></span><br><span class="line">    current_date += timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;从 <span class="subst">&#123;start_date&#125;</span> 到 <span class="subst">&#123;end_date&#125;</span> 一共有 <span class="subst">&#123;saturday_count&#125;</span> 个星期六。&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个程序将计算两个日期之间的星期六的数量，并排除中国的法定节假日和调班日。请注意，这个程序只适用于2020年，如果你需要计算其他年份的日期，你需要更新节假日和调班日的列表。</p><p><strong>Question:</strong><br>所有在开始日期和结束日期内的时间，都要过滤节假日和调班日，重新完善上面的代码，补上 2021 年的过滤。</p><p><strong>ChatGPT:</strong><br>根据我<a href="http://www.gov.cn/zhengce/content/2020-11/25/content_5564127.htm">找到的信息</a>，2021年中国的法定节假日和调班日如下：</p><ul><li>元旦：2021年1月1日至3日放假，共3天。</li><li>春节：2月11日至17日放假调休，共7天。2月7日（星期日）、2月20日（星期六）上班。</li><li>清明节：4月3日至5日放假调休，共3天。</li><li>劳动节：5月1日至5日放假调休，共5天。4月25日（星期日）、5月8日（星期六）上班。</li><li>端午节：6月12日至14日放假，共3天。</li><li>中秋节：9月19日至21日放假调休，共3天。9月18日（星期六）上班。</li><li>国庆节：10月1日至7日放假调休，共7天。9月26日（星期日）、10月9日（星期六）上班。</li></ul><p>接下来，我将这些日期添加到 Python 程序中，并排除这些日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义起始和结束日期</span></span><br><span class="line">start_date = datetime(<span class="number">2020</span>, <span class="number">8</span>, <span class="number">24</span>)</span><br><span class="line">end_date = datetime(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义中国的法定节假日和调班日</span></span><br><span class="line">holidays = [</span><br><span class="line">    <span class="comment"># 2020年的节假日和调班日</span></span><br><span class="line">    <span class="comment"># ...（省略了2020年的日期）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2021年的节假日和调班日</span></span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">1</span>), datetime(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">2</span>), datetime(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">7</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">11</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">12</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">13</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">14</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">15</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">16</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">17</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">20</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">4</span>, <span class="number">3</span>), datetime(<span class="number">2021</span>, <span class="number">4</span>, <span class="number">4</span>), datetime(<span class="number">2021</span>, <span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">4</span>, <span class="number">25</span>), datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">1</span>), datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">2</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">3</span>), datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">4</span>), datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">8</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">6</span>, <span class="number">12</span>), datetime(<span class="number">2021</span>, <span class="number">6</span>, <span class="number">13</span>), datetime(<span class="number">2021</span>, <span class="number">6</span>, <span class="number">14</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">18</span>), datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">19</span>), datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">20</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">21</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">26</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">1</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">2</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">3</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">4</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">5</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">6</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">7</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">9</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化星期六的数量</span></span><br><span class="line">saturday_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历日期范围</span></span><br><span class="line">current_date = start_date</span><br><span class="line"><span class="keyword">while</span> current_date &lt;= end_date:</span><br><span class="line">    <span class="comment"># 如果当前日期是星期六，并且不是法定节假日或调班日，增加计数</span></span><br><span class="line">    <span class="keyword">if</span> current_date.weekday() == <span class="number">5</span> <span class="keyword">and</span> current_date <span class="keyword">not</span> <span class="keyword">in</span> holidays:</span><br><span class="line">        saturday_count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 前进到下一天</span></span><br><span class="line">    current_date += timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;从 <span class="subst">&#123;start_date&#125;</span> 到 <span class="subst">&#123;end_date&#125;</span> 一共有 <span class="subst">&#123;saturday_count&#125;</span> 个星期六。&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个程序将计算两个日期之间的星期六的数量，并排除中国的法定节假日和调班日。请注意，这个程序只适用于2020年和2021年，如果你需要计算其他年份的日期，你需要更新节假日和调班日的列表。</p><blockquote><p>看来 AI 写代码的思路还是清晰一些，总算给出了一个可以的答案。完整对话见 <a href="https://chat.openai.com/share/e446e8a6-ba2e-4c1d-81b1-7f7633f91990">对话 2</a>.</p></blockquote>]]></content>
    
    
    <summary type="html">探索人工智能的无限可能性，本页面详细介绍了如何使用GPT-4进行日期计算，包括如何计算特定日期范围内的星期六数量，并排除中国的法定节假日和调班日。我们通过实际案例，展示了GPT-4在处理复杂问题时的表现，以及如何通过编程让AI更好地完成任务。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
</feed>
