<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just For Fun</title>
  <icon>https://www.gravatar.com/avatar/0de0c23d97c75300e32f8494b1485fb8</icon>
  <subtitle>知其然，知其所以然。知识广度是深度的副产品！</subtitle>
  <link href="https://selfboot.cn/atom.xml" rel="self"/>
  
  <link href="https://selfboot.cn/"/>
  <updated>2024-08-30T13:06:40.795Z</updated>
  <id>https://selfboot.cn/</id>
  
  <author>
    <name>selfboot</name>
    <email>xuezaigds@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：内存分配器、随机数生成、CRC32、整数编解码</title>
    <link href="https://selfboot.cn/2024/08/29/leveldb_source_utils/"/>
    <id>https://selfboot.cn/2024/08/29/leveldb_source_utils/</id>
    <published>2024-08-29T20:36:37.000Z</published>
    <updated>2024-08-30T13:06:40.795Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 中实现了不少 utils 工具，比如定制的内存分配器 Arena，随机数生成类 Random，实现中都会考虑到具体的使用场景，做了优化以及取舍，值得好好学习。本篇文章主要聊聊下面部分的实现：</p><ul><li>内存管理 Arena，一个简单高效，适合 LevelDB 的内存分配管理器；</li><li>随机数 Random，一个不错的<strong>线性同余伪随机生成</strong>算法，用位运算替代取模优化了执行效率。</li><li>CRC32 循环冗余校验，用于检测数据传输或存储过程中是否发生错误；</li><li>整数编、解码，用于将数字存储在字节流或者从字节流中解析数字。</li></ul><p>此外，还有些 utils 组件比较复杂些，会放在单独的文章里聊，比如：</p><ul><li><a href="https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/">LevelDB 源码阅读：禁止对象被析构</a> 讲在 C++中如何禁止某个对象被析构，以为这样做的原因。</li></ul><span id="more"></span><h2 id="内存管理-Arena-类"><a href="#内存管理-Arena-类" class="headerlink" title="内存管理 Arena 类"></a>内存管理 Arena 类</h2><p>LevelDB <strong>没有直接使用</strong>系统默认的 malloc 来分配内存，也没有使用 tcmalloc 等第三方库来管理内存的分配和释放，而是自己实现了一个简单的内存分配器。这里的内存分配器可以说是<strong>量身订制</strong>，主要基于下面考虑：</p><ol><li>主要在 memtable 中使用，会有大量的分配，可能有很多小内存分配；</li><li>统一回收时机，在 memtable 数据落磁盘后，会一并回收；</li></ol><p>内存 memtable 的数据其实存储在 skiplist 中的。每次插入 key，就需要往 skiplist 中插入节点，这里节点使用的内存就是用 arena 来分配的。如果是小 key，这里会优先从当前 block 剩余内存中拿，不够的话才会走到分配逻辑。<a href="https://github.com/google/leveldb/blob/main/util/arena.h#L55">Allocate</a> 的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="type">char</span>* result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过系统调用分配内存的逻辑在 AllocateFallback 中，如果需要的内存大于 kBlockSize &#x2F; 4，则按照实际需要分配。否则的话，就直接分配一个 block 的内存，然后更新使用情况。这里没有用完的内存余量，可以在下次分配内存的时候使用。如果不够下次需要的量，则重新走系统调用来分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></span><br><span class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We waste the remaining space in the current block.</span></span><br><span class="line">  alloc_ptr_ = <span class="built_in">AllocateNewBlock</span>(kBlockSize);</span><br><span class="line">  alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* result = alloc_ptr_;</span><br><span class="line">  alloc_ptr_ += bytes;</span><br><span class="line">  alloc_bytes_remaining_ -= bytes;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可能会导致一些<strong>内存浪费</strong>，比如第一次使用 496 byte，实际会分配 4096 byte，剩余 3600 byte。然后下一次使用超过 3600 byte 的话，就会重新申请新的内存，上次分配剩余的 3600 byte 就会被浪费掉。虽然浪费了一定的内存使用率，不过整体代码比较简单，分配效率也比较高。这部分被浪费掉的内存，在 memtable 落磁盘后也会被重新回收掉。</p><p>顺便再提一下这里最后的内存回收，每次调用 <code>new []</code> 分配内存后，会把首地址放到 vector 中，然后在 Arena 类析构的时候，遍历拿出所有的内存块，统一进行释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span>* result = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">  blocks_.<span class="built_in">push_back</span>(result);</span><br><span class="line">  memory_usage_.<span class="built_in">fetch_add</span>(block_bytes + <span class="built_in">sizeof</span>(<span class="type">char</span>*),</span><br><span class="line">                          std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">Arena::~<span class="built_in">Arena</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] blocks_[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外这个类还提供了一个原子计数器 <code>memory_usage_</code>，统计这个类目前占用的内存大小。</p><h2 id="随机数-Random-类"><a href="#随机数-Random-类" class="headerlink" title="随机数 Random 类"></a>随机数 Random 类</h2><p>LevelDB 的 <a href="https://github.com/google/leveldb/blob/main/util/random.h">util&#x2F;random.h</a> 中实现了一个<a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">伪随机数生成器(PRNG)</a>类 Random，用在<strong>跳表生成层高</strong>等场景。这个随机数生成器是基于线性同余生成器（LCG）实现，随机数的生成公式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seed_ = (seed_ * A) % M</span><br></pre></td></tr></table></figure><p>根据同余理论，只要 A 和 M 被适当选取，那么上述递推公式将能生成一个周期为 M 的伪随机数序列，且这个序列中不会有重复的数(除了最初的值)。这里模数 M 的值 $ 2^{31}-1 $ 是一个常见的选择，因为它是一个<strong>梅森素数（Mersenne prime）</strong>，有利于生成具有良好周期性的随机序列。</p><p>构造函数接收一个 32 位无符号整数作为种子（seed_），并确保种子落在有效范围内（非 0 且不等于 2147483647L，即 $ 2^{31}-1 $）。这是因为种子的值直接影响随机数生成过程，而这两个特定的值（0 和 $ 2^{31}-1 $）在计算过程中会导致生成的序列失去随机性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Random</span><span class="params">(<span class="type">uint32_t</span> s)</span> : seed_(s &amp; <span class="number">0x7fffffff</span>u) &#123;</span></span><br><span class="line">  <span class="comment">// Avoid bad seeds.</span></span><br><span class="line">  <span class="keyword">if</span> (seed_ == <span class="number">0</span> || seed_ == <span class="number">2147483647L</span>) &#123;</span><br><span class="line">    seed_ = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成随机数的代码很精简，如下（忽略原有注释）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> M = <span class="number">2147483647L</span>;  <span class="comment">// 2^31-1</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> A = <span class="number">16807</span>;        <span class="comment">// bits 14, 8, 7, 5, 2, 1, 0</span></span><br><span class="line">  <span class="type">uint64_t</span> product = seed_ * A;</span><br><span class="line">  seed_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;((product &gt;&gt; <span class="number">31</span>) + (product &amp; M));</span><br><span class="line">  <span class="keyword">if</span> (seed_ &gt; M) &#123;</span><br><span class="line">    seed_ -= M;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> seed_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是 <code>product = seed_ * A</code>，这里乘积 product 可能会超出 32 位的范围，为了<strong>防止溢出</strong>使用 uint64_t 来保持这个中间结果。顺便提醒下血泪的教训，<strong>整数的加减乘除一定要考虑溢出场景，很多软件都有因为溢出导致的漏洞</strong>。然后这里 product%M 模运算<strong>用了位操作和加法来代替</strong>，以提高计算效率。</p><p>这里主要是基于<strong>模运算的分配律</strong>：$ (a + b) \mod m &#x3D; ((a \mod m) + (b \mod m)) \mod m $，将 product 分为 <code>product &gt;&gt; 31 + product &amp; M</code>，因为 M &#x3D; $ 2^{31}-1 $，这里的与运算取 product 的低31位。</p><p>除了基本的随机数生成，Random 类还提供了生成特定范围内随机数的 <code>Uniform()</code> 方法，以及概率性返回真或假的 <code>OneIn()</code> 方法和生成偏向小数的 <code>Skewed()</code> 方法，这些都是在特定场景下非常有用的工具函数。</p><p>Skewed 的实现比较有意思，首先从 [0, max_log] 范围内均匀选择一个基数 base，接着用 <code>Uniform(1 &lt;&lt; base)</code> 返回 $ [0, 2^{base} - 1]$ 范围内的一个随机数。这里基数 base 的选择概率是均匀的，这意味着选择一个较小的 base（从而生成较小的随机数）与选择一个较大的 base（从而生成较大的随机数）的概率是相同的。然而，由于 base 的值越小，能生成的随机数的范围就越小，这自然导致了<strong>函数倾向于生成较小的数值</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Skewed: pick &quot;base&quot; uniformly from range [0,max_log] and then</span></span><br><span class="line"><span class="comment">// return &quot;base&quot; random bits.  The effect is to pick a number in the</span></span><br><span class="line"><span class="comment">// range [0,2^max_log-1] with exponential bias towards smaller numbers.</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Skewed</span><span class="params">(<span class="type">int</span> max_log)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Uniform</span>(<span class="number">1</span> &lt;&lt; <span class="built_in">Uniform</span>(max_log + <span class="number">1</span>)); &#125;</span><br></pre></td></tr></table></figure><h2 id="CRC32-循环冗余校验"><a href="#CRC32-循环冗余校验" class="headerlink" title="CRC32 循环冗余校验"></a>CRC32 循环冗余校验</h2><p>CRC（<strong>Cyclic Redundancy Check，循环冗余检查</strong>）是一种通过特定算法来计算数据的校验码的方法，广泛用于<strong>网络通讯和数据存储系统</strong>中以检测数据在传输或存储过程中是否发生错误。CRC32是一种常见的CRC算法，使用了一个32位的校验和。</p><p>CRC 的计算基于<strong>多项式除法</strong>，处理的数据被视为一个巨大的多项式，通过<strong>这个多项式除以另一个预定义的“生成多项式”</strong>，然后取余数作为输出的CRC值。CRC算法具有天然的<strong>流式计算特性</strong>，可以先计算消息的一部分的CRC，然后将这个结果作为下一部分计算的初始值（init_crc）。下面的 <code>Extend</code> 函数接受一个初始的 CRC 值（可能是之前数据块的CRC结果），然后计算加上新的数据块后的CRC值。这使得 LevelDB 能够在不断追加数据时连续计算CRC，而不需要每次都从头开始。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the crc32c of concat(A, data[0,n-1]) where init_crc is the</span></span><br><span class="line"><span class="comment">// crc32c of some string A.  Extend() is often used to maintain the</span></span><br><span class="line"><span class="comment">// crc32c of a stream of data.</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Extend</span><span class="params">(<span class="type">uint32_t</span> init_crc, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the crc32c of data[0,n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Value</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Extend</span>(<span class="number">0</span>, data, n); &#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/google/leveldb/blob/main/util/crc32c.cc">crc32c.cc</a> 中的实现比较比较复杂，涉及到查找表（table-driven approach）、数据对齐、和可能的硬件加速，具体的原理可以参考 <a href="http://www.ross.net/crc/download/crc_v3.txt">A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS</a>。其中<strong>生成多项式</strong>的选择对CRC算法的有效性和错误检测能力至关重要。生成多项式并不是随意选取的，它们通常通过数学和计算机模拟实验被设计出来，以确保最大化特定数据长度和特定应用场景下的错误检测能力，常见的生成多项式<code>0x04C11DB7</code> 就是在IEEE 802.3标准中为 CRC-32 算法选定的。</p><p>这里补充说下，CRC 只是用来<strong>检测随机错误</strong>，比如网络传输或者磁盘存储中某些比特位发生了翻转。它不是纠错校验码，只能检测到错误，并<strong>不能纠正错误</strong>。我们可以故意对内容进行篡改然后保证 CRC 结果一样，如果要防篡改，要用到更为复杂的加密哈希函数或者数字签名技术。</p><p>另外在 <a href="https://github.com/google/leveldb/blob/main/util/crc32c.h">crc32c.h</a> 中还看到有一个 Mask，这里代码注释也写的很清楚了，如果数据本身包含CRC值，然后直接在包含CRC的数据上再次计算CRC，可能会降低CRC的错误检测能力。因此，LevelDB 对CRC值进行高低位交换后加上一个常数（kMaskDelta），来“掩码”原始的CRC值。这种变换后的CRC值可以存储在文件中，当要验证数据完整性时，使用 Unmask 函数将掩码后的CRC值转换回原始的CRC值，再与当前数据的CRC计算结果进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a masked representation of crc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Motivation: it is problematic to compute the CRC of a string that</span></span><br><span class="line"><span class="comment">// contains embedded CRCs.  Therefore we recommend that CRCs stored</span></span><br><span class="line"><span class="comment">// somewhere (e.g., in files) should be masked before being stored.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Mask</span><span class="params">(<span class="type">uint32_t</span> crc)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Rotate right by 15 bits and add a constant.</span></span><br><span class="line">  <span class="keyword">return</span> ((crc &gt;&gt; <span class="number">15</span>) | (crc &lt;&lt; <span class="number">17</span>)) + kMaskDelta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the crc whose masked representation is masked_crc.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">Unmask</span><span class="params">(<span class="type">uint32_t</span> masked_crc)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> rot = masked_crc - kMaskDelta;</span><br><span class="line">  <span class="keyword">return</span> ((rot &gt;&gt; <span class="number">17</span>) | (rot &lt;&lt; <span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实有个有意思的地方，原始 CRC32 值交换高 15 位后，加上常量后可能会大于 uint32_t 的最大值，<strong>导致溢出</strong>。<strong>在 C++ 中，无符号整型的溢出行为是定义良好的，按照取模运算处理</strong>。比如当前 crc 是 32767，这里移动后加上常量，结果是7021325016，按照 $ 2^{32} $ 取模后结果是 2726357720。而在 Unmask 中的减法操作，同样会溢出，C++中这里也是按照取模运算处理的。这里 $ 2726357720-kMaskDelta &#x3D; -131072 $ 按照 $ 2^{32} $ 后结果是 4294836224，再交换高低位就拿到了原始 CRC 32767 了，所以<strong>这里的溢出不会导致 bug 的哦</strong>。</p><h2 id="整数编、解码"><a href="#整数编、解码" class="headerlink" title="整数编、解码"></a>整数编、解码</h2><p>LevelDB 中经常需要将数字存储在字节流或者从字节流中解析数字，比如 key 中存储长度信息，在批量写的任务中存储序列号等。在 <a href="https://github.com/google/leveldb/blob/main/util/coding.h">util&#x2F;coding.h</a> 中定义了一系列编码和解码的工具函数，方便在字节流中存储和解析数字。首先来看固定长度的编、解码，主要有下面几个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed32</span><span class="params">(std::string* dst, <span class="type">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PutFixed64</span><span class="params">(std::string* dst, <span class="type">uint64_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> value)</span></span>;</span><br></pre></td></tr></table></figure><p>以 32 位的编码为例，<code>PutFixed32</code> 函数将一个 32 位的无符号整数 value 编码为 4 个字节，然后追加到 dst 字符串的末尾。<code>EncodeFixed32</code> 函数则将 value 编码为 4 个字节，存储到 dst 指向的内存中。PutFixed32 底层以 EncodeFixed32 为基础，只是将结果追加到了 dst 字符串中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint8_t</span>* <span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  buffer[<span class="number">0</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value);</span><br><span class="line">  buffer[<span class="number">1</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buffer[<span class="number">2</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  buffer[<span class="number">3</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 <code>reinterpret_cast&lt;uint8_t*&gt;(dst)</code> 将 <code>char*</code> 类型的指针转换为 <code>uint8_t*</code> 类型，使得后续可以直接操作单个字节。然后使用位移和掩码操作将 value 的每一个字节分别写入到 buffer 数组中，<strong>value 的低位字节存储在低地址中（小端序）</strong>。假设我们有一个 uint32_t 的数值 0x12345678（十六进制表示），我们想将这个值编码到一个字符数组中，然后再从数组中解码出来。</p><ul><li>buffer[0] 存储 value 的最低8位，即 0x78。</li><li>buffer[1] 存储 value 的次低8位，即 0x56。</li><li>buffer[2] 存储 value 的次高8位，即 0x34。</li><li>buffer[3] 存储 value 的最高8位，即 0x12。</li></ul><p>编码完之后，dst 中的内容将是：<code>78 56 34 12</code>。解码的过程就是将这 4 个字节按照相反的顺序组合起来，得到原始的 value 值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">DecodeFixed32</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* <span class="type">const</span> buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / ldr instruction.</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">0</span>])) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         (<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(buffer[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了将整数编码为固定长度的字节，LevelDB 还支持使用变长整数（Varint）编码来存储数字。因为很多时候，需要存的是范围很广但常常偏小的值，这时候都用 4 个字节来存储整数有点浪费。Varint 是一种高效的数据压缩方法，小的数值占用的字节少，可以节省空间。</p><p>Varint 原理很简单，使用一个或多个字节来存储整数的方法，其中<strong>每个字节的最高位（第8位）用来表示是否还有更多的字节</strong>。如果这一位是1，表示后面还有字节；如果是0，表示这是最后一个字节。剩下的7位用来存储实际的数字值。下图展示了从一个到三个字节的 varint 编码（更多字节类似，这里不列出）：</p><table><thead><tr><th>数值范围</th><th>Varint 字节表达式</th></tr></thead><tbody><tr><td>1-127</td><td>0xxxxxxx</td></tr><tr><td>128-16383</td><td>1xxxxxxx 0xxxxxxx</td></tr><tr><td>16384-2097151</td><td>1xxxxxxx 1xxxxxxx 0xxxxxxx</td></tr></tbody></table><p>具体实现中，EncodeVarint32 和 EncodeVarint64 略有不同，32 位的直接先判断需要的字节数，然后硬编码写入。64 位的则是循环写入，每次处理 7 位，直到数值小于 128。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="type">uint8_t</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(ptr++) = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这里是编码，对应有从字节流中解码出 Varint 的实现。主要实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetVarint64Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">const</span> <span class="type">char</span>* limit, <span class="type">uint64_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">63</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> byte = *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是编码的逆过程，成功解码一个整数后，它会返回一个新的指针，指向字节流中紧跟着解码整数之后的位置。GetVarint64 函数用这个实现，从 input 中解析出一个 64 位整数后，还更新了 input 的状态，<strong>使其指向剩余未处理的数据</strong>。这里更新字节流，对于连续处理数据流中的多个数据项非常有用，例如在解析由多个 varint 编码的整数组成的数据流时，每次调用 GetVarint64 后，input 都会更新，准备好解析下一个整数。</p><p>这里还一类辅助函数，比如 PutLengthPrefixedSlice 用于将一个字符串编码为一个长度前缀和字符串内容的组合，而 GetLengthPrefixedSlice 则是对应的解码函数。这些编码和解码函数在 LevelDB 中被广泛应用，用于存储和解析各种数据结构，比如 memtable 中的 key 和 value，SSTable 文件的 block 数据等。</p><p>这里整数的编、解码配有大量的测试用例，放在 <a href="https://github.com/google/leveldb/blob/main/util/coding_test.cc">util&#x2F;coding_test.cc</a> 中。里面有正常的编码和校对测试，比如 0 到 100000 的 Fixed32 的编、解码校验。此外还有一些<strong>异常测试</strong>，比如错误的 Varint32 的解码用例 Varint32Overflow，用 GetVarint32Ptr 来解码 “\x81\x82\x83\x84\x85\x11”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LevelDB 中的 utils 组件都是为了更好的适应 LevelDB 的使用场景，比如 Arena 内存分配器适合 memtable 的大量小内存分配，Random 随机数生成器用于跳表的层高生成，CRC32 用于数据传输或存储过程中的错误检测，编解码工具函数用于存储和解析数字。</p><p>本文只是简单介绍这些组件的实现，并没有过多涉及这些组件背后的数学知识，比如随机数生成器的线性同余算法、CRC32 的多项式除法等。有兴趣的话，大家可以继续深入研究。</p>]]></content>
    
    
    <summary type="html">本文探讨了 LevelDB 中的核心工具组件实现，包括Arena内存分配器、Random随机数生成器、CRC32循环冗余校验和整数编解码工具。分析了这些组件的设计考量、实现细节和优化策略，展示了它们如何高效地支持LevelDB的各种操作。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：读写 WAL 日志保证持久性</title>
    <link href="https://selfboot.cn/2024/08/14/leveldb_source_wal_log/"/>
    <id>https://selfboot.cn/2024/08/14/leveldb_source_wal_log/</id>
    <published>2024-08-14T21:05:31.000Z</published>
    <updated>2024-08-30T13:06:40.795Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 使用 WAL（Write-Ahead Logging）日志来确保数据的持久性。当写入操作发生时，LevelDB 首先将数据写入到日志文件中，然后再应用到内存中的数据结构（如 MemTable）。系统或数据库崩溃后重新启动时，LevelDB 会检查 WAL 日志文件中的记录。通过读取并重放这些日志记录，LevelDB 可以重建那些在崩溃发生时还未被完全写入磁盘的数据状态。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_leveldb_source_wal_log_cover.svg" alt="LevelDB WAL 日志写入流程"></p><p>整个 WAL 日志相关的操作流程如下：</p><ol><li>LevelDB首先将数据写入WAL日志。确保即使在系统崩溃的情况下，数据也不会丢失。</li><li>数据被写入内存中的MemTable，这个是内存操作，很快。</li><li>LevelDB向客户端确认写入完成。</li><li>随着时间推移，当MemTable满了之后，它会被刷新到磁盘上的SSTable文件中。</li><li>一旦MemTable被成功刷新到SSTable，相应的WAL日志就可以被清除了。</li></ol><p>接下来详细看看这里的实现。</p><span id="more"></span><h2 id="写-WAL-日志"><a href="#写-WAL-日志" class="headerlink" title="写 WAL 日志"></a>写 WAL 日志</h2><p>先来看看 LevelDB 是如何写 WAL 日志的。在 LevelDB 中，<a href="https://github.com/google/leveldb/blob/main/db/log_writer.h">db&#x2F;log_writer.h</a> 中定义了个 Writer 类，用于写入 WAL 日志文件。Writer 类的主要方法是 <code>AddRecord</code>，用于将一个记录追加到日志文件中。主要的数据成员是 <code>WritableFile* dest_;</code>，指向支持追加写的日志文件。这里 WritableFile 是 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h#L277">include&#x2F;leveldb&#x2F;env.h</a> 中定义的抽象类接口，用于封装顺序写文件的操作，具体接口和实现可以参考 <a href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/#%E9%A1%BA%E5%BA%8F%E5%86%99%E6%96%87%E4%BB%B6">LevelDB 源码阅读：Posix 文件操作接口实现细节</a>。</p><p>WAL 日志写入的主要实现在 <a href="https://github.com/google/leveldb/blob/main/db/log_writer.cc">db&#x2F;log_writer.cc</a> 文件中，整体流程比较清晰。AddRecord 方法处理不同大小的数据，确保它们按照正确的格式和类型进行切分，然后调用 <a href="https://github.com/google/leveldb/blob/main/db/log_writer.cc#L82">EmitPhysicalRecord</a> 设置头部，存储单条记录。</p><h3 id="单条记录存储格式"><a href="#单条记录存储格式" class="headerlink" title="单条记录存储格式"></a>单条记录存储格式</h3><p>单条记录存储格式比较清晰，EmitPhysicalRecord 中有完整的实现。每条记录由 2 部分组成：<strong>7 字节固定长度</strong>的 Header以及长度不定的 Data 部分。Header 部分包括 1 字节的记录类型、2 字节的记录长度和 4 字节的校验码。其中：</p><ul><li>Record Type：记录类型，标识是完整记录、第一部分、中间部分还是最后部分。</li><li>Length：单条记录长度，指的是数据部分的长度，不包括头部的长度。单条记录长度最长为 kBlockSize - kHeaderSize，用 2 个字节表达足够了。</li><li>CRC32：循环冗余校验码，用于检查数据在存储或传输过程中是否发生了更改。</li></ul><p>如下图；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+--------------------------------------------------+</span><br><span class="line">|     Header      |                     Data/Payload                  |</span><br><span class="line">+-----------------+--------------------------------------------------+</span><br><span class="line">| Record Type (1B)| Actual data written by the application...         |</span><br><span class="line">| Length (2B)     |                                                  |</span><br><span class="line">| CRC (4B)        |                                                  |</span><br><span class="line">+-----------------+--------------------------------------------------+</span><br></pre></td></tr></table></figure><p>写单条记录的实现如下，首先计算头部各个字段的值，然后将头部和数据部分写入到日志文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="type">const</span> <span class="type">char</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="type">char</span> buf[kHeaderSize];</span><br><span class="line">  buf[<span class="number">4</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(t);</span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="type">uint32_t</span> crc = crc32c::<span class="built_in">Extend</span>(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::<span class="built_in">Mask</span>(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">  <span class="built_in">EncodeFixed32</span>(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    s = dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(ptr, length));</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = dest_-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里计算 CRC32 的时候，用了<code>type_crc_[t]</code>，这个数组是在 Writer 的构造函数中用 InitTypeCrc 函数来进行初始化，这样可以提高计算效率，避免在每次写入记录时都重新计算 CRC32 校验码。如果没有初始化 type_crc_ 数组，其实也可以使用 <code>crc32c::Extend(0, ptr, length)</code> 来计算 CRC 校验码。不过这样的话，只计算了数据部分的 CRC 校验码，而没有考虑<strong>记录类型</strong>。用 type_crc_ 的话，把记录类型作为 crc32 计算的初始值，这样同样的内容，如果类型不同，计算出的 crc32 也不同。</p><p>这里提到了记录类型，代码中还记录了一个 <code>block_offset_</code>，这些又是做什么用的呢？这就是 AddRecord 中做的<strong>数据切分逻辑</strong>了。</p><h3 id="数据切分记录"><a href="#数据切分记录" class="headerlink" title="数据切分记录"></a>数据切分记录</h3><p><strong>在写数据的时候，如果单条数据太大，LevelDB 会将数据进行切分，分为多条记录，然后来一点点写入</strong>。经过切分后，一条数据可能就会包含多条记录，因此需要设计好<strong>记录组织格式</strong>，以便在读取时能够正确地重建完整的数据。这里 LevelDB 的做法比较直接，每条记录增加一个记录类型，用于标识是完整记录、第一部分、中间部分还是最后部分。这样在读取时，只要按照记录类型的顺序组装数据即可。这样一条数据可能分下面几种切分情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first(R1), middle(R1), middle(R1), ..., last(R1)</span><br><span class="line">first(R2), last(R2)</span><br><span class="line">full(R3)</span><br></pre></td></tr></table></figure><p>这里的 first、middle、last 和 full 分别表示记录的类型。所有的记录都放在<strong>逻辑块</strong>中，逻辑块的大小是 kBlockSize（32768&#x3D;32KB），这个值在 <a href="https://github.com/google/leveldb/blob/main/db/log_format.h#L27">db&#x2F;log_format.h</a> 中定义。在切分数据的时候会保证，<strong>单条记录不跨越逻辑块</strong>。整体切分记录的逻辑在 AddRecord 中实现，主要是根据数据的大小，当前逻辑块剩余空间，然后判断是否需要切分。对于需要切分的场景，将数据切分记录，设置好正确的记录类型，然后调用 EmitPhysicalRecord 逐条写入。核心代码如下，去掉了部分注释和 assert 校验逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="type">const</span> Slice&amp; slice)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ptr = slice.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">size_t</span> left = slice.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="type">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="built_in">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(<span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="built_in">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意对于长度为 0 的数据，这里也会写入一条记录，记录类型为 fulltype，记录只含有头部，没有数据部分，有测试用例专门来验证这种情况。另外注意如果写入一些记录后，当前逻辑块剩余空间小于 7，不足以写入 Header，则会用 <code>\x00</code> 填充剩余空间，然后切换到下一个逻辑块。</p><p>这里<strong>判断当前记录类型的实现比较聪明</strong>，只需要维护两个标志 begin 和 end。刚开始写入数据的时候，begin 为 true，写入一条记录后，就更新 begin 为 false。end 的更新则是根据剩余数据长度是否为 0 来判断。然后根据 begin 和 end 的值，就可以确定当前记录的类型了。注意这里 if else 的顺序也很关键，即是 begin 又是 end 的说明是 kFullType 的记录；接着如果只是 begin，就是 kFirstType；如果只是 end，就是 kLastType，其他情况就是 kMiddleType。</p><p>这里有个设计值得思考下，<strong>切分记录的时候，为什么不跨逻辑块</strong>？其实如果看后面读取 WAL 日志部分代码，就会发现这样设计后可以按块进行读取。<strong>每个块内的记录都是完整的，这意味着不需要处理跨块的记录，大大简化了读取逻辑</strong>。另外，如果某个块损坏，只会影响该块内的记录，不会影响其他块的记录。</p><p>至此，将数据写入 WAL 日志文件的流程就介绍完了。下面我们来看看如何读取 WAL 日志文件。</p><h2 id="读-WAL-日志"><a href="#读-WAL-日志" class="headerlink" title="读 WAL 日志"></a>读 WAL 日志</h2><p>相比把数据切分记录然后写日志文件，读取日志并重构数据的逻辑稍微复杂一些。<a href="https://github.com/google/leveldb/blob/main/db/log_reader.h#L20">db&#x2F;log_reader.h</a> 中定义了 Reader 类，用于从日志文件中读取数据。Reader 中主要的数据成员是 <code>SequentialFile* const file_;</code>，指向<strong>支持顺序读取的日志文件</strong>。和 WritableFile 类似，SequentialFile 也是在 include&#x2F;leveldb&#x2F;env.h 中定义的抽象类接口，封装了文件系统的顺序读取操作，具体接口和实现可以参考 <a href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%96%87%E4%BB%B6">LevelDB 源码阅读：Posix 文件操作接口实现细节</a>。</p><p>Reader 类的主要方法是 <code>ReadRecord</code>，用于读取一条完整的数据，可以多次调用，顺序读取出所有的数据。读取过程如果发生一些意外数据，比如记录长度不合法、CRC 校验失败等，可以用 Reader 中定义的 Reporter 接口来记录错误信息。此外，Reader 还支持跳过文件中一定长度的数据，用于恢复数据时跳过已经读取过的数据。完整的实现在 <a href="https://github.com/google/leveldb/blob/main/db/log_reader.cc">db&#x2F;log_reader.cc</a> 中，下面详细看看。</p><h3 id="跳过开头数据"><a href="#跳过开头数据" class="headerlink" title="跳过开头数据"></a>跳过开头数据</h3><p>Reader 中有一个 last_record_offset_ 记录当前读取到的最新一条完整数据的偏移量，初始化为 0。后续每次读取到 kFullType 或者 kLastType 类型的记录时，会更新这个值。在 ReadRecord 入口处，先判断 last_record_offset_ 和 initial_offset_ 的大小，这里 initial_offset_ 在构造时传入，用于指定跳过读取的数据长度。如果 last_record_offset_ 小于 initial_offset_，则需要跳过文件中开始的 initial_offset_ 部分。这里跳过开头部分的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::SkipToInitialBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> offset_in_block = initial_offset_ % kBlockSize;</span><br><span class="line">  <span class="type">uint64_t</span> block_start_location = initial_offset_ - offset_in_block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t search a block if we&#x27;d be in the trailer</span></span><br><span class="line">  <span class="keyword">if</span> (offset_in_block &gt; kBlockSize - <span class="number">6</span>) &#123;</span><br><span class="line">    block_start_location += kBlockSize;</span><br><span class="line">  &#125;</span><br><span class="line">  end_of_buffer_offset_ = block_start_location;</span><br><span class="line">  <span class="comment">// Skip to start of first block that can contain the initial record</span></span><br><span class="line">  <span class="keyword">if</span> (block_start_location &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Status skip_status = file_-&gt;<span class="built_in">Skip</span>(block_start_location);</span><br><span class="line">    <span class="keyword">if</span> (!skip_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReportDrop</span>(block_start_location, skip_status);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个特殊的情况，如果 initial_offset_ 恰好位于一个逻辑块的末尾，这时候需要跳过这整个逻辑块。判断是否处于逻辑块的末尾比较简单，直接拿 initial_offset_ 取模逻辑块的大小(32kb)，如果剩余部分刚好在逻辑块的最后 6 个字节内，则说明处于逻辑块的尾部。注意这里跳的时候，只会跳过整个逻辑块，只保证了从 initial_offset_ 所在的<strong>逻辑块头部</strong>开始读取。可能导致读取到的第一条记录的偏移量小于 initial_offset_，这种情况在后面的 ReadPhysicalRecord 中会处理。</p><h3 id="解析一条完整数据"><a href="#解析一条完整数据" class="headerlink" title="解析一条完整数据"></a>解析一条完整数据</h3><p>ReadRecord 用于从日志文件中读取一条完整的数据，这里的完整数据可能包括多条记录，要把每一条都读出来然后拼接。</p><p>首先用 <strong>in_fragmented_record</strong> 来标记目前是否处于一个<strong>拆分的记录</strong>中，初始化为 false。然后进入一个 while 循环，不断调用 ReadPhysicalRecord 读取出记录，保存在 fragment 中，然后根据记录类型进行处理。注意这里有一个 <code>resyncing_</code>，在初始化的时候，如果有需要跳过的数据(initial_offset_&gt;0)，则会设置为 true，表示当前处于跳过数据的状态。在这种状态下，只要读取到 kFullType 类型的记录，就会更新 resyncing_ 为 false，表示跳过数据结束，开始正常读取数据。</p><p>读取数据部分，会根据当前记录的类型来判断是否需要拼接数据。</p><ul><li>如果是 kFullType 类型，说明这是一条完整的数据，直接将 fragment 设置为 result，更新 last_record_offset_；</li><li>如果是 kFirstType 类型，说明这是一条新的数据，将这条记录保存在 scratch 中，设置 in_fragmented_record 为 true；</li><li>如果是 kMiddleType 类型，说明这是一个数据的中间部分，in_fragmented_record 此时必须为 true，否则就报告错误。这时候 scratch 继续拼接新的记录。</li><li>如果是 kLastType 类型，说明这是一个数据的最后部分，in_fragmented_record 此时必须为 true，否则就报告错误。将最后部分的 fragment 拼接在 scratch 中，然后将 scratch 设置为 result，更新 last_record_offset_ 后返回。</li></ul><p>接着其实还有其他记录类型，比如 kEof 和 kBadRecord，这些都是异常情况，需要特殊处理。ReadRecord 核心逻辑如下，忽略掉部分错误处理的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::ReadRecord</span><span class="params">(Slice* record, std::string* scratch)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  record-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">bool</span> in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">  Slice fragment;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> record_type = <span class="built_in">ReadPhysicalRecord</span>(&amp;fragment);</span><br><span class="line">    <span class="keyword">if</span> (resyncing_) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (record_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> kFullType:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        *record = fragment;</span><br><span class="line">        last_record_offset_ = prospective_record_offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">case</span> kFirstType:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        scratch-&gt;<span class="built_in">assign</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        in_fragmented_record = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kMiddleType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(1)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kLastType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(2)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">          *record = <span class="built_in">Slice</span>(*scratch);</span><br><span class="line">          last_record_offset_ = prospective_record_offset;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取单个逻辑块"><a href="#读取单个逻辑块" class="headerlink" title="读取单个逻辑块"></a>读取单个逻辑块</h3><p>ReadPhysicalRecord <strong>封装了从逻辑块提取记录的过程</strong>。一个逻辑块的大小是 kBlockSize&#x3D;32KB，这个值在 <a href="https://github.com/google/leveldb/blob/main/db/log_format.h#L27">db&#x2F;log_format.h</a> 中定义。我们从磁盘读取文件的时候，<strong>以逻辑块为最小读取单元</strong>，读出来后缓存在内存中，然后逐条解析记录。这里最外层是一个 while 循环，首先判断 buffer_ 的大小，如果 buffer_ 中的数据不足以解析出一条记录(长度小于 kHeaderSize)，则从文件中读取一个逻辑块的数据到 buffer_ 中。</p><ul><li>如果从文件读取出来的长度小于 kBlockSize，说明读到了文件末尾，则设置 eof_ 为 true，然后继续进来循环，清空 buffer_ 中的数据，然后返回 kEof。</li><li>如果读文件出错，用 ReportDrop 报告读失败，清理 buffer_，设置 eof_ 为 true，然后直接返回 kEof。 </li><li>如果成功读取到 kBlockSize 的内容到 buffer_ ，则接着开始解析记录。</li></ul><p>当然，一个逻辑块 Block 中可能有多条记录，每次解析一条后 ReadPhysicalRecord 就会返回。这里返回前会更新 buffer_ 的指针，指向下一条记录的开始位置。下次重新进入 ReadPhysicalRecord 后，判断 buffer_ 中还有记录(长度大于 kHeaderSize)，则不会从文件读取，直接接着上次的位置从 buffer_ 中解析。</p><p>具体解析记录的代码和上面写记录的相反，先从 Header 中解析长度，crc32 等信息，然后把记录数据保存在 result 中，接着更新 buffer_ 的数据，指向下一条记录的开始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db/log_reader.cc</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Reader::ReadPhysicalRecord</span><span class="params">(Slice* result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer_.<span class="built_in">size</span>() &lt; kHeaderSize) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* header = buffer_.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">4</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">5</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> type = header[<span class="number">6</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    buffer_.<span class="built_in">remove_prefix</span>(kHeaderSize + length);    <span class="comment">// 指向下一条记录的开始位置</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *result = <span class="built_in">Slice</span>(header + kHeaderSize, length);</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面代码注释了一些异常处理部分逻辑，比如记录长度不合法，CRC 校验失败。这里的异常处理主要是通过 Reporter 接口来记录错误信息，然后清空 buffer_。这样即使在读取过程中发生了一些异常，最多只影响当前 buffer_ 解析，不会影响后续逻辑块的读取和解析。</p><p>还有一种异常是<strong>当前记录位于跳过的 initial_offset_ 范围内</strong>，这是因为前面我们跳过的时候，只跳过整个逻辑块，保证从 initial_offset_ <strong>所在的逻辑块头部</strong>开始读。如果当前记录的偏移量小于 initial_offset_，则说明这条记录是需要跳过的，调整 buffer_ 的开始部分，然后返回 kBadRecord。</p><h2 id="WAL-读写测试"><a href="#WAL-读写测试" class="headerlink" title="WAL 读写测试"></a>WAL 读写测试</h2><p><a href="https://github.com/google/leveldb/blob/main/db/log_test.cc">db&#x2F;log_test.cc</a> 中提供了一些工具辅助类和函数，以及详细的测试用例，来完整测试这里的 WAL 日志读写。比如用 BigString 生成指定长度的字符串，LogTest 类封装了 Reader 和 Writer 的读写逻辑，暴露了方便测试的接口，比如 Write、ShrinkSize、Read 等。此外这里没有直接读取文件，而是自己实现了 StringSource 类，继承自 SequentialFile，用 string 模拟读文件。实现了 StringDest 类，继承自 WritableFile，也是用 string 模拟写文件。</p><p>下面是一些正常读写的测试 case：</p><ul><li>Empty：测试直接读空文件，返回 EOF。</li><li>ReadWrite：测试简单的写入和读取，确保写入的数据能够正确读取。这里写入了一个空字符串，也是能正常读出来。</li><li>ManyBlocks：测试写入大量不同长度字符串，占用多个逻辑块。然后逐条读取，确保能够正确读取。</li><li>Fragmentation：测试写入超大的字符串，每条数据需要占用多条记录。然后逐条读取，确保能够正确读取。</li></ul><p>此外还构造了一些异常情况的测试 case，比如 TruncatedTrailingRecordIsIgnored 在 LevelDB 的日志系统中用于验证对<strong>日志文件末尾被截断的记录</strong>的处理。当日志文件的最后一个记录未能完整写入（例如，由于系统崩溃或者其他写入中断事件）时，这个不完整的记录会被忽略而不是被视为一个错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(LogTest, TruncatedTrailingRecordIsIgnored) &#123;</span><br><span class="line">  <span class="built_in">Write</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="built_in">ShrinkSize</span>(<span class="number">4</span>);  <span class="comment">// Drop all payload as well as a header byte</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;EOF&quot;</span>, <span class="built_in">Read</span>());</span><br><span class="line">  <span class="comment">// Truncated last record is ignored, not treated as an error.</span></span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="number">0</span>, <span class="built_in">DroppedBytes</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;&quot;</span>, <span class="built_in">ReportMessage</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BadLength 用来验证在处理记录长度字段被破坏（corrupted）的情况下的行为。测试确保日志系统能正确识别并且忽略由于<strong>记录长度字段错误导致的不合法记录</strong>，同时能够继续读取之后的有效记录，并且报告适当的错误信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(LogTest, BadLength) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> kPayloadSize = kBlockSize - kHeaderSize;</span><br><span class="line">  <span class="built_in">Write</span>(<span class="built_in">BigString</span>(<span class="string">&quot;bar&quot;</span>, kPayloadSize));</span><br><span class="line">  <span class="built_in">Write</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="comment">// Least significant size byte is stored in header[4].</span></span><br><span class="line">  <span class="built_in">IncrementByte</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;foo&quot;</span>, <span class="built_in">Read</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kBlockSize, <span class="built_in">DroppedBytes</span>());</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(<span class="string">&quot;OK&quot;</span>, <span class="built_in">MatchError</span>(<span class="string">&quot;bad record length&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用 IncrementByte 把第 4 个字节地方的值加 1，该位置存储的是记录的长度信息，因此导致记录长度增加。在读取的时候，会发现记录长度不合法，然后报告错误信息。校验长度部分逻辑在 ReadPhysicalRecord 中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kHeaderSize + length &gt; buffer_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">  <span class="type">size_t</span> drop_size = buffer_.<span class="built_in">size</span>();</span><br><span class="line">  buffer_.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">if</span> (!eof_) &#123;</span><br><span class="line">    <span class="built_in">ReportCorruption</span>(drop_size, <span class="string">&quot;bad record length&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kBadRecord;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> kEof;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还构造了大量的测试 case，用来验证初始跳过长度。这里封装了一个函数 CheckInitialOffsetRecord，来验证初始跳过长度的记录是否被正确跳过。这个函数会写入一些记录，然后设置 initial_offset_ 来读取记录，验证是否跳过了 initial_offset_ 长度的记录。</p><p>通过大量的测试用例，保证了 WAL 日志的读写逻辑的正确性。这里的测试用例也是非常值得学习的，可以帮助我们更好地理解 WAL 日志的读写逻辑。</p>]]></content>
    
    
    <summary type="html">探讨 LevelDB 的WAL（Write-Ahead Logging）日志读写接口。详细分析 WAL日志的写入过程，包括数据切分、记录格式和存储方式，同时阐述了日志读取的复杂逻辑，如何处理跨块记录和异常情况。还展示了相关的测试用例，验证WAL日志在各种场景下的正确性。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：理解其中的 C++ 高级技巧</title>
    <link href="https://selfboot.cn/2024/08/13/leveldb_source_unstand_c++/"/>
    <id>https://selfboot.cn/2024/08/13/leveldb_source_unstand_c++/</id>
    <published>2024-08-13T21:00:00.000Z</published>
    <updated>2024-08-30T13:06:40.795Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 整体代码还是比较好懂，<strong>没有用很多 C++奇淫技巧</strong>。不过还是有部分实现，相当比较少见，比如柔性数组、链接符号导出、Pimpl 类设计等。本文会梳理这里的 C++ 高级技巧，帮助更好地理解 LevelDB 的实现。</p><h2 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h2><p>在 <a href="https://github.com/google/leveldb/blob/main/util/cache.cc">util&#x2F;cache.cc</a> 的 LRUHandle 结构体定义中，有一个柔性数组(<strong>flexible array member</strong>) <code>char key_data[1]</code>，用来在 C&#x2F;C++ 中实现<strong>可变长数据结构</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LRUHandle</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>在这个 handle 结构体中，<code>key_data[1]</code>实际上只是一个占位符，真正分配给<code>key_data</code>的空间要比 1 字节大，它由 malloc 时计算的total_size确定。具体到 LevelDB 的实现中，在插入新的缓存条目时，会根据 key 的长度动态分配内存，然后将 key 的内容拷贝到这块内存中。如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">uint32_t</span> hash, <span class="type">void</span>* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">size_t</span> charge,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">void</span> (*deleter)(<span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 计算好一共需要的内存大小, 注意这里减去 1 是因为 key_data[1] 是一个占位符，本来已经有一个字节了</span></span><br><span class="line">  LRUHandle* e = <span class="built_in">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  <span class="comment">// 复制 key 数据到 key_data 中</span></span><br><span class="line">  std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// ... 忽略</span></span><br></pre></td></tr></table></figure><p>上面代码在单个 malloc 调用中同时为 LRUHandle 结构体和尾部的 key_data 数组<strong>分配连续的内存</strong>。避免了为键数据单独分配内存，从而<strong>减少了额外的内存分配开销和潜在的内存碎片问题</strong>。同时 LRUHandle 的整个数据结构紧凑地存储在一块连续的内存中，提高了空间利用率，还可能改善缓存局部性（cache locality）。如果改为使用 std::vector 或 std::string，将需要为每个 LRUHandle 对象分配两次内存：一次是为LRUHandle对象本身，一次是std::vector或std::string为存储数据动态分配的内存。在一个高性能的数据库实现中，这种内存分配的开销是不容忽视的。</p><p>另外，这里结构体尾部的数组长度为 1，还有不少代码中，<strong>尾部数组长度为 0 或者直接不写</strong>，这两种方法有啥区别吗？其实这两种做法都用于在结构体末尾添加可变长度的数据，<code>char key_data[];</code>是一种更明确的尾部数组声明方式，直接表示数组本身没有分配任何空间，是在C99标准中引入。不过这种声明在某些标准 C++ 版本中并不合法，尽管一些编译器可能作为扩展支持它。在C++中，为了避免兼容性问题，通常推荐使用<code>char key_data[1];</code>，因为在编译器中通常有更好的支持。</p><p>这里有一些讨论，也可以看看：<a href="https://stackoverflow.com/questions/14643406/whats-the-need-of-array-with-zero-elements">What’s the need of array with zero elements?</a> 和 <a href="https://stackoverflow.com/questions/4559558/one-element-array-in-struct">One element array in struct</a> 。</p><h2 id="链接符号导出"><a href="#链接符号导出" class="headerlink" title="链接符号导出"></a>链接符号导出</h2><p>在 include&#x2F;leveldb 中的很多类，比如 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/db.h">db.h</a> 中的 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/db.h#L46">DB 类</a>， 定义的时候带有一个宏 <code>LEVELDB_EXPORT</code>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> DB &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里宏的定义在 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/export.h">include&#x2F;leveldb&#x2F;export.h</a> 中，有许多编译选项分支，为了方便看，下面加了缩进(实际代码没有)，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LEVELDB_EXPORT)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_SHARED_LIBRARY)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> defined(_WIN32)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_COMPILE_LIBRARY)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __declspec(dllexport)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __declspec(dllimport)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(LEVELDB_COMPILE_LIBRARY)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span>  <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> defined(LEVELDB_COMPILE_LIBRARY)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT __attribute__((visibility(<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span>  <span class="comment">// defined(LEVELDB_SHARED_LIBRARY)</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> LEVELDB_EXPORT</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(LEVELDB_EXPORT)</span></span></span><br></pre></td></tr></table></figure><p>我们知道 leveldb 本身不像 mysql、postgres 一样提供数据库服务，它只是一个库，我们可以链接这个库来读写数据。为了将 leveldb 导出为动态链接库，需要控制符号的可见性和链接属性。为了支持跨平台构建，这里根据不同的平台信息来指定不同的属性。</p><p>在 Linux 系统上，编译库时如果有定义 LEVELDB_COMPILE_LIBRARY，则会加上 <code>__attribute__((visibility(&quot;default&quot;)))</code> 属性。它会将符号的链接可见性设置为默认的，这样其他链接到这个共享库的代码都可以使用这个类。</p><p>如果不加这个宏来导出符号有什么问题吗？在 Linux 环境下，<strong>所有符号默认都是可见的</strong>，这样会导出更多的符号，这不仅会导致库的尺寸增大，还可能与其他库中的符号发生冲突。而隐藏部分不对外公开的符号则可以帮助链接器优化程序，<strong>提高加载速度，减少内存占用</strong>。此外，通过导出宏，可以显式地控制哪些接口是公共的，哪些是私有的，<strong>隐藏实现细节实现良好的封装</strong>。</p><p>在没有定义 <code>LEVELDB_SHARED_LIBRARY</code> 的时候，LEVELDB_EXPORT 宏<strong>被定义为空</strong>，这意味着当 leveldb  被编译为静态库时，所有原本可能需要特殊导出导入标记的符号都不需要这样的标记了。静态链接的情况下，符号导出对于链接过程不是必需的，因为静态库的代码在编译时会直接被包含到最终的二进制文件中。</p><h2 id="Pimpl-类设计"><a href="#Pimpl-类设计" class="headerlink" title="Pimpl 类设计"></a>Pimpl 类设计</h2><p>在 LevelDB 的许多类中，都是只有一个指针类型的私有成员变量。比如 include&#x2F;leveldb&#x2F;table_builder.h 头文件的 TableBuild 类定义中，有私有成员变量 Rep *rep_，它是一个指向 Rep 结构体的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Rep</span>;</span><br><span class="line"> Rep* rep_;</span><br></pre></td></tr></table></figure><p>然后在 <a href="https://github.com/google/leveldb/blob/main/table/table_builder.cc">table&#x2F;table_builder.cc</a> 文件中定义了 Rep 结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TableBuilder</span>::Rep &#123;</span><br><span class="line">  <span class="built_in">Rep</span>(<span class="type">const</span> Options&amp; opt, WritableFile* f)</span><br><span class="line">      : <span class="built_in">options</span>(opt),</span><br><span class="line">        <span class="built_in">index_block_options</span>(opt),</span><br><span class="line">        <span class="built_in">file</span>(f),</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里<strong>为什么不直接在头文件中定义 Rep 结构体</strong>呢？其实这里是使用了 <strong>Pimpl(Pointer to Implementation)</strong> 设计模式，主要有下面几个优点：</p><ul><li><strong>二进制兼容</strong>（ABI stability）。当 TableBuilder 类库更新时，只要其接口(.h 文件)保持不变，即使实现中 Rep 结构体增加成员，或者更改接口的实现，依赖该库的应用程序<strong>只用更新动态库文件，无需重新编译</strong>。如果没有做到二进制兼容，比如为公开的类增加一些成员变量，应用程序只更新动态库，不重新编译的话，运行时就会因为对象内存分布不一致，导致程序崩溃。可以参考之前业务遇到的类似问题，<a href="https://selfboot.cn/2024/03/15/object_memory_coredump/">Bazel 依赖缺失导致的 C++ 进程 coredump 问题分析</a>。</li><li><strong>减少编译依赖</strong>。如果 Rep 结构体的定义在头文件中，那么任何对 Rep 结构体的修改都会导致包含了 table_builder.h 的文件重新编译。而将 Rep 结构体的定义放在源文件中，只有 table_builder.cc 需要重新编译。</li><li><strong>接口与实现分离</strong>。接口（在 .h 文件中定义的公共方法）和实现（在 .cc 文件中定义的 Rep 结构体以及具体实现）是完全分开的。这使得在不更改公共接口的情况下，开发者可以自由地修改实现细节，如添加新的私有成员变量或修改内部逻辑。</li></ul><p><strong>为什么使用成员指针后，会有上面的优点呢</strong>？这就要从 C++ 对象的内存布局说起，一个类的对象在内存中的布局是连续的，并且直接包含其所有的非静态成员变量。如果成员变量是简单类型（如 int、double 等）或其他类的对象，这些成员将直接嵌入到对象内存布局中。可以参考我之前的文章<a href="https://selfboot.cn/2024/05/10/c++_object_model/">结合实例深入理解 C++ 对象的内存布局</a> 了解更多内容。</p><p>当成员变量是一个指向其他类的指针，该成员在内存中的布局只有一个指针（Impl* pImpl），而不是具体的类对象。这个<strong>指针的大小和对齐方式是固定的，与 Impl 中具体包含什么数据无关</strong>。因此无论指针对应的类内部实现如何变化（例如增加或移除数据成员、改变成员的类型等），外部类的大小和布局都保持不变，也不会受影响。</p><p>在 《Effective C++》中，条款 31 就提到用这种方式来减少编译依赖：</p><blockquote><p>如果使用 object references 或 object pointers 可以完成任务，就不要使用objects。你可以只靠一个类型声明式就定义出指向该类型的 references 和 pointers；但如果定义某类型的 objects，就需要用到该类型的定义式。</p></blockquote><p>当然，软件开发没有银弹，这里的优点需要付出相应的开销，参考 <a href="https://en.cppreference.com/w/cpp/language/pimpl">cppreference.com: PImpl</a>：</p><ul><li><strong>生命周期管理开销（Runtime Overhead）</strong>: Pimpl 通常需要在堆上动态分配内存来存储实现对象（Impl 对象）。这种动态分配比<strong>在栈上分配对象（通常是更快的分配方式）慢</strong>，且涉及到更复杂的内存管理。此外，堆上分配内存，如果没有释放会造成内存泄露。不过就上面例子来说，Rep 在对象构造时分配，并在析构时释放，不会造成内存泄露。</li><li><strong>访问开销（Access Overhead）</strong>: 每次通过 Pimpl 访问私有成员函数或变量时，都需要通过指针间接访问。</li><li><strong>空间开销（Space Overhead）</strong>: 每个使用 Pimpl 的类都会在其对象中增加至少一个指针的空间开销来存储实现的指针。如果实现部分需要访问公共成员，可能还需要额外的指针或者通过参数传递指针。</li></ul><p>总的来说，对于基础库来说，Pimpl 是一个很好的设计模式。也可以参考 <a href="https://stackoverflow.com/questions/8972588/is-the-pimpl-idiom-really-used-in-practice">Is the PIMPL idiom really used in practice?</a> 了解更多讨论。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p><code>constexpr</code> 指定了用于声明常量表达式的变量或函数。这种声明的目的是告知编译器<strong>这个值或函数在编译时是已知</strong>的，这允许在编译期间进行更多的优化和检查。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kCacheSize = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>与 const 相比，constexpr 更强调编译期常量，而 const 变量在声明时就被初始化，但它们<strong>不一定非得在编译时确定</strong>，通常只是表示运行时不可修改。</p>]]></content>
    
    
    <summary type="html">深入解析了 LevelDB 中使用的 C++ 高级技巧，包括柔性数组、链接符号导出和 Pimpl 类设计等。文章通过具体代码示例详细说明了如何通过柔性数组实现可变长数据结构，优化内存使用和减少内存碎片。同时，介绍了符号导出的不同方法及其对跨平台编译的重要性，以及 Pimpl 设计模式在封装和二进制兼容性方面的应用。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：布隆过滤器原理、实现、测试与可视化</title>
    <link href="https://selfboot.cn/2024/08/08/leveldb_source_bloom_filter/"/>
    <id>https://selfboot.cn/2024/08/08/leveldb_source_bloom_filter/</id>
    <published>2024-08-08T11:38:52.000Z</published>
    <updated>2024-08-30T13:06:40.795Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 中数据存储在 SSTable 文件中，当用 Get() 来查询 key 的时候，可能需要从 SST 文件中读取多个块。为了减少磁盘读取，LevelDB 提供了 FilterPolicy 过滤策略，如果判断出来一个 Key 不在当前 SSTable 文件中，那么就可以跳过读取该文件，从而提高查询效率。</p><p>LevelDB 支持用户自定义过滤策略，不过提供了一个默认的布隆过滤器实现。布隆过滤器是一种空间效率极高的数据结构，用于判断一个元素是否存在于一个集合中，有一定的误判率但没有漏判。简单说就是如果<strong>布隆过滤器判断一个元素不存在，那么这个元素一定不存在；如果布隆过滤器判断一个元素存在，那么这个元素可能不存在</strong>。</p><span id="more"></span><p>在 LevelDB 中使用布隆过滤器也比较简单，如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leveldb::Options options;</span><br><span class="line">options.filter_policy = <span class="built_in">NewBloomFilterPolicy</span>(<span class="number">10</span>);</span><br><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;/tmp/testdb&quot;</span>, &amp;db);</span><br><span class="line"><span class="comment">// ... use the database ...</span></span><br><span class="line"><span class="keyword">delete</span> db;</span><br><span class="line"><span class="keyword">delete</span> options.filter_policy;</span><br></pre></td></tr></table></figure><p>那么布隆过滤器的原理是什么？LevelDB 中又是怎么实现的呢？本文一起来看看。</p><h2 id="LevelDB-接口定义"><a href="#LevelDB-接口定义" class="headerlink" title="LevelDB 接口定义"></a>LevelDB 接口定义</h2><p>在开始布隆过滤器的实现细节之前，先来看看 LevelDB 中对过滤器接口的定义。</p><p>LevelDB 在 <a href="https://github.com/google/leveldb/blob/main/include/leveldb/filter_policy.h">filter_policy.h</a> 中<strong>定义了过滤策略的接口</strong>。FilterPolicy 本身是一个抽象类，定义了 3 个纯虚函数作为接口，它不能直接实例化，而是必须由子类实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">FilterPolicy</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, <span class="type">int</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::string* dst)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; filter)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这 3 个接口都比较重要，代码里注释也写的非常详细，其中：</p><ul><li>Name(): 返回过滤策略的名称，<strong>对于版本兼容性非常重要</strong>。如果过滤策略的实现（即数据结构或算法）改变了，可能导致与旧版本不兼容，那么返回的名称应该反映这种改变，以防止旧的过滤策略被错误地使用。</li><li>CreateFilter(): 用于创建一个过滤器，即将 keys 中的所有 key 添加到过滤器中，然后将内容保存在 dst 中。</li><li>KeyMayMatch(): 用于判断 key 是否存在于过滤器中，这里的 filter 是 CreateFilter() 生成的 dst。如果 key 存在于过滤器中，那么一定要返回 true。<strong>如果不存在，那么可以返回 true，也可以返回 false，但是要保证返回 false 的概率要尽可能高</strong>。</li></ul><p>此外还提供了一个工厂函数，用于创建一个布隆过滤器实例。不过有个缺点就是使用完返回的过滤策略实例后，需要记得手动释放资源。这里使用工厂函数，<strong>允许库的维护者在不影响现有客户端代码的情况下更改对象的创建过程</strong>。例如，如果未来开发了一个更高效的布隆过滤器实现，<strong>可以简单地修改工厂函数以返回新的实现，而无需修改调用它的代码。这为将来的扩展和维护提供了便利</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LEVELDB_EXPORT <span class="type">const</span> FilterPolicy* <span class="title">NewBloomFilterPolicy</span><span class="params">(<span class="type">int</span> bits_per_key)</span></span>;</span><br></pre></td></tr></table></figure><p>这里通过定义过滤策略接口和使用工厂函数，可以方便开发者实现不同的过滤策略。要实现一个新的过滤策略，只用继承 <code>FilterPolicy</code> 类，并实现相应的方法即可。对于调用方来说，只需要将新的过滤策略传递给 <code>Options</code> 对象即可，整体改动会比较简单。</p><h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>LevelDB 自己实现了一个布隆过滤器，作为默认的过滤策略。在开始看实现代码之前，先大致了解下布隆过滤器的原理。</p><p>1970 年布顿·霍华德·布隆（Burton Howard Bloom）为了在拼写检查器中检查一个英语单词是否在字典里，创建了<a href="https://en.wikipedia.org/wiki/Bloom_filter">布隆过滤器</a>这个高效的数据结构。它的核心是一个 m 位的位数组和 k 个哈希函数，核心操作如下：</p><ol><li>初始化：开始时，布隆过滤器是一个包含 m 位的数组，每一位都设置为 0。</li><li>添加元素：将某个元素添加到布隆过滤器中时，首先使用 k 个哈希函数对元素进行哈希处理，产生 k 个数组位置索引，然后将这些位置的位都设置为 1。</li><li>查询元素：要检查一个元素是否在布隆过滤器中，也用相同的 k 个哈希函数对该元素进行哈希，得到 k 个索引。如果所有这些索引对应的位都是 1，那么<strong>元素可能存在于集合中</strong>；如果任何一个位是 0，则<strong>元素绝对不在集合中</strong>。</li></ol><p>通过上面的描述，可以发现添加或检查元素是否在集合中所需的时间是固定常数$ O( k )$，完全独立于集合中已有的元素数量。和其他表示集合的数据结构，比如 hash 表、平衡二叉树、跳表等相比，除了查找速度快，布隆过滤器的空间效率也非常高，它不需要存储元素本身，可以节省不少空间。</p><p>不过布隆过滤器也是有缺点的，仔细思考上面过程可以发现，<strong>布隆过滤器的查询结果有可能是误判的</strong>。布隆过滤器使用多个哈希函数对每个元素进行处理，将多个结果位置的位设置为 1，<strong>这些位置可能与其他元素的哈希结果重叠</strong>。假设有个 key 并不存在于集合中，但是它的哈希结果与其他元素的哈希结果重叠，那么布隆过滤器就会判断这个 key 存在于集合中，这就是所谓的假阳性（False Positive）。</p><p>当一个元素并不在集合中时，布隆过滤器错误地判定其存在的概率，就是假阳性率（false positive rate）。直观感觉上的话，<strong>对于固定的 k 个哈希函数，数组位数 m 越大，那么哈希碰撞越少，假阳性率就越低</strong>。为了设计一个良好的布隆过滤器，保证很低的假阳性率，上面的定性分析并不够，需要进行数学推导来定量分析。</p><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>这里先简单推导一下布隆过滤器误差率计算，可以跳过这部分直接阅读<a href="#LevelDB-%E5%AE%9E%E7%8E%B0">LevelDB 实现</a>部分。假设布隆过滤器使用的位数组大小为 $( m )$，哈希函数的数量为 $( k )$，并且已经向过滤器中添加了 $( n )$ 个元素。我们用的 hash 函数都很随机，因此<strong>可以假设哈希函数以相等的概率选择数组中的位置</strong>。插入元素过程中，某个位被某个哈希函数设置为 1 的概率是 $( \frac{1}{m} )$，未被设置为 1 的概率是 $( 1 - \frac{1}{m} )$。</p><p>$ k $ 是哈希函数的数量，我们选择的每个哈希函数之间没有相关性，互相独立。所以该位<strong>未被任何哈希函数设置为 1 的概率</strong>为：</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{k}} $$</p><p>接下来是一个数学技巧，自然对数 $ e $ 有个恒等式：</p><p>$$ {\displaystyle \lim _{m\to \infty }\left(1-{\frac {1}{m}}\right)^{m}&#x3D;{\frac {1}{e}}} $$</p><p>对于比较大的 m，我们可以得出：</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{k}&#x3D;\left(\left(1-{\frac {1}{m}}\right)^{m}\right)^{k&#x2F;m}\approx e^{-k&#x2F;m}} $$</p><p>我们插入了 n 个元素，所以某个位没有被设置为 1 的概率是：</p><p>$$ {\displaystyle \left(1-{\frac {1}{m}}\right)^{kn}\approx e^{-kn&#x2F;m}} $$</p><p>所以某个位被设置为 1 的概率是：</p><p>$$ {\displaystyle 1-\left(1-{\frac {1}{m}}\right)^{kn}\approx 1-e^{-kn&#x2F;m}} $$</p><p>假设某个元素不在集合中，但是 k 个位都被设置为 1 的概率是：</p><p>$$ {\displaystyle \left(1-e^{-kn&#x2F;m}\right)^{k}} $$</p><h3 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h3><p>通过上面的推导可以看出，假阳率与哈希函数的数量 $ k $、位数组的大小 $ m $ 以及添加的元素数量 $ n $ 有关。</p><ul><li>$ n $ 通常由应用场景确定，表示<strong>预期插入布隆过滤器的元素总数</strong>。可以预测，由外部因素决定，不易调整。</li><li>增加 $ m $ 可以直接减少误判率，但这会<strong>增加布隆过滤器的存储空间需求</strong>。在存储资源受限的环境中，可能不希望无限制地增加。另外扩大 $ m $ 的效果是<strong>线性的</strong>，需要平衡性能提升和额外的存储成本。</li><li>改变 $ k $ 对于<strong>误判率的影响非常显著</strong>，因为它直接影响到位数组中的位被设置为 1 的概率。</li></ul><p>综合考虑下来，在实际应用中，$ n $ 由使用场景决定，而 $ m $ 受到存储成本的限制，调整 $ k $ 成为了一个实际且直接的优化手段。在已知预期元素数量 $n$ 和位数组大小 $m$ 的情况下，<strong>需要找到一个合适的 k，使得误判率最小</strong>。</p><p>这里找到合适的 k 是一个优化问题，可以通过数学方法求解。比较复杂，这里直接说结论，最优的 $(k)$ 如下：</p><p>$$ k &#x3D; \frac{m}{n} \ln 2 $$</p><h2 id="LevelDB-实现"><a href="#LevelDB-实现" class="headerlink" title="LevelDB 实现"></a>LevelDB 实现</h2><p>上面介绍了布隆过滤器的原理，接下来看看 LevelDB 中具体是如何实现的。LevelDB 中布隆过滤器的实现在 <a href="https://github.com/google/leveldb/blob/main/util/bloom.cc">bloom.cc</a>，BloomFilterPolicy 继承了 FilterPolicy，实现了前面的接口。</p><h3 id="hash-个数选择"><a href="#hash-个数选择" class="headerlink" title="hash 个数选择"></a>hash 个数选择</h3><p>首先看这里 hash 函数个数 k 的选择，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="type">int</span> bits_per_key)</span> : bits_per_key_(bits_per_key) &#123;</span></span><br><span class="line">  <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">  k_ = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">  <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bits_per_key 这个参数在构造布隆过滤器的时候传入，LevelDB 中传的都是 10。这个值代表<strong>平均每个 key 占用的 bit 位数</strong>，即 $ \frac{m}{n} $。这里的 0.69 是 $ \ln (2) $ 的近似值，这个系数来源于上面讨论的最优哈希函数数量公式 $ k &#x3D; \frac{m}{n} \ln 2 $。最后这里进行了一些边界保护，保证 k 的取值范围在 1 到 30 之间，避免 k 过大 hash 计算太耗时。</p><h3 id="创建过滤器"><a href="#创建过滤器" class="headerlink" title="创建过滤器"></a>创建过滤器</h3><p>接下来看看这里过滤器是怎么创建的，<a href="https://github.com/google/leveldb/blob/main/util/bloom.cc#L28">完整代码</a>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, <span class="type">int</span> n, std::string* dst)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">  <span class="type">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">  <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">  <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">  bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">  dst-&gt;<span class="built_in">resize</span>(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">  dst-&gt;<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">  <span class="type">char</span>* array = &amp;(*dst)[init_size];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">    <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">    <span class="type">uint32_t</span> h = <span class="built_in">BloomHash</span>(keys[i]);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      array[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">      h += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是计算位数组需要的空间，根据键的数量 $ n $ 和每个键的平均位数计算需要的总位数。这里还考虑了些边界条件，如果得到的位数太少（少于 64 位），则设为 64 位以避免过高的误判率。另外，也考虑了字节对齐，将位数转换为字节，同时确保总位数是 8 的倍数。</p><p>接着用 resize 增加 dst 的大小，在<strong>目标字符串后面分配位数组的空间</strong>，这里布隆过滤器<strong>被设计为可以附加到现有的数据后面，而不会覆盖或删除已有数据</strong>。新增的空间会被初始化为 0，因为布隆过滤器的位数组需要从一个全零的状态开始。然后在目标字符串 dst 尾部添加 k_，即哈希函数的数量。这个值是布隆过滤器元数据的一部分，在查询键是否存在的时候用来确定需要进行多少次哈希计算。</p><p>最后是布隆过滤器的核心部分，计算哪些位数组位置需要设置为 1。正常来说需要设置 <strong>k 个 hash 函数，计算 k 次然后来设置对应位置</strong>。但是 LevelDB 的实现似乎不是这样的，对于每个键，使用 BloomHash 函数计算该键的初始哈希值 h，然后设置相应位置。之后的计算中，每次将上次的哈希值右移 17 位，左移 15 位然后进行或操作来计算 delta，然后用上次 hash 值加上 delta 来计算下一个 hash 值。这样就可以得到 k 个 hash 值，然后设置对应位置。</p><p>在前面的<a href="#%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC">数学推导</a>中提到过，这里 <strong>k 个 hash 函数要保证随机并且互相独立</strong>，上面的方法能满足这个要求吗？代码注释里提示有提到，这里是采用 <strong>double-hashing（双重哈希）</strong> 的方法，参考了 <a href="https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf">[Kirsch,Mitzenmacher 2006]</a> 的分析，虽然双重哈希生成的哈希值不如完全独立的哈希函数那样完全无关，但在实际应用中，它们提供了足够的随机性和独立性，可以满足布隆过滤器的要求。</p><p>这里的好处也是显而易见的，双重哈希可以从一个基础哈希函数生成多个伪独立的哈希值，不用实现 k 个 hash，实现上很简单。此外，与多个独立的哈希函数相比，<strong>双重哈希方法减少了计算开销，因为它只需计算一次真正的哈希值，其余的哈希值通过简单的算术和位操作得到</strong>。</p><h3 id="查询键存在"><a href="#查询键存在" class="headerlink" title="查询键存在"></a>查询键存在</h3><p>最后是查询键是否存在，如果看懂了前面的创建过滤器部分，这里就很容易理解了。<a href="https://github.com/google/leveldb/blob/main/util/bloom.cc#L56">完整代码</a> 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; bloom_filter)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* array = bloom_filter.<span class="built_in">data</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line">  <span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> k = array[len - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line">    <span class="comment">// Consider it a match.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> h = <span class="built_in">BloomHash</span>(key);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h % bits;</span><br><span class="line">    <span class="keyword">if</span> ((array[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    h += delta;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始部分就是一些边界条件判断，如果过滤器长度小于 2 返回 false。从过滤器数据的最后一个字节读取 k 的值，k 是在创建过滤器时存储的，用来确定需要进行多少次哈希计算。如果 k 大于 30，这种情况被视为可能用于未来新的编码方案，因此函数直接返回 true，假设键可能存在于集合中（直到 2024 年，这里也没扩展新的编码方案了）。</p><p>接下来的部分和创建过滤器的时候类似，使用 BloomHash 函数计算键的哈希值，然后进行位旋转以生成 delta，用于在循环中修改哈希值以模拟多个哈希函数的效果。在这个过程中，如果任何一个位为 0，则表明<strong>键绝对不在集合中</strong>，函数返回 false。如果所有相关位都是 1，则返回 true，表示<strong>键可能在集合中</strong>。</p><h2 id="布隆过滤器测试"><a href="#布隆过滤器测试" class="headerlink" title="布隆过滤器测试"></a>布隆过滤器测试</h2><p>LevelDB 中布隆过滤器的实现还提供了完整的测试代码，可以在 <a href="https://github.com/google/leveldb/blob/main/util/bloom_test.cc">bloom_test.cc</a> 中找到。</p><p>首先从 testing::Test 类派生 BloomTest 类，用于组织和执行与布隆过滤器相关的测试用例。其构造函数和析构函数用于创建和释放 NewBloomFilterPolicy 的实例，确保每个测试用例都能在一个干净的环境中运行。Add 方法用于向布隆过滤器添加键，Build 将收集的键转换成过滤器。Matches 方法用于检查特定键是否与过滤器匹配，而 FalsePositiveRate 方法用于<strong>评估过滤器的误判率</strong>。</p><p>接着就是一系列 TEST_F 宏定义的具体测试用例，允许每个测试用例自动拥有 BloomTest 类中定义的方法和属性。前面两个测试用例比较简单：</p><ul><li>EmptyFilter: 测试空过滤器，即没有添加任何键的情况下，过滤器是否能正确判断键不存在。</li><li>Small: 测试添加少量键的情况，检查过滤器是否能正确判断键是否存在。</li></ul><p>这里值得注意的是 VaryingLengths 测试用例，它是一个比较复杂的测试用例，来评估和验证<strong>布隆过滤器在不同数据规模（即不同数量的键）下的性能和效率</strong>。通过定义的 NextLength 函数来递增键的数量，测试在不同的键集大小下布隆过滤器的表现。主要测试下面三个方面：</p><ol><li>确保构建的布隆过滤器的大小在预期范围内;</li><li>确保所有添加到过滤器的键都能被正确地识别为存在;</li><li>评估布隆过滤器在不同长度下的误判率（假阳性率），确保误判率不超过2%。同时，根据误判率的大小分类过滤器为“好”（good）或“一般”（mediocre），并对它们的数量进行统计和比较，确保“一般”过滤器的数量不会太多。</li></ol><p>完整的测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">TEST_F</span>(BloomTest, VaryingLengths) &#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="built_in">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count number of filters that significantly exceed the false positive rate</span></span><br><span class="line">  <span class="type">int</span> mediocre_filters = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> good_filters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> length = <span class="number">1</span>; length &lt;= <span class="number">10000</span>; length = <span class="built_in">NextLength</span>(length)) &#123;</span><br><span class="line">    <span class="built_in">Reset</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="built_in">Add</span>(<span class="built_in">Key</span>(i, buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(<span class="built_in">FilterSize</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;((length * <span class="number">10</span> / <span class="number">8</span>) + <span class="number">40</span>))</span><br><span class="line">        &lt;&lt; length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All added keys must match</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="built_in">ASSERT_TRUE</span>(<span class="built_in">Matches</span>(<span class="built_in">Key</span>(i, buffer)))</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Length &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;; key &quot;</span> &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check false positive rate</span></span><br><span class="line">    <span class="type">double</span> rate = <span class="built_in">FalsePositiveRate</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      std::<span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                   <span class="string">&quot;False positives: %5.2f%% @ length = %6d ; bytes = %6d\n&quot;</span>,</span><br><span class="line">                   rate * <span class="number">100.0</span>, length, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">FilterSize</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT_LE</span>(rate, <span class="number">0.02</span>);  <span class="comment">// Must not be over 2%</span></span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0.0125</span>)</span><br><span class="line">      mediocre_filters++;  <span class="comment">// Allowed, but not too often</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      good_filters++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (kVerbose &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    std::<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Filters: %d good, %d mediocre\n&quot;</span>, good_filters,</span><br><span class="line">                 mediocre_filters);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ASSERT_LE</span>(mediocre_filters, good_filters / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是执行测试的结果：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_testcase.png" alt="布隆过滤器测试结果"></p><h2 id="布隆过滤器可视化"><a href="#布隆过滤器可视化" class="headerlink" title="布隆过滤器可视化"></a>布隆过滤器可视化</h2><p>在结束文章之前，我们再来看下<a href="https://gallery.selfboot.cn/zh/algorithms/bloomfilter">布隆过滤器的一个可视化演示</a>，把上面的原理和实现用图表展示出来，加深理解。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240808_leveldb_source_bloom_filter_visualization.png" alt="布隆过滤器可视化演示"></p><p>这个演示站点中，可以选择不同的哈希函数数量、预测 key 的数量。然后会自动调整位数组，之后可以添加元素，并检查元素是否在布隆过滤器中。如果在的话，会用黑色方框显示相应数组位。如果不在的话，会用红色方框显示相应数组位。这样可以直观理解布隆过滤器的工作原理。</p><p>同时为了方便演示，点击位组的时候会显示有哪些 key 经过 hash 后会落在这里。实际上布隆过滤器是不会存储这些信息的，这里是额外存储的，只是为了方便演示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>布隆过滤器是一种高效的数据结构，用于判断一个元素是否存在于一个集合中。它的核心是一个位数组和多个哈希函数，通过多次哈希计算来设置位数组中的位。通过严谨的数学推导，可以得出布隆过滤器的误判率与哈希函数的数量、位数组的大小和添加的元素数量有关。在实际应用中，可以通过调整哈希函数的数量来优化误判率。</p><p>LevelDB 中实现了一个布隆过滤器，作为默认的过滤策略，可以通过工厂函数创建，保留了扩展性。为了节省 hash 资源消耗，LevelDB 通过双重哈希方法生成多个伪独立的哈希值，然后设置对应的位。在查询时，也是通过多次哈希计算来判断键是否存在于集合中。LevelDB 提供了完整的测试用例，用于验证布隆过滤器的正确性和误判率。</p><p>另外，为了直观理解布隆过滤器的工作原理，我这里还做了一个布隆过滤器的可视化演示，通过图表展示了布隆过滤器的原理。</p>]]></content>
    
    
    <summary type="html">文章详细介绍了布隆过滤器的基本概念、数学原理和参数选择，并分析了LevelDB源码中的具体实现，包括哈希函数选择、过滤器创建和查询过程。同时展示了LevelDB的布隆过滤器测试用例，验证其正确性和性能。文章还提供了布隆过滤器的可视化演示，帮助读者直观理解其工作原理。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：准备开发环境</title>
    <link href="https://selfboot.cn/2024/08/06/leveldb_source_prepare/"/>
    <id>https://selfboot.cn/2024/08/06/leveldb_source_prepare/</id>
    <published>2024-08-06T20:31:43.000Z</published>
    <updated>2024-08-30T13:06:40.791Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 是 C++ 开发的优秀的 LSM Tree 的存储组件，整体代码量不大，但是设计精巧，值得学习。在阅读源码过程中，整理了<a href="https://selfboot.cn/tags/LevelDB/">系列文章</a>，逐步拆解 LevelDB 的实现细节。不过在阅读代码前，最好先准备好整个开发环境。</p><p>本文会从最基本的拉取代码开始，记录自己准备整个环境的过程，包括配置 VSCode IDE 和 clangd 插件使用，以及如何配置编译选项等。然后会通过简单的读写代码 demo，来简单使用下 LevelDB，对这个库有个感性的认识。另外，还会介绍如何运行测试用例，LevelDB 的测试用例写的很好，在代码阅读过程中，可以借助用例更好的理解代码。</p><span id="more"></span><h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><p>首先是拉代码，这里使用的是 <code>git clone --recurse-submodules</code>，可以一次性拉取所有的子模块。虽然 leveldb 的实现不依赖第三方库，不过压测用到了 benchmark，功能测试用到了 googletest，这两个库都是作为子模块引入的。</p><p>如果拉取代码遇到网络问题，比如下面这种，需要先绕过防火墙才行，可以参考<a href="https://selfboot.cn/2023/12/25/how-to-use-chatgpt/">安全、快速、便宜访问 ChatGPT，最新最全实践教程！</a> 这篇文章中的方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cloning into &#x27;/root/leveldb/third_party/googletest&#x27;...</span><br><span class="line">fatal: unable to access &#x27;https://github.com/google/googletest.git/&#x27;: GnuTLS recv error (-110): The TLS connection was non-properly terminated.</span><br><span class="line">fatal: clone of &#x27;https://github.com/google/googletest.git&#x27; into submodule path &#x27;/root/leveldb/third_party/googletest&#x27; failed</span><br><span class="line">Failed to clone &#x27;third_party/googletest&#x27;. Retry scheduled</span><br></pre></td></tr></table></figure><p>接下来就是编译整个源码，leveldb 用的 cmake 来构建，为了方便后面阅读代码，这里编译的时候加上了 <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=1</code>，这样会生成一个 <code>compile_commands.json</code> 文件，这个文件是 clangd 等工具的配置文件，可以帮助 VSCode 等 IDE 更好的理解代码。有了这个文件，代码跳转、自动补全等功能就会更好用。另外，为了方便用 GDB 进行调试，这里加上了 <code>-DCMAKE_BUILD_TYPE=Debug</code> 生成带调试信息的库。</p><p>完整的命令可以参考下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone --recurse-submodules  git@github.com:google/leveldb.git</span><br><span class="line"></span><br><span class="line">cd leveldb</span><br><span class="line">mkdir -p build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_INSTALL_PREFIX=$(pwd) .. &amp;&amp; cmake --build . --target install</span><br></pre></td></tr></table></figure><p>其中 <code>CMAKE_INSTALL_PREFIX</code> 选项用来指定安装目录，这里指定为当前目录(build 目录)，这样编译完之后，生成的库文件和头文件都会放在 build 目录下，方便后续使用。</p><p>这里 CMake 构建有不少选项，比如 <code>BUILD_SHARED_LIBS</code> 用来控制生成的库是静态链接库（.a 文件）还是动态链接库（.so 文件）。如果在 CMakeLists.txt 或通过命令行传递给 CMake 的参数中没有明确设置 <code>BUILD_SHARED_LIBS</code>，CMake 的默认行为通常是不启用构建共享库。命令行可以用 <code>cmake -DBUILD_SHARED_LIBS=ON ..</code> 来启用构建共享库。</p><h2 id="IDE-配置"><a href="#IDE-配置" class="headerlink" title="IDE 配置"></a>IDE 配置</h2><p>个人平时用 vscode 比较多，vscode 作为代码 IDE，可以说是十分好用。对 C++ 项目来说，虽然微软提供了官方的 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C++ 插件</a>，方便代码跳转等，但从个人使用体验来说，并不好用。这里强烈推荐使用 clangd 来阅读 C++ 代码，只需要<strong>在服务器安装 Clangd，然后在 vscode 安装 clangd 插件，再配合前面 Cmake 生成的编译数据库文件 compile_commands.json 即可</strong>。</p><p>Clangd 是一个基于 LLVM 项目的语言服务器，主要支持 C 和 C++ 的代码分析。它可以<strong>提供代码补全、诊断（即错误和警告）、代码跳转和代码格式化等功能</strong>。和微软自带的 C++ 插件比，clangd 响应速度十分快，并且借助 clang 能实现更精准的跳转和告警等。还支持用 <code>clang-tidy</code> 对项目代码进行静态分析，发现潜在错误。</p><p>比如在下面的代码中，clang-tidy 发现一个可疑问题：<code>Suspicious usage of ‘sizeof(A*)’</code>，还给出了 clang-tidy 的检查规则项 <a href="https://clang.llvm.org/extra/clang-tidy/checks/bugprone/sizeof-expression.html">bugprone-sizeof-expression</a>，这个规则是用来检查 <code>sizeof</code> 表达式的使用是否正确。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_clangd_tidy.png" alt="clangd 插件用 clang-tidy 找到的可疑地方"></p><p>这里 new_list 本身是一个指向指针的指针，new_list[0] 实际上就是一个指针，sizeof(new_list[0]) 是获取指针的大小，而不是指针所指向的元素的大小。不过这里设计本意就是如此，就是要给新的 bucket 设置初始值 nullptr。其实这个规则想防止的是下面这种错误：</p><blockquote><p>A common mistake is to compute the size of a pointer instead of its pointee. These cases may occur because of explicit cast or implicit conversion.</p></blockquote><p>比如下面这类代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="built_in">sizeof</span>(A + <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> point;</span><br><span class="line"><span class="built_in">memset</span>(point, <span class="number">0</span>, <span class="built_in">sizeof</span>(&amp;point));</span><br></pre></td></tr></table></figure><p>整体看，LevelDB 的代码质量很高，极少有 clang-tidy 提示。和业务代码的真是云泥之别，所以很值得学习。</p><h2 id="LevelDB-读改写"><a href="#LevelDB-读改写" class="headerlink" title="LevelDB 读改写"></a>LevelDB 读改写</h2><p>LevelDB 并<strong>不是一个类似 mysql 这样的数据库</strong>，也不支持 SQL 查询等功能，它只是一个<strong>快速的 key-value 存储库</strong>。LevelDB 没有自带的客户端和服务器代码，如果需要提供存储功能，需要自己实现相应逻辑。此外，只支持单进程访问指定数据库，不支持多进程访问。</p><p>业界一般把 LevelDB 作为存储组件底层依赖的一个库来使用，比如微信的核心存储 <a href="https://github.com/Tencent/paxosstore">paxosstore</a>，就会用 LevelDB 来存储数据。LevelDB 的使用入门比较简单，只需要引入头文件，然后调用相应的接口即可。下面代码实现了一个简单的命令行接口，使用 LevelDB 库来读写 key。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple_client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  leveldb::DB* db;</span><br><span class="line">  leveldb::Options options;</span><br><span class="line">  options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">  leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;./db&quot;</span>, &amp;db);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unable to open/create test database &#x27;./db&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string key;</span><br><span class="line">  std::string value;</span><br><span class="line">  std::string cmd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;leveldb&gt; &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; cmd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="string">&quot;set&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key &gt;&gt; value;</span><br><span class="line">      status = db-&gt;<span class="built_in">Put</span>(leveldb::<span class="built_in">WriteOptions</span>(), key, value);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error setting value: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;get&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key;</span><br><span class="line">      status = db-&gt;<span class="built_in">Get</span>(leveldb::<span class="built_in">ReadOptions</span>(), key, &amp;value);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;del&quot;</span>) &#123;</span><br><span class="line">      std::cin &gt;&gt; key;</span><br><span class="line">      status = db-&gt;<span class="built_in">Delete</span>(leveldb::<span class="built_in">WriteOptions</span>(), key);</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error deleting key: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;exit&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Unknown command. Supported commands are: set, get, del, exit&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用 Cmake 来构建，可以参考下面的 CMakeLists.txt 文件，当然下面的 include 和 lib 库的目录要根据前面编译好的目录来更改。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(SimpleLevelDBExamples VERSION <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 设置构建类型为 Debug 以包含调试信息</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"><span class="keyword">add_executable</span>(SimpleClient simple_client.cpp)</span><br><span class="line"><span class="keyword">include_directories</span>(../build/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(SimpleClient <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../build/libleveldb.a pthread)</span><br></pre></td></tr></table></figure><p>接着就可以用 <code>cmake --build .</code> 来编译二进制文件了。当然不习惯 cmake，直接用 gcc 也是可以的，只是需要手动指定头文件和库文件的路径。然后执行如下图，可以在类似 redis 的命令行 client 中操作 LevelDB。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240806_leveldb_source_prepare_simpleclient.png" alt="LevelDB 简单读写命令行接口"></p><p>可以在当前目录的 db 文件夹，看到 LevelDB 的数据存储文件，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> db</span> </span><br><span class="line">000005.ldb  000018.ldb  000020.ldb  000031.ldb  000036.log  CURRENT  LOCK  LOG  LOG.old  MANIFEST-000035</span><br></pre></td></tr></table></figure><p>后面会详细介绍 LevelDB 的数据存储方式，也会展开讲这些文件的作用，这里先不展开。</p><h2 id="跑好测试用例"><a href="#跑好测试用例" class="headerlink" title="跑好测试用例"></a>跑好测试用例</h2><p>到现在为止，我们已经编译 LevelDB 库，并且用 LevelDB 写了一个简单的读写命令行接口。接下来看看 LevelDB 的测试用例。LevelDB 的核心代码都有配套的测试用例，比如 LRU cache 中的 <a href="https://github.com/google/leveldb/blob/main/util/cache_test.cc">cache_test.cc</a>，db实现中的 <a href="https://github.com/google/leveldb/blob/main/db/db_test.cc">db_test.cc</a>，table 中的 <a href="https://github.com/google/leveldb/blob/main/table/table_test.cc">table_test.cc</a> 等等。用前面编译命令生成库的同时，会生成测试用例的可执行文件 <code>build/leveldb_tests</code>。</p><h3 id="动态库依赖"><a href="#动态库依赖" class="headerlink" title="动态库依赖"></a>动态库依赖</h3><p>如果直接运行 <code>leveldb_tests</code> 可能会提示缺少 <code>libtcmalloc</code> 动态库，这是 Google Perftools 的一个内存分配器，LevelDB 用到了这个库，需要在系统上安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/leveldb_tests: error while loading shared libraries: libtcmalloc.so.4: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>安装命令也很简单，比如在 debian 系统上，可以使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libgoogle-perftools-dev</span><br></pre></td></tr></table></figure><p>安装完之后，可以用 <code>ldd</code> 查看是否能找到，正常如下就可以运行二进制了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ldd ./build/leveldb_tests</span><br><span class="line">linux-vdso.so.1 (0x00007ffc0d1fc000)</span><br><span class="line">libtcmalloc.so.4 =&gt; /usr/local/lib/libtcmalloc.so.4 (0x00007f5277e91000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f5277c77000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f5277b98000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f5277b78000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5277997000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f52782ed000)</span><br></pre></td></tr></table></figure><p>这里在没有安装库之前，提示 <code>libtcmalloc.so.4 =&gt; not found</code>，安装动态库之后就<strong>自动链接</strong>到了正确的路径。怎么做到的呢？这是因为二进制文件包含了对动态库的引用，特别是<strong>库的名字和所需的符号（functions 或 data）</strong>。动态链接器（在 Linux 中通常是 <code>ld-linux.so</code>）负责处理这些引用。它会确定二进制文件需要哪些库，然后按照指定的路径和方法加载用到的库。</p><p>我们安装 tcmalloc 库之后，动态库文件 libtcmalloc.so.4 被复制到系统的库目录 &#x2F;usr&#x2F;local&#x2F;lib 中。然后安装程序会执行 ldconfig 更新 ld.so.cache，这个缓存包含库的路径信息，用来加快库的查找速度。这样后面再次运行二进制时，动态链接器查看缓存，找到新安装的库，并解析所有相关的符号引用，从而完成链接。</p><h3 id="修改、运行"><a href="#修改、运行" class="headerlink" title="修改、运行"></a>修改、运行</h3><p>这些功能测试用例都是用 gtest 框架编写的，我们可以通过 <code>--gtest_list_tests</code> 参数查看所有的测试用例。如下图所示：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_list_tests.png" alt="LevelDB 目前所有的测试用例"></p><p>如果直接运行 leveldb_tests，会执行所有的测试用例，不过我们可以通过 <code>--gtest_filter</code> 参数来指定只运行某个测试用例，比如 <code>--gtest_filter=&#39;CacheTest.*&#39;</code> 只运行 LRU cache 相关的测试用例。结果如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_cache_test.png" alt="只运行某个测试用例"></p><p><strong>测试用例可以帮助更好的理解代码逻辑。</strong>在阅读代码的过程中，有时候想验证一些逻辑，因此可以改动一下测试用例。比如我把一个能通过的测试用例故意改坏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--- a/util/cache_test.cc</span><br><span class="line">+++ b/util/cache_test.cc</span><br><span class="line">@@ <span class="number">-69</span>,<span class="number">7</span> +<span class="number">69</span>,<span class="number">7</span> @@ <span class="built_in">TEST_F</span>(CacheTest, HitAndMiss) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Insert</span>(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">   <span class="built_in">ASSERT_EQ</span>(<span class="number">101</span>, <span class="built_in">Lookup</span>(<span class="number">100</span>));</span><br><span class="line">-  <span class="built_in">ASSERT_EQ</span>(<span class="number">-1</span>, <span class="built_in">Lookup</span>(<span class="number">200</span>));</span><br><span class="line">+  <span class="built_in">ASSERT_EQ</span>(<span class="number">101</span>, <span class="built_in">Lookup</span>(<span class="number">200</span>));</span><br><span class="line">   <span class="built_in">ASSERT_EQ</span>(<span class="number">-1</span>, <span class="built_in">Lookup</span>(<span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Insert</span>(<span class="number">200</span>, <span class="number">201</span>);</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>修改用例后，需要重新编译 leveldb_tests。因为前面编译的时候，配置了项目的编译选项，CMake 已经缓存了下来，所以下面命令自动用了前面的配置项，比如 -DCMAKE_BUILD_TYPE&#x3D;Debug 等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target leveldb_tests</span><br><span class="line"></span><br><span class="line">[  2%] Built target gtest</span><br><span class="line">[ 58%] Built target leveldb</span><br><span class="line">[ 61%] Built target gtest_main</span><br><span class="line">[ 64%] Built target gmock</span><br><span class="line">[ 65%] Building CXX object CMakeFiles/leveldb_tests.dir/util/cache_test.cc.o</span><br><span class="line">[ 67%] Linking CXX executable leveldb_tests</span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">] Built target leveldb_tests</span></span><br></pre></td></tr></table></figure><p>注意上面的输出可以看到，这里只重新编译了改动的文件，生成了新的目标文件<code>cache_test.cc.o</code>，因此编译速度很快。重新运行后，就会看到测试用例不过了，如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240515_leveldb_source_prepare_gtest_cache_test_fail.png" alt="测试用例不过"></p><p>可以看到测试用例验证失败的具体原因。在阅读代码过程中，可以随时修改部分代码的用例，验证自己的理解是否正确。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跟着本文，大家应该都能快速准备好 LevelDB 的开发环境了吧。配置好 IDE，编译好源码，跑完简单的读写示例以及测试用例，然后一起来阅读源码吧～</p>]]></content>
    
    
    <summary type="html">介绍如何为 LevelDB 准备开发环境，包括源码拉取、编译和 VSCode 配置。通过简单的读写示例，读者可以对 LevelDB 有一个初步的认识。文章还介绍了如何使用 gtest 框架运行和修改测试用例，以便更好地理解代码逻辑。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：Posix 文件操作接口实现细节</title>
    <link href="https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/"/>
    <id>https://selfboot.cn/2024/08/02/leveldb_source_env_posixfile/</id>
    <published>2024-08-02T10:37:38.000Z</published>
    <updated>2024-08-30T13:06:40.791Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 支持在各种操作系统上运行，为了适配不同的操作系统，需要封装一些系统调用，比如文件操作、线程操作、时间操作等。在对外暴露的 include 文件中，<a href="https://github.com/google/leveldb/blob/main/include/leveldb/env.h">env.h</a> 文件定义了 LevelDB 用到的各种接口。包括 Env 类，封装文件操作，目录操作等，还有一些文件抽象类，比如 SequentialFile、WritableFile、RandomAccessFile 3 个类，用于顺序读取，随机读取和写入文件。</p><p>通过抽象接口，只需要为每个平台实现相应的 Env 子类，LevelDB 就可以在不同的操作系统上运行。这篇文章以 POSIX 系统环境为例，先来看看抽象出来的和<strong>文件操作相关的接口</strong>是怎么实现的。</p><span id="more"></span><h2 id="顺序读文件"><a href="#顺序读文件" class="headerlink" title="顺序读文件"></a>顺序读文件</h2><p>首先看看<strong>顺序读文件</strong>的抽象基类 SequentialFile，它为文件的顺序读取和跳过操作提供了一个标准的接口，可以用于 WAL 日志文件的读取。类中定义了2个主要的虚函数：</p><ul><li>Read(size_t n, Slice* result, char* scratch)：这个函数用于从文件中读取多达 n 字节的数据。result 是一个指向 Slice 类型的指针，用来存储读取的数据。scratch 是一个字符数组，用作临时缓冲区，函数可能会向这个缓冲区写入数据。</li><li>Skip(uint64_t n)：这个函数用于跳过文件中的 n 字节数据。如果文件读取到末尾，跳过操作将停止在文件末尾，函数返回 OK 状态。</li></ul><p>当然，注释里也说明了这个类需要<strong>调用者进行同步，以确保线程安全</strong>。在 POSIX 环境下，这个类的实现是在 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L136">env_posix.cc</a> 文件中，PosixSequentialFile 类 final 继承自 SequentialFile，阻止被其他任何类继承，同时实现了上述两个虚函数。其中 Read 的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">size_t</span> n, Slice* result, <span class="type">char</span>* scratch)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      ::<span class="type">ssize_t</span> read_size = ::<span class="built_in">read</span>(fd_, scratch, n);</span><br><span class="line">      <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) &#123;  <span class="comment">// Read error.</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">        &#125;</span><br><span class="line">        status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      *result = <span class="built_in">Slice</span>(scratch, read_size);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里当系统调用 <a href="https://man7.org/linux/man-pages/man2/read.2.html">read()</a> 返回值小于 0 时，会根据 errno 的值判断是否是 EINTR 错误，如果是则<strong>重试读取</strong>。这是因为，当对一个设置了 O_NONBLOCK 标志的文件描述符进行 read() 操作时，如果没有足够的数据可供读取，read() 会立即返回而不是阻塞等待数据变得可用。这种情况下，read() 将返回 -1 并且 errno 被设置为 EAGAIN，表明没有数据可读，可以稍后再试。</p><p>Skip 的实现则比较简单，直接调用系统调用 <a href="https://man7.org/linux/man-pages/man2/lseek.2.html">lseek()</a> 来跳过文件中的 n 个字节。这里第三个参数是 SEEK_CUR，表示<strong>从当前位置开始跳过 n 个字节</strong>。操作系统中，每个打开的文件都有一个与之关联的文件位置指针（有时也称为文件偏移量）。这个指针指示了下一次读取或写入操作将在文件中的哪个位置进行。<strong>操作系统负责跟踪和维护这个文件位置指针</strong>。当然也可以指定 SEEK_SET 或 SEEK_END，分别表示从文件开始和文件末尾开始跳过 n 个字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Skip</span><span class="params">(<span class="type">uint64_t</span> n)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (::<span class="built_in">lseek</span>(fd_, n, SEEK_CUR) == <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(<span class="number">-1</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在对象销毁时也要关闭文件描述符，确保资源被正确释放</strong>。每次打开文件，操作系统会分配一些资源，比如内核缓冲区、文件锁等。然后返回给用户一个文件描述符(非负整数)，之后用户通过这个文件描述符来操作文件。当我们调用 <a href="https://man7.org/linux/man-pages/man2/close.2.html">close</a> 时，操作系统会减少对该文件的引用计数，如果引用计数为 0，操作系统会释放相应资源。此外每个进程能打开的文件数量有限制，不调用 close(fd) 可能导致进程无法打开新的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">PosixSequentialFile</span>() <span class="keyword">override</span> &#123; <span class="built_in">close</span>(fd_); &#125;</span><br></pre></td></tr></table></figure><h2 id="随机读文件"><a href="#随机读文件" class="headerlink" title="随机读文件"></a>随机读文件</h2><p>RandomAccessFile 是一个抽象基类，定义<strong>随机读取文件</strong>的接口。它声明了一个纯虚函数 Read，强制子类实现这个方法。Read 方法的设计允许从文件的任意位置读取指定数量的字节。因为是一个只读接口，所以支持无锁多线程并发访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">char</span>* scratch)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>在 POSIX 环境下，这个类有 2 种实现，一个是用 <a href="https://man7.org/linux/man-pages/man2/pread.2.html">pread()</a> 实现的 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L176">PosixRandomAccessFile</a>，另一个是用 mmap() 实现的 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L238">PosixMmapReadableFile</a>。</p><h3 id="pread-随机读"><a href="#pread-随机读" class="headerlink" title="pread 随机读"></a>pread 随机读</h3><p>PosixRandomAccessFile 类实现了 RandomAccessFile 接口，主要用的是 POSIX 的 pread() 系统调用。该类的构造函数比较有意思，接收 filename，fd 和外部传入的 fd_limiter 指针。fd_limiter 用于限制持有的文件描述符的数量，避免打开的文件描述符过多，limiter 的具体实现在本文 <a href="#Limiter">Limiter</a> 部分。构造的时候，如果 fd_limiter-&gt;Acquire() 返回 true，说明可以一直持有这个文件描述符。否则的话，需要在构造函数中关闭文件描述符，<strong>在后面每次从文件读内容的时候再使用临时文件描述符</strong>。</p><p>这里 fd_limiter 在 <a href="#Env-%E5%B0%81%E8%A3%85%E6%8E%A5%E5%8F%A3">PosixEnv</a>的工厂函数里面创建，持久文件描述符的最大个数由 MaxOpenFiles 函数获得。首先检查全局变量 g_open_read_only_file_limit 是否被修改为非负数，如果是则使用这个值。如果没设置，则需要根据系统的资源限制来决定。这里通过系统调用 <a href="https://www.man7.org/linux/man-pages/man2/getrlimit.2.html">getrlimit</a> 来<strong>获取当前进程可以打开的最大文件描述符数</strong>。如果系统不限制进程可以打开的文件描述符数量，那么返回一个 int 类型的最大值，否则将这个限制数的20%分配给只读文件的操作。如果拿资源限制失败，或者系统(比如 Fuchsia 操作系统)不支持获取资源限制，则使用一个硬编码的数值 50。</p><p>接下来看看 PosixRandomAccessFile 的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The new instance takes ownership of |fd|. |fd_limiter| must outlive this</span></span><br><span class="line"><span class="comment">// instance, and will be used to determine if .</span></span><br><span class="line"><span class="built_in">PosixRandomAccessFile</span>(std::string filename, <span class="type">int</span> fd, Limiter* fd_limiter)</span><br><span class="line">    : <span class="built_in">has_permanent_fd_</span>(fd_limiter-&gt;<span class="built_in">Acquire</span>()),</span><br><span class="line">      <span class="built_in">fd_</span>(has_permanent_fd_ ? fd : <span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">fd_limiter_</span>(fd_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd_ == <span class="number">-1</span>);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);  <span class="comment">// The file will be opened on every read.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中还用成员变量 has_permanent_fd_ 来记录是否一直持有打开的文件描述符，如果没有则 fd_ 为 -1。对应的，在析构函数中，如果 has_permanent_fd_ 为 true，就需要调用 close() 关闭文件描述符，并释放 fd_limiter_ 的资源计数。接下来看该类的核心 Read 方法，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = fd_;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    fd = ::<span class="built_in">open</span>(filename_.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(fd != <span class="number">-1</span>);</span><br><span class="line">  Status status;</span><br><span class="line">  <span class="type">ssize_t</span> read_size = ::<span class="built_in">pread</span>(fd, scratch, n, <span class="built_in">static_cast</span>&lt;<span class="type">off_t</span>&gt;(offset));</span><br><span class="line">  *result = <span class="built_in">Slice</span>(scratch, (read_size &lt; <span class="number">0</span>) ? <span class="number">0</span> : read_size);</span><br><span class="line">  <span class="keyword">if</span> (read_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// An error: return a non-ok status.</span></span><br><span class="line">    status = <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!has_permanent_fd_) &#123;</span><br><span class="line">    <span class="comment">// Close the temporary file descriptor opened earlier.</span></span><br><span class="line">    <span class="built_in">assert</span>(fd != fd_);</span><br><span class="line">    ::<span class="built_in">close</span>(fd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先判断是否持有<strong>持久文件描述符</strong>，如果没有则需要在每次读取文件时打开文件。然后调用 pread() 读取文件内容，pread() 与 read() 类似，但是它可以从文件的指定位置读取数据。pread() 的第一个参数是文件描述符，第二个参数是读取的缓冲区，第三个参数是读取的字节数，第四个参数是文件中的偏移量。如果读取成功，将读取的数据存入 result 中，否则返回错误状态。最后如果没有持有持久文件描述符，需要在读取完数据后关闭临时文件描述符。</p><p>PosixRandomAccessFile 类实现相对简单，直接使用系统文件API，无需额外的内存映射管理，适用于小文件或者不频繁的读取操作。但是如果访问比较频繁，过多的系统调用可能导致性能下降，这时候就可以使用<strong>mmap 内存映射文件</strong>来提高性能。</p><h3 id="mmap-随机读"><a href="#mmap-随机读" class="headerlink" title="mmap 随机读"></a>mmap 随机读</h3><p>PosixMmapReadableFile 类同样实现了 RandomAccessFile 接口，不过通过内存映射（mmap）将文件或文件的一部分映射到进程的地址空间，访问这部分内存就相当于访问文件本身。<strong>内存映射允许操作系统利用页缓存，可以显著提高频读取的性能，尤其是在大文件场景下，可以提高读取效率</strong>。</p><p>和 PosixRandomAccessFile 有些不同，这里在构造的时候需要传入 mmap_base 指针，指向通过 mmap 系统调用映射的文件内容，同时还需要传入 length 即映射区域的长度，即文件的大小。这里的映射在外面 NewRandomAccessFile 方法中做，PosixMmapReadableFile 直接使用映射好的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PosixMmapReadableFile</span>(std::string filename, <span class="type">char</span>* mmap_base, <span class="type">size_t</span> length,</span><br><span class="line">                      Limiter* mmap_limiter)</span><br><span class="line">    : <span class="built_in">mmap_base_</span>(mmap_base),</span><br><span class="line">      <span class="built_in">length_</span>(length),</span><br><span class="line">      <span class="built_in">mmap_limiter_</span>(mmap_limiter),</span><br><span class="line">      <span class="built_in">filename_</span>(std::<span class="built_in">move</span>(filename)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>当然，这里 mmap 也需要限制资源，避免耗尽虚拟内存，这里同样用的是 Limiter 类，后面会详细介绍。Read 方法<strong>直接从 mmap_base_ 中读取数据，不需要再调用系统调用</strong>，效率高很多，整体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Read</span><span class="params">(<span class="type">uint64_t</span> offset, <span class="type">size_t</span> n, Slice* result,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">char</span>* scratch)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (offset + n &gt; length_) &#123;</span><br><span class="line">    *result = <span class="built_in">Slice</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, EINVAL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *result = <span class="built_in">Slice</span>(mmap_base_ + offset, n);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序写文件"><a href="#顺序写文件" class="headerlink" title="顺序写文件"></a>顺序写文件</h2><p>前面都是读文件，当然也少不了写文件接口了。WritableFile 是一个抽象基类，定义<strong>顺序写入文件</strong>的接口。它为文件的顺序写入和同步操作提供了一个标准的接口，可以用于 WAL 日志文件的写入。类中定义了3个主要的虚函数：</p><ul><li>Append(const Slice&amp; data)：向文件对象中追加数据，对于小块数据追加在对象的内存缓存中，对于大块数据则调用 WriteUnbuffered 写磁盘。</li><li>Flush()：将目前内存缓存中的数据调用系统 write 写磁盘，注意这里<strong>不保证数据已被同步到物理磁盘</strong>。</li><li>Sync()：确保内部缓冲区的数据被写入文件，还<strong>确保数据被同步到物理磁盘</strong>，以保证数据的持久性。调用 Sync() 之后，即使发生电源故障或系统崩溃，数据也不会丢失了。</li></ul><p>在 POSIX 环境下，这个类的实现是 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L277">PosixWritableFile</a>。类内部使用了一个<strong>大小为 65536 字节的缓冲区</strong> <code>buf_</code>，只有缓冲区满才会将数据写入磁盘文件。如果有大量的短内容写入，就可以先在内存中合并，从而减少对底层文件系统的调用次数，提高写操作的效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">size_t</span> kWritableFileBufferSize = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buf_[0, pos_ - 1] contains data to be written to fd_.</span></span><br><span class="line">  <span class="type">char</span> buf_[kWritableFileBufferSize];</span><br></pre></td></tr></table></figure><p>这里合并写入的策略在 Append 中实现，代码比较清晰。对于写入的内容，如果能够完全放入缓冲区，则直接拷贝到缓冲区中，然后就返回成功。否则先填满缓冲区，然后将缓存区中的数据写入文件，此时如果剩余的数据能够写入缓冲区则直接写，不然就直接刷到磁盘中。完整实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Append</span><span class="params">(<span class="type">const</span> Slice&amp; data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> write_size = data.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* write_data = data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fit as much as possible into buffer.</span></span><br><span class="line">  <span class="type">size_t</span> copy_size = std::<span class="built_in">min</span>(write_size, kWritableFileBufferSize - pos_);</span><br><span class="line">  std::<span class="built_in">memcpy</span>(buf_ + pos_, write_data, copy_size);</span><br><span class="line">  write_data += copy_size;</span><br><span class="line">  write_size -= copy_size;</span><br><span class="line">  pos_ += copy_size;</span><br><span class="line">  <span class="keyword">if</span> (write_size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Can&#x27;t fit in buffer, so need to do at least one write.</span></span><br><span class="line">  Status status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Small writes go to buffer, large writes are written directly.</span></span><br><span class="line">  <span class="keyword">if</span> (write_size &lt; kWritableFileBufferSize) &#123;</span><br><span class="line">    std::<span class="built_in">memcpy</span>(buf_, write_data, write_size);</span><br><span class="line">    pos_ = write_size;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WriteUnbuffered</span>(write_data, write_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面将数据写入磁盘调用的是 WriteUnbuffered 函数，该函数通过系统调用 <a href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a> 实现，主要代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteUnbuffered</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> write_result = ::<span class="built_in">write</span>(fd_, data, size);</span><br><span class="line">    <span class="keyword">if</span> (write_result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// Retry</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename_, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    data += write_result;</span><br><span class="line">    size -= write_result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 Append 函数，WritableFile 还提供了 Flush 接口，用于将内存缓冲区 buf_ 的数据写入文件，它内部也是通过调用 WriteUnbuffered 来实现。不过值得注意的是，这里 Flush 写磁盘成功，并<strong>不保证数据已经写入磁盘，甚至不能保证磁盘有足够的空间来存储内容</strong>。如果要保证数据写物理磁盘文件成功，需要调用 Sync() 接口，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Sync</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  Status status = <span class="built_in">SyncDirIfManifest</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line">  status = <span class="built_in">FlushBuffer</span>();</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SyncFd</span>(fd_, filename_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里核心是调用 SyncFd() 方法，<strong>确保文件描述符 fd 关联的所有缓冲数据都被同步到物理磁盘</strong>。该函数的实现考虑了不同的操作系统特性和文件系统行为，使用了条件编译指令（#if、#else、#endif）来处理不同的环境。在 macOS 和 iOS 系统上，使用了 fcntl() 函数的 <code>F_FULLFSYNC</code> 选项来确保数据被同步到物理磁盘。如果定义了 HAVE_FDATASYNC，将使用 fdatasync() 来同步数据。其他情况下，默认使用 fsync() 函数来实现同样的功能。</p><p>注意这里 SyncDirIfManifest 确保如果文件是 manifest 文件(以 “MANIFEST” 开始命名的文件)，相关的目录更改也得到同步。mainfest 文件记录数据库文件的元数据，包括版本信息、合并操作、数据库状态等关键信息。文件系统在创建新文件或修改文件目录项时，这些变更可能并不立即写入磁盘。<strong>在更新 manifest 文件前确保所在目录的数据已被同步到磁盘</strong>，防止系统崩溃时，manifest 文件引用的文件尚未真正写入磁盘。</p><h2 id="资源并发限制"><a href="#资源并发限制" class="headerlink" title="资源并发限制"></a>资源并发限制</h2><p>上面提到为了避免打开的文件描述符过多，使用 Limiter 类的 Acquire 来进行限制，该类的也在实现在 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc#L73">env_posix.cc</a>中。这个类的注释也写的特别棒，把它的作用讲的很明白，主要用来限制资源使用，避免资源耗尽。目前用于限制只读文件描述符和 mmap 文件使用，以避免耗尽文件描述符或虚拟内存，或者在非常大的数据库中遇到内核性能问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper class to limit resource usage to avoid exhaustion.</span></span><br><span class="line"><span class="comment">// Currently used to limit read-only file descriptors and mmap file usage</span></span><br><span class="line"><span class="comment">// so that we do not run out of file descriptors or virtual memory, or run into</span></span><br><span class="line"><span class="comment">// kernel performance problems for very large databases.</span></span><br></pre></td></tr></table></figure><p>构造函数接受一个参数 max_acquires，这个参数设定了可以获取的最大资源数量。类内部维护了一个原子变量 acquires_allowed_ 来跟踪当前允许被获取的资源数量，初始值设置为 max_acquires。这里用到了条件编译，NDEBUG 是一个常用的预处理宏，用来指明程序是否在非调试模式下编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Limit maximum number of resources to |max_acquires|.</span></span><br><span class="line">  <span class="built_in">Limiter</span>(<span class="type">int</span> max_acquires)</span><br><span class="line">      :</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(NDEBUG)</span></span><br><span class="line">        <span class="built_in">max_acquires_</span>(max_acquires),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !defined(NDEBUG)</span></span></span><br><span class="line">        <span class="built_in">acquires_allowed_</span>(max_acquires) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(max_acquires &gt;= <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果在调试模式下，就用 max_acquires_ 来记录最大资源数量，同时在 Acquire 和 Release 方法中加入了断言，确保资源的获取和释放操作正确。在生产环境中，当 <strong>NDEBUG 被定义时，所有的 assert 调用将被编译器忽略，不会产生任何执行代码</strong>。</p><p>该类的核心接口是 Acquire 和 Release，这两个方法分别用来获取和释放资源，Acquire 的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> old_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (old_acquires_allowed &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pre_increment_acquires_allowed = acquires_allowed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Silence compiler warnings about unused arguments when NDEBUG is defined.</span></span><br><span class="line">  (<span class="type">void</span>)pre_increment_acquires_allowed;</span><br><span class="line">  <span class="comment">// If the check below fails, Release() was called more times than acquire.</span></span><br><span class="line">  <span class="built_in">assert</span>(pre_increment_acquires_allowed &lt; max_acquires_);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 fetch_sub(1, std::memory_order_relaxed) 原子地减少 acquires_allowed_ 的值，并返回减少前的值 old_acquires_allowed。如果 old_acquires_allowed 大于0，说明在减少之前还有资源可以被获取，因此返回 true。如果没有资源可用（即 old_acquires_allowed 为0或负），则通过 fetch_add(1, std::memory_order_relaxed) 原子地将计数器加回1，恢复状态，并返回 false。</p><p>Release 方法用来释放之前通过 Acquire 方法成功获取的资源。它使用 fetch_add(1, std::memory_order_relaxed) 原子地增加 acquires_allowed_ 的值，表示资源被释放，同时用断言保证 Release 的调用次数不会超过 Acquire 的成功次数，防止资源计数错误。</p><p>这里在操作原子计数的时候，使用的是 std::memory_order_relaxed，表明这些原子操作<strong>不需要对内存进行任何特别的排序约束</strong>，只保证操作的原子性。这是因为这里的操作并不依赖于任何其他的内存操作结果，只是简单地递增或递减计数器。</p><h2 id="Env-封装接口"><a href="#Env-封装接口" class="headerlink" title="Env 封装接口"></a>Env 封装接口</h2><p>除了上面的几个文件操作类来，还有一个重要的 Env 抽象基类，在 Posix 下派生了 PosixEnv，封装了不少实现。</p><h3 id="工厂构造对象"><a href="#工厂构造对象" class="headerlink" title="工厂构造对象"></a>工厂构造对象</h3><p>首先是几个工厂方法，用于创建前面提到的文件读写对象 SequentialFile、RandomAccessFile 和 WritableFile 对象。NewSequentialFile 工厂方法来创建一个 PosixSequentialFile 文件对象，这里封装了打开文件的调用。这里用工厂方法的好处是，可以在工厂方法中处理一些错误，比如文件打开失败。此外这里入参是 <code>WritableFile**</code> ，支持了多态，如果后续加入其他的 WritableFile 实现，可以在不修改调用代码的情况下，通过修改工厂方法来切换到不同的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewSequentialFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                         SequentialFile** result)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    *result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PosixError</span>(filename, errno);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *result = <span class="keyword">new</span> <span class="built_in">PosixSequentialFile</span>(filename, fd);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里打开文件时候，传入 flag 除了 O_RDONLY 表示只读外，还有一个 kOpenBaseFlags。kOpenBaseFlags 是一个根据编译选项 HAVE_O_CLOEXEC 来决定是否设置的 flag，如果系统支持 O_CLOEXEC，就会设置这个 flag。O_CLOEXEC 确保在执行 exec() 系列函数时<strong>自动关闭文件描述符，从而防止文件描述符泄露到执行的新程序</strong>中。</p><p>默认情况下，当一个进程创建子进程时，所有的文件描述符都会被子进程继承。除非显式地对每个文件描述符进行处理，否则它们在 exec 执行后仍然会保持打开状态。大多数情况下，如果一个进程打算执行另一个程序（通常通过 exec 系列函数），很有可能不希望新程序访问当前进程的某些资源，特别是文件描述符。O_CLOEXEC 标志确保这些文件描述符在 exec 后自动关闭，从而不会泄露给新程序。虽然 LevelDB 本身不会调用 exec 函数，但是这里还是加上了这个 flag，这是一个良好的防御编程习惯。</p><p>当然这个 flag 不一定是所有平台支持，为了跨平台，在 <a href="https://github.com/google/leveldb/blob/main/CMakeLists.txt#L54">CmakeLists.txt</a> 中，用check_cxx_symbol_exists 来检测当前环境的 fcntl.h 文件是否有 O_CLOEXEC，有的话则定义 HAVE_O_CLOEXEC 宏。这里特别提下，check_cxx_symbol_exists 还挺有用的，可以<strong>在编译之前确定特定的特性是否被支持，以便根据检测结果适当调整编译设置或源代码</strong>。LevelDB 中有多个宏就是这样检测的，比如 fdatasync、F_FULLFSYNC 等。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">check_cxx_symbol_exists(fdatasync <span class="string">&quot;unistd.h&quot;</span> HAVE_FDATASYNC)</span><br><span class="line">check_cxx_symbol_exists(F_FULLFSYNC <span class="string">&quot;fcntl.h&quot;</span> HAVE_FULLFSYNC)</span><br><span class="line">check_cxx_symbol_exists(O_CLOEXEC <span class="string">&quot;fcntl.h&quot;</span> HAVE_O_CLOEXEC)</span><br></pre></td></tr></table></figure><p>NewWritableFile 和 NewAppendableFile 工厂函数都是类似的，先打开文件，然后创建 PosixWritableFile 对象。不过这里 open 文件的时候，用的不同 flag:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_TRUNC | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br><span class="line"><span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_APPEND | O_WRONLY | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure><p>O_TRUNC 表示如果文件存在，就将文件长度截断为 0。O_APPEND 表示在写入数据时，总是将数据追加到文件末尾，而不是覆盖文件中已有的数据。</p><p>NewRandomAccessFile 稍微复杂了一些，因为要支持两种随机读的模式。首先打开文件拿到 fd，然后根据 mmap_limiter_ 来限制内存映射打开文件数量，如果超过 mmap 限制，就用 pread 来随机读。没超过限制的话，就用 mmap 来内存映射文件，拿到映射的地址和文件大小，然后创建 PosixMmapReadableFile 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewRandomAccessFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                           RandomAccessFile** result)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> fd = ::<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!mmap_limiter_.<span class="built_in">Acquire</span>()) &#123;</span><br><span class="line">    *result = <span class="keyword">new</span> <span class="built_in">PosixRandomAccessFile</span>(filename, fd, &amp;fd_limiter_);</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint64_t</span> file_size;</span><br><span class="line">  Status status = <span class="built_in">GetFileSize</span>(filename, &amp;file_size);</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="type">void</span>* mmap_base = ::<span class="built_in">mmap</span>(<span class="comment">/*addr=*/</span><span class="literal">nullptr</span>, file_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmap_base != MAP_FAILED) &#123;</span><br><span class="line">      *result = <span class="keyword">new</span> <span class="built_in">PosixMmapReadableFile</span>(filename,</span><br><span class="line">                                          <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(mmap_base),</span><br><span class="line">                                          file_size, &amp;mmap_limiter_);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  ::<span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    mmap_limiter_.<span class="built_in">Release</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 mmap_limiter_ 限制的最大文件数量由 MaxMmaps 函数获得。对于64位系统，由于有非常大的虚拟内存地址空间（实际应用中通常超过 256TB），因此 LevelDB 允许分配 1000 个内存映射区，应该不会对系统的整体性能产生显著影响。而对于32位系统，由于虚拟内存地址空间有限，LevelDB 不允许分配内存映射区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Up to 1000 mmap regions for 64-bit binaries; none for 32-bit.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> kDefaultMmapLimit = (<span class="built_in">sizeof</span>(<span class="type">void</span>*) &gt;= <span class="number">8</span>) ? <span class="number">1000</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="文件工具类"><a href="#文件工具类" class="headerlink" title="文件工具类"></a>文件工具类</h3><p>除了上面几个核心的文件类，Env 还提供了一系列文件操作的接口，包括文件元信息获取、文件删除等，刚好可以借此来熟悉下 <a href="https://github.com/google/leveldb/blob/main/util/env_posix.cc">Posix 环境下的各种系统调用</a>。</p><p>FileExists: 判断 <strong>当前进程是否可以访问该文件(不能访问不代表文件不存在)</strong> ，通过调用系统调用 <a href="https://man7.org/linux/man-pages/man2/access.2.html">access()</a> 实现；</p><p>RemoveFile: 如果没有任何进程正在使用该文件(即没有任何打开的文件描述符指向这个文件)，则会删除该文件。通过系统调用 <a href="https://man7.org/linux/man-pages/man2/unlink.2.html">unlink()</a> 实现，unlink 实际上删除的是文件名和其对应 inode 之间的链接。如果这个 inode 没有其他链接，并且没有任何进程打开这个文件，文件实际的数据块和 inode 才会被释放。</p><p>GetFileSize: 获取文件的大小，如果文件不存在或者获取失败，返回 0。这里通过 <a href="https://man7.org/linux/man-pages/man2/stat.2.html">stat</a> 系统调用实现。调用 stat 函数时，需要传递文件名和一个 stat 结构体的指针。系统会检查文件名对应的路径权限，然后获取文件的 inode。inode 是文件系统中的一个数据结构，保存了文件的元数据，包括文件大小、权限、创建时间、最后访问时间等。在文件系统会保持一个 inode 表，用于快速查找和访问 inode 信息，对于大部分文件系统（如 EXT4, NTFS, XFS 等）来说，通常会在内存中缓存常用的 inode，因此获取 inode 一般会十分高效。</p><p>RenameFile: 重命名文件或者文件夹，这里可以指定新旧文件名，通过系统调用 <a href="https://man7.org/linux/man-pages/man2/rename.2.html">rename()</a> 实现。</p><p>CreateDir: 创建一个目录，默认权限是 755。这里通过系统调用 <a href="https://man7.org/linux/man-pages/man2/mkdir.2.html">mkdir()</a> 实现，如果 pathname 已经存在，这里返回失败。</p><p>RemoveDir: 删除一个目录，这里通过系统调用 <a href="https://man7.org/linux/man-pages/man2/rmdir.2.html">rmdir()</a> 实现。</p><p>GetChildren: 稍微复杂一点，通过系统调用 opendir 获得目录，然后用 readdir 遍历其中的文件，最后还要记得 closedir 来清理资源。 </p><h2 id="文件操作总结"><a href="#文件操作总结" class="headerlink" title="文件操作总结"></a>文件操作总结</h2><p>不得不说，一个简单的文件操作封装，包含了不少实现细节，这里简单总结下吧：</p><ol><li>缓冲区优化: 在 WritableFile 实现中使用了内存缓冲区，可以合并小型写入操作，减少系统调用次数，提高写入效率。</li><li>资源限制管理: 使用 Limiter 类来限制同时打开的文件描述符数量和内存映射(mmap)数量，通过设置合理的限制上限，避免资源耗尽，提高系统稳定性和性能。</li><li>灵活的读取策略: 对于随机读取，LevelDB 提供了基于 pread 和 mmap 两种实现，可以根据系统资源情况动态选择最合适的方式。</li><li>工厂方法模式: 使用工厂方法创建文件对象，封装了文件打开等操作，方便错误处理和未来的扩展。</li><li>跨平台兼容性: 通过条件编译和特性检测(如 O_CLOEXEC 的检查)，保证了代码在不同平台上的兼容性。</li><li>同步机制: 提供了 Flush 和 Sync 接口，允许用户根据需要选择不同级别的数据持久化保证。</li></ol><p>除了封装文件操作，Env 里面还有其他封装，下篇见吧。</p>]]></content>
    
    
    <summary type="html">文章详细介绍了 LevelDB 抽象的文件操作，包括顺序读写、随机读取文件在 Posix 下的实现，以及如何通过抽象接口适配不同操作系统。还介绍了缓冲区优化、资源限制管理、灵活读取策略等关键设计，来提升系统的性能和可用性。此外还有工厂方法模式的应用、错误处理机制和跨平台兼容性考虑等实现细节。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  <entry>
    <title>从法院判决书看性骚扰行为的后果</title>
    <link href="https://selfboot.cn/2024/07/23/lawer_sexual_harassment/"/>
    <id>https://selfboot.cn/2024/07/23/lawer_sexual_harassment/</id>
    <published>2024-07-23T21:08:29.000Z</published>
    <updated>2024-08-30T13:06:40.791Z</updated>
    
    <content type="html"><![CDATA[<p>在当今社会，性骚扰问题引起了广泛关注，特别是高校内部的师生关系中性骚扰问题更是敏感而复杂。近期，一位来自某知名高校的教授因涉嫌对女学生进行性骚扰而被曝光，此事件迅速激发了公众对于高等教育环境中性问题的关注。这不仅是一个高校的内部问题，更触及到了社会法律对于性骚扰行为的态度与处理。</p><p>性骚扰不仅侵犯了个体的人格尊严，还可能对受害者造成长期的心理阴影。我国法律对此有着严格的规定与明确的法律后果，而通过具体的法院判决书，我们可以清晰地看到法律是如何审视这一行为的。本文将结合最新的判例，详细分析关于性骚扰行为的相关法律知识～</p><span id="more"></span><h1 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h1><p>在处理性骚扰案件时，法院对证据的要求非常严格。在提出诉讼时必须具备充分、确凿的证据，以便法院能够做出公正的判断。</p><ol><li>证据的重要性：在性骚扰案件中，证据是判决的关键。原告需<strong>提供充分证据来证明被告的性骚扰行为及其对原告造成的精神和身体伤害</strong>。</li><li>举证责任：侵权纠纷中，受害者必须承担起举证责任，证明被告的行为构成侵权并导致了损害后果。</li><li>法律定义和界定：性骚扰的法律定义涉及身体、语言、动作、文字或图像等方式，违背他人意愿而对其实施的<strong>以性为取向的有辱其尊严的性暗示、性挑逗以及性暴力等行为</strong>。</li></ol><h1 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h1><p>性骚扰很常见，但敢于拿起法律武器保护自己的，少之又少。从公开的裁判文书来看，最近 5 年只有 682 起性骚扰相关诉讼。</p><h2 id="撤诉"><a href="#撤诉" class="headerlink" title="撤诉"></a>撤诉</h2><p>性骚扰案件中有不少撤诉的，大部分是因为证据难以收集。性骚扰往往发生在没有其他证人的私密环境中，如办公室、私人会议。因此，收集直接证据非常困难。<strong>在缺乏物理证据或可信的第三方证人的情况下，受害者不得不撤回诉讼</strong>。</p><p>此外，有些受害者可能会因为害怕社会污名、职业损失或人际关系破裂而选择不公开发声。受害者<strong>可能遭受来自家庭、工作单位或社会的压力，促使他们撤回诉讼</strong>，以保护个人名誉或避免“麻烦”。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_lawer_sexual_harassment_withdrawal.png" alt="性骚扰案件撤诉的案件"></p><h2 id="败诉"><a href="#败诉" class="headerlink" title="败诉"></a>败诉</h2><p>有部分性骚扰案件虽然走到了诉讼环节，但法院的判决并不总是支持原告。在一些案件中，法院认为原告提供的证据不足以证明被告的性骚扰行为，或者认为原告的诉讼请求不符合法律规定。</p><p>下面的案件中，原告提供了录音证据，但法院认为这里的录音中仅表明原、被告在仅有一次言谈交流中，双方就家庭责任、喜欢男人的类型、社会交往等内容进行对话，<strong>并没有被告对原告实施了性暗示、性挑逗以及性暴力方面的陈述，双方也并没有肢体接触</strong>。因原告并未能提供充足的证据证明被告存在性骚扰行为及原告的抑郁、焦虑状态与该被告的行为存在法律上的因果关系，故其应当承担举证不能的法律后果。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_lawer_sexual_harassment_fail.png" alt="性骚扰案件起诉败诉的案件"></p><h2 id="胜诉"><a href="#胜诉" class="headerlink" title="胜诉"></a>胜诉</h2><p>当然，性骚扰案件中如果证据充分，法院肯定会支持原告的。在第三批人民法院大力弘扬社会主义核心价值观典型民事案例中，就有一起性骚扰案件。</p><p>傅某为追求王某，不断拨打王某电话，<strong>频繁向王某发送骚扰短信，内容低俗、语言污秽</strong>。后来王某以傅某骚扰、恐吓为由报警，公安确认傅某多次以发送骚扰短信、拨打骚扰电话方式干扰他人正常生活，<strong>给予傅某行政拘留七日并处罚款200元</strong>。因傅某频繁骚扰，王某被医院确诊患有抑郁发作，伴精神病性症状。王某认为，傅某的行为给其造成了严重的精神损害，向人民法院起诉请求判令傅某向其书面赔礼道歉，并赔偿其精神损害赔偿金 50000 元和医疗费等其他财产损失共计 228300 元。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240723_lawer_sexual_harassment_succ.png" alt="性骚扰案件胜诉的案件"></p><p>本案因为有短信证据，且医院确诊王某患有抑郁发作，伴精神病性症状，法院最终判决傅某赔偿王某精神损害赔偿金 30000 元和医疗费等61804.2 元，并向王某书面赔礼道歉。</p><h1 id="律师建议"><a href="#律师建议" class="headerlink" title="律师建议"></a>律师建议</h1><p>小盛律师建议，在遭受性骚扰时，要<strong>明确并坚定地向施害者表达拒绝</strong>。用口头和书面形式，清晰地表明自己的立场，不同意任何形式的性骚扰行为。</p><p>在保证自己人身安全的基础上，<strong>记录和收集好证据</strong>。尽可能记录下所有相关的信息，包括施害者的言行、时间、地点和可能的目击者。如果条件允许，可以保存电子通信记录、录音、视频或者文字消息等，这些都可能成为处理案件的关键证据。</p><p>之后可以寻求家人、朋友或同事的帮助，也可以向单位的人力资源部门或专门的性骚扰投诉部门举报，或者向公安机关报案。如果情况严重，对自己造成很大的影响，可以寻求法律援助。欢迎联系<a href="https://selfboot.cn/links">小盛律师</a>获得关于如何维权的具体建议，并通过法律途径进行诉讼。</p>]]></content>
    
    
    <summary type="html">性骚扰不仅侵犯人格尊严，还可能对受害者造成长期心理影响。小盛律师结合具体的法院判决书，展示了如何通过法律途径应对和处理性骚扰问题。此外，还详细讨论了性骚扰案件中证据的重要性和举证责任，以及法律对此类行为的定义和界定，为公众提供了宝贵的法律知识和应对策略。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="法律" scheme="https://selfboot.cn/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>LevelDB 源码阅读：禁止对象被析构</title>
    <link href="https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/"/>
    <id>https://selfboot.cn/2024/07/22/leveldb_source_nodestructor/</id>
    <published>2024-07-22T18:03:10.000Z</published>
    <updated>2024-08-30T13:06:40.791Z</updated>
    
    <content type="html"><![CDATA[<p>LevelDB 源码中有一个获取 Comparator 的函数，第一次看到的时候觉得有点奇怪，看起来像是构造了一个单例，但又略复杂。完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/comparator.cc</span></span><br><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>NoDestructor</code> 是一个模板类，看名字是用于<strong>禁止对象析构</strong>。为什么要禁止对象析构，又是如何做到禁止析构呢？这篇文章来深入探讨下这个问题。</p><span id="more"></span><h2 id="NoDestructor-模板类"><a href="#NoDestructor-模板类" class="headerlink" title="NoDestructor 模板类"></a>NoDestructor 模板类</h2><p>我们先来看看 <code>NoDestructor</code> 模板类，它用于<strong>包装一个实例，使得其析构函数不会被调用</strong>。这个模板类用了比较多的高级特性，如模板编程、完美转发、静态断言、对齐要求、以及原地构造（placement new）等，接下来一一解释。这里先给出完整的代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/no_destructor.h</span></span><br><span class="line"><span class="comment">// Wraps an instance whose destructor is never called.</span></span><br><span class="line"><span class="comment">// This is intended for use with function-level static variables.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InstanceType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoDestructor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ConstructorArgTypes&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">NoDestructor</span><span class="params">(ConstructorArgTypes&amp;&amp;... constructor_args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(instance_storage_) &gt;= <span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                  <span class="string">&quot;instance_storage_ is not large enough to hold the instance&quot;</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        <span class="built_in">alignof</span>(<span class="keyword">decltype</span>(instance_storage_)) &gt;= <span class="built_in">alignof</span>(InstanceType),</span><br><span class="line">        <span class="string">&quot;instance_storage_ does not meet the instance&#x27;s alignment requirement&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> (&amp;instance_storage_)</span><br><span class="line">        <span class="built_in">InstanceType</span>(std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">NoDestructor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NoDestructor</span>(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  NoDestructor&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoDestructor&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">InstanceType* <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;InstanceType*&gt;(&amp;instance_storage_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typename</span> std::aligned_storage&lt;<span class="built_in">sizeof</span>(InstanceType),</span><br><span class="line">                                <span class="built_in">alignof</span>(InstanceType)&gt;::type instance_storage_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先来看构造函数部分。<code>typename... ConstructorArgTypes</code> 表示这是一个变参模板函数，可以接受任意数量和类型的参数。这使得 NoDestructor 类可以用于任何类型的 InstanceType，不管其构造函数需要多少个参数或是什么类型的参数。关于变参模板，也可以看看我之前写的一篇文章：<a href="https://selfboot.cn/2024/05/07/variadic_arguments_in_c++/">C++ 函数可变参实现方法的演进</a>。</p><p>构造函数的参数 <code>ConstructorArgTypes&amp;&amp;... constructor_args</code> 是一个万能引用（universal reference）参数包，结合 std::forward 使用，可以实现参数的完美转发。</p><p>构造函数开始是两个<strong>静态断言（static_assert），用于检查 instance_storage_ 是否足够大以及是否满足对齐要求</strong>。第一个 static_assert 确保为 InstanceType 分配的存储空间 instance_storage_ 至少要和 InstanceType 实例本身一样大，这是为了<strong>确保有足够的空间来存放该类型的对象</strong>。第二个 static_assert 确保 instance_storage_ 的对齐方式满足 InstanceType 的对齐要求。对象只所以有内存对齐要求，和性能有关，这里不再展开。</p><p>接着开始构造对象，这里使用了 <strong>C++ 的原地构造语法（placement new）</strong>。<code>&amp;instance_storage_</code> 提供了一个地址，告诉编译器在这个已经分配好的内存地址上构造 InstanceType 的对象。这样做避免了额外的内存分配，直接在预留的内存块中构造对象。接下来使用完美转发，<code>std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...</code> 确保所有的构造函数参数都以正确的类型（保持左值或右值属性）传递给 InstanceType 的构造函数。这是现代 C++ 中参数传递的最佳实践，能够减少不必要的拷贝或移动操作，提高效率。</p><p>前面 placement new 原地构造的时候用的内存地址由成员变量 instance_storage_ 提供，instance_storage_ 的类型由 <a href="https://en.cppreference.com/w/cpp/types/aligned_storage">std::aligned_storage</a> 模板定义。这是一个特别设计的类型，<strong>用于提供一个可以安全地存储任何类型的原始内存块，同时确保所存储的对象类型（这里是 InstanceType）具有适当的大小和对齐要求</strong>。这里 std::aligned_storage 创建的原始内存区域和 NoDestructor 对象所在的内存区域一致，也就是说如果 NoDestructor 被定义为一个函数内的局部变量，那么它和其内的 instance_storage_ 都会位于栈上。如果 NoDestructor 被定义为静态或全局变量，它和 instance_storage_ 将位于静态存储区，静态存储区的对象具有整个程序执行期间的生命周期。</p><p>值得注意的是 C++23 标准里，将废弃 std::aligned_storage，具体可以参考 <a href="https://stackoverflow.com/questions/71828288/why-is-stdaligned-storage-to-be-deprecated-in-c23-and-what-to-use-instead">Why is std::aligned_storage to be deprecated in C++23 and what to use instead?</a>。</p><p>回到文章开始的例子，singleton 对象是一个静态局部变量，第一次调用 BytewiseComparator() 时被初始化，它的生命周期和程序的整个生命周期一样长。程序退出的时候，<strong>singleton 对象本身会被析构销毁掉</strong>，但是 NoDestructor 没有在其析构函数中添加任何逻辑来析构 instance_storage_ 中构造的对象，因此 instance_storage_ 中的 BytewiseComparatorImpl 对象永远不会被析构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Comparator* <span class="title">BytewiseComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;</span><br><span class="line">  <span class="keyword">return</span> singleton.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LevelDB 中还提供了一个测试用例，用来验证这里的 NoDestructor 是否符合预期。</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>在 <code>util/no_destructor_test.cc</code> 中首先定义了一个结构体 <code>DoNotDestruct</code>，这个结构体在析构函数中调用了 std::abort()。如果程序运行或者最后退出的时候，调用了 DoNotDestruct 对象的析构函数，那么测试程序将会异常终止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DoNotDestruct</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DoNotDestruct</span>(<span class="type">uint32_t</span> a, <span class="type">uint64_t</span> b) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">DoNotDestruct</span>() &#123; std::<span class="built_in">abort</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used to check constructor argument forwarding.</span></span><br><span class="line">  <span class="type">uint32_t</span> a;</span><br><span class="line">  <span class="type">uint64_t</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着定义了 2 个测试用例，一个定义了栈上的 NoDestructor 对象，另一个定义了一个静态的 NoDestructor 对象。这两个测试用例分别验证 NoDestructor 对象在栈上和静态存储区上的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StackInstance) &#123;</span><br><span class="line">  <span class="function">NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, StaticInstance) &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> NoDestructor&lt;DoNotDestruct&gt; <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.<span class="built_in">get</span>()-&gt;a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.<span class="built_in">get</span>()-&gt;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 NoDestructor 的实现有问题，无法保证传入对象的析构不被执行，那么测试程序将会异常终止掉。我们跑下这两个测试用例，结果如下：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase.png" alt="测试用例通过，析构函数没有被调用"></p><p>这里我们可以增加个测试用例，验证下如果直接定义 DoNotDestruct 对象的话，测试进程会不会异常终止。可以先定义一个栈上的对象来测试，放在其他 2 个测试用例前面，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(NoDestructorTest, Instance) &#123;</span><br><span class="line">  <span class="function">DoNotDestruct <span class="title">instance</span><span class="params">(kGoldenA, kGoldenB)</span></span>;</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenA, instance.a);</span><br><span class="line">  <span class="built_in">ASSERT_EQ</span>(kGoldenB, instance.b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，这个测试用例执行过程中会异常终止，说明 DoNotDestruct 对象的析构函数被调用了。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240531_leveldb_source_nodestructor_testcase_2.png" alt="测试进程异常终止，说明调用了析构"></p><p>其实这里可以再改下，用 static 直接定义这里的 instance 对象，然后编译重新运行测试用例，就会发现 3 个测试用例都通过了，不过最后测试进程还是 abort 掉，这是因为进程退出的时候，才会析构静态对象，这时 DoNotDestruct 对象的析构函数被调用了。</p><h2 id="为什么不能析构？"><a href="#为什么不能析构？" class="headerlink" title="为什么不能析构？"></a>为什么不能析构？</h2><p>上面的例子中，我们看到了 NoDestructor 模板类的实现，它的作用是禁止静态局部的单例对象析构。那么为什么要禁止对象析构呢？简单来说，<strong>C++ 标准没有规定不同编译单元中静态局部变量的析构顺序</strong>，如果静态变量之间存在依赖关系，而它们的析构顺序错误，可能会导致程序访问已经析构的对象，从而产生未定义行为，可能导致程序崩溃。</p><p>举一个例子，假设有两个类，一个是日志系统，另一个是某种服务，服务在析构时需要向日志系统记录信息。日志类的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span> <span class="comment">// Include assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isAlive; <span class="comment">// Flag to check if the object has been destructed</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Logger instance; <span class="comment">// 静态局部变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>() : <span class="built_in">isAlive</span>(<span class="literal">true</span>) &#123;&#125; <span class="comment">// Constructor initializes isAlive to true</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Logger destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        isAlive = <span class="literal">false</span>; <span class="comment">// Mark as destructed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(isAlive); <span class="comment">// Assert the object is not destructed</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Log: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意这个类的 isAlive 成员变量，在构造函数中初始化为 true，析构函数中置为 false。在 log 函数中，会先检查 isAlive 是否为 true，如果为 false，就会触发断言失败。接着是服务类的代码，这里作为示例，只让它在析构的时候用日志类的静态局部变量记录一条日志。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Service</span>() &#123;</span><br><span class="line">        Logger::<span class="built_in">getInstance</span>().<span class="built_in">log</span>(<span class="string">&quot;Service destroyed.&quot;</span>); <span class="comment">// 在析构时记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 main 函数中，使用全局变量 globalService 和 globalLogger，其中 globalService 是一个全局 Service 实例，globalLogger 是一个 Logger 单例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Service globalService; <span class="comment">// 全局Service实例</span></span><br><span class="line">Logger&amp; globalLogger = Logger::<span class="built_in">getInstance</span>(); <span class="comment">// 全局Logger实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行这个程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -g -fno-omit-frame-pointer -o main main.cpp</span></span><br></pre></td></tr></table></figure><p>运行后 assert 断言<strong>大概率会失败</strong>。我们知道<strong>在单个编译单元(这里是 main.cpp)中，全局变量按照出现的顺序来初始化，然后按照相反的顺序来析构</strong>。这里 globalLogger 会先析构，然后是 globalService，在 globalService 的析构函数中会调用 Logger 的 log 函数，但这时 globalLogger 已经被析构，isAlive 被置为 false，所以大概率会触发断言失败。之所以说大概率是因为，globalLogger 对象析构后，其占用的内存空间可能还<strong>未被操作系统回收或用于其他目的</strong>，对其成员变量 isAlive 的访问可能仍能“正常”。下面是我运行的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">main: logger.h:22: void Logger::log(const string&amp;): Assertion `isAlive&#x27; failed.</span><br><span class="line">[1]    1017435 abort      ./main</span><br></pre></td></tr></table></figure><p>其实这里如果不加 isAlive 相关逻辑，运行的话输出大概率如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger destroyed.</span><br><span class="line">Log: Service destroyed.</span><br></pre></td></tr></table></figure><p>从输出可以看到和前面一样 globalLogger 先析构，lobalService 后析构。只是这里进程大概率不会 crash 掉，这是因为 globalLogger 被析构后，<strong>虽然其生命周期已结束，但是对成员函数的调用仍可能“正常”执行</strong>。这里成员函数的执行通常依赖于类的代码（位于代码段），只要代码段内容没有被重新写，并且方法不依赖于已经被破坏或改变的成员变量，它可能仍能运行而不出错。</p><p>当然就算这里没有触发程序崩溃，使用已析构对象的行为在 C++ 中是<a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">未定义的（Undefined Behavior）</a>。未定义行为意味着程序可能崩溃、可能正常运行，或者产生不可预期的结果。此类行为的结果可能在不同的系统或不同的运行时有所不同，我们在开发中一定要避免这种情况的发生。</p><p>其实就 LevelDB 这里的实现来说，BytewiseComparatorImpl 是一个平凡可析构 <a href="https://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor">trivially destructible</a> 对象，它不依赖其他全局变量，因此它本身析构不会有问题。如果用它生成一个静态局部的单例对象，然后在其他静态局部对象或者全局对象中使用，那么在这些对象析构时，会调用 BytewiseComparatorImpl 的析构函数。而根据前面的分析，这里 BytewiseComparatorImpl 本身是一个静态局部对象，<strong>在进程结束资源回收时，可能早于使用它的对象被被析构</strong>。这样就会导致重复析构，产生未定义行为。</p><p>更多关于静态变量析构的解释也可以参考 <a href="https://ppwwyyxx.com/blog/2023/Safe-Static-Initialization-No-Destruction/">Safe Static Initialization, No Destruction</a> 这篇文章，作者详细讨论了这个问题。</p>]]></content>
    
    
    <summary type="html">深入探讨LevelDB源码中的 NoDestructor 模板类，揭示其禁止对象析构的实现原理和背后动机。分析C++静态局部变量析构顺序问题，介绍NoDestructor的设计细节、测试用例及实际应用场景。适合C++开发者和对底层系统感兴趣的程序员阅读，助您掌握高级C++编程技巧。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="LevelDB" scheme="https://selfboot.cn/tags/LevelDB/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>免费版 Claude3.5 配合 Artifacts，一句话就能写个游戏</title>
    <link href="https://selfboot.cn/2024/06/22/claude35_artifacts/"/>
    <id>https://selfboot.cn/2024/06/22/claude35_artifacts/</id>
    <published>2024-06-22T13:47:28.000Z</published>
    <updated>2024-08-30T13:06:40.791Z</updated>
    
    <content type="html"><![CDATA[<p>Anthropic <strong>不声不响</strong>地发布了 <a href="https://www.anthropic.com/news/claude-3-5-sonnet">Claude 3.5 模型</a>，除了模型效果提升，还支持了 Artifacts。初步体验后，感觉这才是未来 AI 的样子，比之前 GPT4-o 更让我震撼。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_artifacts.png" alt="Artifacts 工作空间内写代码"></p><p>在 Artifacts 之前，如果想用 ChatGPT 等 LLM 来帮忙实现程序功能，需要先提功能需求，然后复制 AI 的代码到自己的环境中运行。如果和预期不符合，要再追问、再修改代码运行。需要重复这个过程，直到满意或者放弃（有些复杂代码目前 AI 还是写不太好）。</p><span id="more"></span><p>现在有了 Artifacts，提供具体功能需求后，Claude 会创建一个<strong>工作空间</strong>，后续对话过程中，AI 可以在这个动态工作空间中实时查看、编辑代码。这样，Claude 就从普通的对话式生成 AI 变成了一个<strong>协作工作环境</strong>，或许在不久的将来，可以将 Claude 引入到我们自己的项目中，让它像普通团队成员一样参与到开发。</p><p>愿景当然很美好，不过目前的 Artifacts 还只是 beta 功能，表现如何呢？下面来试试看。</p><h2 id="AI-实现五子棋游戏"><a href="#AI-实现五子棋游戏" class="headerlink" title="AI 实现五子棋游戏"></a>AI 实现五子棋游戏</h2><p>先试着让 Claude 实现一个 web 版五子棋游戏，我的提示词也很简单：</p><blockquote><p>我想写一个网页五子棋游戏，给出完整的实现代码</p></blockquote><p>然后，就看到了 Artifacts 的工作空间，里面已经有了一个代码文件，并且在自动生成代码。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_gobang_code.png" alt="Artifacts 生成五子棋代码文件中"></p><p>代码生成之后，直接跳到了一个预览页面，可以看到五子棋的界面。本来以为这个预览页面是静态的，没想到还可以在这个页面上进行交互，点击棋盘上的位置，会轮流下黑白子。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_gobang_preview.png" alt="Artifacts 生成五子棋界面预览"></p><p>既然能下子，那么到底有没有实现五子棋的规则呢？于是玩了下，发现 AI 确实实现了五子棋的规则，而且还有胜负判断。</p><p><strong>完全超出预期了</strong>！！！一句话，真的只要一句话，<strong>AI 就实现了一个还算完整的五子棋游戏，有美观的界面，有规则判断，还有胜负判定，已经完全可以拿来玩了</strong>。</p><p>关键是 AI 还接着给出了一些继续完善游戏的建议，比如：</p><ul><li>添加悔棋功能</li><li>实现计时器</li><li>添加音效</li><li>实现AI对手</li><li>优化移动设备上的体验</li></ul><p>感觉这不是一个 AI，而是一个有血有肉，有自己想法，经验丰富的前端工程师了。</p><h3 id="五子棋游戏演示"><a href="#五子棋游戏演示" class="headerlink" title="五子棋游戏演示"></a>五子棋游戏演示</h3><p>大家可以在博客文章中的<a href="#%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F%E6%BC%94%E7%A4%BA">演示地址</a>体验下 AI 写的五子棋游戏。</p><div id="game-container">    <div id="board"></div>    <p id="status">黑方回合</p>    <button onclick="resetGame()">重新开始</button></div><p>跟朋友展示了 Claude3.5 生成的五子棋效果后，朋友有点怀疑 AI 是从哪里抄的代码。毕竟五子棋的实现网上到处都是，AI 学到的别人的代码并拿来用。这样说也不是没道理，那就只能升级下难度，来看看 Claude3.5 的表现如何。</p><h2 id="AI-实现俄罗斯方块"><a href="#AI-实现俄罗斯方块" class="headerlink" title="AI 实现俄罗斯方块"></a>AI 实现俄罗斯方块</h2><p>接着再来一个复杂点的游戏，俄罗斯方块。也是从一句简单的提示开始，AI 生成了一个初始的 python 版本。为了在博客里直接跑，就让它换成 web 版的。开始生成的第一个版本，嵌入到博客后，发现边框没有了，并且上下键切换形状的时候，网页会跟随滚动。于是让 Claude 解决这个问题，没想到一次就给出了完美的代码。</p><p>从下图也可以看到，重新提示后，Claude 给出可第 2 版本的文件，然后预览页面就是一个完整的俄罗斯方块游戏，可以通过键盘控制方块的移动和旋转。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240621_claude35_artifacts_tetris.png" alt="Artifacts 生成俄罗斯方块界面预览"></p><p>这里后续又<strong>通过不断的对话提示</strong>，对一些功能进行了修改，第 5 个版本，就拿到了一个很不错的功能雏形了。整个对话过程感觉 Claude3.5 的<strong>理解能力还是很不错的</strong>，和 GPT4 差别不是很大，最后实现的效果也是超出预期。</p><h3 id="俄罗斯方块演示"><a href="#俄罗斯方块演示" class="headerlink" title="俄罗斯方块演示"></a>俄罗斯方块演示</h3><p>我把 AI 生成的代码直接嵌入到博客中，大家可以在<a href="###%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%E6%BC%94%E7%A4%BA">下面的演示</a>中体验俄罗斯方块游戏。</p><div id="tetrisContainer">    <canvas id="tetrisCanvas" width="300" height="600"></canvas>    <button id="startButton">开始游戏</button>    <div id="gameOverMessage">        游戏结束！<br>        你的得分是：<span id="finalScore"></span><br>        <button id="restartButton">重新开始</button>    </div></div><p>从这里俄罗斯方块的不断修改过程来看，AI 的理解能力和代码能力还是很强的，和 GPT4 应该在一个段位。</p><h2 id="人人用-AI-写程序"><a href="#人人用-AI-写程序" class="headerlink" title="人人用 AI 写程序"></a>人人用 AI 写程序</h2><p>从上面写的简单游戏来看，Anthropic 表现很不错。其实我还尝试用它来做一些算法的 Web 可视化演示，Claude3.5 给出的示例也很可以。比如我让它实现了一个令牌桶限频算法，可以设置令牌桶的容量和速率，以及消耗令牌速度，然后让它绘制一个请求监控曲线。</p><p>每次设置好参数后，会动态生成监控曲线。然后可以随时暂停，重新设置参数，再继续生成新的监控曲线。设置几个参数，并运行后，就得到了下面结果：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240622_claude35_artifacts_token_bucket.png" alt="Artifacts 生成令牌桶限频算法界面预览"></p><p>对于没有前端开发经验的人来说，能够很快实现一个可视化的算法演示，真的是神奇。在 Anthropic 的帮助下，每个人都可以破圈，<strong>不再受限于自己的技术经验，快速实现自己的一些想法</strong>。</p><p>特别是对于想学习编程的人来说，以前基本要先啃书，学习技能，然后逐步应用在项目中。现在可以带着问题和 AI 对话，让 AI 帮忙实现，中间有任何问题，可以随时和 AI 沟通，<strong>这样的学习过程更加有趣</strong>。毕竟，如果让我先学习一堆前端语法，然后磕磕碰碰去实现一个俄罗斯方块，我很快就会放弃。而如果我一句话，就生成了一个完整可运行的游戏，然后可以和 AI 一起交流实现的过程和代码细节，就会有趣很多，也会有更多的成就感。</p><h2 id="Anthropic-不足"><a href="#Anthropic-不足" class="headerlink" title="Anthropic 不足"></a>Anthropic 不足</h2><p>当然，目前的 Anthropic 只是一个 beta 版本，还有很多不足之处。文章标题写着使用免费 Claude3.5，不过这里免费版限制也比较多，首先是<a href="https://support.anthropic.com/en/articles/7996848-how-large-is-claude-s-context-window">对话长度有限制</a>，内容稍微长一点，添加附件就会提示：</p><blockquote><p>Your message will exceed the length limit for this chat. Try attaching fewer or smaller files or starting a new conversation. Or consider upgrading to Claude Pro.</p></blockquote><p>就算没附件，对话轮次太多也会提示：</p><blockquote><p>Your message will exceed the length limit for this chat. Try shortening your message or starting a new conversation. Or consider upgrading to Claude Pro.</p></blockquote><p>此外，免费版<strong>每小时可以发的消息条数也是有限制的</strong>，很容易触发限制。不过这些都还是小问题，升级 Pro 之后，都能解决。在我看来，目前 Anthropic <strong>最大的缺陷在于工作空间功能太受限</strong>，离真正实用还差不少距离。</p><p>目前(2024.06.22)工作空间中的代码只能是 AI 生成，<strong>不能自己编辑</strong>，也不能上传自己的代码。如果想在 AI 代码基础上做一些简单改动，就很困难。另外，每个对话中，工作空间里生成的内容都放在一起，<strong>不能像在文件系统里一样，生成多个文件</strong>。</p><p>比如我想用 python 实现一个 web 后端服务，用 fastapi 框架，实现带鉴权功能的 api，要求方便用 docker 部署。Claude3.5 在工作空间<strong>只生成了一个文件</strong>，然后在里面放了 main.py，Dockfile，requirements.txt 等内容。我想拿来用的话，还需要在本地创建文件夹，把里面的内容单独拷贝到不同文件，然后再初始化环境运行。</p><p>如果 Anthropic 的工作空间，<strong>能够创建文件夹，然后在里放入整个项目的代码</strong>，并提供下载整个项目的功能，就方便很多。甚至更进一步，Anthropic 可以提供 Python 的运行环境，<strong>让用户直接在工作空间里运行并调试代码</strong>。这样的话，Anthropic 就可以成为一个真正的协作工作环境，而不仅仅是一个代码生成工具。</p><p>理想状况下，未来的 Anthropic 应该可以在工作空间生成并管理多个文件夹或者文件，允许我们人工修改部分代码，并在工作空间调试代码。然后 Anthropic 可以在调试过程中发现问题，并进行修复。也就是说，<strong>AI 可以了解整个项目代码，并和人一起，参与到开发的每个过程中去</strong>。</p><p>或许这样的 Anthropic 很快就会诞生吧。</p><!-- 俄罗斯方块 --><style>    #tetrisContainer {        position: relative;        width: 300px;        height: 600px;        margin: 20px auto;    }    #tetrisCanvas {        border: 2px solid #333;    }    #startButton {        position: absolute;        top: 50%;        left: 50%;        transform: translate(-50%, -50%);        padding: 10px 20px;        font-size: 16px;        cursor: pointer;    }    #gameOverMessage {        position: absolute;        top: 50%;        left: 50%;        transform: translate(-50%, -50%);        background-color: rgba(0, 0, 0, 0.7);        color: white;        padding: 20px;        text-align: center;        display: none;        width: 80%;        box-sizing: border-box;    }    #restartButton {        margin-top: 15px;        padding: 10px 20px;        font-size: 16px;        cursor: pointer;    }</style><script>    const canvas = document.getElementById('tetrisCanvas');    const ctx = canvas.getContext('2d');    const startButton = document.getElementById('startButton');    const restartButton = document.getElementById('restartButton');    const gameOverMessage = document.getElementById('gameOverMessage');    const finalScoreSpan = document.getElementById('finalScore');    const ROWS = 20;    const COLS = 10;    const BLOCK_SIZE = 30;    const SHAPES = [        [[1, 1, 1, 1]],        [[1, 1], [1, 1]],        [[1, 1, 1], [0, 1, 0]],        [[1, 1, 1], [1, 0, 0]],        [[1, 1, 1], [0, 0, 1]],        [[1, 1, 0], [0, 1, 1]],        [[0, 1, 1], [1, 1, 0]]    ];    const COLORS = [        '#00FFFF', '#FFFF00', '#FF00FF', '#FF0000',        '#00FF00', '#0000FF', '#FFA500'    ];    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));    let currentPiece = null;    let score = 0;    let gameActive = false;    let gameLoop;    function createPiece() {        const shapeIndex = Math.floor(Math.random() * SHAPES.length);        const colorIndex = Math.floor(Math.random() * COLORS.length);        return {            shape: SHAPES[shapeIndex],            color: COLORS[colorIndex],            x: Math.floor(COLS / 2) - Math.floor(SHAPES[shapeIndex][0].length / 2),            y: 0        };    }    function drawBlock(x, y, color) {        ctx.fillStyle = color;        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);        ctx.strokeStyle = '#000';        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);    }    function drawBoard() {        board.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    drawBlock(x, y, value);                }            });        });    }    function drawPiece() {        currentPiece.shape.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    drawBlock(currentPiece.x + x, currentPiece.y + y, currentPiece.color);                }            });        });    }    function isValidMove(piece, x, y) {        return piece.shape.every((row, dy) => {            return row.every((value, dx) => {                let newX = x + dx;                let newY = y + dy;                return (                    value === 0 ||                    (newX >= 0 && newX < COLS && newY < ROWS && (newY < 0 || board[newY][newX] === 0))                );            });        });    }    function rotatePiece() {        let rotated = currentPiece.shape[0].map((_, i) =>            currentPiece.shape.map(row => row[i]).reverse()        );        if (isValidMove({...currentPiece, shape: rotated}, currentPiece.x, currentPiece.y)) {            currentPiece.shape = rotated;        }    }    function movePiece(dx, dy) {        if (isValidMove(currentPiece, currentPiece.x + dx, currentPiece.y + dy)) {            currentPiece.x += dx;            currentPiece.y += dy;            return true;        }        return false;    }    function mergePiece() {        currentPiece.shape.forEach((row, y) => {            row.forEach((value, x) => {                if (value) {                    board[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;                }            });        });    }    function clearLines() {        let linesCleared = 0;        for (let y = ROWS - 1; y >= 0; y--) {            if (board[y].every(cell => cell !== 0)) {                board.splice(y, 1);                board.unshift(Array(COLS).fill(0));                linesCleared++;            }        }        if (linesCleared > 0) {            score += linesCleared * 100;        }    }    function gameOver() {        return board[0].some(cell => cell !== 0);    }    function updateGame() {        if (!movePiece(0, 1)) {            mergePiece();            clearLines();            if (gameOver()) {                endGame();            } else {                currentPiece = createPiece();            }        }        drawGame();    }    function drawGame() {        ctx.clearRect(0, 0, canvas.width, canvas.height);        drawBoard();        if (currentPiece) {            drawPiece();        }    }    function startGame() {        board = Array(ROWS).fill().map(() => Array(COLS).fill(0));        score = 0;        currentPiece = createPiece();        gameActive = true;        startButton.style.display = 'none';        gameOverMessage.style.display = 'none';        drawGame();        gameLoop = setInterval(updateGame, 500); // 每500毫秒更新一次游戏状态    }    function endGame() {        gameActive = false;        clearInterval(gameLoop);        finalScoreSpan.textContent = score;        gameOverMessage.style.display = 'block';    }    startButton.addEventListener('click', startGame);    restartButton.addEventListener('click', startGame);    document.addEventListener('keydown', event => {        if (!gameActive) return;        event.preventDefault();        switch (event.keyCode) {            case 37: // 左箭头                movePiece(-1, 0);                break;            case 39: // 右箭头                movePiece(1, 0);                break;            case 40: // 下箭头                movePiece(0, 1);                break;            case 38: // 上箭头                rotatePiece();                break;        }        drawGame();    });    drawGame();</script><!-- 五子棋游戏 --><script>    const boardSize = 15;    let currentPlayer = 'black';    let gameBoard = [];    function createBoard() {        const board = document.getElementById('board');        for (let i = 0; i < boardSize; i++) {            const row = document.createElement('div');            row.className = 'row';            gameBoard[i] = [];            for (let j = 0; j < boardSize; j++) {                const cell = document.createElement('div');                cell.className = 'cell';                cell.onclick = () => placePiece(i, j);                row.appendChild(cell);                gameBoard[i][j] = '';            }            board.appendChild(row);        }    }    function placePiece(row, col) {        if (gameBoard[row][col] !== '') return;        const cell = document.getElementById('board').children[row].children[col];        const piece = document.createElement('div');        piece.className = `piece ${currentPlayer}`;        cell.appendChild(piece);        gameBoard[row][col] = currentPlayer;        if (checkWin(row, col)) {            document.getElementById('status').textContent = `${currentPlayer === 'black' ? '黑' : '白'}方获胜！`;            disableBoard();        } else {            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';            document.getElementById('status').textContent = `${currentPlayer === 'black' ? '黑' : '白'}方回合`;        }    }    function checkWin(row, col) {        const directions = [            [1, 0], [0, 1], [1, 1], [1, -1]        ];        for (const [dx, dy] of directions) {            let count = 1;            count += countDirection(row, col, dx, dy);            count += countDirection(row, col, -dx, -dy);            if (count >= 5) return true;        }        return false;    }    function countDirection(row, col, dx, dy) {        let count = 0;        let x = row + dx;        let y = col + dy;        while (x >= 0 && x < boardSize && y >= 0 && y < boardSize && gameBoard[x][y] === currentPlayer) {            count++;            x += dx;            y += dy;        }        return count;    }    function disableBoard() {        const cells = document.getElementsByClassName('cell');        for (const cell of cells) {            cell.onclick = null;        }    }    function resetGame() {        const board = document.getElementById('board');        board.innerHTML = '';        gameBoard = [];        currentPlayer = 'black';        document.getElementById('status').textContent = '黑方回合';        createBoard();    }    createBoard();</script><style>    #game-container {        text-align: center;    }    #board {        display: inline-block;        background-color: #d4a36a;        padding: 10px;        border: 2px solid #8b4513;    }    .row {        display: flex;    }    .cell {        width: 30px;        height: 30px;        border: 1px solid #000;        display: flex;        justify-content: center;        align-items: center;        cursor: pointer;    }    .piece {        width: 26px;        height: 26px;        border-radius: 50%;    }    .black {        background-color: #000;    }    .white {        background-color: #fff;    }</style>]]></content>
    
    
    <summary type="html">深入探讨 Anthropic 新发布的 Claude 3.5 模型及其 Artifacts 功能，通过五子棋和俄罗斯方块游戏的快速实现，展示了代码生成和问题解决方面的卓越能力。还讨论了当前版本的一些局限性，如工作空间功能的限制，并展望了未来 AI 辅助编程的发展方向。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="LLM" scheme="https://selfboot.cn/tags/LLM/"/>
    
  </entry>
  
  
  
  
  
  <entry>
    <title>溢出、异常、线程池、阻塞，奇怪的服务重启问题定位</title>
    <link href="https://selfboot.cn/2024/06/13/async_pool_block_problem/"/>
    <id>https://selfboot.cn/2024/06/13/async_pool_block_problem/</id>
    <published>2024-06-13T20:01:55.000Z</published>
    <updated>2024-08-30T13:06:40.791Z</updated>
    
    <content type="html"><![CDATA[<p>最近在业务中遇见一个很奇怪的服务重启问题，定位过程比较有曲折，本文来复盘下。这个问题涉及到 C++ 线程池、整数溢出、异常捕获、阻塞等多个方面，还是挺有意思的。</p><p>接下来我会按照<strong>问题排查的过程</strong>来组织本文内容，会先介绍问题背景，接着列出初步的排查思路，定位异常请求的方法。然后，通过代码分析，以及复现问题的一些简单用例，来揭开服务重启的神秘面纱。</p><span id="more"></span><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>我们有个模块 A 对外提供 RPC 服务，主调方 B 会调用 A 的服务。模块 A 的服务分为 2 个进程，mesh 进程和业务进程，这两个进程都是多线程的。mesh 进程类似 <a href="https://istio.io/latest/docs/reference/config/networking/sidecar/">Sidecar</a> 的作用，每当接收到主调方发来的 1 个 rpc 请求，就分配一个 worker 线程负责该请求。worker 会通过 unix socket 把请求包发给业务进程，然后等业务进程处理完后回复主调方。业务进程则专门用来做业务逻辑，拿到请求包处理完成后，把响应包给 mesh 进程里的 worker。整体如下图所示：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_bg.png" alt="服务分mesh进程和业务进程"></p><p>最近，主调方 B 通过监控发现每天会有几次连不上模块 A 的服务端口，每次持续时间也不长，过一会就自动恢复了。</p><p>简单看了下模块 A 的日志，发现在对应时间点，<strong>监控脚本拨测 A 服务失败，于是重启服务</strong>。这里的监控脚本每隔固定时间，会拨测模块 A 的 存活探测 rpc(就是简单回复一个 hello)，来检测服务是否正常。如果连续的几次拨测都失败，则认为服务有问题，就尝试重启服务。这次模块 A 的偶现重启，就是脚控脚本发现一直没法拿到存活探测 rpc 的回复，于是重启服务。</p><p>那么<strong>什么时候开始出现这个问题呢？</strong>把模块 A 的监控时间拉长，发现 7 天前才开始有偶现的诡异重启。模块 A 的每台服务器都有重启，重启频次很低，所以模块 A 也没有告警出来。</p><p>按照经验，拨测失败一般是服务进程挂了，比如进程 coredump 退出或者内存泄露导致 OOM 被系统杀了。但是查了下模块 A 的日志，发现并不是上面两种情况。模块 A 没看到 coredump 相关的日志，内存使用在重启时间段都是正常的。那会不会是代码中有<strong>死循环导致 worker 线程被占着一直没法释放呢</strong>？看了下重启时间段的 CPU 使用率，也是正常水平。当然如果死循环中一直 sleep，那么 CPU 使用率也不高，不过业务中并没有什么地方用到 sleep，所以这里初步排查不是死循环。</p><p>这就有点奇怪了，接着仔细看服务日志来排查吧。</p><h2 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h2><p>找了一台最近有重启的机器，先看看重启时间点服务进程的日志。模块 A 里 mesh 进程是一个 C++ 多线程服务，一共有 N 个 worker 线程并发处理业务的 RPC 请求。框架每隔一段时间，会打印日志，记录当前 worker 中有多少是空闲(idle)的，多少正在处理请求(busy)。正常情况下，打印出来的日志中，大部分线程是 idle 的，只有少部分是 busy。</p><p>但是在进程重启前，发现日志中的 worker 线程数有点异常，<strong>1 分钟内 idle 线程越来越少，直到为 0</strong>。假设总 worker 数为 200，重启前的相关日志大概如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">worker idle 100, busy 100;</span><br><span class="line">worker idle 40, busy 160;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">worker idle 0, busy 200;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>怪不得监控脚本会拨测失败，此刻服务的所有 worker 都被占用，没有空闲 worker 处理新来的请求，所有新来的请求都会排队等待 worker 直到超时失败。</p><p>那么是什么原因导致 worker 一直被占用没有释放出来呢？服务是最近才出现这个问题的，所以首先想到可能和最近的变更有关。把最近的代码变更看了下，没发现什么问题。</p><p>接下来其实有两个排查思路，第一个是等服务进程再次卡住的时候，通过 gdb attach 进程，或者 gcore 转储 coredump 文件，这样就可以查看 worker 线程的调用栈，看看是什么函数导致 worker 一直被占用。首先排除掉 gdb attach，第一是出现概率比较低，监控脚本会很短时间内重启服务，不太好找到时机，并且现网服务也不太适合 attach 上去排查问题。gcore 的话，需要改动下监控脚本，在拨测有问题的时候，保存下进程 coredump 文件。不过当时考虑到需要改监控脚本，并且通过 coredump 文件不一定能发现问题，所以暂时没采用。</p><p>第二个思路就是找到可以复现的请求，通过复现问题来定位，毕竟<strong>如果一个问题能稳定复现，相当于已经解决了一大半</strong>。这里其实基于这样一个假设，<strong>一般偶发的问题，都是由某类特殊的请求触发了一些边界条件导致</strong>。</p><p>对于我们的 RPC 模块来说，如果有一个特殊的请求导致 worker 一直被占用，那么这个请求一定是没有回包的。因此，我们可以在模块<strong>接收到请求包以及给出响应包的时候，分别打印出相关日志</strong>。然后在服务卡住的时间段，就可以过滤出日志中那些只有请求没有响应的 RPC 请求。</p><p>加了日志上线后，刚好又一次出现了服务重启，通过日志，终于找到了可疑请求。结合这个可疑请求，发现了一段有问题的代码，正是这段有问题的代码，成为解决问题的突破口。</p><h2 id="问题代码分析"><a href="#问题代码分析" class="headerlink" title="问题代码分析"></a>问题代码分析</h2><p>我们先来看下这段有问题的代码，简化后并隐去关键信息，大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gramCount = <span class="number">3</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; posVec;</span><br><span class="line"><span class="comment">// GetPosVec(posVec);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt; posVec.<span class="built_in">size</span>() - gramCount; ++i) &#123;</span><br><span class="line">posVec[i] = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聪明如你，一定发现这段代码的问题了吧。</p><p>这里 i 是无符号整数，<code>posVec.size()</code> 返回的也是无符号整数类型 size_t。当 posVec.size() 小于 gramCount 时，<code>posVec.size() - gramCount</code> 会<strong>溢出</strong>，变成一个很大的正整数。接着在循环中，会用这个很大的正整数来遍历 posVec，就会导致<strong>数组越界</strong>。这里用 operator[] 访问数组的时候，当下标越界就是<a href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/">未定义行为</a>，一般会导致程序 crash 掉。写了一个简单测试代码，发现确实 segmentation fault 了。这里补充说下，如果是用 <a href="https://cplusplus.com/reference/array/array/at/">at 访问数组</a>的话，下标越界会抛出 out_of_range 异常，如果被捕获异常，肯定会 crash。</p><p>但是模块 A 中这里的代码却没有 crash，而是导致 worker 线程一直被占用，这又是为什么呢？一个可疑的地方就是，上面的代码其实是在一个新开的线程池中跑的。再补充说下这里的背景，模块 A 收到 RPC 请求后，会在一个 worker 线程中处理业务逻辑。有部分业务逻辑比较耗时，<strong>为了提高处理速度，会把耗时的部分放到一个额外的线程池来并发执行</strong>。</p><p>这里线程池的实现稍微有点复杂，大致思路就是<strong>一个任务队列 + 配置好的 N 个 worker 线程</strong>。任务队列用来存放需要执行的任务，worker 线程从任务队列中取任务执行。线程池对外提供了一个接口 <code>RunTask(concur, max_seq, task);</code> 其中 concur 是并发执行的线程数，max_seq 是任务总数，task 是任务函数。RunTask 会用 concur 个线程并发执行这个任务函数 task，直到 max_seq 个任务全部完成。</p><p>在任务开始前，RunTask 里面定义了一个管道，用来在主线程和任务线程池之间同步消息。一旦所有线程完成任务，最后一个退出的线程会向管道写入一个字符以通知主线程。主线程会等待管道中的字符，然后返回。</p><p>上面有整数溢出的代码，就是放在这个额外的线程池执行的，难道是线程池导致的问题？为了快速验证猜想，写了个简单的测试脚本，把上面代码放到线程池执行，进程果真卡住没反应了。首先猜想，会不会是线程池中的线程因为数组越界导致 crash 掉，没有写 pipe，导致主线程一直阻塞在 pipe 的读操作上呢？</p><p>下面来验证下。</p><h2 id="多线程：thread"><a href="#多线程：thread" class="headerlink" title="多线程：thread"></a>多线程：thread</h2><p>为了验证上面的猜想，写了一个简单的测试程序，模拟业务中线程池的工作流程。这里用 C++11 的 thread 来开启 5 个新线程，并且让这些线程 sleep 一段时间模拟执行任务。当所有线程都执行完任务后，最后一个完成的线程向管道写入一个字符，主线程阻塞在管道读取上。测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">completedThreads</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCurrentTimeAndThread</span><span class="params">(<span class="type">const</span> std::string&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_c), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot; Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>], <span class="type">int</span> totalThreads)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="type">int</span> finished = ++completedThreads;</span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 最后一个完成的线程写入管道</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(threadFunction, fds, totalThreads);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 主线程阻塞在这里等待管道写入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里注释掉会发生什么呢？</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            thread.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread finished&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后发现这里是符合预期的，5 个线程并发执行 1s，主线程等最后一个线程执行完，就会从管道中读到结果继续往下执行。结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140358584862528 - 2024-06-12 11:40:51</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140358568072960 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358559680256 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358551287552 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358584858368 - 2024-06-12 11:40:52</span><br><span class="line">Completed Thread ID: 140358576465664 - 2024-06-12 11:40:52</span><br><span class="line">Main thread finished Thread ID: 140358584862528 - 2024-06-12 11:40:52</span><br></pre></td></tr></table></figure><p>现在让<strong>最后一个子线程直接抛出异常，来看看主线程是否阻塞</strong>。在上面代码基础上改动如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Out of range exception&quot;</span>); <span class="comment">// 模拟 at 越界访问数组，抛出异常</span></span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 最后一个完成的线程写入管道</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重新编译运行发现整个进程直接 crash 掉了，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140342189496128 - 2024-06-12 11:46:23</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140342189491968 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342181099264 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342172706560 - 2024-06-12 11:46:24</span><br><span class="line">Completed Thread ID: 140342164313856 - 2024-06-12 11:46:24</span><br><span class="line">terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span><br><span class="line">  what():  Out of range exception</span><br><span class="line">[1]    2622429 abort      ./thread_test2</span><br></pre></td></tr></table></figure><p>看来前面的猜想失败了！在多线程下，单个线程抛出异常导致整个进程 abort 掉了。为什么会这样？这里不得不提一下<strong>C++ 的异常处理机制了</strong>？</p><h3 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++ 异常处理"></a>C++ 异常处理</h3><p>在 C++ 中，当程序遇到一个无法自行解决的问题时，它可以抛出（throw）一个异常。异常通常是一个从标准异常类派生的对象，如 std::runtime_error。编程时，可以把可能抛异常的代码放到 try 块里面，然后在后面跟一个或多个 catch 块，用来捕获和处理特定类型的异常。</p><p>如果在当前作用域内没有捕获异常，<strong>异常将被传递到调用栈中较高层的 try-catch 结构中</strong>，直到找到合适的 catch 块。如果整个调用栈都没有找到合适的 catch 块，会调用 <a href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate()</a>，具体执行操作由 std::terminate_handler 指定，默认下是调用 <a href="https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a>。如果没有设置信号处理程序捕获 SIGABRT 信号，那么程序就会被异常终止。</p><p>对于上面的示例多线程代码来说，最后一个线程抛出异常，但是没有地方捕获，所以最终调用 std::abort() 终止整个进程。从上面的输出也可以看到，最后一行是 abort。</p><p>其实 C++ 之所以这样设计，是因为一个未捕获的异常通常意味着程序已经进入一个未知的状态，继续运行可能会导致更严重的错误，如数据损坏或安全漏洞。因此，<strong>立即终止程序被认为是一种安全的失败模式</strong>。</p><h3 id="thread-对象生命周期"><a href="#thread-对象生命周期" class="headerlink" title="thread 对象生命周期"></a>thread 对象生命周期</h3><p>这里再提一个地方，上面示例程序，主线程最后会对每个子线程的 thread 对象调用 thread.join()，如果把这里注释掉，运行程序会发生什么呢？进程还是会 crash 掉，并且也是调用的 terminate()。这又是为什么呢？</p><p>其实前面 terminate 的文档里有提到，下面这种情况也会调用 terminate：</p><blockquote><ol start="10"><li>A joinable std::thread is destroyed or assigned to.</li></ol></blockquote><p>接着继续查看 std::thread::joinable 的文档，发现如下解释：</p><blockquote><p>A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</p></blockquote><p>我们知道，子线程在执行完相关代码后会自动退出。但是，这并不意味着与该线程相关联的 std::thread 对象会自动处理这个线程的所有资源和状态。在 C++ 中，操作系统线程的结束和 std::thread 对象的生命周期管理是两个相关但又相对独立的概念：</p><ul><li><strong>操作系统的线程</strong>：当线程执行完代码后会自动停止，此时线程的系统资源（如线程描述符和堆栈）通常会被操作系统回收。</li><li><strong>std::thread 对象的管理</strong>：虽然线程已经结束，但是 std::thread 对象依然需要正确地更新其状态来<strong>反映线程已经不再活跃</strong>。这一点主要是通过 <a href="https://en.cppreference.com/w/cpp/thread/thread/join">join()</a> 或 detach() 方法来实现的。如果没有调用这些方法，std::thread 对象在被销毁时将检测到它仍然“拥有”一个活跃的线程，这将导致调用 std::terminate()。</li></ul><p>前面示例代码中主线程调用 join() 方法，会阻塞等待子线程执行完(其实就这里的例子来说，管道写入字符已经确保执行完了的)，然后标记 std::thread 对象状态为“非活跃”。</p><p>那么回到前面的问题，为啥<strong>业务代码中线程池中的线程抛出异常，主线程会卡住呢</strong>？接着仔细看了下线程池的实现代码，发现这里并不是用 thread 来创建线程，而是用的 <a href="https://en.cppreference.com/w/cpp/thread/async">std::async</a>。async 是什么？它是怎么工作的，这里线程卡死会和 async 有关吗？</p><p>接着一起来验证吧。</p><h2 id="多线程：async"><a href="#多线程：async" class="headerlink" title="多线程：async"></a>多线程：async</h2><p>C++11 引入了 std::async，这是一个用于<strong>简化并发编程</strong>的高级工具，它可以在<strong>异步的执行上下文中运行一个函数或可调用对象，并返回一个 std::future 对象</strong>来访问该函数的返回值或异常状态。</p><p>哈哈，看完这里的介绍，是不是一头雾水、不知所云？没事，先抛开这些，直接看代码先。我们在前面 thread 示例代码的基础上，稍加改动，用 async 来并发执行，完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">completedThreads</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCurrentTimeAndThread</span><span class="params">(<span class="type">const</span> std::string&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;now_c), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot; Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> fds[<span class="number">2</span>], <span class="type">int</span> totalThreads)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 模拟一些工作</span></span><br><span class="line">    <span class="type">int</span> finished = ++completedThreads;</span><br><span class="line">    <span class="keyword">if</span> (finished == totalThreads) &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Out of range exception&quot;</span>); <span class="comment">// 模拟 at 越界访问数组，抛出异常</span></span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;c, <span class="number">1</span>); <span class="comment">// 最后一个完成的线程写入管道</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">        futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, threadFunction, fds, totalThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 主线程阻塞在这里等待管道写入</span></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printCurrentTimeAndThread</span>(<span class="string">&quot;Main thread finished&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后发现，主线程卡住了！！运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Main thread started Thread ID: 140098007660352 - 2024-06-12 21:06:00</span><br><span class="line">Main thread is now waiting for read...</span><br><span class="line">Completed Thread ID: 140097990870784 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140097974085376 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140097999263488 - 2024-06-12 21:06:01</span><br><span class="line">Completed Thread ID: 140098007656192 - 2024-06-12 21:06:01</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功复现了业务中的问题。在继续深入分析前，先来看看 async 的用法，主要如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> totalThreads = <span class="number">5</span>;</span><br><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futures;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalThreads; ++i) &#123;</span><br><span class="line">    futures.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async, threadFunction, fds, totalThreads));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码用 std::async 函数来启动一组异步任务，这些任务由 threadFunction 定义。每个任务在创建时都被配置为在新线程上执行，并且使用 std::launch::async 策略来确保它们会立即启动。这些任务的执行结果（或状态）被封装在 std::future<void> 对象中，并存储在 futures 这个 std::vector 中。先了解这么多就够了，接下来我们继续分析为什么主线程会卡住。</p><h3 id="GDB-分析"><a href="#GDB-分析" class="headerlink" title="GDB 分析"></a>GDB 分析</h3><p>我们用 GDB 来看看进程运行过程发生了啥。这里 run 之后，可以看到新创建了 5 个线程来执行 async 任务，接着有 4 个线程都打印了任务输出，然后 5 个线程又全部被系统销毁。之后 GDB 控制台会卡住，这时候用 Ctrl+C 来暂停程序执行，然后就可以用 GDB 控制台了。</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_gdb.png" alt="GDB 排查阻塞进程"></p><p>进程卡住后看堆栈，发现阻塞在主线程 main 函数的 read 上。这时候进程只剩下主线程，可以用 info threads 确认，这里 0x7ffff7a9e740 其实就是进程开始打印出的 Thread ID: 140737348495168 的十六进制。从 GDB 的结果来看，最后一个子线程在要 write 前抛出异常，然后直接退出，没有往管道写入字符，主线程一直阻塞在管道的 read 中。</p><p>问题来了，整个进程不是应该 abort 终止吗？在前面 <a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9Athread">thread 的示例</a> 中，线程抛出的异常没被捕获导致进程 abort 掉，主线程也随之结束。而这里 async 创建的<strong>线程抛出的异常似乎不见了，没看到有捕获的地方，也没有触发进程 abort</strong>，这是为什么呢？</p><h3 id="async-异常处理"><a href="#async-异常处理" class="headerlink" title="async 异常处理"></a>async 异常处理</h3><p>先来看看 <a href="https://en.cppreference.com/w/cpp/thread/async">async</a> 的文档里有没有说是怎么处理异常的吧。</p><blockquote><p>If the function f returns a value or throws an exception, it is stored in the shared state accessible through the std::future that std::async returns to the caller.</p></blockquote><p>可以看到，使用 std::async 启动的线程如果抛出了异常，这些<strong>异常会被捕获并存储在返回的 std::future 对象中</strong>。再查看 future 的文档，发现可以用 <a href="https://en.cppreference.com/w/cpp/thread/future/get">future::get</a> 来拿到任务的执行结果，如果任务抛出异常，调用 get 的时候会重新抛出异常。</p><blockquote><p>If an exception was stored in the shared state referenced by the future (e.g. via a call to std::promise::set_exception()) then that exception will be thrown.</p></blockquote><p>至此上面示例程序没有 abort 的原因找到了，就在于 async 的异常处理机制。<strong>在 async 中，线程抛出的异常会被存储在 std::future 对象中，而不会直接导致进程 abort。子线程抛出异常后没有往管道写入字符，主线程就一直阻塞在 read 上等待，导致整个进程看起来就跟卡住一样</strong>。</p><p>这里我们可以在示例程序 read 前调用 get 来捕获异常，然后打印出来验证下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; future : futures) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        future.<span class="built_in">get</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Main thread is now waiting for read...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 主线程阻塞在这里等待管道写入</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>可以看到这里确实捕获到了一个 out_of_range 异常。</p><h3 id="async-的优势"><a href="#async-的优势" class="headerlink" title="async 的优势"></a>async 的优势</h3><p>关于 async 再补充一点思考，C++11 引入的 async 和传统的 thread 比有什么优点呢？</p><p>首先 std::async 提供了一种比直接使用 std::thread <strong>更简单的方法来创建并执行异步任务</strong>。它自动处理线程的创建和管理，使得开发者可以专注于业务逻辑而非线程管理的细节。std::async 可以自动管理任务的生命周期，包括适时地启动和终止线程。使用 std::async 不需要显式地调用 join() 或 detach()。</p><p>另外，如前面所述，使用 std::async 启动的任务可以在执行中抛出异常，这些异常会被捕获并存储在返回的 std::future 对象中。通过调用 std::future::get()，可以在主线程中捕获和处理这些异常。</p><p>此外，调用 std::async 可以指定启动模式（std::launch::async 或 std::launch::deferred），其中 std::launch::async 强制立即在新线程中运行任务，而 std::launch::deferred 则延迟任务的执行直到调用 std::future::get() 或 std::future::wait()。</p><p>一般来说，当需要并行执行且彼此之间没有依赖关系的任务时，用 std::async 不需要关注线程的管理，会简单很多。或者需要在将来的某个时间点获取并行任务的执行结果，可以将 std::async 与 std::future 结合起来用，也会方便很多。</p><h2 id="现网服务复盘"><a href="#现网服务复盘" class="headerlink" title="现网服务复盘"></a>现网服务复盘</h2><p>好了，现在回到现网服务的讨论，通过前面分析已经能确定问题所在了，不过还有几个和现网服务相关的细节这里也需要搞清楚。第一个就是这里出问题的代码早就上线了，为什么最近才出问题？回到<a href="##%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">问题代码分析</a>这里的示例，如果数组大小大于等于 gramCount，就不会溢出，也不会导致 crash。最近这里数组的长度有了变化，所以才出现上面的问题。</p><p>第二个疑问就是，每次遇到异常的数据，只会卡住当前的 1 个工作 worker，短时间也不会有很多异常请求数据。但是前面<a href="#%E5%88%9D%E6%AD%A5%E6%8E%92%E6%9F%A5">初步排查</a>的时候观察日志，在<strong>极短时间内，所有 worker 都耗尽</strong>。这又是为什么呢？</p><p>前面<a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF">问题背景</a>有提到过，mesh 进程和业务进程都是多线程，日志中看到短时间极速减少的 idle worker，是 mesh 进程的。实际业务逻辑在业务进程处理，业务进程中的所有线程共用一个 async 单例实现的全局线程池。async 实现的线程池在创建单例对象的时候会指定一共有多少个线程，这些线程供所有业务进程 worker 线程使用。整体如下图所示：</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240613_async_pool_block_problem_worker.png" alt="业务线程架构"></p><p>每当有一个异常数据，就会导致 async 线程池中的 1 个线程退出，同时阻塞业务进程中的 1 个线程。随着时间推移，积累足够多异常数据后，会出现下面 2 种情况：</p><ol><li>async 线程池中的线程因为异常全部退出，这时候还没有阻塞的业务线程只要使用线程池处理数据，不管数据是否异常，都会阻塞在 read 上，因为根本没有 async 线程来计算。这种情况发生在业务进程的线程数大于 async 线程池中的线程数时。</li><li>async 线程池中还有可以工作的线程，不过业务进程中所有线程都因为曾经出现的异常数据导致阻塞在 read 上。这种情况发生在业务进程的线程数小于 async 线程池中的线程数时。</li></ol><p>不管是哪种情况，<strong>都会在某一刻，因为最后的一个异常请求数据，导致业务进程所有工作线程阻塞，无法处理 mesh 来的请求</strong>。从这一刻起，每当 mesh 接收到一个请求，mesh 进程的一个 worker 就会被占用，短时间内的请求积压，导致 mesh 进程所有 worker 被占用，也就无法处理新来的请求，最终导致监控脚本检测到服务异常。</p><p>至此，整个重启的原因水落石出，修复方法也跃然纸上了。最简单的方法就是在 async 线程中执行业务函数时，加上 try-catch 块，如果捕获到异常，直接调用 abort 来中止整个业务进程。这样如果代码中有导致抛出异常的 bug，上线后一旦触发进程就会立马终止，出问题早发现，也方便从 coredump 文件中分析问题。</p>]]></content>
    
    
    <summary type="html">本文详细分析了一个由 C++ 线程池、整数溢出和异常处理引发的服务重启问题。探讨了 std::thread 和 std::async 在异常处理上的差异，揭示了 async 实现的线程池中未处理异常可能导致的连锁反应。通过日志分析、代码审查和 GDB 调试，逐步定位问题根源，并提供了修复方案。文章还总结了多线程编程、异常处理和线程池设计的关键点，为开发者提供了宝贵的经验和参考。</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
  
  
  <entry>
    <title>谁主张谁举证，吵架时也用得到的法律知识</title>
    <link href="https://selfboot.cn/2024/06/06/who_asserts_must_prove/"/>
    <id>https://selfboot.cn/2024/06/06/who_asserts_must_prove/</id>
    <published>2024-06-06T21:55:28.000Z</published>
    <updated>2024-08-30T13:06:40.791Z</updated>
    
    <content type="html"><![CDATA[<p>一个晴朗的周末，你去超市购物。突然保安把你拦下来，说你偷了东西。<strong>你需要要证明你没偷东西吗</strong>？如果要证明，<strong>你又怎么证明呢</strong>？</p><p>又或者，你把自己的伞忘在了茶水间，过了会去找发现不见了。通过查监控，发现是另一个同事拿走了你的伞，于是想找这个同事拿回来。结果拿伞的同事<strong>让你证明这是你的伞，问你要购物记录和发票</strong>，你需要提供吗？</p><p><img src="https://slefboot-1251736664.file.myqcloud.com/20240606_who_asserts_must_prove_cover_new.png" alt="谁主张谁举证，举证责任倒置"></p><span id="more"></span><p>生活中类似的例子数不胜数。遇到胡搅蛮缠、强词夺理的人，有时候我们可能会陷入自我怀疑，我是不是真的要自证啊？其实大可不必，记住这六个字，“<span style='color: red'><strong>谁主张谁举证</strong></span>”。这不仅是民事诉讼中的基本原则，也是我们应对各种纠纷时的法宝。</p><p>接下来<a href="https://selfboot.cn/links">小盛律师</a>和大家详细聊聊民事诉讼中的“谁主张谁举证”以及“举证责任倒置”，希望能帮大家理清思路，遇到类似情况时能够做到心中有数，游刃有余。</p><h2 id="谁主张谁举证"><a href="#谁主张谁举证" class="headerlink" title="谁主张谁举证"></a>谁主张谁举证</h2><p>“谁主张谁举证”是民事诉讼中的一项基本原则。当事人在民事诉讼中<strong>对自己所主张的事实，有责任提供证据加以证明</strong>。也就是说，如果一方提出了某个主张，那么这一方就需要承担提供证据的责任，以证明其主张的事实是真实存在的。如果这一方没有足够的证据来支持其主张，那么法院可能不会接受这个主张。这里主要依据<a href="https://www.faxin.cn/lib/zyfl/zyflcontent.aspx?gid=A310972&nid=45205">《中华人民共和国民事诉讼法》</a>：</p><blockquote><p>第六十七条　当事人对自己提出的主张，有责任提供证据。<br>　　当事人及其诉讼代理人因客观原因不能自行收集的证据，或者人民法院认为审理案件需要的证据，人民法院应当调查收集。<br>　　人民法院应当按照法定程序，全面地、客观地审查核实证据。</p></blockquote><p>直接看法律条文可能有点难懂，我找几个案例，咱们通过案例来理解一下。</p><h3 id="夫妻离心小三得利？"><a href="#夫妻离心小三得利？" class="headerlink" title="夫妻离心小三得利？"></a>夫妻离心小三得利？</h3><p>(2022)粤民初42**号：原告和被告是夫妻关系，原告婚后在家照顾家中老人、孩子，发现被告刘某在婚姻存续期间与被告万某保持不正常男女关系长达5、6年。还发现被告刘某在婚姻期间用夫妻共同财产为被告万某购买了房和车，还给被告刘某 27 万元。</p><p>原告认为被告万某没有工作的，根本没有经济能力购买上述的房产和车辆。被告刘某的行为明显属于在婚姻期间恶意转移夫妻共同财产，请求法院判令被告刘某返还 27 万元，并判令被告万某返还房产和车辆。</p><p>法院怎么认定的呢？首先原告提供的证据，<strong>尚不足以证实被告刘某与万某之间存在婚外情关系，二被告亦不确认存在婚外情关系</strong>。对于 27 万，原告提交的证据<strong>不足以证实刘某已实际支付给万某</strong>，二被告亦不确认张某的主张，张某的该项主张缺乏事实基础。所以法院最后认定，原告关于被告刘某与万某存在婚外情并转移夫妻共同财产的主张，无事实依据，不予支持。</p><p>其实很多类似的案例，夫妻一方怀疑对方有外遇，转移财产给第三人，但是没有足够的证据证明这一点。按照“谁主张谁举证”的原则，法院在没有证据的情况下，并不会支持原告的主张。</p><h3 id="民间借贷朋友反目"><a href="#民间借贷朋友反目" class="headerlink" title="民间借贷朋友反目"></a>民间借贷朋友反目</h3><p>(2024)桂民初13**号：本案是一个典型的民间借贷案件，<strong>借了钱最后朋友也没得做了</strong>。背景是这样的，被告周某因资金周转困难为由，向原告借 6000 元。原告作为朋友，<strong>基于朋友之间的信任</strong>，也没有要借条，当天直接通过现金和微信转账等方式借给了被告 6000 元。然后过了快 1 年，原告需要钱的时候，多次催被告还钱，但是被告周某<strong>拒绝履行还款义务</strong>，于是原告起诉要求被告还款。</p><p>原告主张，<strong>王某作为被告周某的老婆，也应该承担债务</strong>。法院认定，<strong>原告没有提供证据证实两被告为夫妻关系</strong>，根据谁主张谁举证的原则，应由原告承担<strong>举证不能的法律后果</strong>，所以最后没有支持王某对周某的债务承担共同偿还责任。</p><p>这两个常见的真实案例，是不是让你对“谁主张谁举证”有了一点深入的理解呢？</p><h2 id="举证责任倒置"><a href="#举证责任倒置" class="headerlink" title="举证责任倒置"></a>举证责任倒置</h2><p>谁主张谁举证这个大家应该很好理解，也符合常识。不过有时候会有<span style='color: red'><strong>举证责任倒置</strong></span>，这又是怎么回事呢？</p><p>举证责任倒置，也称举证责任反转，是指在某些特定情形下，<strong>原本应由一方当事人承担的举证责任，转由另一方当事人承担</strong>。这通常发生在一些特殊类型的案件中，如环境污染、产品责任等，由于举证困难等原因，法律为了平衡双方当事人的举证能力，特别规定将举证责任转移给另一方。</p><p>在<a href="https://www.gov.cn/xinwen/2020-06/01/content_5516649.htm">《中华人民共和国民法典》</a> 中有多个条款都有举证责任倒置相关说明。这里列举 2 个：</p><blockquote><p>第一千二百三十条 因污染环境、破坏生态发生纠纷，行为人应当就法律规定的不承担责任或者减轻责任的情形及其行为与损害之间不存在因果关系承担举证责任。</p><p>第一千二百五十四条　禁止从建筑物中抛掷物品。从建筑物中抛掷物品或者从建筑物上坠落的物品造成他人损害的，由侵权人依法承担侵权责任；经调查难以确定具体侵权人的，<strong>除能够证明自己不是侵权人的外，由可能加害的建筑物使用人给予补偿</strong>。可能加害的建筑物使用人补偿后，有权向侵权人追偿。</p></blockquote><p>下面还是先看案例吧。</p><h3 id="高空坠物飞来横祸"><a href="#高空坠物飞来横祸" class="headerlink" title="高空坠物飞来横祸"></a>高空坠物飞来横祸</h3><p>(2023)湘民终4**号：背景先介绍下，这是一个代位求偿权纠纷案件，保险公司向责任方物业公司追偿。一审中，车主将小轿车停在被告所管理的小区，小区<strong>外墙玻璃脱落砸到轿车</strong>，致使该车辆严重受损。车主投保的保险公司起诉要求被告赔偿损失。一审法院认为，物业服务企业承担的是<strong>无过错责任</strong>，<strong>适用的是举证责任倒置原则</strong>，不管该玻璃是受太阳暴晒、还是受风雨影响导致玻璃爆裂，被告对受损车辆均具有不可推卸的赔偿责任。被告不服，提起上诉。</p><p>二审认为对于物件脱落、坠落造成他人人身财产损害的，建筑物的所有人、管理人应当承担侵权责任，归责原则<strong>适用过错推定原则</strong>，即法律推定加害人有过错，从而实现举证责任倒置，由<strong>加害人证明自己没有过错</strong>。如果其能够证明自己没有过错，就不承担民事责任，否则就认定其有过错并结合其他构成要件承担相应的民事责任。</p><p>本案上诉单位作为小区的服务企业，<strong>提供的证据不足以证明其对于被上诉人车辆受损害的事实没有过错</strong>，因此，应推定上诉人对其服务的小区<strong>建筑物存在维护、管理瑕疵</strong>，应当承担相应的赔偿责任。不过小车没停放在指定的停车位，<strong>具有一定的过错</strong>，需对损失承担 30% 的责任，物业公司未履行安全管理义务，承担 70% 的责任。</p><p>这里小盛律师再展开聊下高空坠物，假设张三在小区走路，被楼上扔下来的菜刀砸中。警察调查半天，没找到是哪一户扔的菜刀，这时候整栋楼所有住户都有可能是加害人。根据举证责任倒置，<strong>除非能够证明自己没有扔菜刀，比如那个时段家里没人，否则都需要承担侵权责任</strong>。这样的规定是为了保护受害人的合法权益，避免因为举证困难而导致受害人无法获得赔偿。</p><h3 id="猪粪污水毒死鱼蟹"><a href="#猪粪污水毒死鱼蟹" class="headerlink" title="猪粪污水毒死鱼蟹"></a>猪粪污水毒死鱼蟹</h3><p>(2024)吉民终1**号：原告闫某承包了一个大坝，用于养殖鱼蟹，春季水库解冻后，发现水库出现死鱼。闫某顺着水流追溯到董某、钱某承包的养殖场，发现该养殖场冬季猪粪及排水物堆积，春季解冻后粪水流入水道，而后流入水库。闫某认为粪水对水质造成严重污染，导致鱼类死亡，于是找到董某、钱某要求赔偿，但沟通数次未达成赔偿协议，遂诉至法院。</p><p>一审法院认定董某、钱某承担赔偿责任，董某、钱某不服，提起上诉。上诉的一个核心观点是，<strong>之前闫某申请的鉴定结果不对，并不能证明猪粪尿水与其鱼蟹死亡之间存在因果关系</strong>，所以董某、钱某不应承担赔偿责任。</p><p>二审法院认为本案为水污染责任纠纷，<strong>因果关系举证责任倒置</strong>。所以这里<strong>因果关系的举证责任应由董某、钱某承担</strong>。董某、钱某虽主张闫某鱼塘内鱼蟹死亡是因鱼塘上游农田排放农药和居民生活垃圾导致，但<strong>二人对此并未举证加以证明</strong>，且二人<strong>也未对侵权行为与损害结果之间不存在因果关系进行举证</strong>，所以一审法院的结果并无不当。</p><p>本案是一个环境污染案，这里因果关系的举证责任倒置，所以被告需要证明猪粪尿水与鱼蟹死亡之间<strong>没有因果关系</strong>才行。对原告来说，虽然主张被告侵权，但不需要证明因果关系，只需要举证关联关系即可。这里关联关系其实根据生活常识，猪粪尿水流入水库，导致水质污染，鱼蟹死亡，是可以认为有关联的。 </p><p>不过值得注意的是，举证责任倒置并非普遍适用的原则，而是针对特定案件类型所作的特别规定。在具体案件中是否适用举证责任反转，需根据相关法律法规及案件具体情况来判断。这里不再展开，如有具体法律需求，可以咨询小盛律师。</p><h2 id="生活中的建议"><a href="#生活中的建议" class="headerlink" title="生活中的建议"></a>生活中的建议</h2><p>前面介绍了法律中的举证责任，可以看到还是有点复杂的。不过对于咱们大部分人来说，日常生活中用好“谁主张谁举证”就足够了。</p><p>回到文章开头的小场景：</p><ol><li>如果保安说你偷东西，你<strong>不需要证明自己没偷</strong>，应该先让保安调监控或者用其他方式证明你偷了。或者直接报警，让警察介入来调查就好了。</li><li>如果“拿”你伞的人要你提供购物记录，<strong>你没必要提供</strong>。从监控来看，是你先放那里，按照生活常识这伞就是你的，她后来拿走的行为是盗窃。如果她说是自己的伞，那么也是要她来证明这伞是她的才行。</li></ol><p>下次再遇见类似纠纷，知道怎么做了吧！</p><hr><p>我是 <a href="https://selfboot.cn/links">小盛律师</a>，欢迎关注我获取更多法律科普。如果有法律纠纷，欢迎付费咨询。</p><div class="pure-g">  <div class="pure-u-1 pure-u-md-1-3" style="width: auto;">    <img src="https://slefboot-1251736664.file.myqcloud.com/20230914_wx_qrcode_2.png" style="height: 200px; margin-right: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  </div>  <div class="pure-u-1 pure-u-md-1-3" style="width: auto;">    <img src="https://slefboot-1251736664.file.myqcloud.com/20230914_xhs_qrcode_2.png" style="height: 200px; margin-right: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  </div>  <div class="pure-u-1 pure-u-md-1-3" style="width: auto;">    <img src="https://slefboot-1251736664.file.myqcloud.com/20230914_dy_qrcode.png" style="height: 200px; margin-right: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  </div></div>]]></content>
    
    
    <summary type="html">遇到被指责偷窃、被指错误等纠纷时，很多人会下意识自证清白。但&quot;谁主张谁举证&quot;是民事诉讼的基本原则，即提出指控的一方应提供证据证实，而非被指控方需自证清白。本文通过多个生动案例，阐释了谁主张谁举证原则及例外情况下的举证责任倒置规则，帮助读者理清思路，在生活中遇到纠纷时能正确认识举证责任，避免自证的错误做法，维护自身合法权益。</summary>
    
    
    
    <category term="法律普及" scheme="https://selfboot.cn/categories/%E6%B3%95%E5%BE%8B%E6%99%AE%E5%8F%8A/"/>
    
    
    <category term="法律" scheme="https://selfboot.cn/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  
</feed>
