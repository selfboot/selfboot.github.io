<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just For Fun</title>
  <icon>https://www.gravatar.com/avatar/0de0c23d97c75300e32f8494b1485fb8</icon>
  <subtitle>知其然，知其所以然。知识广度是深度的副产品！</subtitle>
  <link href="https://selfboot.cn/atom.xml" rel="self"/>
  
  <link href="https://selfboot.cn/"/>
  <updated>2023-06-05T12:31:21.471Z</updated>
  <id>https://selfboot.cn/</id>
  
  <author>
    <name>FeiZhao</name>
    <email>xuezaigds@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GPT4 解 Leetcode 题目：判断是否一条直线</title>
    <link href="https://selfboot.cn/2023/06/05/gpt4_leetcode_1232/"/>
    <id>https://selfboot.cn/2023/06/05/gpt4_leetcode_1232/</id>
    <published>2023-06-05T21:53:26.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>在当今的数字化世界中，人工智能和机器学习正在改变我们学习和解决问题的方式。特别是在算法学习领域，OpenAI 的 GPT-4 模型已经展示了其强大的能力。这个模型可以理解复杂的问题，提供深入的解答，甚至帮助编写代码。这为学习者打开了一扇新的大门，使他们能够更有效地理解和掌握算法。在这篇博客中，我们将探讨 GPT-4 如何帮助我们解决一个具体的算法问题。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230605_gpt4_leetcode_1232.png" alt="GPT 解决 Leetcode 算法题"></p><blockquote><p>这里用了 Webpolit 和  Showme 插件, 完整的对话可以见<a href="https://chat.openai.com/share/f8bd50fe-593d-461c-8ecd-d7fe75e79e45">这里</a>。</p></blockquote><span id="more"></span><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p><strong>Human:</strong><br>请仔细看下面的题目，然后给出代码来解决题目。题目在 <a href="https://leetcode.com/problems/check-if-it-is-a-straight-line/%EF%BC%8C%E8%AF%B7%E8%A1%A5%E5%85%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">https://leetcode.com/problems/check-if-it-is-a-straight-line/，请补全下面的代码实现</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ChatGPT:</strong><br>这是一个在二维平面上检查给定点是否在一条直线上的问题。我们可以通过计算两点之间的斜率来解决这个问题。如果所有相邻点之间的斜率都相同，那么这些点就在一条直线上。</p><p>这是一个可能的 C++ 解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = coordinates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> xDiff = coordinates[<span class="number">1</span>][<span class="number">0</span>] - coordinates[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// Difference in x</span></span><br><span class="line">        <span class="type">int</span> yDiff = coordinates[<span class="number">1</span>][<span class="number">1</span>] - coordinates[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// Difference in y</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> pt = coordinates[i];</span><br><span class="line">            <span class="comment">// If the slopes are not equal then return false</span></span><br><span class="line">            <span class="keyword">if</span>(xDiff * (pt[<span class="number">1</span>] - coordinates[<span class="number">0</span>][<span class="number">1</span>]) != yDiff * (pt[<span class="number">0</span>] - coordinates[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个解决方案首先计算前两个点的斜率，然后检查其余的点是否具有相同的斜率。如果有任何一个点的斜率与前两个点的斜率不同，那么函数就会返回 false。如果所有的点都有相同的斜率，那么函数就会返回 true。</p><p>注意，<strong>这个解决方案假设输入的点的数量至少为2，因为至少需要两个点来定义一条直线</strong>。如果输入的点的数量少于2，那么这个函数可能会出现问题。</p><blockquote><p>看了下代码基本没问题，提交 Leetcode ，直接 Accepted</p></blockquote><hr><p><strong>Human:</strong><br>这个实现的时间复杂度是多少呢？</p><p><strong>ChatGPT:</strong><br>这个实现的时间复杂度是 O(n)，其中 n 是坐标数组的长度。</p><p>原因是我们需要遍历一次输入的坐标数组，以检查所有相邻点之间的斜率是否相同。在这个过程中，每个点都被访问一次，因此时间复杂度是线性的。</p><p>这是最优的时间复杂度，因为我们必须至少查看一次每个点来确定它们是否在同一直线上。</p><blockquote><p>直接补充说这个是最优的时间复杂度，这一点我们也并没有问，不过这个补充很好。</p></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p><strong>Human:</strong><br>现在有一个小学生碰见这个题目，没有一点思路，你可以给他讲解下你的思考步骤，让他下次遇见类似的题目能想到解决方案吗》</p><p><strong>ChatGPT:</strong><br>好的，让我们一步一步来解决这个问题。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230605_gpt4_leetcode_1232_method.png" alt="GPT 的解题思考步骤"></p><p>首先，你需要理解问题的要求。这个问题是在二维平面上，给你一些点的坐标，你需要判断这些点是否在一条直线上。你可以这样思考：</p><ol><li>观察问题：看看题目给的信息，这里是一些点的坐标。</li><li>理解问题：你需要判断这些点是否在一条直线上。</li><li>找出解决问题的关键：你可能会想，什么样的点在一条直线上呢？如果你记得数学课上学的，两点确定一条直线，而且在一条直线上的点，它们之间的斜率是相同的。斜率是什么呢？就是垂直距离（y）除以水平距离（x）。所以，你可以通过计算斜率来判断这些点是否在一条直线上。</li><li>编写代码：现在你可以开始写代码了。你可以先计算前两个点的斜率，然后看看其他的点是不是和这两个点有相同的斜率。</li><li>测试代码：最后，你需要测试你的代码，看看它是否能正确地解决问题。</li></ol><p>这就是解决这个问题的思考步骤。下次你遇到类似的问题，也可以试试这样的步骤。</p><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p><strong>Human:</strong><br>你可以给上面的实现写一段测试代码吗？</p><p><strong>ChatGPT:</strong><br>当然可以。以下是一段测试这个函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test case 1: Points are on a straight line</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; coordinates1 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>&#125;, &#123;<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    <span class="type">bool</span> result1 = solution.<span class="built_in">checkStraightLine</span>(coordinates1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Test case 1 result: &quot;</span> &lt;&lt; (result1 ? <span class="string">&quot;True&quot;</span> : <span class="string">&quot;False&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test case 2: Points are not on a straight line</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; coordinates2 = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>&#125;, &#123;<span class="number">7</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    <span class="type">bool</span> result2 = solution.<span class="built_in">checkStraightLine</span>(coordinates2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Test case 2 result: &quot;</span> &lt;&lt; (result2 ? <span class="string">&quot;True&quot;</span> : <span class="string">&quot;False&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码创建了一个 Solution 对象，并使用两个测试用例来测试 checkStraightLine 函数。第一个测试用例的所有点都在一条直线上，所以预期的结果是 True。第二个测试用例的点不在一条直线上，所以预期的结果是 False。测试代码将实际的结果打印出来，这样你就可以看到函数是否按预期工作。</p>]]></content>
    
    
    <summary type="html">这篇博客详细讨论了如何利用 OpenAI 的 GPT-4 模型来学习和解决算法问题。我们以一个具体的例子——在二维平面上判断一组点是否在同一直线上的问题为例，展示了 GPT-4 如何提供解决方案，编写代码，以及进行代码测试。此外，我们还讨论了 GPT-4 如何帮助我们理解问题，找出解决问题的关键，以及编写和测试代码。这篇博客是对 GPT-4 在算法学习中应用的深入探讨，对于想要了解人工智能如何改变我们学习方式的读者来说，这是一篇必读的文章。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Plugin" scheme="https://selfboot.cn/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 帮忙写 sed, awk 数据处理命令</title>
    <link href="https://selfboot.cn/2023/06/05/gpt4_write_cmd/"/>
    <id>https://selfboot.cn/2023/06/05/gpt4_write_cmd/</id>
    <published>2023-06-05T21:30:15.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>AWK 和 SED 在处理文本数据时，无论是过滤、转换，还是操作，都展现出了无与伦比的效率和灵活性。但是工具的语法不是那么好记忆，有时候用起来还得去查看帮助文档。但是有了 GPT，直接描述具体想处理的任务内容，然后由 GPT 生成所需要的命令，十分方便。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230605_gpt4_write_cmd.png" alt="GPT 解决 Leetcode 算法题"></p><span id="more"></span><h1 id="awk-统计"><a href="#awk-统计" class="headerlink" title="awk 统计"></a>awk 统计</h1><p><strong>Human:</strong><br>把下面脚本改对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt  | grep &#x27;8:1&#x27; | awk &#x27;&#123;print $7&#125;&#x27; | awk -F &#x27;:&#x27; &#x27;if($2&gt;=1683993600 and $2&lt;=1685808000) &#123;print $0&#125;&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>这里每次写老是记不住语法，总要去看看文档才行。有了 GPT 就方便多了，直接让他纠错。这里甚至都不用给他背景，他能自动发现你的问题并修复的。</p></blockquote><p><strong>ChatGPT:</strong><br>你的脚本中的问题在于 <code>awk</code> 的 if 语句的语法不正确。awk 的 if 语句应该在 <code>&#123;&#125;</code> 内部，并且 if 语句后面应该直接跟条件，然后是动作。所以，你的脚本应该修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep &#x27;8:1&#x27; | awk &#x27;&#123;print $7&#125;&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;if($2&gt;=1683993600 &amp;&amp; $2&lt;=1685808000) print $0&#125;&#x27;</span><br></pre></td></tr></table></figure><p>这个脚本的意思是：</p><ol><li>从 data.txt 文件中读取数据。</li><li>使用 grep 命令查找包含 ‘8:1’ 的行。</li><li>使用 awk 命令打印出每行的第7个字段。</li><li>使用 awk 命令，以 : 为分隔符，如果第2个字段的值在 1683993600 和 1685808000 之间，则打印出整行。</li></ol><hr><p><strong>Human:</strong><br>我想让上面的过滤脚本，在最后显示整行的内容，要怎么重新写 脚本</p><p><strong>ChatGPT:</strong><br>如果你希望在最后显示整行的内容，你需要在第一次使用 awk 命令时就进行条件判断。这样你可以在满足条件时打印整行，而不仅仅是第7个字段。你可以这样修改你的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep &#x27;8:1&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;if($7&gt;=1683993600 &amp;&amp; $7&lt;=1685808000) print $0&#125;&#x27;</span><br></pre></td></tr></table></figure><p>这个脚本的意思是：</p><ol><li>从 data.txt 文件中读取数据。</li><li>使用 grep 命令查找包含 ‘8:1’ 的行。</li><li>使用 awk 命令，以 : 为分隔符，如果第7个字段的值在 1683993600 和 1685808000 之间，则打印出整行。</li></ol><p>这样，你就可以在满足条件时看到整行的内容了。</p><hr><p><strong>Human:</strong><br>可以帮我再按照第 7 列的数据倒序排序吗</p><p><strong>ChatGPT:</strong><br>当然可以，你可以使用 sort 命令对第7列的数据进行倒序排序。这里是修改后的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep &#x27;8:1&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;if($7&gt;=1683993600 &amp;&amp; $7&lt;=1685808000) print $0&#125;&#x27; | sort -t &#x27;:&#x27; -k7 -nr</span><br></pre></td></tr></table></figure><p>这个脚本的意思是：</p><ol><li>从 data.txt 文件中读取数据。</li><li>使用 grep 命令查找包含 ‘8:1’ 的行。</li><li>使用 awk 命令，以 : 为分隔符，如果第7个字段的值在 1683993600 和 1685808000 之间，则打印出整行。</li><li>使用 sort 命令，以 : 为分隔符，对第7列进行倒序排序（-nr 表示数值排序并且是倒序）。</li></ol><p>这样，你就可以看到满足条件的行，并且这些行是按照第7列的值进行倒序排序的。</p><hr><p><strong>Human:</strong>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep &#x27;8:1&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;if($7&gt;=1683993600 &amp;&amp; $7&lt;=1685808000) print $0&#125;&#x27; | sort -t &#x27;:&#x27; -k7 -nr</span><br></pre></td></tr></table></figure><p>我想改下上面的脚本，计算满足上面过滤条件的数据中，第 2 列数字的和</p><p><strong>ChatGPT:</strong><br>如果你想计算满足过滤条件的数据中，第2列数字的和，你可以使用 awk 命令来实现。这里是修改后的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt | grep &#x27;8:1&#x27; | awk -F &#x27;:&#x27; &#x27;&#123;if($7&gt;=1683993600 &amp;&amp; $7&lt;=1685808000) sum+=$2&#125; END &#123;print sum&#125;&#x27;</span><br></pre></td></tr></table></figure><p>这个脚本的意思是：</p><ol><li>从 data.txt 文件中读取数据。</li><li>使用 grep 命令查找包含 ‘8:1’ 的行。</li><li>使用 awk 命令，以 : 为分隔符，如果第7个字段的值在 1683993600 和 1685808000 之间，则将第2个字段的值加到 sum 变量上。</li><li>在所有行处理完毕后，打印出 sum 变量的值，即第2列数字的和。</li></ol><p>这样，你就可以计算出满足条件的数据中，第2列数字的和了。</p><blockquote><p>可以看到 GPT 使用 awk 是炉火纯青，基本手到擒来，很是方便。 </p></blockquote><h1 id="sed-文本处理"><a href="#sed-文本处理" class="headerlink" title="sed 文本处理"></a>sed 文本处理</h1><p><strong>Human:</strong><br>有一个很大的文本文件，我想删除中间的第 5 行，用什么命令可以完成呢</p><p><strong>ChatGPT:</strong><br>如果你想删除一个文本文件中的特定行，你可以使用 <code>sed</code> 命令。sed 是一个流编辑器，可以用来对输入流（文件或管道）进行基于行的编辑。</p><p>如果你想删除第5行，你可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;5d&#x27; filename</span><br></pre></td></tr></table></figure><p>这个命令的意思是：</p><ol><li>-i：这个选项告诉 sed 对文件进行原地编辑，也就是说，修改会直接反映到文件上。</li><li>‘5d’：这是 sed 的命令，表示删除第5行。</li><li>filename：这是你要编辑的文件的名称。</li></ol><p>请注意，这个命令会直接修改文件，所以在运行之前，你可能需要备份你的文件。如果你不想直接修改文件，你可以去掉 <code>-i</code> 选项，这样 sed 会将修改的结果输出到标准输出，而不会改变原文件。</p><hr><p><strong>Human:</strong><br>我有一个文本文件，如下示例<br>Timestamp       Category        Message<br>1598843202      INFO    Booting up system<br>1598843402      INFO    Booting up critical service: Authorization<br>1598843502      INFO    System booted successfully</p><p>我想把里面的  INFO  改为  DEBUG，用什么命令来完成呢</p><p><strong>ChatGPT:</strong><br>如果你想在一个文本文件中替换某个字符串，你可以使用 sed 命令。<code>sed</code> 是一个流编辑器，可以用来对输入流（文件或管道）进行基于行的编辑。</p><p>如果你想将所有的 “INFO” 替换为 “DEBUG”，你可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/INFO/DEBUG/g&#x27; filename</span><br></pre></td></tr></table></figure><p>这个命令的意思是：</p><ol><li>-i：这个选项告诉 sed 对文件进行原地编辑，也就是说，修改会直接反映到文件上。</li><li>‘s&#x2F;INFO&#x2F;DEBUG&#x2F;g’：这是 sed 的命令，表示将所有的 “INFO” 替换为 “DEBUG”。</li><li>filename：这是你要编辑的文件的名称。</li></ol><p>请注意，这个命令会直接修改文件，所以在运行之前，你可能需要备份你的文件。如果你不想直接修改文件，你可以去掉 -i 选项，这样 sed 会将修改的结果输出到标准输出，而不会改变原文件。</p><hr><p><strong>Human:</strong><br>sed 还可以用来完成什么复杂的文本操作</p><p><strong>ChatGPT:</strong>  </p><p>sed 是一个非常强大的文本处理工具，它可以用来执行各种复杂的文本操作。以下是一些 sed 可以完成的操作：</p><ol><li>查找和替换：这可能是 sed 最常见的用途。你可以使用 sed 来查找并替换文件中的文本，就像我们在上面的例子中所做的那样。</li><li>删除行：你可以使用 sed 来删除文件中的特定行，或者删除匹配特定模式的行。</li><li>插入和追加文本：你可以使用 sed 在文件的特定位置插入或追加文本。</li><li>修改行：你可以使用 sed 修改文件中的特定行。</li><li>打印特定行：你可以使用 sed 打印文件中的特定行。</li><li>多点编辑：你可以在一个 sed 命令中执行多个编辑操作。</li><li>正则表达式匹配：sed 支持正则表达式，这使得你可以执行复杂的文本匹配和操作。</li><li>脚本化：你可以将一系列 sed 命令写入一个脚本文件中，然后使用 sed -f 命令来执行这个脚本。</li></ol><p>这只是 sed 可以做的一些基本操作，实际上 sed 的功能远不止这些。如果你想深入了解 sed，我建议你查阅 sed 的手册或者其他相关的教程。</p>]]></content>
    
    
    <summary type="html">在这篇博客中，我们将探索如何利用 AWK 和 SED 进行复杂的文本处理，同时展示了如何使用 OpenAI 的 GPT-4 模型来帮助我们编写命令和解决问题。我们将深入解析各种实际示例，包括如何过滤和排序数据，如何进行文本替换，以及如何删除或修改特定行。这篇文章不仅为你提供了深入理解 AWK 和 SED 的机会，还展示了人工智能如何帮助我们更有效地进行编程和数据处理。</summary>
    
    
    
    <category term="工具介绍" scheme="https://selfboot.cn/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
  </entry>
  
  <entry>
    <title>Mac 图片自动压缩上传 COS</title>
    <link href="https://selfboot.cn/2023/06/02/auto_compress_upload/"/>
    <id>https://selfboot.cn/2023/06/02/auto_compress_upload/</id>
    <published>2023-06-02T19:36:08.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>把个人博客放在了 netilfy 托管，它给了一个优化建议，可以压缩图片节省带宽。但是每次截图后都要再压缩下图片有点麻烦，于是想着应该可以<strong>偷偷懒</strong>。目标很明确，截图后图片传到我的 git 仓库 images 目录后，能给我自动压缩，并且上传 COS，这样我就只用在 markdown 文件里面拼链接就好了。</p><p>打开 Web Browsing 功能的  GPT4，让他帮忙实现吧。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_auto_compress_upload_gpt.png" alt="GPT 自动化工具"></p><h1 id="监听文件并压缩"><a href="#监听文件并压缩" class="headerlink" title="监听文件并压缩"></a>监听文件并压缩</h1><p><strong>Human:</strong><br>在 mac 上，我有一个目录，想在目录里面添加文件的时候，自动对图片进行压缩，替换原来的文件。要怎么实现呢？</p><p><strong>ChatGPT:</strong><br>你可以通过使用 Automator（自动操作程序）来实现这个功能。Automator 是 Mac OS X 提供的一种强大工具，能帮助你自动执行各种任务。</p><p>以下是设置步骤：</p><ol><li>打开 Automator（位于“应用程序”文件夹中）。</li><li>点击“新建文稿”，然后选择“文件夹操作”。</li><li>在弹出的窗口中，选择你要监视的文件夹。</li><li>在左侧面板中，找到并双击“缩放图片”。</li><li>在弹出的对话框中，设置你希望的图片大小。</li><li>另外，你可能需要添加一个“复制 Finder 项目”操作，将原始图片复制到另一个地方，以防万一。你可以在左侧面板中找到并双击它。</li><li>最后，保存你的 Automator 工作流程。</li></ol><p>这样，每当你向该文件夹添加图片时，Automator 都会自动将其缩放到你指定的大小，然后替换原来的图片。请注意，这个方法会覆盖原始图片，因此如果你不想丢失原始图片，最好先做好备份。</p><hr><p><strong>Human:</strong><br>这里我想用 <a href="https://imageoptim.com/command-line.html">https://imageoptim.com/command-line.html</a> 中提到的ImageOptim 来压缩图片，要怎么做呢</p><p><strong>ChatGPT:</strong><br>在使用 ImageOptim 命令行工具前，你需要先确保它已经安装在你的 Mac 上。你可以通过以下命令安装它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g imageoptim-cli</span><br></pre></td></tr></table></figure><p>然后，你可以在 Automator（自动操作程序）中使用 Shell 脚本来调用 ImageOptim。以下是具体步骤：</p><ol><li>打开 Automator（位于“应用程序”文件夹中）。</li><li>点击“新建文稿”，然后选择“文件夹操作”。</li><li>在弹出的窗口中，选择你要监视的文件夹。</li><li>在左侧面板中，找到并双击“运行 Shell 脚本”。</li><li>在弹出的对话框中，输入以下命令： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for f in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    /usr/local/bin/imageoptim &quot;$f&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li>最后，保存你的 Automator 工作流程。</li></ol><p>这样，每当你向该文件夹添加图片时，Automator 就会自动调用 ImageOptim 命令行工具对其进行压缩，并替换原来的文件。</p><p>请注意，这个方法会覆盖原始图片，因此如果你不想丢失原始图片，最好先做好备份。</p><p>也请注意，这个脚本假设你的 ImageOptim 命令行工具是通过 npm 安装的，且安装位置在 <code>/usr/local/bin/</code>。如果你的安装位置不同，你需要修改脚本中的路径。</p><hr><p><strong>Human:</strong><br>我按照上面方法保存Automator之后，往步骤 3 里面的文件夹加了一个图片，但是并没有被压缩，是怎么回事呢？</p><p><strong>ChatGPT:</strong><br>这可能有几个原因，我们可以进行以下排查：</p><ol><li>确认你的 Automator 文件夹操作是否正确保存，并且指定的是正确的文件夹。</li><li>确认在 Automator 工作流程中添加的 “运行 Shell 脚本” 操作里的命令是否正确。特别要注意 ImageOptim 命令行工具的路径是否正确。</li><li>查看是否有权限问题。你可能需要给 Automator 工作流程足够的权限来修改文件夹中的图片。</li><li>最后，确保 ImageOptim CLI 工具已经正确安装，并可以在 Terminal（终端）中直接运行。</li></ol><p>如果以上步骤都无法解决问题，你可以尝试在 Automator 的 “运行 Shell 脚本” 操作中添加一些调试代码，例如在命令中添加 echo “$f” 来查看正在处理的文件路径，或者在命令最后添加 2&gt; &#x2F;path&#x2F;to&#x2F;error.log 来将可能的错误输出到一个日志文件。</p><blockquote><p>这里真的超出预期了，直接教你打日志来排查问题，有点专业工程师的感觉。</p></blockquote><hr><p><strong>Human:</strong><br>我加了 <code>2&gt; /path/to/error.log</code>，但是没有任何日志输出</p><p><strong>ChatGPT:</strong><br>如果没有任何日志输出，这可能表明你的 Automator 工作流程没有被正确触发，或者 “运行 Shell 脚本” 操作没有被正确执行。</p><p>我建议你首先检查你的 Automator 工作流程是否被正确保存，并且关联到了正确的文件夹。你可以尝试重新创建一个新的文件夹操作，以确保所有的设置都是正确的。</p><p>然后，你可以在 “运行 Shell 脚本” 操作中添加一些简单的调试代码，例如 <code>echo &quot;Hello, world!&quot; &gt; /path/to/debug.log</code>。然后再添加一个新的图片到文件夹中，看看是否有任何输出。</p><p>如果这个简单的测试也不能工作，那么问题可能出在 Automator 或者你的系统设置上。你可以检查你的系统设置，确保 Automator 有足够的权限来监视文件夹和修改文件。你也可以尝试在 Automator 中创建一个新的文件夹操作，看看是否有其他的操作能够被正确触发。</p><p>如果这个简单的测试可以工作，那么问题可能出在 ImageOptim CLI 工具或者你的 Shell 脚本上。你可以在 Terminal（终端）中手动运行相同的 ImageOptim 命令，看看是否有任何错误。</p><hr><p><strong>Human:</strong><br>我的  shell  如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello, world!&quot; &gt;&gt; ~/Desktop/error.log</span><br><span class="line">for f in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    /Users/daemonzhao/.nvm/versions/node/v20.2.0/bin/imageoptim &quot;$f&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">2&gt;&gt; ~/Desktop/error.log</span><br></pre></td></tr></table></figure><p>这里 error.log 只输出了 <code>Hello, world!</code> ，<code>$@</code> 应该是空值。</p><blockquote><p>这里后面又有几轮聊天，GPT4 开始并没有给出一个正确的答案。不过我们可以信任 GPT、然后验证 GPT 的内容。</p></blockquote><h1 id="换-Apple-Script"><a href="#换-Apple-Script" class="headerlink" title="换 Apple Script"></a>换 Apple Script</h1><hr><p><strong>Human:</strong><br>Automator的 Folder Actions，如何成功拿到新添加的文件路径。上面你给出的方法拿不到，所以没法执行 shell 脚本</p><p><strong>ChatGPT:</strong><br>对不起刚刚的解答可能有些误导。在 Automator 的 “<strong>运行 Shell 脚本</strong>“ 操作中，”$@” 是代表所有的参数，而在 Folder Actions 中，这些参数就是新添加到文件夹的文件路径。</p><p>不过，如果你的脚本中 “$@” 是空的，那么可能是因为 Automator 并没有正确地将文件路径作为参数传递给 Shell 脚本。</p><p>为了解决这个问题，你可以尝试使用 AppleScript 而不是 Shell 脚本来获取文件路径。你可以在 Automator 中添加一个 “运行 AppleScript” 操作，然后使用以下的代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line">    <span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;Finder&quot;</span></span><br><span class="line">        <span class="keyword">set</span> filePath <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> (input <span class="keyword">as</span> <span class="built_in">alias</span>)</span><br><span class="line">        <span class="built_in">do shell script</span> <span class="string">&quot;/path/to/your/command &quot;</span> &amp; filePath</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>这个 AppleScript 脚本会将新添加到文件夹的文件路径作为 input 参数传递给 run 函数，然后使用 Finder 来获取文件的 POSIX 路径，最后执行你的 Shell 命令。</p><p>注意你需要将 &#x2F;path&#x2F;to&#x2F;your&#x2F;command 替换为你想要执行的 Shell 命令，比如 ImageOptim CLI 的路径。你也可以在 do shell script 命令中添加其他的参数，比如文件路径。</p><p>这是一个实例，你可以根据你的需要进行修改。希望这个方法能够解决你的问题！</p><blockquote><p>最开始让用  shell script，一直拿不到增加的文件，这次换了 apple script，一下子就拿成功了。</p></blockquote><hr><p><strong>Human:</strong><br>不能将“current application”转换为“alias”类型。</p><p><strong>ChatGPT:</strong><br>对不起，我犯了个错误。在 AppleScript 中，input 参数是一个列表，表示所有传递给脚本的文件。如果你想要处理每个文件，你需要使用一个循环。这是一个修改后的脚本：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line">    <span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">in</span> input</span><br><span class="line">        <span class="keyword">set</span> filePath <span class="keyword">to</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> i</span><br><span class="line">        <span class="built_in">do shell script</span> <span class="string">&quot;/path/to/your/command &quot;</span> &amp; <span class="keyword">quoted form</span> <span class="keyword">of</span> filePath</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>这个脚本会遍历所有传递给脚本的文件，获取每个文件的 POSIX 路径，然后执行你的 Shell 命令。注意 quoted form of filePath 是用来确保文件路径在传递给 Shell 命令时被正确引用，这对于含有空格或其他特殊字符的文件路径是必要的。</p><p>你需要将 <code>/path/to/your/command</code> 替换为你想要执行的 Shell 命令，比如 ImageOptim CLI 的路径。你也可以在 do shell script 命令中添加其他的参数，比如文件路径。</p><blockquote><p>这次终于成功了，但是压缩速度有点慢。</p></blockquote><h1 id="更换压缩工具"><a href="#更换压缩工具" class="headerlink" title="更换压缩工具"></a>更换压缩工具</h1><hr><p><strong>Human:</strong><br>除了 ImageOptim ，mac  上还有其他免费的工具可以压缩图片吗？要求有较快的速度和较高的无损压缩比。</p><p><strong>ChatGPT:</strong><br>在 Mac 上除了 ImageOptim，你还有以下一些免费的图片压缩工具可以选择：</p><ol><li>Preview：这是 Mac 自带的一个应用程序，可以用来压缩图片。你可以选择单个或多个图片来进行压缩，方法是打开 Preview，然后点击顶部菜单栏的“文件” &gt; “导出”。然后你可以选择图片的格式，并通过调整质量滑块来压缩图片<a href="https://www.idownloadblog.com/2022/01/04/how-to-compress-image-mac/">​1</a>​。</li><li>Mac 的 Photos 应用：你也可以使用 Mac 的 Photos 应用来压缩图片。你可以在 Photos 应用中选择一张或多张照片，然后按 Command + Shift + E 或从顶部菜单栏点击“文件” &gt; “导出” &gt; “导出照片”来压缩图片<a href="https://www.idownloadblog.com/2022/01/04/how-to-compress-image-mac/">​1</a>​。</li><li>图片压缩应用：Mac App Store 有许多可以压缩图片的应用。比如你可以在 App Store 中搜索“压缩图片”，就可以找到一些相关的应用<a href="https://www.idownloadblog.com/2022/01/04/how-to-compress-image-mac/%E2%80%8B1%E2%80%8B%E3%80%82">https://www.idownloadblog.com/2022/01/04/how-to-compress-image-mac/​1​。</a></li><li>在线图片压缩网站：你也可以选择使用在线的图片压缩服务，比如 iLoveIMG.com 和 ShortPixel.com。这些在线服务可以方便快捷地压缩图片，但你需要注意的是，你上传的图片会被存储在这些网站的服务器上，所以对于包含个人或敏感信息的图片，建议使用离线的压缩方法<a href="https://www.idownloadblog.com/2022/01/04/how-to-compress-image-mac/">​1​</a>。</li></ol><blockquote><p>这里用了 browsing 功能，GPT 自己去网上搜索。</p></blockquote><hr><p><strong>Human:</strong><br>我想找的是能在 mac 本地命令行运行的压缩图片工具，你有啥建议的</p><p><strong>ChatGPT:</strong><br>在 Mac 上，有一些命令行工具可以用来压缩图片：</p><ol><li>jpegoptim：这是一个用来优化和压缩 JPEG 图片的命令行工具。你可以使用 Homebrew 来安装它，命令是 brew install jpegoptim。压缩一个 JPEG 图片的命令是 jpegoptim –size&#x3D;100k your_image.jpg，这会将 your_image.jpg 压缩到 100KB 或更小的大小。</li><li>optipng：这是一个 PNG 图片优化工具，可以通过命令行使用。安装命令是 brew install optipng。使用 OptiPNG 压缩图片的命令是 optipng -o7 your_image.png，这会使用最高级别的优化选项来压缩 your_image.png。</li><li>pngquant：这是另一个用于 PNG 图片的命令行工具，可以创建具有少量颜色的优质 PNG 图片，从而大大减小文件大小。安装命令是 brew install pngquant。压缩 PNG 图片的命令是 <code>pngquant your_image.png</code>，这会创建一个新的，压缩后的 PNG 图片。</li></ol><p>所有这些工具都需要通过命令行来使用，并且可以在脚本中使用，以便于批量处理图片。但是请注意，每个工具都有其自己的一套参数和选项，你可能需要阅读各自的文档来更好地理解如何使用它们。</p><hr><p><strong>Human:</strong><br>我想用 pngquant，我用 <code>brew install pngquant</code> 安装后，如何更改 上面  apple script  的脚本呢</p><p><strong>ChatGPT:</strong><br>你可以将 AppleScript 脚本修改为如下形式，以使用 pngquant 工具：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> adding folder items <span class="keyword">to</span> this_folder <span class="keyword">after</span> receiving added_items</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        <span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;Terminal&quot;</span></span><br><span class="line">            <span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> <span class="built_in">number</span> <span class="keyword">of</span> items <span class="keyword">in</span> added_items</span><br><span class="line">                <span class="keyword">set</span> this_item <span class="keyword">to</span> <span class="built_in">item</span> i <span class="keyword">of</span> added_items</span><br><span class="line">                <span class="built_in">do shell script</span> <span class="string">&quot;/usr/local/bin/pngquant --force --ext .png &quot;</span> &amp; <span class="keyword">quoted form</span> <span class="keyword">of</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> this_item</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">try</span></span><br><span class="line"><span class="keyword">end</span> adding folder items <span class="keyword">to</span></span><br></pre></td></tr></table></figure><p>这段脚本在新的文件添加到文件夹时，会使用 <code>pngquant</code> 来压缩这些文件。–force 选项使得 pngquant 在文件已经存在时会覆盖它，而 –ext .png 选项会使得输出文件的扩展名为 .png。</p><p>请注意，你可能需要根据 pngquant 在你的系统上的实际安装位置来修改脚本中的 <code>/usr/local/bin/pngquant</code>。你可以通过在终端运行 which pngquant 命令来找到 pngquant 的实际路径。</p><p>同样，你需要根据实际情况来调整 pngquant 的参数。例如，如果你想要指定压缩级别，你可以添加 -quality 参数，如 –quality 60-80。你可以参考 pngquant 的文档来了解更多的参数和选项。</p><h1 id="添加图片前缀"><a href="#添加图片前缀" class="headerlink" title="添加图片前缀"></a>添加图片前缀</h1><hr><p><strong>Human:</strong><br>我想在脚本中改一下压缩后的文件名，在每个文件明前面加上日期前缀，比如20230601_ ，要怎么做呢？</p><p><strong>ChatGPT:</strong><br>为了实现这个功能，你需要获取当前日期，然后格式化为你需要的格式。然后，你可以将这个日期前缀添加到文件名中。你可以使用 <code>do shell script</code> 和 <code>date</code> 命令来获取和格式化日期，然后使用 <code>text item delimiters</code> 来修改文件名。以下是你可以尝试的 AppleScript：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;System Events&quot;</span></span><br><span class="line"><span class="keyword">set</span> currentDate <span class="keyword">to</span> <span class="built_in">do shell script</span> <span class="string">&quot;date &#x27;+%Y%m%d&#x27;&quot;</span></span><br><span class="line"><span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">in</span> input</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>这个脚本首先获取当前日期，并将其格式化为 “YYYYMMDD” 的形式。然后，对于每个输入文件，它检查扩展名是否为 “png”。如果是，它获取文件名，将其分解为基本名称和扩展名，然后将日期前缀添加到基本名称。然后，它将文件重命名为新的文件名，然后使用新的文件路径来执行 pngquant 命令。</p><blockquote><p>这里有坑，因为没写过apple script，也懒得去看代码。结果这里代码死循环添加前缀，中间和 GPT 交流了几轮，改了几遍代码，有点不顺。最后提示让 GPT 一步步来思考，竟然可以啦。</p></blockquote><hr><p><strong>Human:</strong><br>还是不行，你重新一步步思考下这个步骤，然后给出一个正确的代码</p><p><strong>ChatGPT:</strong><br>我明白你的问题了，确实是我之前的脚本存在问题。因为每次添加文件到文件夹，<code>Folder Action</code>都会触发一次，处理文件夹中所有的文件。如果同时添加了多个文件，这个<code>Folder Action</code>就会被多次触发，处理的对象包括已经处理过的文件，这就导致了问题。</p><p>我们可以修改脚本，使得它只处理那些没有被处理过的文件。具体来说，我们可以检查文件名是否已经包含了日期前缀，如果包含，我们就跳过这个文件。</p><p>另外，我们应该在压缩文件后立即重命名文件，而不是在压缩前。因为pngquant工具会直接覆盖原文件，如果我们先重命名再压缩，原文件就不会被压缩，而新文件会保留原来的大小。</p><p>下面是修改后的脚本：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line">    <span class="keyword">set</span> currentDate <span class="keyword">to</span> <span class="built_in">do shell script</span> <span class="string">&quot;date &#x27;+%Y%m%d&#x27;&quot;</span></span><br><span class="line">    <span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;System Events&quot;</span></span><br><span class="line">        <span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">in</span> input</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>这个脚本应该可以解决你的问题。它只会处理那些没有被处理过的.png文件，并且在压缩文件后立即重命名文件。同时添加的多个文件也不会造成问题。</p><blockquote><p>这次可以自动压缩重命名了，还想再自动传到 COS 上。</p></blockquote><h1 id="上传-COS"><a href="#上传-COS" class="headerlink" title="上传 COS"></a>上传 COS</h1><p><strong>Human:</strong><br>在上面的改名字和压缩步骤完成后，我想把图片传到 Tencent cos 的某一个 bucket 中，要怎么做呢？</p><p><strong>ChatGPT:</strong><br>首先，你需要在本地安装腾讯云的命令行工具 COSCMD，你可以使用以下命令进行安装：<code>pip install coscmd</code></p><p>然后，你需要配置你的COSCMD。运行以下命令并按照提示输入你的腾讯云 API 密钥（SecretId 和 SecretKey）以及你的地域（Region）和默认的存储桶（Bucket）：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coscmd config -a &lt;SecretId&gt; -s &lt;SecretKey&gt; -b &lt;Bucket&gt; -r &lt;Region&gt;</span><br></pre></td></tr></table></figure><p>在上面的命令中，<SecretId>，<SecretKey>，<Bucket> 和 <Region> 是你需要替换的部分。例如，你可能需要这样：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coscmd config -a AKIDxxxxxxxx -s xxxxxxxx -b mybucket<span class="number">-1250000000</span> -r ap-beijing</span><br></pre></td></tr></table></figure><p>现在，你可以在 AppleScript 中使用 do shell script 命令来调用 COSCMD 并将文件上传到你的存储桶中。你可以使用 coscmd upload 命令来上传文件，如下所示：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">do shell script</span> <span class="string">&quot;coscmd upload &quot;</span> &amp; <span class="keyword">quoted form</span> <span class="keyword">of</span> filePath &amp; <span class="string">&quot; /&quot;</span></span><br></pre></td></tr></table></figure><p>所以，你的 AppleScript 可能看起来像这样：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line">    <span class="keyword">set</span> currentDate <span class="keyword">to</span> <span class="built_in">do shell script</span> <span class="string">&quot;date &#x27;+%Y%m%d&#x27;&quot;</span></span><br><span class="line">    <span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;System Events&quot;</span></span><br><span class="line">        <span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">in</span> input</span><br><span class="line">            <span class="keyword">set</span> filePath <span class="keyword">to</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> i</span><br><span class="line">            <span class="keyword">set</span> fileExtension <span class="keyword">to</span> <span class="built_in">name</span> extension <span class="keyword">of</span> i</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>在这个脚本中，我们在重命名文件后获取新的文件路径，并将其上传到 COS。注意，你需要确保你的计算机上已经安装了 Python 和 pip，并且你的腾讯云 API 密钥、Bucket 和 Region 都是正确的。你还需要确保你的 Bucket 允许你上传文件。</p><blockquote><p>这里自己搞错了几个地方，不过 GPT 提示加了 log，然后也很快定位到了。</p></blockquote><h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><p>最终脚本如下:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="built_in">run</span> &#123;input, parameters&#125;</span><br><span class="line"><span class="keyword">set</span> currentDate <span class="keyword">to</span> <span class="built_in">do shell script</span> <span class="string">&quot;date &#x27;+%Y%m%d&#x27;&quot;</span></span><br><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">&quot;System Events&quot;</span></span><br><span class="line"><span class="keyword">repeat</span> <span class="keyword">with</span> i <span class="keyword">in</span> input</span><br><span class="line"><span class="keyword">set</span> filePath <span class="keyword">to</span> <span class="keyword">POSIX path</span> <span class="keyword">of</span> i</span><br><span class="line"><span class="keyword">set</span> fileExtension <span class="keyword">to</span> <span class="built_in">name</span> extension <span class="keyword">of</span> i</span><br><span class="line"><span class="keyword">set</span> folderName <span class="keyword">to</span> <span class="built_in">do shell script</span> <span class="string">&quot;dirname &quot;</span> &amp; filePath</span><br><span class="line"><span class="keyword">if</span> fileExtension <span class="keyword">is</span> <span class="string">&quot;png&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> fileName <span class="keyword">to</span> <span class="built_in">name</span> <span class="keyword">of</span> i</span><br><span class="line"><span class="keyword">set</span> <span class="literal">AppleScript</span>&#x27;s <span class="literal">text item delimiters</span> <span class="keyword">to</span> <span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="keyword">set</span> baseName <span class="keyword">to</span> <span class="keyword">first</span> <span class="built_in">text</span> <span class="built_in">item</span> <span class="keyword">of</span> fileName</span><br><span class="line"><span class="keyword">if</span> baseName <span class="keyword">does</span> <span class="keyword">not</span> <span class="keyword">start with</span> currentDate <span class="keyword">then</span></span><br><span class="line"><span class="built_in">do shell script</span> <span class="string">&quot;/opt/homebrew/bin/pngquant --force --ext .png &quot;</span> &amp; <span class="keyword">quoted form</span> <span class="keyword">of</span> filePath</span><br><span class="line"><span class="keyword">set</span> newBaseName <span class="keyword">to</span> currentDate &amp; <span class="string">&quot;_&quot;</span> &amp; baseName</span><br><span class="line"><span class="keyword">set</span> newFileName <span class="keyword">to</span> newBaseName &amp; <span class="string">&quot;.&quot;</span> &amp; fileExtension</span><br><span class="line"><span class="keyword">set</span> <span class="built_in">name</span> <span class="keyword">of</span> i <span class="keyword">to</span> newFileName</span><br><span class="line"><span class="keyword">set</span> newFilePath <span class="keyword">to</span> folderName &amp; <span class="string">&quot;/&quot;</span> &amp; newFileName</span><br><span class="line"><span class="keyword">set</span> uploadCommand <span class="keyword">to</span> <span class="string">&quot;/opt/homebrew/Caskroom/miniconda/base/bin/coscmd upload &quot;</span> &amp; <span class="keyword">quoted form</span> <span class="keyword">of</span> newFilePath &amp; <span class="string">&quot; /&quot;</span></span><br><span class="line"><span class="built_in">do shell script</span> uploadCommand</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">end</span> <span class="built_in">run</span></span><br></pre></td></tr></table></figure><p>实现的结果，指定一个目录，后面往这个目录新增加的 png，都自动压缩，在前缀加上当前日期，然后传输到腾讯云 COS 上。完整的对话在<a href="https://chat.openai.com/share/724a1870-7524-4ed7-be08-c22c2b4acfb3">这里</a>。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_auto_compress_upload_final.png" alt="最终自动化工具"></p>]]></content>
    
    
    <summary type="html">本篇文章详细讲解如何在 macOS 中通过 AppleScript 实现监控文件夹并自动进行图片压缩及文件重命名，最后上传到腾讯云 COS 的过程。涉及技术包括 AppleScript、pngquant 图片压缩工具以及腾讯云 COS 的命令行工具 coscmd。本教程适合对自动化文件处理感兴趣的 macOS 用户参考。</summary>
    
    
    
    <category term="工具介绍" scheme="https://selfboot.cn/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="教程" scheme="https://selfboot.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 plugin 来做数据分析</title>
    <link href="https://selfboot.cn/2023/06/01/gpt4_plugin_noteable/"/>
    <id>https://selfboot.cn/2023/06/01/gpt4_plugin_noteable/</id>
    <published>2023-06-01T13:16:35.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>GPT4 的部分插件还是能提高工作效率的，其中 noteable 可以写脚本绘制图，在数据分析领域还是很不错的。我们可以 AI 总结中国过去十年的出生人口趋势，可以分析用户留存率，或者找出某些日子都活跃的用户。</p><h1 id="人口趋势"><a href="#人口趋势" class="headerlink" title="人口趋势"></a>人口趋势</h1><p><strong>Human:</strong><br>统计下中国官方给的最近 10 年总出生人口，用 python 画一个曲线走势图。</p><p><strong>ChatGPT:</strong><br>好的，首先我们需要找到这些数据。这些数据可能来自中国的官方统计局或其他可靠的数据源。让我帮你找一下。</p><p>我在中国统计局的官方网站上没有直接找到过去十年的出生人口数据。可能需要在网站的不同部分或者在年度统计报告中进行深入搜索。另一种可能是这些数据可能需要在其他可靠的数据源中查找。你是否有推荐的数据源，或者我可以继续在中国统计局网站上进行深入搜索？</p><blockquote><p>这里用了插件 WebPilot，可以去网上搜索，目前用过的最好用的插件了。作者是一个产品经理，可以在<a href="https://twitter.com/CocoSgt_twt">这里</a>找他。不过这里没有找到相关数据，就自己去网上搜索了下，给他链接。</p></blockquote><hr><p><strong>Human:</strong><br>这里有，<a href="https://www.163.com/dy/article/HSAQ6SQ2055611U3.html">https://www.163.com/dy/article/HSAQ6SQ2055611U3.html</a> ，帮我用  python  画一个曲线走势图吧</p><p><strong>ChatGPT:</strong><br>这篇文章中包含了从1949年到2022年中国每年的出生人口数据。以下是最近十年的数据：</p><ul><li>2013年：1640万</li><li>2014年：1687万</li><li>2015年：1655万</li><li>2016年：1786万</li><li>2017年：1723万</li><li>2018年：1523万</li><li>2019年：1465万</li><li>2020年：1202万</li><li>2021年：1062万</li><li>2022年：956万</li></ul><p>接下来，我将使用这些数据创建一个Python notebook，并绘制出生人口的曲线走势图。</p><p>我已经创建了一个名为 “China_Birth_Rate_Analysis.ipynb” 的 Python notebook。你可以点击<a href="https://app.noteable.io/f/f033b7db-8516-4543-b085-447dc449b97f/China_Birth_Rate_Analysis.ipynb">这里</a>查看。</p><p>接下来，我将在 notebook 中添加一些 Python 代码来创建出生人口的曲线走势图。这是从2013年到2022年中国出生人口的曲线走势图：<br><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt4_plugin_noteable_analysis.png" alt="出生人口走势图"></p><p>从图中可以看出，中国的出生人口在2016年达到了峰值，之后开始逐年下降。</p><h1 id="计算留存"><a href="#计算留存" class="headerlink" title="计算留存"></a>计算留存</h1><blockquote><p>下面给他一个随便编的用户活跃天数记录，然后让 AI 计算留存；</p></blockquote><hr><p><strong>Human:</strong><br>这是一个记录用户活跃天数的表，第一列是用户 id，第二列是活跃日期，可以帮我写一个脚本，计算20230501号活跃的用户，在 20230502 和20230503日的留存率是多少吗？ 帮我画一个留存率的图。</p><p><strong>ChatGPT:</strong><br>当然可以。首先，我需要查看一下你的数据。你能提供一下数据的链接或者文件吗？</p><hr><p><strong>Human:</strong><br><a href="https://docs.google.com/spreadsheets/d/1b2HiAqlAQGRS2RMnI8ZbFD3i3dZu-Fv460Q6mh_cFLQ/edit#gid=0">https://docs.google.com/spreadsheets/d/1b2HiAqlAQGRS2RMnI8ZbFD3i3dZu-Fv460Q6mh_cFLQ/edit#gid=0</a></p><p><strong>ChatGPT:</strong><br>很抱歉，我无法直接访问 Google Sheets 文档。你能将数据下载为 CSV 文件并上传吗？或者，如果你愿意的话，我可以提供一段 Python 代码，你可以在本地运行来计算留存率。</p><hr><p><strong>Human:</strong><br>csv 文件在这里 <a href="https://docs.google.com/spreadsheets/d/1b2HiAqlAQGRS2RMnI8ZbFD3i3dZu-Fv460Q6mh_cFLQ/edit?usp=sharing">https://docs.google.com/spreadsheets/d/1b2HiAqlAQGRS2RMnI8ZbFD3i3dZu-Fv460Q6mh_cFLQ/edit?usp=sharing</a></p><p><strong>ChatGPT:</strong><br>很抱歉，我仍然无法直接访问 Google Sheets 文档的内容。你能将数据下载为 CSV 文件并上传吗？或者，如果你愿意的话，我可以提供一段 Python 代码，你可以在本地运行来计算留存率。</p><hr><p><strong>Human:</strong><br>抱歉，给错了，用新的这个<a href="https://drive.google.com/file/d/1Ax9tZcKQjlittBy9mA08NaZu2VadVEjx/view?usp=sharing">https://drive.google.com/file/d/1Ax9tZcKQjlittBy9mA08NaZu2VadVEjx/view?usp=sharing</a></p><p><strong>ChatGPT:</strong><br>很抱歉，我仍然无法直接访问 Google Drive 上的文件。然而，我可以提供一段 Python 代码，你可以在本地运行来计算留存率。这段代码假设你已经将数据下载为 CSV 文件，并且文件的路径是 ‘data.csv’。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将活跃日期转换为日期格式</span></span><br><span class="line">df[<span class="string">&#x27;活跃日期&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;活跃日期&#x27;</span>], <span class="built_in">format</span>=<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算20230501号活跃的用户</span></span><br><span class="line">active_users = df[df[<span class="string">&#x27;活跃日期&#x27;</span>] == <span class="string">&#x27;2023-05-01&#x27;</span>][<span class="string">&#x27;用户&#x27;</span>].unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算这些用户在20230502和20230503的活跃情况</span></span><br><span class="line">active_users_next_day = df[(df[<span class="string">&#x27;活跃日期&#x27;</span>] == <span class="string">&#x27;2023-05-02&#x27;</span>) &amp; (df[<span class="string">&#x27;用户&#x27;</span>].isin(active_users))][<span class="string">&#x27;用户&#x27;</span>].unique()</span><br><span class="line">active_users_next_two_days = df[(df[<span class="string">&#x27;活跃日期&#x27;</span>] == <span class="string">&#x27;2023-05-03&#x27;</span>) &amp; (df[<span class="string">&#x27;用户&#x27;</span>].isin(active_users))][<span class="string">&#x27;用户&#x27;</span>].unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算留存率</span></span><br><span class="line">retention_rate_next_day = <span class="built_in">len</span>(active_users_next_day) / <span class="built_in">len</span>(active_users)</span><br><span class="line">retention_rate_next_two_days = <span class="built_in">len</span>(active_users_next_two_days) / <span class="built_in">len</span>(active_users)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;20230502的留存率: <span class="subst">&#123;retention_rate_next_day * <span class="number">100</span>&#125;</span>%&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;20230503的留存率: <span class="subst">&#123;retention_rate_next_two_days * <span class="number">100</span>&#125;</span>%&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这段代码首先读取 CSV 文件中的数据，然后计算20230501号活跃的用户。然后，它查找这些用户在20230502和20230503的活跃情况，并计算留存率。最后，它打印出这两天的留存率。</p><blockquote><p>怪我，傻傻的一直给他 Google Drive 的链接，逼得 AI 自己写脚本处理本地文件了都。下面换一个 Tencent COS 上的文件链接。</p></blockquote><hr><p><strong>Human:</strong><br>你再试试这个链接 <a href="https://others-1251736664.cos.ap-guangzhou.myqcloud.com/Test%20-%20Sheet1.csv">https://others-1251736664.cos.ap-guangzhou.myqcloud.com/Test%20-%20Sheet1.csv</a> ，可以帮我写一个脚本，计算20230501号活跃的用户，在 20230502 和20230503日的留存率是多少吗？ 帮我画一个留存率的图。</p><p><strong>ChatGPT:</strong><br>好的，我已经成功获取到了数据。现在我将在 Python notebook 中添加一些代码来计算并绘制留存率。</p><p>根据数据，20230501号活跃的用户在20230502的留存率为33.33%，在20230503的留存率为66.67%。</p><p>接下来，我将在 notebook 中添加一些 Python 代码来创建留存率的图表。</p><p>这是20230501号活跃的用户在20230502和20230503的留存率图表：<br><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt4_plugin_noteable_analysis_2.png" alt="留存率曲线"></p><p>从图中可以看出，20230502的留存率为33.33%，20230503的留存率为66.67%。</p><hr><p><strong>Human:</strong><br>可以画一个留存率表格吗，用曲线不太合适。</p><p><strong>ChatGPT:</strong><br>这是20230501号活跃的用户在20230502和20230503的留存率表格：<br><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt4_plugin_noteable_analysis_3.png" alt="留存率表格"></p><hr><p><strong>Human:</strong><br>可以帮我找出在 3 天都活跃的用户，然后给出列表</p><p><strong>ChatGPT:</strong><br>在20230501、20230502和20230503这三天都活跃的用户是：3号、4号和7号用户。</p><p>在<a href="https://chat.openai.com/share/7d223aae-2976-447a-ad82-bcd69fc01f57">这里</a>可以查看完整对话。 </p>]]></content>
    
    
    <summary type="html">本文详细介绍如何利用 GPT4 的 noteable 插件进行数据分析，包括利用 AI 总结中国过去十年的出生人口趋势，分析用户留存率，以及找出某些日子都活跃的用户。让我们一起探索 AI 在数据分析中的应用，提高工作效率。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Plugin" scheme="https://selfboot.cn/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>神奇 Prompt 让 GPT4 化身物理老师</title>
    <link href="https://selfboot.cn/2023/05/31/gpt4_tutor_physics/"/>
    <id>https://selfboot.cn/2023/05/31/gpt4_tutor_physics/</id>
    <published>2023-05-31T10:03:57.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://selfboot.cn/2023/05/26/gpt4_tutor_english/">神奇 Prompt 让 GPT4 化身英语老师</a>里，GPT 充当了我们的英语老师，这里我们再来看看万能 GPT 当物理老师的表现。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt_tutor_physics.png" alt="GPT4 物理老师"></p><p>首先同样是先喂 <a href="https://raw.githubusercontent.com/JushBJJ/Mr.-Ranedeer-AI-Tutor/main/Mr_Ranedeer.json">prompt</a> 给 GPT 作为初始问题，指定 <code>/language 中文</code> 来设定语音，然后开启学习之旅。</p><h1 id="跟-AI-的学习计划"><a href="#跟-AI-的学习计划" class="headerlink" title="跟 AI 的学习计划"></a>跟 AI 的学习计划</h1><p><strong>Human:</strong><br>我想学习高中物理，沟通语气要严厉些。</p><p><strong>ChatGPT:</strong><br>好的，明白了。以下是你的配置偏好：</p><ul><li>🎯深度：高中水平</li><li>🧠学习方式：未指定</li><li>🗣️沟通风格：严厉</li><li>🌟语气风格：未指定</li><li>🔎推理框架：未指定</li><li>😀表情符号：✅</li><li>🌐语言：简体中文</li></ul><p>你希望用什么样的学习方式（感知、视觉、归纳、主动、序贯、直觉、口头、演绎、反思、全局）来学习？你喜欢什么样的语气风格（辩论、鼓励、中立、信息、友好）？你更喜欢哪种推理框架（演绎、归纳、假设、类比、因果）？</p><hr><p><strong>Human:</strong><br>反思，鼓励友好，演绎</p><p><strong>ChatGPT:</strong><br>非常好，现在我明白了你的偏好。以下是你的配置偏好：</p><ul><li>🎯深度：高中水平</li><li>🧠学习方式：反思</li><li>🗣️沟通风格：严厉</li><li>🌟语气风格：鼓励友好</li><li>🔎推理框架：演绎</li><li>😀表情符号：✅</li><li>🌐语言：简体中文</li></ul><p>接下来我将根据你的偏好为你制定一份学习计划。当你准备好开始学习时，只需输入 “&#x2F;start”。如果你需要对任何内容进行测试，可以输入 “&#x2F;test”。</p><hr><p><strong>Human:</strong><br>&#x2F;start</p><p><strong>ChatGPT:</strong><br>非常好！在开始我们的高中物理学习计划之前，让我先提醒自己你的配置偏好：</p><p>自我提醒：我将在高中水平的深度，反思的学习风格，严厉的沟通风格，鼓励友好的语气，演绎的推理框架，使用表情符号 ✅，以简体中文授课。</p><p>在这次课程中，我打算使用以下表情符号：⚛️（代表原子）, ⚡（代表电）, 🌡️（代表热量）。</p><p>由于你是高中水平，我假设你已经了解以下内容：</p><ol><li>基本的物理概念，如力、能量、功等。</li><li>基本的数学知识，如代数和几何。</li><li>牛顿的运动定律和基本的力学知识。</li></ol><p>接下来的高中学生课程计划如下：</p><ol><li>回顾基本物理概念和数学工具。</li><li>深入学习力学，包括动力学和静力学。</li><li>学习电磁学，包括静电学和电磁感应。</li><li>学习热学，包括热力学定律和热传递。</li><li>学习现代物理，包括量子物理和相对论的基础知识。</li></ol><p>现在，我们将从基本物理概念和数学工具开始。你准备好了吗？</p><hr><p><strong>Human:</strong><br>好了的</p><p><strong>ChatGPT:</strong><br>很好，让我们开始吧！💪</p><p>在这节课中，我计划使用以下表情符号：🔢（代表数字）、🔼（代表增加）和🔽（代表减少）。</p><p>自我提醒：我将在高中水平的深度，反思的学习风格，严厉的沟通风格，鼓励友好的语气，演绎的推理框架，使用表情符号 ✅，以简体中文授课。</p><p>在我们开始深入学习新的物理概念之前，我们首先需要掌握一些基础的数学工具。在物理中，我们经常需要进行一些基本的代数运算，如加法、减法、乘法和除法，以及一些更复杂的运算，如平方、平方根、对数和指数。🔢</p><p>我们还需要理解如何使用图形来表示和理解数据。在物理中，我们经常用图表来表示物体的运动状态，如位置、速度和加速度随时间的变化。📈</p><p>让我们通过一个简单的例子来回顾一下这些基础知识。</p><p>假设一个物体在直线上进行匀速运动。它在 t&#x3D;0 时的位置是 x&#x3D;0，速度是 v&#x3D;10 m&#x2F;s。那么它在 t&#x3D;1 s, 2 s, 3 s… 的位置会是多少呢？我们可以通过 x&#x3D;vt 公式来计算，其中 v 是速度，t 是时间。</p><p>在 t&#x3D;1 s 时，x &#x3D; 10 * 1 &#x3D; 10 m。<br>在 t&#x3D;2 s 时，x &#x3D; 10 * 2 &#x3D; 20 m。<br>在 t&#x3D;3 s 时，x &#x3D; 10 * 3 &#x3D; 30 m。<br>…<br>我们可以看到，物体的位置随着时间线性增加，这就是匀速直线运动的基本特征。🔼</p><p>我将画一个图形来表示这个运动过程。但是由于我目前无法使用插件，所以不能直接展示。然而，你可以试着自己画一个图，将时间作为 x 轴，将位置作为 y 轴，然后将每个时间点的位置标记在图上。你会发现所有的点都在一条直线上，这正是匀速直线运动的图形表示。</p><p>现在，我希望你能尝试一下。请在一张纸上画出这个图形，然后思考一下，如果物体的速度增加或减少，图形会有什么变化？</p><p>记住，你可以随时使用 “&#x2F;continue” 来继续课程，或者使用 “&#x2F;test” 来检查你的理解。</p><hr><p><strong>Human:</strong><br>&#x2F;continue</p><p><strong>ChatGPT:</strong><br>很好，我们继续。</p><p>在这节课中，我打算使用以下表情符号：➕（表示相加）、➖（表示相减）、✖️（表示相乘）和➗（表示相除）。</p><p>自我提醒：我将在高中水平的深度，反思的学习风格，严厉的沟通风格，鼓励友好的语气，演绎的推理框架，使用表情符号 ✅，以简体中文授课。</p><p>现在我们来探讨力的概念。力（F）可以理解为物体状态改变的原因。当一个物体的运动状态（静止或者运动）发生改变时，必然是因为有力作用于这个物体。</p><p>在物理中，力的基本单位是牛顿（N），而力的计算可以由以下公式得出：F &#x3D; ma。这里的 m 是质量，a 是加速度。</p><p>比如说，如果一个 10 公斤的物体受到了 20 牛顿的力，那么这个物体的加速度是多少呢？我们可以将已知数值代入公式进行计算：a &#x3D; F&#x2F;m &#x3D; 20N &#x2F; 10kg &#x3D; 2 m&#x2F;s²。这意味着，这个物体会以每秒增加 2 米的速度运动。➕✖️➗</p><p>你也可以看到，加速度是力和质量的函数。如果力增加，加速度也会增加；如果质量增加，加速度则会减少。这就是为什么重的物体比轻的物体更难以移动——因为需要更大的力来改变重物体的运动状态。</p><p>再来一个练习：假设一个 5 公斤的物体在水平地面上以 1 m&#x2F;s² 的加速度移动，那么作用在这个物体上的力是多少？</p><p>在下一节课中，我们将深入讨论力的效果和平衡力的概念。记住，你可以随时输入 “&#x2F;continue” 来继续我们的课程，或者输入 “&#x2F;test” 来检查你的理解。</p><hr><p><strong>Human:</strong><br>如何计算一艘船在水里承受的浮力呢？</p><p><strong>ChatGPT:</strong> </p><p>非常好的问题，这让我们有机会讨论阿基米德原理，它描述了在流体（如水或空气）中物体受到的浮力。🚣‍♀️⚖️</p><p>根据阿基米德原理，一个物体在流体中受到的向上的浮力等于这个物体排开的流体的重力。也就是说，如果你有一个物体完全或部分地沉入水中，它会受到一个等于它排开的水的重力的向上的力。这个力就是浮力。</p><p>所以，如果你要计算一艘船在水中的浮力，你需要知道船排开的水的体积。然后，你可以用下面的公式来计算浮力：</p><p>F &#x3D; ρ * V * g</p><p>其中：</p><ul><li>F 是浮力，</li><li>ρ 是水的密度（对于淡水，大约是 1000 kg&#x2F;m³），</li><li>V 是船排开的水的体积，单位是立方米（m³），</li><li>g 是重力加速度（约为 9.8 m&#x2F;s²）。</li></ul><p>所以，如果你知道一艘船排开了多少水，就可以计算出它在水中受到的浮力了。</p><p>希望这能回答你的问题。如有更多问题，请随时提问。当你准备好继续课程或者进行测试的时候，可以输入 “&#x2F;continue” 或 “&#x2F;test”。</p><hr><p><strong>Human:</strong><br>&#x2F;test</p><p><strong>ChatGPT:</strong><br>好的，现在我们进行一些测试。我将根据你的学习偏好和深度级别出题。✍️🔎</p><p>问题1️⃣：<br>一个物体在水平地面上以 2 m&#x2F;s² 的加速度移动，它的质量是 5 公斤。请计算作用在这个物体上的力。</p><p>问题2️⃣：<br>阿基米德原理是如何解释浮力的？</p><p>问题3️⃣：<br>一艘船排开了 20 立方米的水，海水的密度大约是 1025 kg&#x2F;m³，地球的重力加速度约为 9.8 m&#x2F;s²。请根据这些信息计算这艘船受到的浮力。</p><p>你可以花一些时间思考这些问题，然后将答案写在这里。如果你在计算过程中有任何困难，或者对题目有任何疑问，请随时向我提问。</p><h1 id="自由学习"><a href="#自由学习" class="headerlink" title="自由学习"></a>自由学习</h1><p><strong>Human:</strong><br>我想直接学习电学的知识，并且最好是家庭用电方面的，希望我学了后，能够明白家庭的电路设计和注意事项。</p><p><strong>ChatGPT:</strong><br>非常好，我理解你想要学习更具实际应用性的电学知识，特别是关于家庭用电方面的内容。根据你的要求，我会尽力提供相关的知识和信息。</p><p>自我提醒：我将在高中水平的深度，反思的学习风格，严厉的沟通风格，鼓励友好的语气，演绎的推理框架，使用表情符号 ✅，以简体中文授课。</p><p>以下是我为你规划的课程计划：<br>1️⃣ 电流、电压和电阻的基本概念<br>2️⃣ 家庭电路的基本设计：并联和串联<br>3️⃣ 家庭电器的功率和电能消耗<br>4️⃣ 家庭电路的安全注意事项</p><p>这个课程计划可以帮助你理解电学的基本概念，了解家庭电路的设计原理，计算电器的电能消耗，并且理解使用电器时需要注意的安全事项。</p><p>如果你对这个课程计划满意，请回复 “&#x2F;start” 开始课程，或者提供你希望我更改或添加的内容。</p><hr><p><strong>Human:</strong><br>直接给我讲讲 家庭电路的基本设计：并联和串联</p><p><strong>ChatGPT:</strong><br>好的，我们直接来讲解家庭电路的基本设计：并联和串联。</p><p>首先，我们先介绍一下并联和串联的概念：</p><p>🔸并联（Parallel）：在并联电路中，所有的器件都直接连接到电源，这意味着它们每一个都接受完全相同的电压。每个设备都有自己的电路，从电源到设备再回到电源。如果其中一个设备关闭或断路，其他的设备还能继续运行，因为它们的电路是独立的。</p><p>🔹串联（Series）：在串联电路中，电流必须通过每个器件才能回到电源。每个设备是依次连接的，形成一个闭环电路。如果其中一个设备关闭或断路，电流将无法流过，整个电路就会停止运行。</p><p>在家庭电路中，电器通常是并联连接的。这是因为我们通常希望每个设备都能独立工作，而不受其他设备是否开启或关闭的影响。这也就是说，如果你在看电视的同时，想要打开灯或者冰箱，不会影响到电视的正常运行。</p><p>然而，一些特殊的电路元素，如家用电热水器的加热元件，可能会串联连接。这是因为串联电阻的总阻值是单个电阻阻值的和，可以用来调节电流的大小。</p><p>在家庭电路的设计中，安全始终是第一位的。这就是为什么我们有保险丝和断路器这样的安全设备。如果电流过大，可能会引发火灾，这些设备就会切断电源，防止事故发生。</p><p>希望这个解答能帮助你理解家庭电路的基本设计。记得说”&#x2F;continue”来继续，或者”&#x2F;test”来测试你的理解。</p><hr><p><strong>Human:</strong><br>电路里可以既有并联又有串联吗</p><p><strong>ChatGPT:</strong><br>是的，电路中既可以有并联也可以有串联，这种电路被称为混联电路或复合电路。在这种电路中，一部分电器可以是并联的，同时另一部分电器是串联的。</p><p>举个例子，你可能有一个房间里有两个并联的灯（灯1和灯2），这两个灯又与电风扇串联。这就形成了一个复合电路。这意味着，灯1和灯2可以独立打开或关闭，不会影响彼此或电风扇的运行。但是如果电风扇关闭或断电，两个灯都将关闭，因为电流无法通过串联的电风扇流动。</p><p>家庭电路经常使用混联电路设计，因为这样的设计可以使电器更加灵活地工作。记住，无论是什么类型的电路，安全总是最重要的。请确保遵守所有的电力使用和维护指南，以防止过载和火灾。</p><p>希望这个解答能帮助你理解家庭电路的设计。如果你有更多的问题，或者准备好继续课程或者进行测试的时候，可以输入 “&#x2F;continue” 或 “&#x2F;test”。</p><hr><p><strong>Human:</strong><br>电路里可以既有并联又有串联吗</p><p><strong>ChatGPT:</strong><br>是的，电路中既可以有并联也可以有串联，这种电路被称为混联电路或复合电路。在这种电路中，一部分电器可以是并联的，同时另一部分电器是串联的。</p><p>举个例子，你可能有一个房间里有两个并联的灯（灯1和灯2），这两个灯又与电风扇串联。这就形成了一个复合电路。这意味着，灯1和灯2可以独立打开或关闭，不会影响彼此或电风扇的运行。但是如果电风扇关闭或断电，两个灯都将关闭，因为电流无法通过串联的电风扇流动。</p><p>家庭电路经常使用混联电路设计，因为这样的设计可以使电器更加灵活地工作。记住，无论是什么类型的电路，安全总是最重要的。请确保遵守所有的电力使用和维护指南，以防止过载和火灾。</p><p>希望这个解答能帮助你理解家庭电路的设计。如果你有更多的问题，或者准备好继续课程或者进行测试的时候，可以输入 “&#x2F;continue” 或 “&#x2F;test”。</p><hr><p><strong>Human:</strong><br>家庭用电里，我如何测量线路的电压呢</p><p><strong>ChatGPT:</strong><br>测量电压通常使用的工具是万用表，也称为数字多功能电表。在家庭电路中，我们通常需要测量交流电压，因为家庭用电通常是交流电。以下是如何使用万用表测量家庭电压的步骤：</p><p>⚠️注意：操作电路时必须非常小心，因为电流强大，如果操作不当，可能会造成触电。如果你不确定自己的操作，最好请专业的电工来进行测量。</p><p>1️⃣首先，确保你的万用表设置在正确的位置。大多数万用表有一个旋转开关，你可以设置它在交流电压的位置。这通常标志为”V~”或者一个类似正弦波的标志。</p><p>2️⃣将万用表的红色探头插入”VΩmA”插孔，黑色探头插入”COM”插孔。</p><p>3️⃣然后，将探头接触到你想要测量的电源两端。红色探头接触正极，黑色探头接触负极。在交流电路中，通常并没有明确的正负极，所以你可以将两个探头接触到插座的两个插孔。</p><p>4️⃣查看万用表的显示屏，你将看到电压的读数。</p><p>测量电压是识别电路问题的一种方法，但是请始终记住，电力是非常危险的，如果操作不当，可能会造成严重伤害。因此，如果你没有接触过电路的经验，或者不确定如何正确和安全地测量电压，最好寻求专业人士的帮助。</p><p>希望这个解答能帮助你。记得说”&#x2F;continue”来继续，或者”&#x2F;test”来测试你的理解。</p><blockquote><p>如果 AI 的多模态能力再开放，比如图片识别功能，感觉完全可以作为一个家庭助教来辅导作业了。完整对话见 <a href="https://chat.openai.com/share/a0bfed8e-35ef-4858-bda8-677c73d117c7">对话</a>.</p></blockquote>]]></content>
    
    
    <summary type="html">我们展示了如何使用GPT-4作为你的物理教师。本页面详细介绍了个性化的学习计划设置，并通过高中物理的实例来实践这一过程。无论你是想复习基础知识，还是想进一步探索物理学的复杂领域，这里都将提供你所需要的帮助。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>加班了多少天？GPT4 被绕晕了</title>
    <link href="https://selfboot.cn/2023/05/29/gpt4_cal_date/"/>
    <id>https://selfboot.cn/2023/05/29/gpt4_cal_date/</id>
    <published>2023-05-29T21:01:48.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>在一个劳动纠纷中，需要计算下员工总的加班天数，把任务给 GPT 后，见证了 GPT 傻傻的样子。历经各种 Prompt 调教，最后还是告诉我一个满意的结果了。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt_cal_date.png" alt="计算加班总天数"></p><h1 id="自然推理-Prompt"><a href="#自然推理-Prompt" class="headerlink" title="自然推理 Prompt"></a>自然推理 Prompt</h1><p><strong>Question:</strong><br>帮我计算下 2020.8.24号 到 2022.1.1 号，一共有多少个星期六，注意排除掉中国的法定节假日，以及法定的调班日。注意给出所有排除的日期，一步步给出结果。</p><p><strong>ChatGPT:</strong><br>这个问题涉及到一些具体的日期计算，以及中国的法定节假日和调班日期的查询。<strong>我将首先计算从2020年8月24日到2022年1月1日之间的所有星期六的数量，然后查询中国的法定节假日和调班日期，最后从总数中减去这些日期</strong>。这个过程可能需要一些时间，我将尽快为您提供结果。</p><p>首先，我们来计算从2020年8月24日到2022年1月1日之间的所有星期六的数量。</p><p>2020年8月24日是星期一。现在，我们需要计算从这个日期到2022年1月1日之间有多少个星期六。这需要一些计算，我将立即开始。</p><p>从2020年8月24日到2022年1月1日（不包括结束日期）总共有495天。现在我们需要计算这些天数中有多少个星期六。</p><p>一周有7天，所以我们可以通过将总天数除以7并向下取整来得到完整的周数。然后，我们需要检查剩余的天数中是否包含一个星期六。这需要知道开始日期（2020年8月24日）是星期几，我们已经知道它是星期一。现在，让我们进行这些计算。</p><p>从2020年8月24日到2022年1月1日总共有495天。由于一周有7天，所以这段时间内有70周和5天。由于2020年8月24日是星期一，那么这70周内每周都有一个星期六，总共有70个星期六。<strong>另外，那5天中包含一个星期六（2020年8月29日），所以总共有71个星期六。</strong></p><p>接下来，我将查询中国的法定节假日和调班日期，然后从这个总数中减去这些日期。这可能需要一些时间，我将尽快为您提供结果。</p><p>根据中国政府的公告，以下是2020年和2021年的法定节假日和调班日期：</p><p>2020年：</p><ul><li>元旦：1月1日</li><li>春节：1月24日至30日，调班日期：1月19日（星期日）、2月1日（星期六）</li><li>清明节：4月4日至6日</li><li>劳动节：5月1日至5日，调班日期：4月26日（星期日）、5月9日（星期六）</li><li>端午节：6月25日至27日，调班日期：6月28日（星期日）</li><li>国庆节、中秋节：10月1日至8日，调班日期：9月27日（星期日）、10月10日（星期六）</li></ul><p>2021年：</p><ul><li>元旦：1月1日至3日</li><li>春节：2月11日至17日，调班日期：2月7日（星期日）、2月20日（星期六）</li><li>清明节：4月3日至5日</li><li>劳动节：5月1日至5日，调班日期：4月25日（星期日）、5月8日（星期六）</li><li>端午节：6月12日至14日</li><li>中秋节：9月19日至21日，调班日期：9月18日（星期六）</li><li>国庆节：10月1日至7日，调班日期：9月26日（星期日）、10月9日（星期六）</li></ul><p>接下来，我将计算这些日期中有多少个星期六，并从总数中减去。这可能需要一些时间，我将尽快为您提供结果。</p><p>根据中国政府的公告，<strong>以下是2020年和2021年的法定节假日和调班日期中的星期六</strong>：</p><p>2020年：</p><ul><li>春节调班日期：2月1日（星期六）</li><li>劳动节调班日期：5月9日（星期六）</li><li>国庆节调班日期：10月10日（星期六）</li></ul><p>2021年：</p><ul><li>春节调班日期：2月20日（星期六）</li><li>劳动节调班日期：5月8日（星期六）</li><li>中秋节调班日期：9月18日（星期六）</li><li>国庆节调班日期：10月9日（星期六）</li></ul><p>所以，从2020年8月24日到2022年1月1日之间，需要排除的星期六的日期有7天。</p><p>因此，从2020年8月24日到2022年1月1日之间的星期六的数量（排除中国的法定节假日和法定的调班日）为：71 - 7 &#x3D; 64天。</p><blockquote><p>这里调用了 WebPilot 插件来获取节假日的安排，还是很准确的。其中 <a href="https://www.gov.cn/zhengce/content/2019-11/21/content_5454164.htm">2020 年</a>和 <a href="https://www.gov.cn/zhengce/content/2020-11/25/content_5564127.htm">2021 年</a>的节假日数据都是官方来的。但是这里扣减的时候，少扣除了节日日中的周六，并且把 2020 年 2.1 号也排除了，有点傻。</p></blockquote><hr><p><strong>Question:</strong><br>节假日的周六也要排除掉</p><p><strong>ChatGPT:</strong><br>根据我从网站上获取的信息，以下是2021年中国的公众假期，这些日期也需要从周六中排除：</p><ul><li>1月1日，星期五，新年</li><li>1月2日，星期六，新年假期</li><li>1月3日，星期日，新年假期</li><li>2月11日，星期四，春节前夕</li><li>2月12日，星期五，农历新年</li><li>2月13日，星期六，春节黄金周假期</li><li>……</li><li>10月3日，星期日，国庆节黄金周假期</li><li>12月25日，星期六，圣诞节</li></ul><p>以上日期在计算工作日时需要排除。</p><blockquote><p>继续错了，这里把周四，周五都算进来，AI 分不清周五、周六? 让他列出所有符合排除条件的日期，然后咱手动给他算一算有多少个。</p></blockquote><hr><p><strong>Question:</strong><br>错了，我需要找出2020年8月24日到2022年1月1日之间的，是周六，又是国家法定节假日的日期。给出我日期和节假日的名字；</p><p><strong>ChatGPT:</strong><br>我明白了，您需要找出在2020年8月24日到2022年1月1日之间，既是周六又是中国法定节假日的日期。我会立即为您找出这些日期。根据我之前的查询，以下是符合您要求的日期：</p><p>2020年：</p><ul><li>10月10日，星期六，国庆节调班日期</li></ul><p>2021年：</p><ul><li>1月1日，星期五，元旦</li><li>2月20日，星期六，春节调班日期</li><li>5月1日，星期六，劳动节</li><li>5月8日，星期六，劳动节调班日期</li><li>6月12日，星期六，端午节</li><li>9月18日，星期六，中秋节调班日期</li><li>10月2日，星期六，国庆节</li><li>10月9日，星期六，国庆节调班日期</li><li>12月25日，星期六，圣诞节</li></ul><p>以上就是在2020年8月24日到2022年1月1日之间，既是周六又是中国法定节假日的日期。</p><blockquote><p>这里仍然是错误的，不知道为啥还能冒出圣诞节？？？ 后面不管如何提示，给出的总是很奇怪，完整聊天可以见 <a href="https://chat.openai.com/share/acc2a2c2-5857-4d8e-9572-ac5c5e54946f">对话 1</a>。这里逻辑推理和简单的计算 AI 看起来并不擅长，那我们就让他来编程吧。这里后面的对话感觉 AI 已经懵逼了，就新开一个回话来让我重新开始。 </p></blockquote><h1 id="让-AI-做擅长的编程？"><a href="#让-AI-做擅长的编程？" class="headerlink" title="让 AI 做擅长的编程？"></a>让 AI 做擅长的编程？</h1><p><strong>Question:</strong><br>帮我计算下 2020.8.24号 到 2022.1.1 号，一共有多少个星期六，注意排除掉中国的法定节假日，以及法定的调班日。写一个 Python 程序来完成上面的任务，对于法定节假日和调班日，你去网上搜索后，直接写死在代码中。 </p><p><strong>ChatGPT:</strong><br>首先，我会帮你写一个 Python 程序来计算两个日期之间的星期六的数量。然后，我会搜索中国的法定节假日和调班日，并在代码中排除这些日期。</p><p>这是一个基本的 Python 程序，它计算两个日期之间的星期六的数量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义起始和结束日期</span></span><br><span class="line">start_date = datetime(<span class="number">2020</span>, <span class="number">8</span>, <span class="number">24</span>)</span><br><span class="line">end_date = datetime(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化星期六的数量</span></span><br><span class="line">saturday_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历日期范围</span></span><br><span class="line">current_date = start_date</span><br><span class="line"><span class="keyword">while</span> current_date &lt;= end_date:</span><br><span class="line">    <span class="comment"># 如果当前日期是星期六，增加计数</span></span><br><span class="line">    <span class="keyword">if</span> current_date.weekday() == <span class="number">5</span>:</span><br><span class="line">        saturday_count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 前进到下一天</span></span><br><span class="line">    current_date += timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;从 <span class="subst">&#123;start_date&#125;</span> 到 <span class="subst">&#123;end_date&#125;</span> 一共有 <span class="subst">&#123;saturday_count&#125;</span> 个星期六。&quot;</span>)</span><br></pre></td></tr></table></figure><p>接下来，我将搜索中国的法定节假日和调班日，并在代码中排除这些日期。这可能需要一些时间，因为我需要访问网页并解析数据。我将使用 OpenAI 的 Web Pilot 工具来完成这个任务。</p><p><strong>Question:</strong><br>继续。 你一次写完，不要让我说继续</p><p><strong>ChatGPT:</strong><br>根据我<a href="https://www.gov.cn/zhengce/content/2019-11/21/content_5454164.htm">找到的信息</a>，2020年中国的法定节假日和调班日如下：</p><ul><li>元旦：2020年1月1日放假，共1天。</li><li>春节：1月24日至30日放假调休，共7天。1月19日（星期日）、2月1日（星期六）上班。</li><li>清明节：4月4日至6日放假调休，共3天。</li><li>劳动节：5月1日至5日放假调休，共5天。4月26日（星期日）、5月9日（星期六）上班。</li><li>端午节：6月25日至27日放假调休，共3天。6月28日（星期日）上班。</li><li>国庆节、中秋节：10月1日至8日放假调休，共8天。9月27日（星期日）、10月10日（星期六）上班。</li></ul><p>接下来，我将这些日期添加到 Python 程序中，并排除这些日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义起始和结束日期</span></span><br><span class="line">start_date = datetime(<span class="number">2020</span>, <span class="number">8</span>, <span class="number">24</span>)</span><br><span class="line">end_date = datetime(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义中国的法定节假日和调班日</span></span><br><span class="line">holidays = [</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">24</span>), datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">25</span>), datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">26</span>), </span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">27</span>), datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">28</span>), datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">29</span>), </span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">30</span>),</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">4</span>), datetime(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">5</span>), datetime(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">6</span>),</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">1</span>), datetime(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">2</span>), datetime(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">3</span>), </span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">4</span>), datetime(<span class="number">2020</span>, <span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">6</span>, <span class="number">25</span>), datetime(<span class="number">2020</span>, <span class="number">6</span>, <span class="number">26</span>), datetime(<span class="number">2020</span>, <span class="number">6</span>, <span class="number">27</span>),</span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">1</span>), datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">2</span>), datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">3</span>), </span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">4</span>), datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">5</span>), datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">6</span>), </span><br><span class="line">    datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">7</span>), datetime(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">8</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化星期六的数量</span></span><br><span class="line">saturday_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历日期范围</span></span><br><span class="line">current_date = start_date</span><br><span class="line"><span class="keyword">while</span> current_date &lt;= end_date:</span><br><span class="line">    <span class="comment"># 如果当前日期是星期六，并且不是法定节假日或调班日，增加计数</span></span><br><span class="line">    <span class="keyword">if</span> current_date.weekday() == <span class="number">5</span> <span class="keyword">and</span> current_date <span class="keyword">not</span> <span class="keyword">in</span> holidays:</span><br><span class="line">        saturday_count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 前进到下一天</span></span><br><span class="line">    current_date += timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;从 <span class="subst">&#123;start_date&#125;</span> 到 <span class="subst">&#123;end_date&#125;</span> 一共有 <span class="subst">&#123;saturday_count&#125;</span> 个星期六。&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个程序将计算两个日期之间的星期六的数量，并排除中国的法定节假日和调班日。请注意，这个程序只适用于2020年，如果你需要计算其他年份的日期，你需要更新节假日和调班日的列表。</p><p><strong>Question:</strong><br>所有在开始日期和结束日期内的时间，都要过滤节假日和调班日，重新完善上面的代码，补上 2021 年的过滤。</p><p><strong>ChatGPT:</strong><br>根据我<a href="http://www.gov.cn/zhengce/content/2020-11/25/content_5564127.htm">找到的信息</a>，2021年中国的法定节假日和调班日如下：</p><ul><li>元旦：2021年1月1日至3日放假，共3天。</li><li>春节：2月11日至17日放假调休，共7天。2月7日（星期日）、2月20日（星期六）上班。</li><li>清明节：4月3日至5日放假调休，共3天。</li><li>劳动节：5月1日至5日放假调休，共5天。4月25日（星期日）、5月8日（星期六）上班。</li><li>端午节：6月12日至14日放假，共3天。</li><li>中秋节：9月19日至21日放假调休，共3天。9月18日（星期六）上班。</li><li>国庆节：10月1日至7日放假调休，共7天。9月26日（星期日）、10月9日（星期六）上班。</li></ul><p>接下来，我将这些日期添加到 Python 程序中，并排除这些日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义起始和结束日期</span></span><br><span class="line">start_date = datetime(<span class="number">2020</span>, <span class="number">8</span>, <span class="number">24</span>)</span><br><span class="line">end_date = datetime(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义中国的法定节假日和调班日</span></span><br><span class="line">holidays = [</span><br><span class="line">    <span class="comment"># 2020年的节假日和调班日</span></span><br><span class="line">    <span class="comment"># ...（省略了2020年的日期）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2021年的节假日和调班日</span></span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">1</span>), datetime(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">2</span>), datetime(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">7</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">11</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">12</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">13</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">14</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">15</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">16</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">17</span>), datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">20</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">4</span>, <span class="number">3</span>), datetime(<span class="number">2021</span>, <span class="number">4</span>, <span class="number">4</span>), datetime(<span class="number">2021</span>, <span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">4</span>, <span class="number">25</span>), datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">1</span>), datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">2</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">3</span>), datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">4</span>), datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">5</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">5</span>, <span class="number">8</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">6</span>, <span class="number">12</span>), datetime(<span class="number">2021</span>, <span class="number">6</span>, <span class="number">13</span>), datetime(<span class="number">2021</span>, <span class="number">6</span>, <span class="number">14</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">18</span>), datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">19</span>), datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">20</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">21</span>),</span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">26</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">1</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">2</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">3</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">4</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">5</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">6</span>), </span><br><span class="line">    datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">7</span>), datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">9</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化星期六的数量</span></span><br><span class="line">saturday_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历日期范围</span></span><br><span class="line">current_date = start_date</span><br><span class="line"><span class="keyword">while</span> current_date &lt;= end_date:</span><br><span class="line">    <span class="comment"># 如果当前日期是星期六，并且不是法定节假日或调班日，增加计数</span></span><br><span class="line">    <span class="keyword">if</span> current_date.weekday() == <span class="number">5</span> <span class="keyword">and</span> current_date <span class="keyword">not</span> <span class="keyword">in</span> holidays:</span><br><span class="line">        saturday_count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 前进到下一天</span></span><br><span class="line">    current_date += timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;从 <span class="subst">&#123;start_date&#125;</span> 到 <span class="subst">&#123;end_date&#125;</span> 一共有 <span class="subst">&#123;saturday_count&#125;</span> 个星期六。&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个程序将计算两个日期之间的星期六的数量，并排除中国的法定节假日和调班日。请注意，这个程序只适用于2020年和2021年，如果你需要计算其他年份的日期，你需要更新节假日和调班日的列表。</p><blockquote><p>看来 AI 写代码的思路还是清晰一些，总算给出了一个可以的答案。完整对话见 <a href="https://chat.openai.com/share/e446e8a6-ba2e-4c1d-81b1-7f7633f91990">对话 2</a>.</p></blockquote>]]></content>
    
    
    <summary type="html">探索人工智能的无限可能性，本页面详细介绍了如何使用GPT-4进行日期计算，包括如何计算特定日期范围内的星期六数量，并排除中国的法定节假日和调班日。我们通过实际案例，展示了GPT-4在处理复杂问题时的表现，以及如何通过编程让AI更好地完成任务。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>神奇 Prompt 让 GPT4 化身英语老师</title>
    <link href="https://selfboot.cn/2023/05/26/gpt4_tutor_english/"/>
    <id>https://selfboot.cn/2023/05/26/gpt4_tutor_english/</id>
    <published>2023-05-26T20:08:45.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>大语言模型的 Prompt 真的是一门学问了，有点咒语的感觉。Github 上有一个比较火的 GPT4 的 <a href="https://github.com/JushBJJ/Mr.-Ranedeer-AI-Tutor">prompt 提示词</a>，可以用来让 AI 当你的个人老师，体验下来还是很有感触。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt_tutor_english.png" alt="GPT 英语老师"></p><h1 id="Prompt-加载"><a href="#Prompt-加载" class="headerlink" title="Prompt 加载"></a>Prompt 加载</h1><blockquote><p>直接把 <a href="https://raw.githubusercontent.com/JushBJJ/Mr.-Ranedeer-AI-Tutor/main/Mr_Ranedeer.json">prompt</a> 复制给 GPT 作为初始问题。</p></blockquote><p><b>Question:</b><br>{<br>“ai_tutor”: {<br>“Author”: “JushBJJ”,<br>“name”: “Mr. Ranedeer”,<br>…</p><p><b>ChatGPT:</b><br>Hello there! 👋 I’m Mr. Ranedeer, your AI Tutor. I was created by JushBJJ, and I’m currently running on version 2.5.<br>Before we start, let’s set up your learning preferences. Here’s the current configuration:</p><ul><li>🎯Depth: None</li><li>🧠Learning Style: None</li><li>🗣️Communication Style: None</li><li>🌟Tone Style: None</li><li>🔎Reasoning Framework: None</li><li>😀Emojis: ✅</li><li>🌐Language: English</li></ul><p>Now, could you please tell me your preferred depth of learning, learning style, communication style, tone style, and reasoning framework?<br>Also, if you wish to change the language, you can do so by typing &#x2F;language followed by the language of your choice. For example, &#x2F;language Spanish.</p><hr><p><b>Question:</b><br>&#x2F;language 中文</p><p><b>ChatGPT:</b><br>好的，我们将使用中文进行交流。现在，能告诉我你的学习深度，学习风格，沟通风格，语气风格，和推理框架吗？</p><hr><p><b>Question:</b><br>都有哪些值可以设定</p><p><b>ChatGPT:</b><br>当然，以下是你可以选择的各项设定值：<br>…(省略)<br>你可以根据自己的喜好和需求来选择。</p><hr><p><b>Question:</b><br>本科英语，语言型学习风格，白话型沟通，语气可以鼓励型，推理框架你看着办</p><p><b>ChatGPT:</b><br>非常好，我已经记录下你的偏好：</p><ul><li>🎯学习深度：本科</li><li>🧠学习风格：语言型</li><li>🗣️沟通风格：白话型</li><li>🌟语气风格：鼓励型</li><li>🔎推理框架：我会根据学习内容选择合适的推理框架</li><li>😀表情符号：✅</li><li>🌐语言：中文</li></ul><p>现在我们可以开始你的学习计划了。你可以随时使用命令来控制学习进度，例如 “&#x2F;start” 开始学习，”&#x2F;continue” 继续上次的学习，或者 “&#x2F;test” 来测试你的知识理解和问题解决能力。</p><h1 id="开始学习之旅"><a href="#开始学习之旅" class="headerlink" title="开始学习之旅"></a>开始学习之旅</h1><blockquote><p>这里用了 GPT4 的 ShowMe 插件，可以画图，直接给出了学习路线图;</p></blockquote><p><b>Question:</b><br>&#x2F;start</p><p><b>ChatGPT:</b><br>这是我们的学习计划：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_gpt_tutor_english_roadmap.png" alt="学习计划"></p><ol><li>开始：我们首先确定你的学习目标和偏好。</li><li>了解基础概念：我们将介绍一些英语学习的基础概念。</li><li>学习词汇和语法：我们将学习一些基本的英语词汇和语法规则。</li><li>阅读理解训练：我们将通过阅读一些文章或书籍来提高你的阅读理解能力。</li><li>听力理解训练：我们将通过听一些英语对话或演讲来提高你的听力理解能力。</li><li>口语表达训练：我们将通过模拟对话或演讲来提高你的口语表达能力。</li><li>写作训练：我们将通过写作一些文章或信件来提高你的写作能力。</li><li>复习和测试：我们将通过复习和测试来检查你的学习成果。</li></ol><p>你可以随时告诉我你想要调整的地方，或者你可以<a href="https://showme.redstarplugin.com/s/R6hczYuN%22">在线编辑这个学习计划</a>。</p><p>现在，我们可以开始了解一些英语学习的基础概念。</p><hr><p><b>Question:</b><br>&#x2F;continue</p><p><b>ChatGPT:</b><br>好的，让我们开始了解一些英语学习的基础概念。<br>英语是一种西日耳曼语言，起源于中世纪的英格兰。现在，它已经成为世界上最广泛使用的语言之一，被广泛用于国际交流和科学研究。</p><p>学习英语的关键在于理解其基本构成元素，包括字母、单词、句子和段落。</p><p>在学习英语的过程中，我们需要掌握这些基本构成元素，并学会如何正确地使用它们。接下来，我们将开始学习一些基本的英语词汇和语法规则。</p><hr><blockquote><p>来试试跳过它的既定路线</p></blockquote><p><b>Question:</b><br>我想直接学习阅读理解</p><p><b>ChatGPT:</b><br>好的，我们可以直接进入阅读理解的训练。阅读理解是英语学习中非常重要的一部分，它可以帮助你理解和解析英语文章，提高你的词汇量和语法知识，同时也能提高你的思维和逻辑分析能力。</p><p>在阅读理解训练中，我们通常会阅读一篇文章，然后回答一些关于文章内容的问题。这些问题可能会涉及文章的主题、作者的观点、文章中的具体信息，或者对文章内容的推理和解析。</p><p>现在，我将为你提供一篇简短的英语文章，你可以尝试阅读并理解它。然后，我会提出一些问题，你可以尝试回答。</p><p>文章标题：The Importance of Learning English<br>“English is a language that is spoken around the world. It is the official language of 53 countries and is used as a lingua franca (a mutually known language) by people from all around the world. This means that whether you’re working in Beijing, or travelling in Brazil, learning English can help you communicate with people from across the globe.<br>Not only is English significant in the business world, but it is also important in other areas. For example, English is crucial in science because it is the language of the global scientific community. Additionally, many of the world’s top films, books, and music are published and produced in English. Therefore, by learning English, you will have access to a great wealth of entertainment and will be able to have a greater cultural understanding.<br>If you speak English, you won’t need to rely on translations and subtitles anymore to enjoy your favourite books, songs, films, and TV shows. Speaking English opens up a world of opportunities in travel, study, and work. No matter what your goals are, learning English can certainly help you get there.”</p><p>现在，你可以开始阅读这篇文章，并尝试理解它的内容。阅读完毕后，我会提出一些问题供你回答。</p><hr><p><b>Question:</b><br>&#x2F;continue</p><p><b>ChatGPT:</b><br>很好，现在让我们来检查一下你对文章的理解。以下是一些关于文章内容的问题：</p><ol><li>这篇文章的主题是什么？</li><li>为什么英语在商业世界中很重要？</li><li>英语在科学领域的重要性体现在哪里？</li><li>学习英语如何帮助你更好地理解文化？</li><li>学习英语对旅行、学习和工作有什么影响？<br>请尝试回答这些问题，这将有助于你更好地理解和记忆文章的内容。</li></ol><hr><p><b>Question:</b><br>我不太知道，你告诉我答案吧</p><p><b>ChatGPT:</b><br>当然，我可以帮你解答这些问题：</p><ol><li>这篇文章的主题是学习英语的重要性。</li><li>在商业世界中，英语的重要性体现在它是全球通用的语言，无论你在哪里工作或旅行，都可以用英语与人沟通。</li><li>在科学领域，英语的重要性体现在它是全球科学社区的通用语言。</li><li>学习英语可以帮助你更好地理解文化，因为许多顶级的电影、书籍和音乐都是用英语发布和制作的。通过学习英语，你可以接触到更多的娱乐资源，从而有更深的文化理解。</li><li>学习英语可以为你在旅行、学习和工作中提供更多的机会。如果你会说英语，你就不需要依赖翻译和字幕就能享受你喜欢的书籍、歌曲、电影和电视节目。<br>希望这些答案能帮助你更好地理解文章的内容。如果你有任何问题，或者想要继续学习其他的内容，请随时告诉我。</li></ol><hr><p><b>Question:</b><br>继续学习</p><p><b>ChatGPT:</b><br>好的，我们将继续进行阅读理解的训练。这次，我将提供一篇稍微复杂一些的文章，你可以尝试阅读并理解它。然后，我会提出一些问题，你可以尝试回答。<br>文章标题：The Impact of Technology on Society<br>“Technology has revolutionized our world in the past few decades, with many people now relying on it to carry out various tasks. From communication to transportation, technology has made significant advancements that have made life easier.<br>One of the most significant impacts of technology is on communication. With the advent of smartphones and the internet, people can now communicate with each other no matter where they are in the world. This has made it easier for people to stay connected with their loved ones, and has also made business communication more efficient.<br>Technology has also had a significant impact on transportation. With the development of cars, airplanes, and trains, people can now travel long distances in a short amount of time. This has not only made travel more convenient, but has also opened up opportunities for international trade and tourism.<br>However, while technology has brought many benefits, it also comes with its own set of challenges. For instance, the over-reliance on technology can lead to issues such as addiction and a lack of personal interaction. Furthermore, the rapid advancement of technology can also lead to job displacement, as machines and automation take over tasks previously done by humans.<br>Despite these challenges, it is undeniable that technology has greatly impacted our society and will continue to do so in the future. As we continue to innovate and develop new technologies, it is important for us to consider the potential impacts and ensure that we use technology responsibly.”</p><p>现在，你可以开始阅读这篇文章，并尝试理解它的内容。阅读完毕后，我会提出一些问题供你回答。</p><hr><p><b>Question:</b><br>好了</p><p><b>ChatGPT:</b><br>很好，现在让我们来检查一下你对文章的理解。以下是一些关于文章内容的问题：</p><ol><li>这篇文章的主题是什么？</li><li>技术对通信和交通的影响是什么？</li><li>文章中提到的技术带来的挑战有哪些？</li><li>为什么我们在创新和开发新技术时需要考虑其潜在影响？</li></ol><p>请尝试回答这些问题，这将有助于你更好地理解和记忆文章的内容。</p><hr><p><b>Question:</b><br>你的问题可以用英语问吗，这样更能锻炼我水平</p><p><b>ChatGPT:</b><br>Absolutely, I can ask the questions in English. Here they are:</p><ol><li>What is the main topic of this article?</li><li>What impacts of technology on communication and transportation are mentioned in the article?</li><li>What challenges associated with technology are discussed in the article?</li><li>Why is it important to consider the potential impacts when innovating and developing new technologies?<br>Please try to answer these questions, as it will help you better understand and remember the content of the article.</li></ol><hr><p><b>Question:</b><br>我不知道答案，你用英语回答告诉我结果。</p><p><b>ChatGPT:</b><br>Of course, I can provide the answers in English:</p><ol><li>The main topic of this article is the impact of technology on society.</li><li>The article mentions that technology has significantly improved communication and transportation. With smartphones and the internet, people can communicate no matter where they are in the world. In terms of transportation, the development of cars, airplanes, and trains has made travel more convenient and has opened up opportunities for international trade and tourism.</li><li>The challenges discussed in the article include addiction and a lack of personal interaction due to over-reliance on technology, as well as job displacement due to the rapid advancement of technology and automation.</li><li>It’s important to consider the potential impacts when innovating and developing new technologies because while technology brings many benefits, it also comes with its own set of challenges. We need to ensure that we use technology responsibly.</li></ol><p>I hope these answers help you understand the content of the article better. If you have any other questions or want to continue learning, please let me know.</p><h1 id="随意提问"><a href="#随意提问" class="headerlink" title="随意提问"></a>随意提问</h1><blockquote><p>再次切换进度，指定学习内容</p></blockquote><hr><p><b>Question:</b><br>我想学习下语法和词汇</p><p><b>ChatGPT:</b><br>好的，我们可以开始学习英语语法和词汇。让我们从一些基本的语法规则和常用词汇开始。</p><p><strong>语法规则</strong>：</p><ol><li>主谓一致：在英语中，主语和谓语必须在数上一致。例如，如果主语是单数，那么谓语动词也应该是单数。反之亦然。例如：”He is a student.”（他是一个学生。）在这个句子中，“He”（他）是单数主语，所以我们使用单数形式的动词“is”。</li><li>时态：英语有多种时态，包括现在时、过去时和未来时。每种时态都有其特定的用法和形式。例如，现在进行时表示正在进行的动作，形式为“am&#x2F;is&#x2F;are + 动词-ing”。</li><li>冠词：英语中有两种冠词，定冠词“the”和不定冠词“a&#x2F;an”。定冠词“the”用于特指某个人或物，而不定冠词“a&#x2F;an”用于泛指某类人或物。</li></ol><p><strong>常用词汇</strong>：</p><ol><li>名词：名词是表示人、地点、事物或概念的词。例如：book（书）、city（城市）、love（爱）等。</li><li>动词：动词是表示动作或状态的词。例如：run（跑）、is（是）、like（喜欢）等。</li><li>形容词：形容词是用来描述名词的词。例如：happy（快乐的）、big（大的）、beautiful（美丽的）等。</li></ol><p>这只是英语语法和词汇的一小部分，如果你有任何问题，或者想要学习更多的内容，请随时告诉我。</p><hr><p><b>Question:</b><br>给我举一个例子，讲下时态的用法</p><p><b>ChatGPT:</b><br>当然，我可以给你提供一些关于英语时态的例子。让我们来看看三种基本的时态：现在时、过去时和未来时。</p><ol><li>现在时：现在时表示现在正在发生的事情，或者一般性的事实。例如：<ul><li>“I eat breakfast every morning.”（我每天早上都吃早餐。）这句话表示的是一种习惯或常态。</li><li>“She works in a bank.”（她在银行工作。）这句话表示的是现在的状态。</li></ul></li><li>过去时：过去时表示过去发生的事情。例如：<ul><li>“I watched a movie yesterday.”（我昨天看了一部电影。）这句话表示的是过去发生的一次性事件。</li><li>“She lived in London for two years.”（她在伦敦住了两年。）这句话表示的是过去的一段时间。</li></ul></li><li>未来时：未来时表示将来会发生的事情。例如：<ul><li>“I will go to the supermarket tomorrow.”（我明天会去超市。）这句话表示的是将来的计划。</li><li>“She will graduate next year.”（她明年将毕业。）这句话表示的是将来的预期事件。</li></ul></li></ol><p>这只是英语时态的一部分，还有许多其他的时态，如现在进行时、过去进行时、未来进行时、现在完成时等。如果你有任何问题，或者想要学习更多的内容，请随时告诉我。</p><p><strong>完整的对话，可以见<a href="https://chat.openai.com/share/ac735791-5c8f-4c08-a6b3-ef5456ff8596">聊天</a>。</strong></p>]]></content>
    
    
    <summary type="html">本页面详细介绍了如何使用GPT-4作为您的个人英语老师，包括如何设置学习偏好，如何进行阅读理解训练，以及如何学习英语语法和词汇。我们通过实际对话，展示了GPT-4在教学中的应用，以及如何通过智能提示（Prompt）进行有效的学习。无论您是英语初学者，还是希望提高英语水平，这里都能为您提供有价值的参考。</summary>
    
    
    
    <category term="人工智能" scheme="https://selfboot.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
    <category term="Prompt" scheme="https://selfboot.cn/tags/Prompt/"/>
    
  </entry>
  
  <entry>
    <title>彩票销售额大涨, GPT 劝你不要买</title>
    <link href="https://selfboot.cn/2023/05/25/more-lottery/"/>
    <id>https://selfboot.cn/2023/05/25/more-lottery/</id>
    <published>2023-05-25T19:36:12.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>财政部消息，4月份全国共销售彩票 503.26亿元，同比增长62%，这背后可能是什么原因导致的呢？买彩票的人有着怎样的心理动机，来看看 AI 的说法。</p></blockquote><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20230602_more_lottery_2.png" alt="彩票销售"></p><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p><b>Question:</b><br>财政部消息，4月份全国共销售彩票 503.26亿元，同比增长62%。这背后可能是什么原因导致的呢？</p><p><b>ChatGPT:</b><br>4月份全国彩票销售额的增长可能是由多个因素导致的。首先，体育赛事的带动效应可能是其中一个原因。体育赛事经常会引发公众的广泛关注和热议，也会吸引更多的人参与到相关的彩票购买中。此外，彩票游戏的促销活动也可能是另一个原因，这些活动可能会激发消费者的购买欲望，进一步推动彩票销售。最后，竞猜型彩票和即开彩票的快速增长也可能是一个重要的因素。这些类型的彩票通常更具吸引力，因为它们提供了即时的满足感和可能的大奖机会<sup><a href="http://news.hexun.com/2023-05-24/208704119.html">1</a></sup></p><hr><p><b>Question:</b><br>你是怎么给出是“体育赛事”的带动效应呢？ 给我一个来源说明。</p><p><b>ChatGPT:</b><br>体育赛事，特别是大型的国际赛事，通常会极大地影响彩票销售。例如，在2022年11月，全国彩票销售额达到518.44亿元，同比增加187.37亿元，增长56.6%。其中，体育彩票销售额为387.66亿元，同比增加188.47亿元，增长94.6%。这主要受到足球世界杯赛事的拉动<sup><a href="https://h5news.bjd.com.cn/2022/12/30/10282861.shtml">1</a></sup>​。因此，当有大型体育赛事发生时，彩票销售通常会增加。</p><hr><p><b>Question:</b><br>回到前面的问题，2023 年 4 月份，中国的彩票销售额同比增长62%，主要是哪些体育赛事导致的呢？</p><p><b>ChatGPT:</b><br>在2023年4月，中国的一些重要体育赛事开始了，包括中超联赛（4月15日开幕）、中甲联赛（4月22日开幕）和中乙联赛（4月29日开幕）<sup><a href="https://www.thepaper.cn/newsDetail_forward_22638426%22">1</a></sup>​。这些赛事可能刺激了彩票的销售，尤其是竞猜型的彩票，因为体育赛事常常与彩票竞猜活动相结合。</p><h1 id="买彩票的动机"><a href="#买彩票的动机" class="headerlink" title="买彩票的动机"></a>买彩票的动机</h1><p><b>Question:</b><br>从理性上来讲，你会推荐人买彩票吗？</p><p><b>ChatGPT:</b><br>从理性的经济学角度来看，购买彩票并不是一种有效的投资策略。彩票的期望回报（即可能的收益与其概率的乘积）通常是负的，这意味着在长期内，购买彩票的人平均而言将会亏损。这是因为彩票的中奖概率极低，而且彩票机构需要收取一部分的手续费或利润。</p><p>然而，这并不意味着购买彩票总是不理性的。对于一些人来说，购买彩票可能带来了乐趣，或者提供了一个可能改变生活的希望，这些都是无法用金钱量化的。在这种情况下，购买彩票可以看作是一种消费行为，而不是投资行为。</p><p>因此，如果你是在寻找有效的投资策略，那么购买彩票可能不是一个好的选择。但如果你享受购买彩票带来的乐趣，或者愿意支付一小部分钱来换取可能的巨大收益，那么购买彩票是可以理解的。</p><p>总的来说，每个人都应该根据自己的经济状况、风险承受能力和个人偏好来做出决策。购买彩票是否合适，取决于这些因素。</p><h1 id="劝朋友远离彩票？"><a href="#劝朋友远离彩票？" class="headerlink" title="劝朋友远离彩票？"></a>劝朋友远离彩票？</h1><p><b>Question:</b><br>如果让你劝一个好朋友不要买彩票，你会怎么说呢？尽量用委婉的语气，不要超过 100 个字，要简单，动之以情，晓之以理。</p><p><b>ChatGPT:</b><br>朋友，我理解你买彩票的乐趣和希望，但长期看，中奖几率微小，可用这钱去做更有保障的事。让我们一起找其他乐趣，保持开心，平稳生活，你说呢？</p><hr><p><b>Question:</b><br>这个朋友不相信中奖几率微小，你怎么反驳呢？</p><p><b>ChatGPT:</b><br>我理解你的观点，朋友。但实际上，彩票中奖的几率非常低。比如说，假设你在中国的福利彩票双色球游戏中购买一张彩票，你的中大奖（六个红球号码和一个蓝球号码）的几率是1比1400多万。这就像在整个北京市里随机找一个特定的人一样困难。这是个很大的数字，不是吗？让我们思考一下这个概念，可能会有所帮助。</p>]]></content>
    
    
    <summary type="html">本页面深入探讨了彩票销售额的增长原因和购买彩票的心理动机。我们通过AI的角度，分析了体育赛事对彩票销售的影响，以及购买彩票的经济学理论。同时，我们也讨论了如何以理性的方式看待购买彩票，以及如何以委婉的语言劝告朋友远离彩票。如果你对彩票有所疑惑，或者想要了解更多关于彩票的知识，这里是一个不错的开始。</summary>
    
    
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
  </entry>
  
  <entry>
    <title>GPT4 教我什么是期权</title>
    <link href="https://selfboot.cn/2023/05/24/gpt4_teach_option/"/>
    <id>https://selfboot.cn/2023/05/24/gpt4_teach_option/</id>
    <published>2023-05-24T13:45:15.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<p><b>Question:</b><br>什么是期权</p><p><b>ChatGPT:</b><br>期权是一种金融衍生品，它给予买方（期权持有人）购买或出售某种资产（如股票、债券、商品等）的权利，但不承担义务。买方可以选择在未来的某个日期（即行权日期），或在到期日期之前的任何时间，以预定的价格（即行权价格）执行购买或出售的权利。</p><p>期权有两种主要类型：看涨期权和看跌期权。看涨期权授予持有者以特定价格购买特定资产的权利，而看跌期权则授予以特定价格出售资产的权利。</p><hr><p><b>Question:</b><br>可以给我举一个具体的例子吗</p><p><b>ChatGPT:</b><br>当然可以。假设你买了一份ABC公司股票的看涨期权，行权价格是$50，这意味着你有权（但不是义务）以$50的价格购买ABC公司的股票。</p><p>假设在期权到期日，ABC公司的股票价格升到了$60。由于你有权以$50的价格购买股票，所以你可以行权购买股票，然后立刻以市场价$60出售，从中赚取$10的利润（这还未扣除购买期权的成本）。</p><p>然而，如果ABC公司的股票价格在期权到期日是$40，那么你就不会选择行权，因为市场上的价格比你的行权价格还低。在这种情况下，你购买的期权就会“作废”，你的损失就是你购买期权的成本。</p><p>这就是期权的基本工作原理。希望这个例子有助于你理解期权。</p><hr><p><b>Question:</b><br>上面的例子，如果购买期权的成本，是 $50 一股吗</p><p><b>ChatGPT:</b><br>不，购买期权的成本（也被称为期权的”溢价”）通常要低得多。实际上，期权的价格取决于许多因素，包括潜在资产的价格、行权价格、期权到期日与当前日期的距离（也就是期权的”期限”）以及市场对潜在资产价格波动性的预期等。</p><p>比如，你可能只需要支付$5来购买一份行权价格为$50的ABC公司股票的看涨期权。这意味着你实际上为每股股票支付了$5，以换取在期权有效期内以$50的价格购买股票的权利。</p><p>这样，如果股票价格上升到$60，你行权后的利润就是$60（股票市场价格）减去$50（行权价格）再减去$5（期权溢价），即$5。如果股票价格低于$50，你的损失就是你为期权支付的$5溢价。</p><hr><p><b>Question:</b><br>如果价格是 48，我可以买入吗，这样我的损失会不会少一些</p><p><b>ChatGPT:</b><br>如果ABC公司的股票价格在期权到期时是$48，并且你持有的是行权价格为$50的看涨期权，那么你通常不会选择行权。因为在开放市场上，你可以以$48的价格直接购买股票，而不需要以更高的$50的价格通过行权购买。所以，即使股票价格低于行权价格，你也可以选择不行权，而是在开放市场上直接购买股票。<br>你购买期权的溢价（在这个例子中是$5）是你的最大损失。无论潜在资产的价格是多少，你的损失都不会超过这个溢价。所以，如果股票价格在期权到期时低于行权价格，你的损失就是你支付的期权溢价。</p><hr><p><b>Question:</b><br>所以无论行权不行权，我前期付出的5$每股，在期权到期的时候都是要支付的？</p><p><b>ChatGPT:</b><br>是的，你正确地理解了。期权的溢价，即你购买期权时所支付的费用，在任何情况下都不会退还给你。无论你是否行权，这个成本都是不可避免的。</p><p>在你的例子中，$5就是购买期权的费用，也就是你为获得在未来某一时间以$50的价格购买股票的权利而支付的价格。如果股票的价格在期权到期时超过$50，你可能会选择行权，从中获利。但如果股票价格低于$50，你则可能会选择放弃行权，这时你的损失就是这个$5的期权溢价。</p><p>因此，购买期权的决策应该基于你对未来价格走势的预测，你需要权衡潜在的收益和可能的损失。</p>]]></content>
    
    
    <summary type="html">本页面详细解释了期权的概念，包括期权的工作原理，购买期权的成本，以及如何理性看待期权投资。我们通过具体的例子，深入解析了看涨期权的购买和行权过程，以及期权溢价的计算。无论你是金融领域的专业人士，还是对期权投资感兴趣的普通读者，这里都能为你提供深入浅出的理解和实用的知识。</summary>
    
    
    
    <category term="金融" scheme="https://selfboot.cn/categories/%E9%87%91%E8%9E%8D/"/>
    
    
    <category term="GPT4" scheme="https://selfboot.cn/tags/GPT4/"/>
    
  </entry>
  
  <entry>
    <title>Postman 高级用法指南</title>
    <link href="https://selfboot.cn/2017/11/12/postman_read_doc/"/>
    <id>https://selfboot.cn/2017/11/12/postman_read_doc/</id>
    <published>2017-11-12T12:18:50.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>Postman是一款强大的API接口测试工具，有许多不容易发现的好用的功能，下面简单介绍其中一部分功能。详细内容可以参考<a href="https://www.getpostman.com/docs/">文档</a>，官方还有视频教程，非常方便入手。后续本博客会持续提供一些Postman使用的细节技巧，方便大家用Postman进行接口调试。</p><p><img src="https://s3.amazonaws.com/postman-static-getpostman-com/postman-docs/statusBar.png" alt="Navigating Postman"> </p><span id="more"></span><p>作为一个跨平台的API测试工具，Postman有Win&#x2F;Mac&#x2F;Linux客户端，还有浏览器扩展程序。不过官方建议使用客户端，主要有以下优点：</p><ul><li>自带cookie支持：请求可以使用同一域名下的cookie；</li><li>内置代理支持：可以用来转发请求，分析请求流量；</li><li>自定义请求头：不必受限于Chrome中对于请求头的限制；</li><li>内置控制台：在控制台可以查看请求的详细信息</li></ul><p>简单来说，postman 做的事情就是模拟浏览器发送请求，接受响应。使用Postman可以模拟任何浏览器发出的请求，可以自由地构造请求地址，请求方法，请求内容，Cookies等。Postman的响应内容包括完整的响应头，响应时间，响应大小，cookie等内容。</p><p>此外，postman还提供如下方便功能：</p><ul><li><a href="https://www.getpostman.com/docs/postman/sending_api_requests/debugging_and_logs">Debugging and logs</a>：可以在控制台对postman的请求进行调试，特别是如果有pre-request或者test script时，使用控制台可以方便debug。原生postman可以通过<code>CMD/CTRL + ALT + C</code>打开控制台。</li><li><a href="https://www.getpostman.com/docs/postman/sending_api_requests/generate_code_snippets">Generate code snippets</a>：将当前请求导出为各种版本的请求代码，比如python，js，curl等，方便用命令行测试；</li><li><a href="https://www.getpostman.com/docs/postman/sending_api_requests/proxy">Proxy</a>：如果本机不能直接访问服务端，可以在<code>Settings-Proxy-Using custom/system proxy</code>设置代理；</li><li><a href="https://www.getpostman.com/docs/postman/sending_api_requests/capturing_http_requests">Capturing HTTP requests</a>：有时候用手机访问服务端时，我们可能需要借助fiddler来查看HTTP请求。postman也可以做相同的工作，只需要将postman作为代理转发HTTP请求即可。</li><li><a href="https://www.getpostman.com/docs/postman/sending_api_requests/certificates">Certificates</a>： 如果服务端要验证客户端证书，可以在<code>Settings-Certificates-Add Certificate</code>配置证书；</li></ul><h1 id="Environments-and-globals"><a href="#Environments-and-globals" class="headerlink" title="Environments and globals"></a>Environments and globals</h1><p>我们在构造API请求时，经常会在多个地方使用相同的值，比如相同的请求域名，一些固定的参数值。这时候如果使用<strong>变量</strong>来保存相应的值，然后在需要使用该值的地方用变量来代替会带来不少好处，比如要改变这些值，只用在变量的定义地方作出改动即可。</p><p><img src="https://s3.amazonaws.com/postman-static-getpostman-com/postman-docs/59165135.png" alt="Quick Look for variables"></p><p>Postman定义了4类变量，极大地方便了构造请求以及对结果进行测试：</p><ul><li>Global: 全局变量，postman中所有请求都可以访问或者修改；</li><li>Environment: 构造请求时可以选择使用某个Environment，这样就可以访问或者修改该Environment下的所有变量；</li><li>Local: 脚本中定义的变量，只对脚本的当前作用域有用；</li><li>Data: 只有在使用 <code>Collection Runner</code> 的时候，可以通过导入 Data Files 来构造当前测试集中用到的数据。</li></ul><p>就像程序中的变量一样，这里的变量也是有优先级，如果在Environment中有和Global重名的变量，会优先使用Environment中变量。上面4个变量的优先级由上到下依次减弱。 </p><p>在postman中使用变量有着很多意想不到的好处，比如：</p><ol><li>Collection Runner中通过Data file来构造不同的测试数据，方便快速进行大量不同请求数据的测试；</li><li>可以在不同请求中传递值，比如在一个请求中产生流水号，将其设置为某个变量的值，下一个请求即可使用该变量值。</li></ol><h1 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h1><p>Postman 内置了Node.js的运行时环境，可以执行JS脚本。这样就带来了很多激动人心的好处，比如构建动态请求参数，编写强大的测试用例等。Postman中的Scripts分为2类：</p><ul><li><a href="https://www.getpostman.com/docs/postman/scripts/pre_request_scripts">pre-request script</a>: 在发送请求之前执行的脚本，一般用来构建请求参数；</li><li><a href="https://www.getpostman.com/docs/postman/scripts/test_scripts">test script</a>: 在获取相应之后执行的脚本，一般用来做测试。不过需要注意，测试脚本运行在Sandbox环境，内置了许多JS库支持，方便进行测试。</li></ul><p><img src="https://s3.amazonaws.com/postman-static-getpostman-com/postman-docs/59184189.png" alt="Request Execution Flow"></p><p>Postman的<a href="https://www.getpostman.com/docs/postman/scripts/postman_sandbox">Sandbox</a>环境十分强大，比如：</p><ol><li>通过提供 <code>postman.setNextRequest(&quot;request_name&quot;)</code> 实现，可以很方便地在 Collection 中控制请求的执行路径；</li><li>提供了一系列<a href="https://www.getpostman.com/docs/postman/scripts/postman_sandbox_api_reference">内置接口</a>，方便对环境变量，请求或者相应内容进行访问；</li><li>提供了 CryptoJS 库，可以方便地进行加解密操作；</li><li>提供了 tv4 库，可以对 Json Scheme进行测试；JSON Schema 定义了如何基于 JSON 格式描述 JSON 数据结构的规范，进而提供数据校验、文档生成和接口数据交互控制等一系列能力。</li></ol><h1 id="Collections-runs"><a href="#Collections-runs" class="headerlink" title="Collections runs"></a>Collections runs</h1><p>Collections 是一系列请求的集合，postman通过collection来支持构建请求工作流，自动化测试，请求的导入导出，持续集成等功能。Collection 支持以下功能：</p><ul><li><a href="https://www.getpostman.com/docs/postman/collections/sharing_collections">Sharing collections</a>：可以将Collection中的请求导出分享给其他人；</li><li><a href="https://www.getpostman.com/docs/postman/collections/data_formats">Data formats</a>：Postman可以导出环境变量，甚至可以将请求和环境变量等一起打包为一个Json，方便迁移所有的请求数据。</li></ul><p>Collection的一大用处就是一次执行其中所有的请求，这就是所谓的 <a href="https://www.getpostman.com/docs/postman/collection_runs/starting_a_collection_run">collection run</a>。</p><p><img src="https://s3.amazonaws.com/postman-static-getpostman-com/postman-docs/58793861.png" alt="collection runner"></p><p>在执行collection run时，有很多配置选项，主要如下：</p><ul><li><a href="https://www.getpostman.com/docs/postman/collection_runs/using_environments_in_collection_runs">Using environments in collection runs</a>: 可以指定一个 Environment，这样collection中的请求可以使用其中的变量；</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/working_with_data_files">Working with data files</a>: 可以导入一个Data File，里面存放测试中用到的Data变量。可以存放很多不同的Data变量，这样迭代跑多次Collection时，每次使用不同的数据；</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/running_multiple_iterations">Running multiple iterations</a>: 可以配置迭代的运行Collection中的请求，对接口的稳定性进行测试。此外配合Data files，也可以对接口的正确性进行测试；</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/building_workflows">Building workflows</a>：默认情况下会顺序执行Collection中的请求，不过可以通过<code>setNextRequest()</code>来更改请求的执行流程。</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/debugging_a_collection_run">Debugging a collection run</a>: Collection中的请求执行后，会有可视化的执行结果展示，可以方便进行调试，此外，也可以通过控制台来进行调试。</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/sharing_a_collection_run">Sharing a collection run</a>: 整个Collection Run也是可以导出，可以在其他平台进行运行；</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/command_line_integration_with_newman">Command line integration with Newman</a>: 导出Collection Run后，可以在命令行使用 newman 运行。</li><li><a href="https://www.getpostman.com/docs/postman/collection_runs/integration_with_travis">Integration with Travis CI</a>: 可以将 newman 和 Travis CI集成，配置好持续性集成，指定自动运行测试用例的时机。</li></ul><h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><p><strong>1. 文件上传</strong></p><p>图形界面端，Collection 中的请求不支持POST文件上传，不过在导出Collection后，可以在json文件中配置文件路径，然后使用 newman 进行文件上传。详细可以参考Postman官方博客：<a href="http://blog.getpostman.com/2014/11/15/using-newman-to-run-collections-with-file-post-requests/">Using Newman to run collections with file-post requests</a></p><p>不过文件上传时必须指定文件路径，不能用变量代替，也不能通过Data Files来设置不同的文件，不是很方便。所以我给官方提了 <a href="https://github.com/postmanlabs/postman-app-support/issues/3779">Issue</a>，目前该功能已经纳入 Feature，有望在后续版本中实现该功能。这里就不得不赞一下Postman的社区支持了，基本上有任何问题，只要在官方Issue上提出，基本很快就会有Postman的工作人员提供支持。</p><p>（备注：本文所有图片均来自Postman Doc）</p>]]></content>
    
    
    <summary type="html">探索Postman的高级用法，学习如何更有效地进行HTTP API测试。本篇指南深入讲解Postman的功能，带领读者了解如何更好地使用这个强大的工具，提高工作效率。适合各类开发者阅读。</summary>
    
    
    
    <category term="工具介绍" scheme="https://selfboot.cn/categories/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="教程" scheme="https://selfboot.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="总结" scheme="https://selfboot.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python2.x 字符编码终极指南</title>
    <link href="https://selfboot.cn/2016/12/28/py_encode_decode/"/>
    <id>https://selfboot.cn/2016/12/28/py_encode_decode/</id>
    <published>2016-12-28T22:02:50.000Z</published>
    <updated>2023-06-05T12:31:21.471Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://selfboot.cn/2014/08/28/character_encoding/">人机交互之字符编码</a> 一文中对字符编码进行了详细的讨论，并通过一些简单的小程序验证了我们对于字符编码的认识。但仅了解这篇文章的内容，并不能帮我们在日常编程中躲过一些字符编码相关的坑，Stackoverflow 上就有大量编码相关的问题，比如 <a href="http://stackoverflow.com/questions/9942594/unicodeencodeerror-ascii-codec-cant-encode-character-u-xa0-in-position-20">1</a>，<a href="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161228_encode_decode_2.png">2</a>(Python: Convert Unicode to ASCII without errors)，<a href="http://stackoverflow.com/questions/2688020/how-to-print-chinese-word-in-my-code-using-python">3</a>。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161228_encode_decode_1.png" alt="图1. 错误的编解码"></p><p>本文首先尝试对编码、解码进行一个<strong>宏观、直观</strong>的解读，然后详细来解释 python2 中的str和unicode，并对常见的UnicodeEncodeError 和 UnicodeDecodeError 异常进行剖析。</p><span id="more"></span><h1 id="如何理解编、解码？"><a href="#如何理解编、解码？" class="headerlink" title="如何理解编、解码？"></a>如何理解编、解码？</h1><p>如何去理解编码、解码？举个例子，Alice同学刚加入了机器学习这门课，想给同班的Bob同学打个招呼。但是作为人，Alice不能通过意念和Bob交流，必须通过某种方式，比如手语、声音、文字等来表达自己的想法。如果Alice选择用文字，那么他可能会写下这么一段文字：<code>My name is： boot …… 来学机器学习喽</code>，写文字这个过程其实就是<strong>编码</strong>，经过编码后的文字才能给Bob看。Bob收到Alice的文字后，就会用自己对文字的认知来解读Alice传达的含义，这个过程其实就是<strong>解码</strong>。当然，如果Bob不懂中文，那么就无法理解Alice的最后一句了，如果Bob不识字，就完全不知道Alice想表达什么了。</p><p>上面的例子只是为了方便我们理解编码、解码这个抽象的概念，现在来看看对于计算机程序来说，如何去理解字符的编码、解码过程。我们知道绝大多数程序都是读取数据，做一些操作，然后输出数据。比如当我们打开一个文本文件时，就会从硬盘读取文件中的数据，接着我们输入了新的数据，点击保存后，文本程序会将更新后的内容输出到硬盘。程序读取数据就相当于Bob读文字，必须进行一个解码的过程，解码后的数据才能让我们进行各种操作。同理，保存到硬盘时，也需要对数据进行编码。</p><p>下图方框 A 代表一个输出数据的程序，方框 B 代表一个读取数据的程序。当然这里的程序只是一个概念，表示一个处理数据的逻辑单元，可以是一个进程、一个函数甚至一个语句等。A 和 B 也可以是同一个程序，先解码外部获取的数据，内部操作后，再进行某种编码。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161228_encode_decode_2.png" alt="图2. 编码、解码的过程"></p><p>值得注意的是，有的编码方案不一定能表示某些信息，这时编码就会失败，比如 ASCII 就不能用来表示中文。当然，如果以错误的方式去解读某段内容，解码也会失败，比如用 ASCII 来解读包含 UTF-8的信息。至于什么是 ASCII，UTF-8等，在<a href="http://selfboot.cn/2014/08/28/character_encoding/">人机交互之字符编码</a> 中有详细的说明，这里不再赘述。下面结合具体的例子，来看看编码、解码的细节问题。</p><h1 id="python2-x-中的字符串"><a href="#python2-x-中的字符串" class="headerlink" title="python2.x 中的字符串"></a>python2.x 中的字符串</h1><p>在程序设计中，字符串一般是指一连串的<a href="https://docs.python.org/2/howto/unicode.html#definitions">字符</a>，比如<code>hello world!</code>、<code>你好</code>或者<code>もしもし</code>（日语）等等。各种语言对于字符串的支持各不相同，Python 2 中字符串的设计颇不合理，导致新手经常会出现各种问题，类似下面的提示信息相信很多人都遇到过（<code>UnicodeEncodeError</code> 或者 <code>UnicodeDecodeError</code>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 0-1: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>下面我们一起来解决这个疑难杂症。首先需要搞清楚python中的两个类型：<code>&lt;type &#39;str&#39;&gt;</code> 和 <code>&lt;type &#39;unicode&#39;&gt;</code>，<a href="https://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange">文档</a>中关于这两个类型的说明其实挺含糊的：</p><blockquote><p>There are seven sequence types: strings, Unicode strings, lists, …</p><p>String literals are written in single or double quotes: ‘xyzzy’, “frobozz”. Unicode strings are much like strings, but are specified in the syntax using a preceding ‘u’ character: u’abc’, u”def”.</p></blockquote><p>上面并没有给出什么有用的信息，不过好在<a href="https://www.azavea.com/blog/2014/03/24/solving-unicode-problems-in-python-2-7/">这篇文章</a>讲的特别好，简单来说：</p><ul><li>str：是<code>字节串（container for bytes）</code>，由 Unicode 经过编码(encode)后的字节组成的。</li><li>unicode：真正意义上的<code>字符串</code>，其中的每个字符用 Unicode 中对应的 <a href="https://en.wikipedia.org/wiki/Code_point">Code Point</a> 表示。</li></ul><p>翻译成<strong>人话</strong>就是，unicode 有点类似于前面 Alice 打招呼传递的想法，而 str 则是写下来的文字（或者是说出来的声音，甚至可以是手语）。我们可以用 GBK，UTF-8 等编码方案将 Unicode 类型转换为 str 类型，类似于用语言、文字或者手语来表达想法。</p><h2 id="repr-与终端交互"><a href="#repr-与终端交互" class="headerlink" title="repr 与终端交互"></a>repr 与终端交互</h2><p>为了彻底理解字符编码、解码，下面要用 python 交互界面进行一些小实验来加深我们的理解（下面所有的交互代码均在 Linux 平台下）。在这之前，我们先来看下面交互代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo = <span class="string">&#x27;Test 试试&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo</span><br><span class="line"><span class="string">&#x27;Test \xe8\xaf\x95\xe8\xaf\x95&#x27;</span></span><br></pre></td></tr></table></figure><p>当我们只输入标识符 demo 时，终端返回了 demo 的内容。这里返回的内容是怎么得到呢？答案是通过 <a href="https://docs.python.org/2/library/functions.html#repr">repr() 函数</a> 获得。文档中对于 repr 函数解释如下：</p><blockquote><p>Return a string containing a printable representation of an object.</p></blockquote><p>所以，我们可以在源文件中用下面的代码，来获取和上面终端一样的输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">demo = <span class="string">&#x27;Test 试试&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">repr</span>(demo)</span><br><span class="line"><span class="comment"># &#x27;Test \xe8\xaf\x95\xe8\xaf\x95&#x27;</span></span><br></pre></td></tr></table></figure><p>对于字符串来说，<code>repr()</code> 的返回值很好地说明了其在python内部的表示方式。通过 repr 的返回值，我们可以真切体会到前面提到的两点：</p><ul><li><strong>str：实际上是字节串</strong></li><li><strong>unicode：真正意义上的字符串</strong></li></ul><p>下面分别来看看这两个类型。</p><h2 id="unicode-类型"><a href="#unicode-类型" class="headerlink" title="unicode 类型"></a>unicode 类型</h2><p><strong>unicode 是真正意义上的字符串</strong>，为了理解这句话，先看下面的一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode_str = <span class="string">u&#x27;Welcome to 广州&#x27;</span> <span class="comment"># &#x27;&#x27;前面的 u 表示这是一个 unicode 字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode_str, <span class="built_in">type</span>(unicode_str)  <span class="comment"># repr(unicode_str)</span></span><br><span class="line">(<span class="string">u&#x27;Welcome to \u5e7f\u5dde&#x27;</span>, &lt;<span class="built_in">type</span> <span class="string">&#x27;unicode&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><p>repr 返回的 <code>Welcome to \u5e7f\u5dde</code> 说明了unicode_str存储的内容，其中两个<code>\u</code>后面的数字分别对应了<code>广、州</code>在unicode中的code point：</p><ul><li><code>5e7f</code> 对应<code>广</code>字；</li><li><code>5dde</code> 对应<code>州</code>字；</li></ul><p>英文字母也有对应的code point，它的值等于ASCII值，不过repr并没有直接输出。我们可以在<a href="http://tool.chinaz.com/tools/unicode.aspx">站长工具</a>中查看所有字符对应的code point。也可以用 python 的内置函数 <code>ord</code> 查看字符的 code point，如下所示（调用了 format 将code point转换为十六进制）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:04x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">ord</span>(<span class="string">u&#x27;广&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;5e7f&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:04x&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">ord</span>(<span class="string">u&#x27;W&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0057&#x27;</span></span><br></pre></td></tr></table></figure><p>总结一下，我们可以将 <code>&lt;type &#39;unicode&#39;&gt;</code> 看作是<strong>一系列字符组成的数组</strong>，数组的每一项是一个code point，用来表示相应位置的字符。所以对于 unicode 来说，其长度等于它包含的字符（<code>a</code> 和 <code>广</code> 都是一个字符）的数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(unicode_str)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode_str[<span class="number">0</span>], unicode_str[<span class="number">12</span>], unicode_str[-<span class="number">1</span>]</span><br><span class="line">(<span class="string">u&#x27;W&#x27;</span>, <span class="string">u&#x27;\u5dde&#x27;</span>, <span class="string">u&#x27;\u5dde&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="str-类型"><a href="#str-类型" class="headerlink" title="str 类型"></a>str 类型</h2><p><strong>str 是字节串（container for bytes）</strong>，为了理解这句话，先来看下面的一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_str = <span class="string">&#x27;Welcome to 广州&#x27;</span>       <span class="comment"># 这是一个 str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_str, <span class="built_in">type</span>(str_str)</span><br><span class="line">(<span class="string">&#x27;Welcome to \xe5\xb9\xbf\xe5\xb7\x9e&#x27;</span>, &lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><p>python中 <code>\xhh</code>（h为16进制数字）表示一个字节，输出中的<code>\xe5\xb9\xbf\xe5\xb7\x9e</code> 就是所谓的字节串，它对应了<code>广州</code>。实际上 str_str 中的英文字母也是保存为字节串的，不过 repr 并没有以 <code>\x</code> 的形式返回。为了验证上面输出内容确实是<strong>字节串</strong>，我们用python提供的 <a href="https://docs.python.org/2.7/library/functions.html#bytearray">bytearray 函数</a>将相同内容的 unicode字符串用 UTF-8 编码为字节数组，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode_str = <span class="string">u&#x27;Welcome to 广州&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bytearray</span>(unicode_str, <span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;Welcome to \xe5\xb9\xbf\xe5\xb7\x9e&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">bytearray</span>(unicode_str, <span class="string">&#x27;UTF-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 字节数组，每一项为一个字节；</span></span><br><span class="line">[<span class="number">87</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">116</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">229</span>, <span class="number">185</span>, <span class="number">191</span>, <span class="number">229</span>, <span class="number">183</span>, <span class="number">158</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="string">r&quot;\x&quot;</span> + <span class="string">r&quot;\x&quot;</span>.join([<span class="string">&quot;%02x&quot;</span> % c <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">bytearray</span>(unicode_str, <span class="string">&#x27;UTF-8&#x27;</span>))])</span><br><span class="line"><span class="comment"># 转换为 \xhh 的形式</span></span><br><span class="line">\x57\x65\x6c\x63\x6f\x6d\x65\x20\x74\x6f\x20\xe5\xb9\xbf\xe5\xb7\x9e</span><br></pre></td></tr></table></figure><p>可见，上面的 str_str 是 unicode_str 经过 <a href="http://selfboot.cn/2014/08/28/character_encoding/#%E5%8F%91%E6%89%AC%E5%85%89%E5%A4%A7-UTF-8%E7%BC%96%E7%A0%81">UTF-8 编码</a> 后的字节串。这里透漏了一个十分重要的信息，<strong>str类型隐含有某种编码方式</strong>，正是这种隐式编码（<em>implicit encoding</em>）的存在导致了许多问题的出现（后面详细说明）。值得注意的是，str类型字节串的隐式编码不一定都是’UTF-8’，前面示例程序都是在 OS X 平台下的终端，所以隐式编码是 UTF-8。对于 Windows 而言，如果语言设置为简体中文，那么交互界面输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Win 平台下，系统语言为简体中文</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_str = <span class="string">&#x27;Welcome to 广州&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_str, <span class="built_in">type</span>(str_str)</span><br><span class="line">(<span class="string">&#x27;Welcome to \xb9\xe3\xd6\xdd&#x27;</span>, &lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><p>这里str_str的隐式编码是<strong>cp936</strong>，可以用 <code>bytearray(unicode_str, &#39;cp936&#39;)</code> 来验证这点。终端下，str类型的隐式编码由系统 locale 决定，可以采用下面方式查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Unix or Linux</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> locale</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locale.getdefaultlocale()</span><br><span class="line">(<span class="string">&#x27;zh_CN&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 简体中文 Windows</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locale.getdefaultlocale()</span><br><span class="line">(<span class="string">&#x27;zh_CN&#x27;</span>, <span class="string">&#x27;cp936&#x27;</span>)</span><br></pre></td></tr></table></figure><p>总结一下，我们可以将 <code>&lt;type &#39;str&#39;&gt;</code> 看作是<strong>unicode字符串经过某种编码后的字节组成的数组</strong>。数组的每一项是一个字节，用 <code>\xhh</code> 来表示。所以对于 str 字符串来说，其长度等于编码后字节的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(str_str)</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_str[<span class="number">0</span>], str_str[-<span class="number">1</span>]</span><br><span class="line">(<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;\x9e&#x27;</span>)       <span class="comment"># 实际上是(&#x27;\x57&#x27;, &#x27;\x9e&#x27;)</span></span><br></pre></td></tr></table></figure><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Python 2.x 中为上面两种类型的字符串都提供了 <a href="https://docs.python.org/2/library/stdtypes.html#string-methods">encode 和 decode</a> 方法，原型如下：</p><blockquote><p>str.decode([encoding[, errors]])<br>str.encode([encoding[, errors]])</p></blockquote><p>利用上面的两个函数，可以实现 str 和 unicode 类型之间的相互转换，如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161228_encode_decode_3.png" alt="图3. 类型间相互转换"></p><p>上图中绿色线段标示的即为我们常用的转换方法，红色标示的转换在 python 2.x 中是合法的，不过没有什么意义，通常会抛出错误（可以参见 <a href="http://stackoverflow.com/questions/447107/what-is-the-difference-between-encode-decode">What is the difference between encode&#x2F;decode?</a>）。下面是两种类型之间的转换示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># decode： &lt;type &#x27;str&#x27;&gt; 到 &lt;type &#x27;unicode&#x27;&gt;的转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>enc = str_str.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>enc, <span class="built_in">type</span>(enc)</span><br><span class="line">(<span class="string">u&#x27;Welcome to \u5e7f\u5dde&#x27;</span>, &lt;<span class="built_in">type</span> <span class="string">&#x27;unicode&#x27;</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># encode： &lt;type &#x27;unicode&#x27;&gt; 到 &lt;type &#x27;str&#x27;&gt; 的转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dec = unicode_str.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dec, <span class="built_in">type</span>(dec)</span><br><span class="line">(<span class="string">&#x27;Welcome to \xe5\xb9\xbf\xe5\xb7\x9e&#x27;</span>, &lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><p>上面代码中通过encode将unicode类型<strong>编码</strong>为str类型，通过 decode 将str类型<strong>解码</strong>为unicode类型。当然，编码、解码的过程并不总是一帆风顺的，通常会出现各种错误。</p><h2 id="编、解码错误"><a href="#编、解码错误" class="headerlink" title="编、解码错误"></a>编、解码错误</h2><p>Python 中经常会遇到 UnicodeEncodeError 和 UnicodeDecodeError，怎么产生的呢？ 如下代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; u<span class="string">&#x27;Hello 广州&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 6-7: ordinal not in range(128)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;Hello 广州&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: &#x27;ascii&#x27; codec can&#x27;t decode byte 0xe5 in position 6: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>当我们用 ascii 去编码带有中文的unicode字符串时，发生了UnicodeEncodeError，当我们用 ascii 去解码有中文的str字节串时，发生了UnicodeDecodeError。我们知道，ascii 只包含 127 个字符，根本无法表示中文。所以，让 ascii 来编码、解码中文，就超出了其能力范围。这就像你对一个不懂中文的老外说中文，他根本没法听懂。简单来说，<strong>所有的编码、解码错误都是由于所选的编码、解码方式无法表示某些字符造成的</strong>。</p><p>有时候我们就是想用 ascii 去编码一段夹杂中文的str字节串，并不希望抛出异常。那么可以通过 errors 参数来指定当无法编码某个字符时的处理方式，常用的处理方式有 “strict”，”ignore”和”replace”。改动后的程序如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; u<span class="string">&#x27;Hello 广州&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>)</span></span><br><span class="line">&#x27;Hello ??&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; u<span class="string">&#x27;Hello 广州&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>)</span></span><br><span class="line">&#x27;Hello &#x27;</span><br></pre></td></tr></table></figure><h2 id="隐藏的解码"><a href="#隐藏的解码" class="headerlink" title="隐藏的解码"></a>隐藏的解码</h2><p>str和unicode类型都可以用来表示字符串，为了方便它们之间进行操作，python并不要求在操作之前统一类型，所以下面的代码是合法的，并且能得到正确的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; new_str = u<span class="string">&#x27;Welcome to &#x27;</span> + <span class="string">&#x27;GuangZhou&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; new_str, <span class="built_in">type</span>(new_str)</span></span><br><span class="line">(u&#x27;Welcome to GuangZhou&#x27;, &lt;type &#x27;unicode&#x27;&gt;)</span><br></pre></td></tr></table></figure><p>因为str类型是隐含有某种编码方式的字节码，所以python内部将其<strong>解码</strong>为unicode后，再和unicode类型进行 <code>+ 操作</code>，最后返回的结果也是unicode类型。</p><p>第2步的解码过程是在幕后悄悄发生的，<strong>默认采用ascii来进行解码</strong>，可以通过 <code>sys.getdefaultencoding()</code> 来获取默认编码方式。Python 之所以采用 ascii，是因为 ascii 是最早的编码方式，是许多编码方式的子集。</p><p>不过正是这个不可见的解码过程，有时候会导致出乎意料的解码错误，考虑下面的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; u<span class="string">&#x27;Welcome to&#x27;</span> + <span class="string">&#x27;广州&#x27;</span></span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: &#x27;ascii&#x27; codec can&#x27;t decode byte 0xe5 in position 0: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>上面在字符串的+操作时，python 偷偷对’广州’用 ascii 做解码操作，所以抛出了UnicodeDecodeError异常。其实上面操作等同于 <code>u&#39;Welcome to&#39; + &#39;广州&#39;.decode(&#39;ascii&#39;)</code> ，你会发现这句代码抛出的异常和上面的一模一样。</p><h2 id="隐藏的编码"><a href="#隐藏的编码" class="headerlink" title="隐藏的编码"></a>隐藏的编码</h2><p>Python 不只偷偷地用 ascii 来解码str类型的字节串，有时还会偷偷用ascii来编码unicode类型。如果函数或类等对象接收的是 str 类型的字符串，但传进去的是unicode，python2 就会使用 ascii 将其编码成str类型再做运算。</p><p>以raw_input为例，我们可以给 <a href="https://docs.python.org/2/library/functions.html#raw_input">raw_input</a> 函数提供 prompt 参数，作为输入提示内容。这里如果 prompt 是 unicode 类型，python会先用ascii对其进行编码，所以下面代码会抛出UnicodeEncodeError异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = raw_input(u<span class="string">&#x27;请输入内容: &#x27;</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 0-4: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>上面操作完全等同于 <code>a = raw_input(u&#39;请输入内容: &#39;.encode(&#39;ascii&#39;))</code>，你会发现它们抛出的异常完全一样。此外，如果尝试将unicode字符串重定向输出到文本中，也可能会抛出UnicodeEncodeError异常。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> a.py</span></span><br><span class="line">demo = u&#x27;Test 试试&#x27;</span><br><span class="line">print demo</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python a.py &gt; output</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;a.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    print demo</span><br><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 5-6: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>当然，如果直接在终端进行输出，则不会抛出异常。因为python会使用控制台的默认编码，而不是 ascii。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结下本文的内容：</p><ul><li>str可以看作是unicode字符串经过某种编码后的字节组成的数组</li><li>unicode是真正意义上的字符串</li><li>通过 encode 可以将unicode类型<strong>编码</strong>为str类型</li><li>通过 decode 可以将str类型<strong>解码</strong>为unicode类型</li><li>python 会隐式地进行编码、解码，默认采用 ascii</li><li>所有的编码、解码错误都是由于所选的编码、解码方式无法表示某些字符造成的</li></ul><p>如果你明白了上面每句话的含义，那么应该能解决大部分编、解码引起的问题了。当然，本篇文章其实并不能帮你完全避免python编码中的坑（坑太多）。还有许多问题在这里并没有说明：</p><ul><li>读取、写入文件时的编码问题：</li><li>数据库的读写</li><li>网络数据操作</li><li>源文件编码格式的指定</li></ul><p>有空再详细谈谈上面列出的坑。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://nedbatchelder.com/text/unipain.html">Pragmatic Unicode</a><br><a href="http://farmdev.com/talks/unicode/">Unicode In Python, Completely Demystified</a><br><a href="https://www.azavea.com/blog/2014/03/24/solving-unicode-problems-in-python-2-7/">Solving Unicode Problems in Python 2.7</a><br><a href="https://docs.python.org/2.7/howto/unicode.html">Unicode HOWTO</a><br><a href="https://wiki.python.org/moin/PrintFails">Wiki：PrintFails</a><br><a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">Unicode and Character Sets</a><br><a href="http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python">What is the purpose of __str__ and __repr__ in Python?</a><br><a href="http://stackoverflow.com/questions/2672326/what-does-a-leading-x-mean-in-a-python-string-xaa">What does a leading \x mean in a Python string \xaa</a></p><p><a href="https://funhacks.net/2016/11/25/character_encoding/">Python: 熟悉又陌生的字符编码</a><br><a href="http://wklken.me/posts/2013/08/31/python-extra-coding-intro.html">PYTHON-进阶-编码处理小结</a><br><a href="http://python.jobbole.com/85482/">五分钟战胜 Python 字符编码</a><br><a href="http://blog.csdn.net/trochiluses/article/details/16825269">python 字符编码与解码</a></p>]]></content>
    
    
    <summary type="html">深入探索 Python 2.x 的字符编码问题。本文详细介绍了 Python 2.x 中的编码和解码过程，包括 Unicode、UTF-8 和其他编码格式。理解 Python 的字符编码可以帮助您避免编程中的常见错误，提高代码质量。</summary>
    
    
    
    <category term="计算机基础" scheme="https://selfboot.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="方法" scheme="https://selfboot.cn/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Python中的ThreadLocal变量（下）</title>
    <link href="https://selfboot.cn/2016/11/03/threadlocal_enhance/"/>
    <id>https://selfboot.cn/2016/11/03/threadlocal_enhance/</id>
    <published>2016-11-03T22:02:50.000Z</published>
    <updated>2023-06-05T12:31:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://selfboot.cn/2016/08/22/threadlocal_overview/">上篇</a>我们看到了 ThreadLocal 变量的简单使用，<a href="http://selfboot.cn/2016/08/26/threadlocal_implement/">中篇</a>对python中 ThreadLocal 的实现进行了分析，但故事还没有结束。本篇我们一起来看下<a href="http://werkzeug.pocoo.org/">Werkzeug</a>中ThreadLocal的设计。</p><p>Werkzeug 作为一个 WSGI 工具库，由于一些方面的考虑，并没有直接使用python内置的ThreadLocal类，而是自己实现了一系列Local类。包括简单的Local，以及在此基础上实现的LocalStack，LocalManager 和 LocalProxy。接下来我们一起来看看这些类的使用方式，设计的初衷，以及具体的实现技巧。</p><span id="more"></span><h1 id="Local-类的设计"><a href="#Local-类的设计" class="headerlink" title="Local 类的设计"></a>Local 类的设计</h1><p>Werkzeug 的设计者认为python自带的ThreadLocal并不能满足需求，主要因为下面两个原因：</p><ol><li>Werkzeug 主要用“ThreadLocal”来满足并发的要求，python 自带的ThreadLocal只能实现基于线程的并发。而python中还有其他许多并发方式，比如常见的<a href="https://github.com/xuelangZF/CS_Offer/blob/4ab9bed1a0b11b34f1761ba2ead3bf8387350d60/Python/Coroutine.md">协程</a>（greenlet），因此需要实现一种能够支持协程的Local对象。</li><li><a href="http://selfboot.cn/2016/08/07/forum_design_wsgi/">WSGI</a>不保证每次都会产生一个新的线程来处理请求，也就是说线程是可以复用的（可以维护一个线程池来处理请求）。这样如果werkzeug 使用python自带的ThreadLocal，一个“不干净（存有之前处理过的请求的相关数据）”的线程会被用来处理新的请求。</li></ol><p>为了解决这两个问题，werkzeug 中实现了Local类。Local对象可以做到线程和协程之间数据的隔离，此外，还要支持清理某个线程或者协程下的数据（这样就可以在处理一个请求之后，清理相应的数据，然后等待下一个请求的到来）。</p><p>具体怎么实现的呢，思想其实特别简单，我们在<a href="http://selfboot.cn/2016/08/22/threadlocal_overview/">深入理解Python中的ThreadLocal变量（上）</a> 一文的最后有提起过，就是创建一个全局字典，然后将线程（或者协程）标识符作为key，相应线程（或协程）的局部数据作为 value。这里 werkzeug 就是按照上面思路进行实现，不过利用了python的一些黑魔法，最后提供给用户一个清晰、简单的接口。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>Local 类的实现在 <a href="https://github.com/pallets/werkzeug/blob/master/werkzeug/local.py">werkzeug.local</a> 中，以 <a href="https://github.com/pallets/werkzeug/commit/8a84b62b3dd89fe7d720d7948954e20ada690c40">8a84b62</a> 版本的代码进行分析。通过前两篇对ThreadLocal的了解，我们已经知道了Local对象的特点和使用方法。所以这里不再给出Local对象的使用例子，我们直接看代码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="constructor">Local(<span class="params">object</span>)</span>:</span><br><span class="line">    __slots__ = (&#x27;__storage__&#x27;, &#x27;__ident_func__&#x27;)</span><br><span class="line"></span><br><span class="line">    def <span class="constructor">__init__(<span class="params">self</span>)</span>:</span><br><span class="line">        <span class="keyword">object</span>.<span class="constructor">__setattr__(<span class="params">self</span>, &#x27;<span class="params">__storage__</span>&#x27;, &#123;&#125;)</span></span><br><span class="line">        <span class="keyword">object</span>.<span class="constructor">__setattr__(<span class="params">self</span>, &#x27;<span class="params">__ident_func__</span>&#x27;, <span class="params">get_ident</span>)</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>由于可能有大量的Local对象，为了节省Local对象占用的空间，这里使用 <code>__slots__</code> 写死了Local可以拥有的属性：</p><ul><li>__storage__： 值为一个字典，用来保存实际的数据，初始化为空；</li><li>__ident_func__：值为一个函数，用来找到当前线程或者协程的标志符。</li></ul><p>由于Local对象实际的数据保存在__storage__中，所以对Local属性的操作其实是对__storage__的操作。对于获取属性而言，这里用魔术方法<code>__getattr__</code>拦截__storage__ 和 __ident_func__以外的属性获取，将其导向__storage__存储的当前线程或协程的数据。而对于属性值的set或者del，则分别用__setattr__和__setattr__来实现（这些魔术方法的介绍见<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python/Class.md#%E5%B1%9E%E6%80%A7%E6%8E%A7%E5%88%B6">属性控制</a>）。关键代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">    ident = self.__ident_func__()</span><br><span class="line">    storage = self.__storage__</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        storage[ident][name] = value</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__delattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(name)</span><br></pre></td></tr></table></figure><p>假设我们有ID为1，2， … ， N 的N个线程或者协程，每个都用Local对象保存有自己的一些局部数据，那么Local对象的内容如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161103_threadlocal_enhance_1.png"></p><p>此外，Local类还提供了<code>__release_local__</code>方法，用来释放当前线程或者协程保存的数据。</p><h1 id="Local-扩展接口"><a href="#Local-扩展接口" class="headerlink" title="Local 扩展接口"></a>Local 扩展接口</h1><p>Werkzeug 在 Local 的基础上实现了 LocalStack 和 LocalManager，用来提供更加友好的接口支持。</p><h2 id="LocalStack"><a href="#LocalStack" class="headerlink" title="LocalStack"></a>LocalStack</h2><p>LocalStack通过封装Local从而实现了一个线程（或者协程）独立的栈结构，注释里面有具体的使用方法，一个简单的使用例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls = LocalStack()</span><br><span class="line">ls.push(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span> ls.top    <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span> ls._local.__storage__</span><br><span class="line"><span class="comment"># &#123;140735190843392: &#123;&#x27;stack&#x27;: [12]&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>LocalStack 的实现比较有意思，它将一个Local对象作为自己的属性<code>_local</code>，然后定义接口push, pop 和 top 方法进行相应的栈操作。这里用 <strong>_local.__storage__.[_local.__ident_func__()][‘stack’]</strong> 这个list来模拟栈结构。在接口push, pop和top中，通过操作这个list来模拟栈的操作，需要注意的是在接口函数内部获取这个list时，不用像上面黑体那么复杂，可以直接用_local的getattr()方法即可。以 push 函数为例，实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, obj</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Pushes a new item to the stack&quot;&quot;&quot;</span></span><br><span class="line">    rv = <span class="built_in">getattr</span>(self._local, <span class="string">&#x27;stack&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._local.stack = rv = []</span><br><span class="line">    rv.append(obj)</span><br><span class="line">    <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure><p>pop 和 top 的实现和一般栈类似，都是对 <code>stack = getattr(self._local, &#39;stack&#39;, None)</code> 这个列表进行相应的操作。此外，LocalStack还允许我们自定义<code>__ident_func__</code>，这里用 <a href="https://docs.python.org/2/library/functions.html#property">内置函数 property</a> 生成了<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python/Descriptor.md">描述器</a>，封装了__ident_func__的get和set操作，提供了一个属性值__ident_func__作为接口，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get__ident_func__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self._local.__ident_func__</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_set__ident_func__</span>(<span class="params">self, value</span>):</span><br><span class="line">    <span class="built_in">object</span>.__setattr__(self._local, <span class="string">&#x27;__ident_func__&#x27;</span>, value)</span><br><span class="line">__ident_func__ = <span class="built_in">property</span>(_get__ident_func__, _set__ident_func__)</span><br><span class="line"><span class="keyword">del</span> _get__ident_func__, _set__ident_func__</span><br></pre></td></tr></table></figure><h1 id="LocalManager"><a href="#LocalManager" class="headerlink" title="LocalManager"></a>LocalManager</h1><p>Local 和 LocalStack 都是线程或者协程独立的单个对象，很多时候我们需要一个线程或者协程独立的容器，来组织多个Local或者LocalStack对象（就像我们用一个list来组织多个int或者string类型一样）。</p><p>Werkzeug实现了LocalManager，它通过一个list类型的属性locals来存储所管理的Local或者LocalStack对象，还提供cleanup方法来释放所有的Local对象。Werkzeug中LocalManager最主要的接口就是<a href="http://selfboot.cn/2014/08/10/python_decorator/">装饰器</a>方法<code>make_middleware</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_middleware</span>(<span class="params">self, app</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Wrap a WSGI application so that cleaning up happens after</span></span><br><span class="line"><span class="string">    request end.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">        <span class="keyword">return</span> ClosingIterator(app(environ, start_response), self.cleanup)</span><br><span class="line">    <span class="keyword">return</span> application</span><br></pre></td></tr></table></figure><p>这个装饰器注册了回调函数cleanup，当一个线程（或者协程）处理完请求之后，就会调用cleanup清理它所管理的Local或者LocalStack 对象（ClosingIterator 的实现在 <a href="https://github.com/pallets/werkzeug/blob/master/werkzeug/wsgi.py">werkzeug.wsgi</a>中）。下面是一个使用 LocalManager 的简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local, LocalManager</span><br><span class="line"></span><br><span class="line">local = Local()</span><br><span class="line">local_2 = Local()</span><br><span class="line">local_manager = LocalManager([local, local2])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">    local.request = request = Request(environ)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># application 处理完毕后，会自动清理local_manager 的内容</span></span><br><span class="line">application = local_manager.make_middleware(application)</span><br></pre></td></tr></table></figure><p>通过LocalManager的make_middleware我们可以在某个线程（协程）处理完一个请求后，清空所有的Local或者LocalStack对象，这样这个线程又可以处理另一个请求了。至此，文章开始时提到的第二个问题就可以解决了。Werkzeug.local 里面还实现了一个 LocalProxy 用来作为Local对象的代理，也非常值得去学习。</p><p>通过这三篇文章，相信对 ThreadLocal 有了一个初步的了解。Python标准库和Werkzeug在实现中都用到了很多python的黑魔法，不过最终提供给用户的都是非常友好的接口。Werkzeug作为WSGI 工具集，为了解决Web开发中的特定使用问题，提供了一个改进版本，并且进行了一系列封装，便于使用。不得不说，werkzeug的代码可读性非常好，注释也是写的非常棒，建议去阅读源码。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://werkzeug.pocoo.org/docs/0.11/local/">Context Locals</a><br><a href="https://docs.python.org/2/tutorial/classes.html#private-variables-and-class-local-references">Private Variables and Class-local References</a><br><a href="http://stackoverflow.com/questions/17330160/how-does-the-property-decorator-work">How does the @property decorator work?</a><br><a href="http://stackoverflow.com/questions/350404/how-do-the-proxy-decorator-adapter-and-bridge-patterns-differ/350471#350471">How do the Proxy, Decorator, Adapter, and Bridge Patterns differ?</a></p><p><a href="http://mingxinglai.com/cn/2016/08/flask-source-code/">Flask源码剖析</a><br><a href="https://www.15yan.com/story/j7BfM4NHEI9/">Werkzeug.locals 模块解读</a><br><a href="http://www.zlovezl.cn/articles/charming-python-start-from-flask-request/">Charming Python: 从Flask的request说起</a><br><a href="http://stackoverflow.com/questions/11277432/how-to-remove-a-key-from-a-python-dictionary">How to remove a key from a python dictionary?</a><br><a href="https://www.ficapy.com/2016/08/03/werkzeug_local_note/">werkzeug源码分析(local.py)</a></p>]]></content>
    
    
    <summary type="html">本文详细分析了 ThreadLocal 变量的使用和实现，包括 Werkzeug 中的 ThreadLocal 设计和实现。通过阅读本文，您可以更好地理解 Python 的并发编程和线程管理，提升您的编程技能。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Flask" scheme="https://selfboot.cn/tags/Flask/"/>
    
    <category term="Thread" scheme="https://selfboot.cn/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建论坛（三）：Flask框架简单介绍</title>
    <link href="https://selfboot.cn/2016/10/30/forum_design_flask/"/>
    <id>https://selfboot.cn/2016/10/30/forum_design_flask/</id>
    <published>2016-10-30T22:02:50.000Z</published>
    <updated>2023-06-05T12:31:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>前面两篇文章中我们已经了解 Web(HTTP)服务器，Web应用程序，Web框架，WSGI这些 Python Web 开发中的概念。我们知道，Web框架通过将不同Web应用程序中的共性部分给抽象出来，提供一系列通用的接口，从而避免开发者做重复性工作，让其将精力放在业务相关的实现。</p><p>接下来一起来看一个具体的 Web 框架，这里选择 Flask，因为它是一个年轻充满活力的微框架，有着众多的拥护者，文档齐全，社区活跃度高。我们的<a href="https://github.com/xuelangZF/NaHan">论坛项目</a> 就使用了该框架。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161030_forum_design_flask_1.png"></p><span id="more"></span><h1 id="Flask-框架"><a href="#Flask-框架" class="headerlink" title="Flask 框架"></a>Flask 框架</h1><p>为了理解 Flask 框架是如何抽象出Web开发中的共同部分，我们先来看看Web应用程序的一般流程。对于Web应用来说，当客户端想要获取<strong>动态资源</strong>时，就会发起一个HTTP请求（比如用浏览器访问一个 URL），Web应用程序会在后台进行相应的业务处理，（从数据库或者进行一些计算操作等）取出用户需要的数据，生成相应的HTTP响应（当然，如果访问静态资源，则直接返回资源即可，不需要进行业务处理）。整个处理过程如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161030_forum_design_flask_2.png"></p><p>实际应用中，<strong>不同的请求可能会调用相同的处理逻辑</strong>。这里有着相同业务处理逻辑的 HTTP 请求可以用一类 URL 来标识。比如论坛站点中，对于所有的获取Topic内容的请求而言，可以用 <code>topic/&lt;topic_id&gt;/</code> 这类URL来表示，这里的 topic_id 用以区分不同的topic。接着在后台定义一个 <code>get_topic(topic_id)</code> 的函数，用来获取topic相应的数据，此外还需要建立URL和函数之间的一一对应关系。这就是Web开发中所谓的<strong>路由分发</strong>，如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161030_forum_design_flask_3.png"></p><p>Flask底层使用<a href="https://github.com/pallets/werkzeug">werkzeug</a>来做路由分发，代码写起来十分简单，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/topic/&lt;int:topic_id&gt;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_topic</span>(<span class="params">topic_id</span>):</span><br><span class="line">    <span class="comment"># Do some cal or read from database</span></span><br><span class="line">    <span class="comment"># Get the data we need.</span></span><br></pre></td></tr></table></figure><p>通过业务逻辑函数拿到数据后，接下来需要根据这些数据生成HTTP响应（对于Web应用来说，HTTP响应一般是一个HTML文件）。Web开发中的一般做法是提供一个HTML模板文件，然后将数据传入模板，经过渲染后得到最终需要的HTML响应文件。</p><p>一种比较常见的场景是，<strong>请求虽然不同，但响应中数据的展示方式是相同的</strong>。仍以论坛为例，对不同topic而言，其具体topic content虽然不同，但页面展示的方式是一样的，都有标题拦，内容栏等。也就是说，对于 topic 来说，我们只需提供一个HTML模板，然后传入不同topic数据，即得到不同的HTTP响应。这就是所谓的<strong>模板渲染</strong>，如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20161030_forum_design_flask_4.png"></p><p>Flask 使用 <a href="https://github.com/pallets/jinja">Jinja2</a> 模板渲染引擎来做模板渲染，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/topic/&lt;int:topic_id&gt;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_topic</span>(<span class="params">topic_id</span>):</span><br><span class="line">    <span class="comment"># Do some cal or read from database</span></span><br><span class="line">    <span class="comment"># Get the data we need.</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;path/to/template.html&#x27;</span>, data_needed)</span><br></pre></td></tr></table></figure><p>总结一下，Flask处理一个请求的流程就是，首先根据 URL 决定由那个函数来处理，然后在函数中进行操作，取得所需的数据。再将数据传给相应的模板文件中，由Jinja2 负责渲染得到 HTTP 响应内容，然后由Flask返回响应内容。</p><h1 id="Flask-入门"><a href="#Flask-入门" class="headerlink" title="Flask 入门"></a>Flask 入门</h1><p>关于 Flask 框架的学习，不建议直接读<a href="http://flask.pocoo.org/docs/0.11/">官网文档</a>，虽然这是一手的权威资料，但并不适合初学者入手。这里推荐几个学习资料，可以帮助新手很快的入门：</p><p>汇智网<a href="http://www.hubwiz.com/course/562427361bc20c980538e26f/">flask框架</a>教程：一个非常适合入门的精简教程，主要分为七部分：</p><ul><li>快速入门</li><li>路由：URL 规则与视图函数</li><li>请求、应答与会话</li><li>上下文对象：Flask 核心机制</li><li>模版：分离数据与视图</li><li>访问数据库：SQLAlchemy简介</li><li>蓝图：Flask应用组件化</li></ul><p>教程简练地总结了 Flask 最核心的内容，并且还提供了一个简单的在线练习环境，方便一边学习理论一边动手实践。</p><p>此外，麦子学院也有一个 <a href="http://www.maiziedu.com/course/313/">Flask入门</a> 视频教程，一共8小时的视频教程，涵盖flask web 开发的方方面面，包括环境的搭建，flask 语法介绍，项目结构的组织，flask 全球化，单元测试等内容。视频作者有 17 年软件开发经验，曾任微软深圳技术经理及多家海外机构担任技术顾问，够牛！视频讲的也确实不错。</p><p>如果上面两个不能满足你，那么还可以看 <a href="https://book.douban.com/subject/26274202/">Flask Web开发：基于Python的Web应用开发实战</a> 这本有着 8.6 评分的书，相信没看完就跃跃欲试想写点什么了。这么优秀的框架，Github 上当然也有 <a href="https://github.com/humiaozuzu/awesome-flask">awesome-flask</a>了，想深入学习flask的话，这里不失为一个好的资源帖。</p><p>本篇大概谈了下 Flask 的路由分发和模版渲染，下篇我们会继续讲Flask使用中的一些问题。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks">What is the purpose of Flask’s context stacks?</a><br><a href="https://blog.tonyseek.com/post/the-context-mechanism-of-flask/">Flask 的 Context 机制</a><br><a href="http://python.jobbole.com/81396/">Flask、Django、Pyramid三个框架的对比</a></p>]]></content>
    
    
    <summary type="html">探索如何使用Flask设计论坛的全过程。这篇文章详细介绍了从零开始搭建论坛的步骤，包括数据库设计、用户管理、帖子发布等关键功能的实现。适合对Flask和Web开发感兴趣的读者。</summary>
    
    
    
    <category term="项目实践" scheme="https://selfboot.cn/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Flask" scheme="https://selfboot.cn/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的未定义行为</title>
    <link href="https://selfboot.cn/2016/09/18/c++_undefined_behaviours/"/>
    <id>https://selfboot.cn/2016/09/18/c++_undefined_behaviours/</id>
    <published>2016-09-18T22:02:50.000Z</published>
    <updated>2023-06-05T12:31:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们需要一个程序从控制台读入一个 INT 型整数（输入确保是INT），然后输出其绝对值，你可能闭着眼睛就会写出下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">abs</span>(n) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等下，好好思考两分钟，然后写几个测试例子跑一下程序。那么你找出程序存在的问题了吗？好了，欢迎走进未定义行为 (Undefined Behavior) 的世界。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160918_ub.png"></p><span id="more"></span><h1 id="什么是未定义行为"><a href="#什么是未定义行为" class="headerlink" title="什么是未定义行为"></a>什么是未定义行为</h1><p>文章一开始的程序中用到了 abs 求绝对值函数，当n为 INT_MIN 时，函数返回什么呢？<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf">C++ 标准</a>中有这么一条：</p><blockquote><p>If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.</p></blockquote><p>在一个2进制系统中，当 n 是 INT_MIN 时，<code>int abs(int n)</code> 返回的值超出了 int 的范围，所以这将导致一个未定义行为。很多时候，标准过于精炼，不便于我们快速查找，因此我们可以在 <a href="http://en.cppreference.com/w/cpp">cppreference</a> 找到需要的信息，以 abs函数为例，cppreference 明确指出可能导致未定义行为：</p><blockquote><p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.</p></blockquote><p>那么到底什么是未定义行为呢？简单来说，就是某个操作逻辑上是不合法的，比如越界访问数组等，但是C++ 标准并没有告诉我们遇到这种情况该如何去处理。</p><p>我们知道在大部分语言（比如 Python 和 Java）中，一个语句要么按照我们的预期正确执行，要么立即抛出异常。但是在 C++ 中，还有一种情况就是，某条语句并没有按照预期执行（逻辑上已经出错了），但是程序还是可以继续执行（C++标准没有告诉怎么继续执行）。只不过程序的行为已经不可预测了，也就是说程序可能发生运行时错误，也可能给出错误的结果，甚至还可能给出正确的结果。</p><p>有一点需要注意的是，对于有的未定义行为，现代编译器有时候可以给出警告，或者是编译失败的提示信息。此外，不同编译器对于未定义行为的处理方式也不同。</p><h1 id="常见的未定义行为"><a href="#常见的未定义行为" class="headerlink" title="常见的未定义行为"></a>常见的未定义行为</h1><p>C++ 标准中有大量的未定义行为，如果在标准中查找 <code>undefined behavior</code>，将会看到几十条相关内容。如此众多的未定义行为，无疑给我们带来了许多麻烦，下面我们将列出一些常见的未定义行为，写程序时应该尽量避免。</p><p>指针相关的常见未定义行为有如下内容：</p><ul><li>解引用 nullptr 指针；</li><li>解引用一个未初始化的指针；</li><li>解引用 new 操作失败返回的指针；</li><li>指针访问越界（解引用一个超出数组边界的指针）；</li><li>解引用一个指向已销毁对象的指针；</li></ul><p>解引用一个指向已销毁对象的指针，有时候很容易就会犯这个错误，例如在<a href="https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Function.md#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">函数中返回局部指针地址</a>。 一些简单的错误代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">get</span><span class="params">(<span class="type">int</span> tmp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *foo = <span class="built_in">get</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; *foo &lt;&lt; std::endl; <span class="comment">// Undefined Behavior;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; *(arr+<span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// Undefined Behavior;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *bar=<span class="number">0</span>;</span><br><span class="line">    *bar = <span class="number">2</span>;                       <span class="comment">// Undefined Behavior;</span></span><br><span class="line">    std::cout &lt;&lt; *bar &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他常见未定义行为如下：</p><ul><li>有符号整数溢出（文章开头的例子）；</li><li>整数做左移操作时，移动的位数为负数；</li><li>整数做移位操作时，移动的位数超出整型占的位数。（int64_t i &#x3D; 1; i &lt;&lt;&#x3D; 72）；</li><li>尝试修改字符串字面值或者常量的内容；</li><li>对自动初始化且没有赋初值的变量进行操作；（int i; i++; cout &lt;&lt; i;）</li><li>在有返回值的函数结束时不返回内容；</li></ul><p>更完整的未定义行为列表可以在<a href="http://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviours-that-a-c-programmer-should-know-a">这里</a>找到。</p><h1 id="为什么存在未定义行为"><a href="#为什么存在未定义行为" class="headerlink" title="为什么存在未定义行为"></a>为什么存在未定义行为</h1><p>C++ 程序经常因为未定义行为而出现各种千奇百怪的 Bug，调试起来也十分困难。相反，其他很多语言中并没有未定义行为，比如 python，当访问 list 越界时会抛出 <code>list index out of range</code>，这些语言中不会因为未定义行为出现各种奇怪的错误。那么为什么 C++ 标准为什么要搞这么多未定义行为呢？</p><p>原因是这样可以<strong>简化编译器的工作，有时候还可以产生更加高效的代码</strong>。举个例子来说，如果我们想让解引用指针的操作行为变的明确起来（成功或者抛出异常），就需要在编译期知道指针使用是否合法，那么编译器至少需要做下面这些工作：</p><ul><li>检查指针是否为 nullptr；</li><li>通过某种机制检查指针保存的地址是否合法；</li><li>通过某种机制抛出错误</li></ul><p>这样的话编译器的实现会复杂很多。此外，如果我们有一个循环需要对大量的指针进行操作，那么编译生成的代码就会因为做各种附加检查而导致效率低下。</p><p>实际上，很多未定义行为，都是因为程序违反了某一先决条件而导致的，比如赋给指针的地址值必须是可访问的，数组访问时下标在正确的范围内。对 C++来说，语言设计者认为这是程序员（大家都是成年人了）需要保证的内容，语言层面并不会去做相应的检查。</p><p>不过，好消息是现在很多编译器已经可以诊断出一些可能导致未定义行为的操作，可以帮我们写出更加健壮的程序。</p><h1 id="其他一些行为"><a href="#其他一些行为" class="headerlink" title="其他一些行为"></a>其他一些行为</h1><p>C++ 标准还规定了一些 <strong>Unspecified Behavior</strong>，一个简单的例子（一个大公司曾经的笔试题目）如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Cal</span>(<span class="built_in">get</span>(<span class="number">0</span>), <span class="built_in">get</span>(<span class="number">10</span>)) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出多少？答案是视编译器而定，可能是0 10 12，也可能是 10 0 12。这是因为<strong>函数参数的执行顺序是 Unspecified Behavior</strong>，引用C++标准对 Unspecified Behavior 的说明：</p><blockquote><p>Unspecified behavior use of an unspecified value, or other behavior where this International Standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance.</p></blockquote><p>此外，C++标准中还有所谓的 <code>implementation-defined behavior</code>，比如C++标准说需要一个数据类型，然后具体的编译器去选择该类型占用的字节数，或者是存储方式（大端还是小端）。</p><p>一般情况下，我们需要关心的只有未定义行为，因为它通常会导致程序出错。而其他的两种行为，不需要我们去关心。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://en.cppreference.com/w/cpp/language/ub">Cppreference：Undefined behavior</a><br><a href="http://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviours-that-a-c-programmer-should-know-a">What are all the common undefined behaviors that a C++ programmer should know about? </a><br><a href="http://stackoverflow.com/questions/98340/what-are-the-common-undefined-unspecified-behavior-for-c-that-you-run-into">What are the common undefined&#x2F;unspecified behavior for C that you run into?</a><br><a href="http://stackoverflow.com/questions/9566187/function-parameter-evaluation-order">function parameter evaluation order</a><br><a href="http://blog.regehr.org/archives/213">A Guide to Undefined Behavior in C and C++, Part 1</a><br><a href="http://blog.regehr.org/archives/213">A Guide to Undefined Behavior in C and C++, Part 2</a><br><a href="https://www.quora.com/Why-is-there-so-much-undefined-behaviour-in-C++-Wouldnt-it-be-better-if-some-of-them-were-pre-defined-in-the-standard">Why is there so much undefined behavior in C++? </a><br><a href="http://www.cplusplus.com/reference/cstdlib/abs/?kw=abs">Cplusplus: abs</a><br><a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">What Every C Programmer Should Know About Undefined Behavior</a><br><a href="http://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points">Undefined behavior and sequence points</a><br><a href="http://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior">Undefined, unspecified and implementation-defined behavior</a><br><a href="http://stackoverflow.com/questions/81656/where-do-i-find-the-current-c-or-c-standard-documents">Where do I find the current C or C++ standard documents?</a></p>]]></content>
    
    
    <summary type="html">深入探讨C++中的未定义行为。这篇文章详细解释了未定义行为的概念，以及为什么它们存在，以及如何避免它们。对于希望提高C++编程技能的读者来说，这是一篇不容错过的文章。</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>被忽视的 partition 算法</title>
    <link href="https://selfboot.cn/2016/09/01/lost_partition/"/>
    <id>https://selfboot.cn/2016/09/01/lost_partition/</id>
    <published>2016-09-01T12:02:08.000Z</published>
    <updated>2023-06-05T12:31:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>如果你学习过算法，那么肯定听说过快速排序的大名，但是对于快速排序中用到的 partition 算法，你了解的够多吗？或许是快速排序太过于光芒四射，使得我们往往会忽视掉同样重要的 partition 算法。</p><p>Partition 可不只用在快速排序中，还可以用于 <a href="https://en.wikipedia.org/wiki/Selection_algorithm">Selection algorithm</a>（在无序数组中寻找第K大的值）中。甚至有可能正是这种<strong>通过一趟扫描来进行分类的思想</strong>激发 Edsger Dijkstra 想出了 Three-way Partitioning，高效地解决了 <a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">Dutch national flag problem</a> 问题。接下来我们一起来探索 partition 算法。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160901_lost_partition_1.png" alt="Partition 一次扫描进行划分"></p><span id="more"></span><h1 id="Partition-实现"><a href="#Partition-实现" class="headerlink" title="Partition 实现"></a>Partition 实现</h1><p>快速排序中用到的 partition 算法思想很简单，首先从无序数组中选出枢轴点 pivot，然后通过一趟扫描，以 pivot 为分界线将数组中其他元素分为两部分，使得左边部分的数小于等于枢轴，右边部分的数大于等于枢轴（左部分或者右部分都可能为空），最后返回枢轴在新的数组中的位置。</p><p>Partition 的一个直观简单实现如下（这里取数组的第一个元素为pivot）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do partition in arr[begin, end), with the first element as the pivot.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[begin];</span><br><span class="line">    <span class="comment">// Last position where puts the no_larger element.</span></span><br><span class="line">    <span class="type">int</span> pos = begin;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=begin+<span class="number">1</span>; i!=end; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= pivot)&#123;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">if</span>(i!=pos)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[pos], arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[begin], arr[pos]);</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果原始数组为[5,9,2,1,4,7,5,8,3,6]，那么整个处理的过程如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160901_lost_partition_2.png" alt="Partition 简单实现"></p><p>这种实现思路比较直观，但是其实并不高效。从直观上来分析一下，每个小于pivot的值<strong>基本上</strong>（除非到现在为止还没有遇见大于pivot的值）都需要一次交换，大于pivot的值（例如上图中的数字9）有可能需要被交换多次才能到达最终的位置。</p><p>如果我们考虑用 <a href="https://github.com/xuelangZF/LeetCode/tree/master/TwoPointers">Two Pointers</a> 的思想，保持头尾两个指针向中间扫描，每次在头部找到大于pivot的值，同时在尾部找到小于pivot的值，然后将它们做一个交换，就可以一次把这两个数字放到最终的位置。一种比较明智的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[begin];</span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end &amp;&amp; arr[--end] &gt;= pivot);</span><br><span class="line">        arr[begin] = arr[end];</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end &amp;&amp; arr[++begin] &lt;= pivot);</span><br><span class="line">        arr[end] = arr[begin];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[begin] = pivot;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是第一次看到上面的代码，那么停下来，好好品味一下。这里没有用到 swap 函数，但其实也相当于做了 swap 操作。以前面的数组为例，看看以这种方法来做的话，整个处理的流程。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160901_lost_partition_3.png" alt="Partition 高效实现"></p><p>直观上来看，赋值操作的次数不多，比前面单向扫描的swap次数都少，效率应该会更高。<a href="http://cs.stackexchange.com/questions/11458/quicksort-partitioning-hoare-vs-lomuto/11550">这里</a>从理论上对这两种方法进行了分析，有兴趣可以看看。</p><h1 id="Partition-应用"><a href="#Partition-应用" class="headerlink" title="Partition 应用"></a>Partition 应用</h1><p>我们都知道经典的快速排序就是首先用 partition 将数组分为两部分，然后分别对左右两部分递归进行快速排序，过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt;= end - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">partition</span>(arr, begin, end);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, begin, pos);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, pos+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然快排用到了经典的<strong>分而治之</strong>的思想，但是快排实现的前提还是在于 partition 函数。正是有了 partition 的存在，才使得可以将整个大问题进行划分，进而分别进行处理。</p><p>除了用来进行快速排序，partition 还可以用 O(N) 的平均时间复杂度<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">从无序数组中寻找第K大的值</a>。和快排一样，这里也用到了分而治之的思想。首先用 partition 将数组分为两部分，得到分界点下标 pos，然后分三种情况：</p><ul><li>pos &#x3D;&#x3D; k-1，则找到第 K 大的值，arr[pos]；</li><li>pos &gt; k-1，则第 K 大的值在左边部分的数组。</li><li>pos &lt; k-1，则第 K 大的值在右边部分的数组。</li></ul><p>下面给出基于迭代的实现（这里寻找第 k 小的数字）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_kth_number</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> begin = <span class="number">0</span>, end = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">assert</span>(k&gt;<span class="number">0</span> &amp;&amp; k&lt;=end);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end)&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">partition</span>(arr, begin, end);</span><br><span class="line">        <span class="keyword">if</span>(pos == k<span class="number">-1</span>)&#123;</span><br><span class="line">            target_num = arr[pos];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; k<span class="number">-1</span>)&#123;</span><br><span class="line">            end = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            begin = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的时间复杂度是多少呢？考虑最坏情况下，每次 partition 将数组分为长度为 N-1 和 1 的两部分，然后在长的一边继续寻找第 K 大，此时时间复杂度为 O(N^2 )。不过如果在开始之前将数组进行随机打乱，那么可以尽量避免最坏情况的出现。而在最好情况下，每次将数组均分为长度相同的两半，运行时间 T(N) &#x3D; N + T(N&#x2F;2)，时间复杂度是 O(N)。</p><h1 id="Partition-进阶"><a href="#Partition-进阶" class="headerlink" title="Partition 进阶"></a>Partition 进阶</h1><p>接下来先考虑这样一个<a href="https://leetcode.com/problems/sort-colors/">问题</a>，给定红、白、蓝三种颜色的小球若干个，将其排成一列，使相同颜色的小球相邻，三种颜色先后顺序为红，白，蓝。这就是经典的 <a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">Dutch national flag problem</a>。</p><p>我们可以针对红，蓝，白三种颜色的球分别计数，然后根据计数结果来重新放球。不过如果我们将问题进一步抽象，也就是说将一个数组按照某个target值分为三部分，使得左边部分的值小于 target，中间部分等于 target，右边部分大于 target，这样就不能再用简单的计数来确定排序后的结果。这时候，就可以用到另一种 partition 算法：three-way-partition。它的思路稍微复杂一点，用<strong>三个指针</strong>将数组分为四个部分，通过一次扫描最终将数组分为 &lt;，&#x3D;，&gt; 的三部分，如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160901_lost_partition_4.png" alt="三分划分"></p><p>可以结合下面代码来理解具体的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume target is in the arr.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">three_way_partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> next_less_pos = <span class="number">0</span>, next_bigger_pos = arr.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> next_scan_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (next_scan_pos &lt;= next_bigger_pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[next_scan_pos] &lt; target)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[next_scan_pos++], arr[next_less_pos++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[next_scan_pos] &gt; target)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[next_scan_pos], arr[next_bigger_pos--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            next_scan_pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的主要思想就是在一遍扫描中，通过交换不同位置的数字，使得数组最终可以维持一定的顺序，和前面快排中用到的 partition 思想一致。区别在于快排按照 pivot 将数组分为两部分，左右部分中的值都可能等于 pivot，而 three-way-partition 将数组分为 &lt;, &#x3D;, &gt;的三部分。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://algs4.cs.princeton.edu/lectures/23DemoPartitioning.pdf">Algorithms 4.0: DemoPartitioning</a><br><a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">Dutch national flag problem</a><br><a href="https://www.cise.ufl.edu/class/cot3100fa07/quicksort_analysis.pdf">Time complexity of quick-sort in detail</a><br><a href="http://cs.stackexchange.com/questions/11458/quicksort-partitioning-hoare-vs-lomuto/11550">Quicksort Partitioning: Hoare vs. Lomuto</a><br><a href="http://blog.csdn.net/pongba/article/details/2544933">数学之美番外篇：快排为什么那样快</a></p>]]></content>
    
    
    <summary type="html">详细介绍了partition算法的实现，包括在快速排序和选择算法中的应用，以及如何解决荷兰国旗问题。此外，我们还探讨了partition算法的进阶内容，包括三分划分和其在数组排序中的应用。无论你是算法初学者，还是希望提高算法技能的专业人士，这里都能为你提供深入浅出的理解和实用的知识。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Python中的ThreadLocal变量（中）</title>
    <link href="https://selfboot.cn/2016/08/26/threadlocal_implement/"/>
    <id>https://selfboot.cn/2016/08/26/threadlocal_implement/</id>
    <published>2016-08-26T00:02:50.000Z</published>
    <updated>2023-06-05T12:31:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="http://selfboot.cn/2016/08/22/threadlocal_overview/">深入理解Python中的ThreadLocal变量（上）</a> 中我们看到 ThreadLocal 的引入，使得可以很方便地在多线程环境中使用局部变量。如此美妙的功能到底是怎样实现的？如果你对它的实现原理没有好奇心或一探究竟的冲动，那么接下来的内容估计会让你后悔自己的浅尝辄止了。</p><p>简单来说，Python 中 ThreadLocal 就是通过<a name="img_1"></a>下图中的方法，将全局变量伪装成线程局部变量，相信读完本篇文章你会理解图中内容的。（对这张图不眼熟的话，可以回顾下<a href="(http://selfboot.cn/2016/08/22/threadlocal_overview/)">上篇</a>）。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160826_threadlocal_implement_1.png" alt="ThreadLocal 实现机制"></p><span id="more"></span><h1 id="在哪里找到源码？"><a href="#在哪里找到源码？" class="headerlink" title="在哪里找到源码？"></a>在哪里找到源码？</h1><p>好了，终于要来分析 ThreadLocal 是如何实现的啦，不过，等等，怎么找到它的源码呢？上一篇中我们只是用过它（<code>from threading import local</code>），从这里只能看出它是在 threading 模块实现的，那么如何找到 threading 模块的源码呢。</p><p>如果你在使用 PyCharm，恭喜你，你可以用 <code>View source</code>（OS X 快捷键是 ⌘↓）找到 local 定义的地方。现在许多 IDE 都有这个功能，可以查看 IDE 的帮助来找到该功能。接着我们就会发现 local 是这样子的（这里以 python 2.7 为例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get thread-local implementation, either from the thread</span></span><br><span class="line"><span class="comment"># module, or from the python fallback</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> thread <span class="keyword">import</span> _local <span class="keyword">as</span> local</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> _threading_local <span class="keyword">import</span> local</span><br></pre></td></tr></table></figure><p>嗯，自带解释，非常好。我们要做的是继续往下深挖具体实现，用同样的方法（⌘↓）找 _local 的实现，好像不太妙，没有找到纯 python 实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_local</span>(object):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot; Thread-local data &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    def __delattr__(self, name): <span class="meta"># real signature unknown; restored from __doc__</span></span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot; x.__delattr__(&#x27;name&#x27;) &lt;==&gt; del x.name &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        pass</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>没关系，继续来看下_threading_local吧，这下子终于找到了local的纯 python 实现。开始就是很长的一段注释文档，告诉我们这个模块是什么，如何用。这个文档的质量非常高，值得我们去学习。所以，再次后悔自己的浅尝辄止了吧，差点错过了这么优秀的文档范文！</p><h2 id="将源码私有化"><a href="#将源码私有化" class="headerlink" title="将源码私有化"></a>将源码私有化</h2><p>在具体动手分析这个模块之前，我们先把它拷出来放在一个单独的文件 <code>thread_local.py</code> 中，这样可以方便我们随意肢解它（比如在适当的地方加上log），并用修改后的实现验证我们的一些想法。此外，如果你真的理解了_threading_local.py最开始的一段，你就会发现这样做是多么的有必要。因为python的threading.local不一定是用的_threading_local（还记得class _local(object) 吗？）。</p><p>所以如果你用 threading.local 来验证自己对_threading_local.py的理解，你很可能会一头雾水的。不幸的是，我开始就这样干的，所以被下面的代码坑了好久：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> local, current_thread</span><br><span class="line">data = local()</span><br><span class="line">key = <span class="built_in">object</span>.__getattribute__(data, <span class="string">&#x27;_local__key&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> current_thread().__dict__.get(key)</span><br><span class="line"><span class="comment"># AttributeError: &#x27;thread._local&#x27; object has no attribute &#x27;_local__key&#x27;</span></span><br></pre></td></tr></table></figure><p>当然，你可能不理解这里是什么意思，没关系，我只是想强调在 threading.local 没有用到_threading_local.py，你必须要创建一个模块（我将它命名为 thread_local.py）来保存_threading_local里面的内容，然后像下面这样验证自己的想法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"><span class="keyword">from</span> thread_local <span class="keyword">import</span> local</span><br><span class="line"></span><br><span class="line">data = local()</span><br><span class="line">key = <span class="built_in">object</span>.__getattribute__(data, <span class="string">&#x27;_local__key&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> current_thread().__dict__.get(key)</span><br></pre></td></tr></table></figure><h1 id="如何去理解源码"><a href="#如何去理解源码" class="headerlink" title="如何去理解源码"></a>如何去理解源码</h1><p>现在可以静下心来读读这不到两百行的代码了，不过，等等，好像有许多奇怪的内容（黑魔法）：</p><ul><li><a href="https://docs.python.org/2/reference/datamodel.html#slots">__slots__</a></li><li><a href="https://docs.python.org/2.7/reference/datamodel.html#basic-customization">__new__</a></li><li><a href="https://docs.python.org/2.7/reference/datamodel.html#customizing-attribute-access">__getattribute__／__setattr__／__delattr__</a></li><li><a href="https://docs.python.org/2/library/threading.html#rlock-objects">Rlock</a></li></ul><p>这些是什么？如果你不知道，没关系，千万不要被这些纸老虎吓到，我们有丰富的文档，查文档就对了（这里不建议直接去网上搜相关关键字，最好是先读文档，读完了有疑问再去搜）。</p><h2 id="python-黑魔法"><a href="#python-黑魔法" class="headerlink" title="python 黑魔法"></a>python 黑魔法</h2><p>下面是我对上面提到的内容的一点总结，如果觉得读的明白，那么可以继续往下分析源码了。如果还有不理解的，再读几遍文档（或者我错了，欢迎指出来）。</p><ul><li>简单来说，python 中创建一个<strong>新式类</strong>的实例时，首先会调用<code>__new__(cls[, ...])</code>创建实例，如果它成功返回cls类型的对象，然后才会调用__init__来对对象进行初始化。</li><li>新式类中我们可以用__slots__指定该类可以拥有的属性名称，这样每个对象就不会再创建__dict__，从而节省对象占用的空间。特别需要注意的是，基类的__slots__并不会屏蔽派生类中__dict__的创建。</li><li>可以通过重载<code>__setattr__，__delattr__和__getattribute__</code>这些方法，来控制自定义类的属性访问（x.name），它们分别对应属性的赋值，删除，读取。</li><li>锁是操作系统中为了保证操作原子性而引入的概念，python 中 RLock是一种可重入锁（reentrant lock，也可以叫作递归锁），Rlock.acquire()可以不被阻塞地多次进入同一个线程。</li><li><code>__dict__</code>用来保存对象的（可写）属性，可以是一个字典，或者其他映射对象。</li></ul><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>对这些相关的知识有了大概的了解后，再读源码就亲切了很多。为了彻底理解，我们首先回想下<strong>平时是如何使用local对象的，然后分析源码在背后的调用流程</strong>。这里从定义一个最简单的thread-local对象开始，也就是说当我们写下下面这句时，发生了什么？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> = local()</span></span><br></pre></td></tr></table></figure><p>上面这句会调用 <code>_localbase.__new__</code> 来为data对象设置一些属性（还不知道有些属性是做什么的，不要怕，后面遇见再说），然后将data的属性字典(<code>__dict__</code>)作为当前线程的一个属性值（这个属性的 key 是根据 id(data) 生成的身份识别码）。</p><p>这里很值得玩味：在创建ThreadLocal对象时，同时在线程（也是一个对象，没错万物皆对象）的属性字典<code>__dict__</code>里面保存了ThreadLocal对象的属性字典。还记得文章开始的<a href="#img_1">图片</a>吗，红色虚线就表示这个操作。</p><p>接着我们考虑在线程 Thread-1 中对ThreadLocal变量进行一些常用的操作，比如下面的一个操作序列：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">data</span>.name = <span class="string">&quot;Thread 1(main)&quot;</span> <span class="comment"># 调用 __setattr__</span></span><br><span class="line"><span class="built_in">print</span> <span class="title">data</span>.name     <span class="comment"># 调用 __getattribute__</span></span><br><span class="line">del <span class="title">data</span>.name       <span class="comment"># 调用 __delattr__</span></span><br><span class="line"><span class="built_in">print</span> <span class="title">data</span>.__dict__</span><br><span class="line"><span class="comment"># Thread 1(main)</span></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>那么背后又是如何操作的呢？上面的操作包括了给属性赋值，读属性值，删除属性。这里我们以__getattribute__的实现为例（读取值）进行分析，属性的__setattr__和__delattr__和前者差不多，区别在于禁止了对__dict__属性的更改以及删除操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">    lock = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;_local__lock&#x27;</span>)</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        _patch(self)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, name)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        lock.release()</span><br></pre></td></tr></table></figure><p>函数中首先获得了ThreadLocal变量的<code>_local__lock</code>属性值（知道这个变量从哪里来的吗，回顾下_localbase吧），然后用它来保证 <code>_patch(self)</code> 操作的原子性，还用 <strong>try-finally 保证即使抛出了异常也会释放锁资源，避免了线程意外情况下永久持有锁而导致死锁</strong>。现在问题是_patch究竟做了什么？答案还是在源码中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_patch</span>(<span class="params">self</span>):</span><br><span class="line">    key = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;_local__key&#x27;</span>)  <span class="comment"># ThreadLocal变量 的标识符</span></span><br><span class="line">    d = current_thread().__dict__.get(key)  <span class="comment"># ThreadLocal变量在该线程下的数据</span></span><br><span class="line">    <span class="keyword">if</span> d <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        current_thread().__dict__[key] = d</span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__dict__&#x27;</span>, d)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we have a new instance dict, so call out __init__ if we have one</span></span><br><span class="line">        cls = <span class="built_in">type</span>(self)</span><br><span class="line">        <span class="keyword">if</span> cls.__init__ <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">object</span>.__init__:</span><br><span class="line">            args, kw = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;_local__args&#x27;</span>)</span><br><span class="line">            cls.__init__(self, *args, **kw)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__dict__&#x27;</span>, d)</span><br></pre></td></tr></table></figure><p>_patch做的正是整个ThreadLocal实现中最核心的部分，<strong>从当前正在执行的线程对象那里拿到该线程的私有数据，然后将其交给ThreadLocal变量</strong>，就是本文开始<a href="#img_1">图片</a>中的虚线2。这里需要补充说明以下几点：</p><ul><li>这里说的线程的私有数据，其实就是指通过x.name可以拿到的数据（其中 x 为ThreadLocal变量）</li><li>主线程中在创建ThreadLocal对象后，就有了对应的数据（还记得红色虚线的意义吗？）</li><li>对于那些第一次访问ThreadLocal变量的线程来说，需要创建一个空的字典来保存私有数据，然后还要调用该变量的初始化函数。</li><li>还记得_localbase基类里__new__函数设置的属性   _local__args 吗？在这里被用来进行初始化。</li></ul><p>到此，整个源码核心部分已经理解的差不多了，只剩下<code>local.__del__</code>用来执行清除工作。因为每次创建一个ThreadLocal 变量，都会在进程对象的__dict__中添加相应的数据，当该变量被回收时，我们需要在相应的线程中删除保存的对应数据。</p><h1 id="从源码中学到了什么？"><a href="#从源码中学到了什么？" class="headerlink" title="从源码中学到了什么？"></a>从源码中学到了什么？</h1><p>经过一番努力，终于揭开了 ThreadLocal 的神秘面纱，整个过程可以说是收获颇丰，下面一一说来。</p><p>不得不承认，计算机基础知识很重要。你得知道进程、线程是什么，CPU 的工作机制，什么是操作的原子性，锁是什么，为什么锁使用不当会导致死锁等等。</p><p>其次就是语言层面的知识也必不可少，就ThreadLocal的实现来说，如果对__new__，__slots__等不了解，根本不知道如何去做。所以，学语言还是要有深度，不然下面的代码都看不懂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">dict_test</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = dict_test()</span><br><span class="line"><span class="built_in">print</span> d.__dict__</span><br><span class="line">d.__dict__ = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;value&#x27;</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="built_in">print</span> d.name</span><br></pre></td></tr></table></figure><p>还有就是高质量的功能实现需要考虑各方各面的因素，以ThreadLocal 为例，在基类_localbase中用__slots__节省空间，用try…finally保证异常环境也能正常释放锁，最后还用__del__来及时的清除无效的信息。</p><p>最后不得不说，好的文档和注释简直就是画龙点睛，不过<strong>写文档和注释是门技术活，绝对需要不断学习的</strong>。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init">Python’s use of __new__ and __init__?</a><br><a href="http://spyhce.com/blog/understanding-new-and-init">Understanding __new__ and __init__</a><br><a href="http://stackoverflow.com/questions/472000/usage-of-slots">Usage of __slots__?</a><br><a href="https://pymotw.com/2/weakref/">weakref – Garbage-collectable references to objects</a><br><a href="https://www.quora.com/How-do-I-find-the-source-code-of-a-function-in-Python">How do I find the source code of a function in Python?</a><br><a href="http://stackoverflow.com/questions/269795/how-do-i-find-the-location-of-python-module-sources">How do I find the location of Python module sources?</a><br><a href="http://stackoverflow.com/questions/9728243/is-self-dict-updatekwargs-good-or-poor-style">Is self.__dict__.update(**kwargs) good or poor style?</a><br><a href="https://docs.python.org/2/library/weakref.html">Doc: weakref — Weak references</a><br><a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python/Class.md#%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84">python class 全面分析</a></p><p><a href="http://vincestyling.com/posts/2014/how-am-i-read-open-source-projects-code.html">我是如何阅读开源项目的源代码的</a><br><a href="http://blog.a0z.me/2016/04/28/how-to-read-open-project/">高效阅读源代码指南</a><br><a href="https://www.zhihu.com/question/19625320">如何阅读程序源代码？</a><br><a href="http://www.cnblogs.com/ToDoToTry/archive/2009/06/21/1507760.html">如何看懂源代码–(分析源代码方法)</a></p>]]></content>
    
    
    <summary type="html">深入探讨Python中ThreadLocal变量的实现。这篇文章详细介绍了ThreadLocal变量的工作原理，以及如何在Python中实现它。对于希望深入理解Python多线程编程的读者来说，这是一篇必读的文章。</summary>
    
    
    
    <category term="源码剖析" scheme="https://selfboot.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Thread" scheme="https://selfboot.cn/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Python中的ThreadLocal变量（上）</title>
    <link href="https://selfboot.cn/2016/08/22/threadlocal_overview/"/>
    <id>https://selfboot.cn/2016/08/22/threadlocal_overview/</id>
    <published>2016-08-22T22:02:50.000Z</published>
    <updated>2023-06-05T12:31:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道多线程环境下，每一个线程均可以使用所属进程的全局变量。如果一个线程对全局变量进行了修改，将会影响到其他所有的线程。为了避免多个线程同时对变量进行修改，引入了线程同步机制，通过互斥锁，条件变量或者读写锁来控制对全局变量的访问。</p><p>只用全局变量并不能满足多线程环境的需求，很多时候线程还需要拥有自己的私有数据，这些数据对于其他线程来说不可见。因此线程中也可以使用局部变量，局部变量只有线程自身可以访问，同一个进程下的其他线程不可访问。</p><p>有时候使用局部变量不太方便，因此 python 还提供了 ThreadLocal 变量，它本身是一个全局变量，但是每个线程却可以利用它来保存属于自己的私有数据，这些私有数据对其他线程也是不可见的。下图给出了线程中这几种变量的存在情况：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160822_threadlocal_overview_1.png" alt="线程变量"></p><span id="more"></span><h1 id="全局-VS-局部变量"><a href="#全局-VS-局部变量" class="headerlink" title="全局 VS 局部变量"></a>全局 VS 局部变量</h1><p>首先借助一个小程序来看看多线程环境下全局变量的同步问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">global_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_cal</span>():</span><br><span class="line">    <span class="keyword">global</span> global_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        global_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get 10 threads, run them and wait them all finished.</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    threads.append(threading.Thread(target=thread_cal))</span><br><span class="line">    threads[i].start()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    threads[i].join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Value of global variable can be confused.</span></span><br><span class="line"><span class="built_in">print</span> global_num</span><br></pre></td></tr></table></figure><p>这里我们创建了10个线程，每个线程均对全局变量 global_num 进行1000次的加1操作（循环1000次加1是为了延长单个线程执行时间，使线程执行时被中断切换），当10个线程执行完毕时，全局变量的值是多少呢？答案是不确定。简单来说是因为 <code>global_num += 1</code> 并不是一个原子操作，因此执行过程可能被其他线程中断，导致其他线程读到一个脏值。以两个线程执行 +1 为例，其中一个可能的执行序列如下（此情况下最后结果为1）：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160822_threadlocal_overview_2.png" alt="多线程全局变量同步"></p><p>多线程中使用全局变量时普遍存在这个问题，解决办法也很简单，可以使用互斥锁、条件变量或者是读写锁。下面考虑用互斥锁来解决上面代码的问题，只需要在进行 +1 运算前加锁，运算完毕释放锁即可，这样就可以保证运算的原子性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = threading.Lock()</span><br><span class="line">...</span><br><span class="line">    l.acquire()</span><br><span class="line">    global_num += <span class="number">1</span></span><br><span class="line">    l.release()</span><br></pre></td></tr></table></figure><p>在线程中使用局部变量则不存在这个问题，因为每个线程的局部变量不能被其他线程访问。下面我们用10个线程分别对各自的局部变量进行1000次加1操作，每个线程结束时打印一共执行的操作次数（每个线程均为1000）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span> threading.current_thread().getName(), num</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_cal</span>():</span><br><span class="line">    local_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        local_num += <span class="number">1</span></span><br><span class="line">    show(local_num)</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    threads.append(threading.Thread(target=thread_cal))</span><br><span class="line">    threads[i].start()</span><br></pre></td></tr></table></figure><p>可以看出这里每个线程都有自己的 local_num，各个线程之间互不干涉。</p><h1 id="Thread-local-对象"><a href="#Thread-local-对象" class="headerlink" title="Thread-local 对象"></a>Thread-local 对象</h1><p>上面程序中我们需要给 show 函数传递 local_num 局部变量，并没有什么不妥。不过考虑在实际生产环境中，我们可能会调用很多函数，每个函数都需要很多局部变量，这时候用传递参数的方法会很不友好。</p><p>为了解决这个问题，一个直观的的方法就是建立一个全局字典，保存进程 ID 到该进程局部变量的映射关系，运行中的线程可以根据自己的 ID 来获取本身拥有的数据。这样，就可以避免在函数调用中传递参数，如下示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">global_data = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    cur_thread = threading.current_thread()</span><br><span class="line">    <span class="built_in">print</span> cur_thread.getName(), global_data[cur_thread]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_cal</span>():</span><br><span class="line">    cur_thread = threading.current_thread()</span><br><span class="line">    global_data[cur_thread] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        global_data[cur_thread] += <span class="number">1</span></span><br><span class="line">    show()  <span class="comment"># Need no local variable.  Looks good.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>保存一个全局字典，然后将线程标识符作为key，相应线程的局部数据作为 value，这种做法并不完美。首先，每个函数在需要线程局部数据时，都需要先取得自己的线程ID，略显繁琐。更糟糕的是，这里并没有真正做到线程之间数据的隔离，因为每个线程都可以读取到全局的字典，每个线程都可以对字典内容进行更改。</p><p>为了更好解决这个问题，python 线程库实现了 ThreadLocal 变量（很多语言都有类似的实现，比如Java）。ThreadLocal 真正做到了线程之间的数据隔离，并且使用时不需要手动获取自己的线程 ID，如下示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">global_data = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    <span class="built_in">print</span> threading.current_thread().getName(), global_data.num</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_cal</span>():</span><br><span class="line">    global_data.num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        global_data.num += <span class="number">1</span></span><br><span class="line">    show()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Main thread: &quot;</span>, global_data.__dict__ <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>上面示例中每个线程都可以通过 global_data.num 获得自己独有的数据，并且每个线程读取到的 global_data 都不同，真正做到线程之间的隔离。</p><p>Python通过 local 类来实现 ThreadLocal 变量，代码量不多（只有100多行），但是比较难理解，涉及很多 Python 黑魔法，<a href="http://selfboot.cn/2016/08/26/threadlocal_implement/">下一篇</a>再来详细分析。那么 ThreadLocal 很完美了？不！Python 的 WSGI 工具库 werkzeug 中有一个更好的 <a href="https://github.com/pallets/werkzeug/blob/8a84b62b3dd89fe7d720d7948954e20ada690c40/werkzeug/local.py">ThreadLocal 实现</a>，甚至支持协程之间的私有数据，实现更加复杂，有机会再分析。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://stackoverflow.com/questions/1408171/thread-local-storage-in-python">Thread local storage in Python</a><br><a href="https://pymotw.com/2/threading/">threading – Manage concurrent threads</a><br><a href="https://harveyqing.gitbooks.io/python-read-and-write/content/python_advance/python_thread_sync.html">Python线程同步机制</a><br><a href="http://www.cnblogs.com/vamei/archive/2012/10/09/2715393.html">Linux多线程与同步</a><br><a href="https://www.quora.com/Are-local-variables-in-a-python-function-thread-safe">Are local variables in a python function thread safe?</a></p>]]></content>
    
    
    <summary type="html">这篇文章详细解释了ThreadLocal变量的概念，以及它在多线程环境下的使用场景和优点。对于希望提高Python多线程编程技能的读者来说，这是一篇不容错过的文章。</summary>
    
    
    
    <category term="程序设计" scheme="https://selfboot.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Thread" scheme="https://selfboot.cn/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建论坛（二）：Web服务器网关接口</title>
    <link href="https://selfboot.cn/2016/08/07/forum_design_wsgi/"/>
    <id>https://selfboot.cn/2016/08/07/forum_design_wsgi/</id>
    <published>2016-08-07T22:02:50.000Z</published>
    <updated>2023-06-05T12:31:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="http://selfboot.cn/2016/07/28/forum_design_framework/">从零开始搭建论坛（一）：Web服务器与Web框架</a> 中我们弄清楚了Web 服务器、Web 应用程序、Web框架的概念。对于 Python 来说，越来越多的 Web 框架面世，在给我们更多选择机会的同时，也限制了我们对于 Web Server 的选择。同样是有着很多 Web 框架的Java，因为有着 servlet API 的存在，任何Java Web框架写的应用程序都可以运行在任意一个 Web Server 上。</p><p>Python 社区当然也需要这样一套 API，来适配Web服务器和应用程序，这套 API 就是 WSGI（Python Web Server Gateway Interface），在 <a href="https://www.python.org/dev/peps/pep-3333/">PEP 3333</a> 里有详细的说明。简单来说，WSGI是连接Web服务器和Web应用程序的桥梁，一方面从Web server 拿到原始 HTTP 数据，处理成统一格式后交给 Web 应用程序，另一方面从应用程序／框架这边进行业务逻辑处理，生成响应内容后交给服务器。</p><p>Web服务器和框架通过 WSGI 来进行耦合的详细过程如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160807_forum_design_WSGI_1.png" alt="WSGI Server 适配"></p><span id="more"></span><p>具体解释如下：</p><ul><li>应用程序（网络框架）提供一个命名为application的可调用对象（WSGI协议并没有指定如何实现这个对象）。</li><li>服务器每次从HTTP客户端接收请求之后，调用可调用对象application，调用时传递一个名叫environ的字典作为参数，以及一个名为start_response的可调用对象。</li><li>框架&#x2F;应用生成HTTP状态码以及HTTP响应报头，然后将二者传递至start_response，等待服务器保存。此外，框架&#x2F;应用还将返回响应的正文。</li><li>服务器将状态码、响应报头和响应正文组合成HTTP响应，并返回给客户端（这一步并不属于WSGI协议）。</li></ul><p>下面分别从服务器端和应用程序端来看看 WSGI 是如何做适配的。</p><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>我们知道客户端（通常是浏览器）发出的每个HTTP请求由请求行、消息报头、请求正文三部分组成，里面包含了本次请求的相关细节内容。比如：</p><ul><li>Method：指出在由Request-URI标识的资源上所执行的方法，包括GET，POST 等</li><li>User-Agent：允许客户端将它的操作系统、浏览器和其它属性告诉服务器；</li></ul><p>服务器从客户端接收HTTP请求之后，WSGI 接口必须要对这些请求字段进行统一化处理，方便传给应用服务器接口（其实就是给框架）。Web服务器具体传递哪些数据给应用程序，早在<a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>（Common Gateway Interface，通用网关接口）里就有详细规定，这些数据被叫做 CGI 环境变量。WSGI 沿用了 CGI 环境变量的内容，要求 Web 服务器必须创建一个字典用来保存这些环境变量（一般将其命名为 <code>environ</code>）。除了 CGI 定义的变量，environ 还必须保存一些WSGI定义的变量，此外还可以保存一些客户端系统的环境变量，可以参考 <a href="https://www.python.org/dev/peps/pep-3333/#environ-variables">environ Variables</a> 来看看具体有哪些变量。</p><p>接着 WSGI 接口必须将 environ 交给应用程序去处理，这里 WSGI 规定应用程序提供一个可调用对象 application，然后服务器去调用 application，获得返回值为HTTP响应正文。服务器在调用 application 的时候，需要提供两个变量，一个是前面提到的变量字典environ，另一个是可调用对象 start_response，它产生状态码和响应头，这样我们就得到了一个完整的HTTP响应。Web 服务器将响应返回给客户端，一次完整的<code>HTTP请求－响应</code>过程就完成了。</p><h2 id="wsgiref-分析"><a href="#wsgiref-分析" class="headerlink" title="wsgiref 分析"></a>wsgiref 分析</h2><p>Python 中内置了一个实现了WSGI接口的 Web 服务器，在模块<a href="https://docs.python.org/2.7/library/wsgiref.html">wsgiref</a>中，它是用纯Python编写的WSGI服务器的参考实现，我们一起来简单分析一下它的实现。首先假设我们用下面代码启动一个 Web 服务器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Instantiate the server</span></span><br><span class="line">httpd = make_server(</span><br><span class="line">    <span class="string">&#x27;localhost&#x27;</span>,    <span class="comment"># The host name</span></span><br><span class="line">    <span class="number">8051</span>,           <span class="comment"># A port number where to wait for the request</span></span><br><span class="line">    application     <span class="comment"># The application object name, in this case a function</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for a single request, serve it and quit</span></span><br><span class="line">httpd.handle_request()</span><br></pre></td></tr></table></figure><p>然后我们以Web服务器接收一个请求、生成 environ，然后调用 application 来处理请求这条主线来分析源码的调用过程，简化如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160807_forum_design_WSGI_2.png" alt="WSGI Server 调用流程"></p><p>这里主要有三个类，WSGIServer，WSGIRequestHandler，ServerHandle。WSGIServer 是Web服务器类，可以提供server_address（IP:Port）和 WSGIRequestHandler 类来进行初始化获得一个server对象。该对象监听响应的端口，收到HTTP请求后通过 finish_request 创建一个RequestHandler 类的实例，在该实例的初始化过程中会生成一个 Handle 类实例，然后调用其 run(application) 函数，在该函数里面再调用应用程序提供的 application对象来生成响应。</p><p>这三个类的继承关系如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160807_forum_design_WSGI_3.png" alt="WSGI 类继承关系图"></p><p>其中 TCPServer 使用 socket 来完成 TCP 通信，HTTPServer 则是用来做 HTTP 层面的处理。同样的，StreamRequestHandler 来处理 stream socket，BaseHTTPRequestHandler 则是用来处理 HTTP 层面的内容，这部分和 WSGI 接口关系不大，更多的是 Web 服务器的具体实现，可以忽略。</p><h2 id="微服务器实例"><a href="#微服务器实例" class="headerlink" title="微服务器实例"></a>微服务器实例</h2><p>如果上面的 wsgiref 过于复杂的话，下面一起来实现一个微小的 Web 服务器，便于我们理解 Web 服务器端 WSGI 接口的实现。代码摘自 <a href="http://codingpy.com/article/build-a-simple-web-server-part-two/">自己动手开发网络服务器（二）</a>，放在 <a href="https://gist.github.com/xuelangZF/217b1b6ab34ec33c3ca155ce681f72ad">gist</a> 上，主要结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WSGIServer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 套接字参数</span></span><br><span class="line">    address_family, socket_type = socket.AF_INET, socket.SOCK_STREAM</span><br><span class="line">    request_queue_size = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, server_address</span>):</span><br><span class="line">        <span class="comment"># TCP 服务端初始化：创建套接字，绑定地址，监听端口</span></span><br><span class="line">        <span class="comment"># 获取服务器地址，端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_app</span>(<span class="params">self, application</span>):</span><br><span class="line">        <span class="comment"># 获取框架提供的 application</span></span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serve_forever</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 处理 TCP 连接：获取请求内容，调用处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_request</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 解析 HTTP 请求，获取 environ，处理请求内容，返回HTTP响应结果</span></span><br><span class="line">        env = self.get_environ()</span><br><span class="line">        result = self.application(env, self.start_response)</span><br><span class="line">        self.finish_response(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_request</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="comment"># 解析 HTTP 请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_environ</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 分析 environ 参数，这里只是示例，实际情况有很多参数。</span></span><br><span class="line">        env[<span class="string">&#x27;wsgi.url_scheme&#x27;</span>]   = <span class="string">&#x27;http&#x27;</span></span><br><span class="line">        ...</span><br><span class="line">        env[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>]    =  self.request_method    <span class="comment"># GET</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> env</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_response</span>(<span class="params">self, status, response_headers, exc_info=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># 添加响应头，状态码</span></span><br><span class="line">        self.headers_set = [status, response_headers + server_headers]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finish_response</span>(<span class="params">self, result</span>):</span><br><span class="line">        <span class="comment"># 返回 HTTP 响应信息</span></span><br><span class="line"></span><br><span class="line">SERVER_ADDRESS = (HOST, PORT) = <span class="string">&#x27;&#x27;</span>, <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个服务器实例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_server</span>(<span class="params">server_address, application</span>):</span><br><span class="line">    server = WSGIServer(server_address)</span><br><span class="line">    server.set_app(application)</span><br><span class="line">    <span class="keyword">return</span> server</span><br></pre></td></tr></table></figure><p>目前支持 WSGI 的成熟Web服务器有很多，<a href="http://gunicorn.org/">Gunicorn</a>是相当不错的一个。它脱胎于ruby社区的Unicorn，成功移植到python上，成为一个WSGI HTTP Server。有以下优点：</p><ul><li>容易配置</li><li>可以自动管理多个worker进程</li><li>选择不同的后台扩展接口（sync, gevent, tornado等）</li></ul><h1 id="应用程序端（框架）"><a href="#应用程序端（框架）" class="headerlink" title="应用程序端（框架）"></a>应用程序端（框架）</h1><p>和服务器端相比，应用程序端（也可以认为框架）要做的事情就简单很多，它只需要提供一个可调用对象（一般习惯将其命名为application），这个对象接收服务器端传递的两个参数 environ 和 start_response。这里的可调用对象不仅可以是函数，还可以是类（下面第二个示例）或者拥有 <code>__call__</code> 方法的实例，总之只要<strong>可以接受前面说的两个参数，并且返回值可以被服务器进行迭代即可</strong>。</p><p>Application 具体要做的就是根据 environ 里面提供的关于 HTTP 请求的信息，进行一定的业务处理，返回一个可迭代对象，服务器端通过迭代这个对象，来获得 HTTP 响应的正文。如果没有响应正文，那么可以返回None。</p><p>同时，application 还会调用服务器提供的 start_response，产生HTTP响应的状态码和响应头，原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_response</span>(<span class="params">self, status, headers,exc_info=<span class="literal">None</span></span>):</span><br></pre></td></tr></table></figure><p>Application 需要提供 status：一个字符串，表示HTTP响应状态字符串，还有 response_headers: 一个列表，包含有如下形式的元组：(header_name, header_value)，用来表示HTTP响应的headers。同时 exc_info 是可选的，用于出错时，server需要返回给浏览器的信息。</p><p>到这里为止，我们就可以实现一个简单的 application 了，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_app</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Simplest possible application function&quot;&quot;&quot;</span></span><br><span class="line">    HELLO_WORLD = <span class="string">&quot;Hello world!\n&quot;</span></span><br><span class="line">    status = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line">    response_headers = [(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [HELLO_WORLD]</span><br></pre></td></tr></table></figure><p>或者用类实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppClass</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Produce the same output, but using a class&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.start = start_response</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        HELLO_WORLD = <span class="string">&quot;Hello world!\n&quot;</span></span><br><span class="line">        <span class="keyword">yield</span> HELLO_WORLD</span><br></pre></td></tr></table></figure><p>注意这里 <code>AppClass</code> 类本身就是 application，用 environ 和 start_response 调用（实例化）它返回一个实例对象，这个实例对象本身是可迭代的，符合 WSGI 对 application 的要求。</p><p>如果想使用 AppClass 类的对象作为 application，那么必须给类添加一个 <code>__call__</code> 方法，接受 environ 和 start_response 为参数，返回可迭代对象，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppClass</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Produce the same output, but using an object&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这部分涉及到python的一些高级特性，比如 yield 和 magic method，可以参考我总结的<a href="https://github.com/xuelangZF/CS_Offer/tree/master/Python">python语言要点</a>来理解。</p><h2 id="Flask-中的-WSGI"><a href="#Flask-中的-WSGI" class="headerlink" title="Flask 中的 WSGI"></a>Flask 中的 WSGI</h2><p>flask 是一个轻量级的Python Web框架，符合 WSGI 的规范要求。它的最初版本只有 600 多行，相对便于理解。下面我们来看下它最初版本中关于 WSGI 接口的部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wsgi_app</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;The actual WSGI application.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is not implemented in `__call__` so that middlewares can be applied:</span></span><br><span class="line"><span class="string">        app.wsgi_app = MyMiddleware(app.wsgi_app)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> self.request_context(environ):</span><br><span class="line">        rv = self.preprocess_request()</span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            rv = self.dispatch_request()</span><br><span class="line">        response = self.make_response(rv)</span><br><span class="line">        response = self.process_response(response)</span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Shortcut for :attr:`wsgi_app`&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> self.wsgi_app(environ, start_response)</span><br></pre></td></tr></table></figure><p>这里的 wsgi_app 实现了我们说的 application 功能，rv 是 对请求的封装，response 是框架用来处理业务逻辑的具体函数。这里对 flask 源码不做过多解释，感兴趣的可以去github下载，然后check 到最初版本去查看。</p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>前面 flask 代码 wsgi_app 函数的注释中提到不直接在 <code>__call__</code> 中实现 application 部分，是为了可以使用<code>中间件</code>。 那么为什么要使用中间件，中间件又是什么呢？</p><p>回顾前面的 application&#x2F;server 端接口，对于一个 HTTP 请求，server 端总是会调用一个 application 来进行处理，并返回 application 处理后的结果。这足够应付一般的场景了，不过并不完善，考虑下面的几种应用场景：</p><ul><li>对于不同的请求（比如不同的 URL），server 需要调用不同的 application，那么如何选择调用哪个呢；</li><li>为了做负载均衡或者是远程处理，需要使用网络上其他主机上运行的 application 来做处理；</li><li>需要对 application 返回的内容做一定处理后才能作为 HTTP 响应；</li></ul><p>上面这些场景有一个共同点就是，有一些必需的操作不管放在服务端还是应用（框架）端都不合适。对应用端来说，这些操作应该由服务器端来做，对服务器端来说，这些操作应该由应用端来做。为了处理这种情况，引入了<code>中间件</code>。</p><p>中间件就像是应用端和服务端的桥梁，来沟通两边。对服务器端来说，中间件表现的像是应用端，对应用端来说，它表现的像是服务器端。如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160807_forum_design_WSGI_4.png" alt="中间件"></p><h2 id="中间件的实现"><a href="#中间件的实现" class="headerlink" title="中间件的实现"></a>中间件的实现</h2><p>flask 框架在 Flask 类的初始化代码中就使用了中间件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.wsgi_app = SharedDataMiddleware(self.wsgi_app, &#123; self.static_path: target &#125;)</span><br></pre></td></tr></table></figure><p>这里的作用和 python 中的装饰器一样，就是在执行 self.wsgi_app 前后执行 SharedDataMiddleware 中的一些内容。中间件做的事，很类似python中装饰器做的事情。SharedDataMiddleware 中间件是 <a href="https://github.com/pallets/werkzeug/blob/2e9f5c0d0c1c36b612f6797c00f8c6ac3ba7b1db/werkzeug/wsgi.py">werkzeug</a> 库提供的，用来支持站点托管静态内容。此外，还有DispatcherMiddleware 中间件，用来支持根据不同的请求，调用不同的 application，这样就可以解决前面场景 1, 2 中的问题了。</p><p>下面来看看 DispatcherMiddleware 的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DispatcherMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Allows one to mount middlewares or applications in a WSGI application.</span></span><br><span class="line"><span class="string">    This is useful if you want to combine multiple WSGI applications::</span></span><br><span class="line"><span class="string">        app = DispatcherMiddleware(app, &#123;</span></span><br><span class="line"><span class="string">            &#x27;/app2&#x27;:        app2,</span></span><br><span class="line"><span class="string">            &#x27;/app3&#x27;:        app3</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, app, mounts=<span class="literal">None</span></span>):</span><br><span class="line">        self.app = app</span><br><span class="line">        self.mounts = mounts <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, environ, start_response</span>):</span><br><span class="line">        script = environ.get(<span class="string">&#x27;PATH_INFO&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        path_info = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> script:</span><br><span class="line">            <span class="keyword">if</span> script <span class="keyword">in</span> self.mounts:</span><br><span class="line">                app = self.mounts[script]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            script, last_item = script.rsplit(<span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">            path_info = <span class="string">&#x27;/%s%s&#x27;</span> % (last_item, path_info)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            app = self.mounts.get(script, self.app)</span><br><span class="line">        original_script_name = environ.get(<span class="string">&#x27;SCRIPT_NAME&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        environ[<span class="string">&#x27;SCRIPT_NAME&#x27;</span>] = original_script_name + script</span><br><span class="line">        environ[<span class="string">&#x27;PATH_INFO&#x27;</span>] = path_info</span><br><span class="line">        <span class="keyword">return</span> app(environ, start_response)</span><br></pre></td></tr></table></figure><p>初始化中间件时需要提供一个 mounts 字典，用来指定不同 URL 路径到 application 的映射关系。这样对于一个请求，中间件检查其路径，然后选择合适的 application 进行处理。</p><p>关于 WSGI 的原理部分基本结束，下一篇我会介绍下对 flask 框架的理解。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="https://wsgi.readthedocs.io/en/latest/">WSGI Content</a><br><a href="http://wsgi.tutorial.codepoint.net/intro">WSGI Tutorial by Clodoaldo Neto</a><br><a href="http://linuxgazette.net/115/orr.html">WSGI Explorations in Python</a><br><a href="http://codingpy.com/article/build-a-simple-web-server-part-two/">自己动手开发网络服务器（二）</a><br><a href="https://segmentfault.com/a/1190000003069785">WSGI 是什么?</a><br><a href="https://segmentfault.com/a/1190000005640475">自己写一个 wsgi 服务器运行 Django 、Tornado 等框架应用</a><br><a href="https://www.python.org/dev/peps/pep-3333/">PEP 3333 – Python Web Server Gateway Interface v1.0.1</a><br><a href="http://stackoverflow.com/questions/111234/what-is-a-callable-in-python">What is a “callable” in Python?</a></p>]]></content>
    
    
    <summary type="html">详细解析了WSGI的工作原理，以及如何在Python中实现WSGI。这是一个必读的指南，无论你是想要理解WSGI的工作原理，还是想要在自己的项目中实现WSGI。</summary>
    
    
    
    <category term="项目实践" scheme="https://selfboot.cn/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Flask" scheme="https://selfboot.cn/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建论坛（一）：Web服务器与Web框架</title>
    <link href="https://selfboot.cn/2016/07/28/forum_design_framework/"/>
    <id>https://selfboot.cn/2016/07/28/forum_design_framework/</id>
    <published>2016-07-28T22:02:50.000Z</published>
    <updated>2023-06-05T12:31:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>之前用 Django 做过一个小的站点，感觉Django太过笨重，于是就准备换一个比较轻量级的 Web 框架来玩玩。Web.py 作者已经挂掉，项目好久没有更新，所以不准备用它。而 Flask 也是一个成熟的轻量级 Web 框架，在 github 上有众多的 Star 和 Fork，文档和扩展也很丰富，值得学习。</p><p>学习一个框架最好的方式就是用框架做一个项目，在实战中理解掌握框架。这里我用 Flask 框架，使用 Mysql 数据库做了一个<a href="https://github.com/xuelangZF/NaHan">论坛系统</a>。麻雀虽小，五脏俱全，论坛效果图如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_1.png" alt="论坛系统截图"></p><span id="more"></span><p>下面是论坛的基本功能：</p><ul><li>完整的用户模块（注册、登录，更改、找回密码、信息修改、站内消息通知）；</li><li>丰富的论坛模块（创建、回复话题，站内搜索，markdown支持，@user 提醒）；</li><li>强大的后台管理，支持屏蔽用户、话题、评论，支持各种条件搜索话题、评论；</li></ul><p>本博客将会用一系列文章，记录论坛系统搭建的过程，希望对刚入门Web开发的同学有所帮助。</p><p>我们经常听说 Django, Flask 这些 python 语言的<code>Web 框架</code>，那么框架到底是什么，Web框架和Web服务器（Nginx, Apache等）有什么区别？离开框架还能用 Python 搭建Web站点吗？要解决这些疑问，我们有必要来理解下 Web 服务器的工作原理，以及 Web 框架的本质。</p><h1 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h1><p>当我们在浏览器输入URL后，浏览器会先请求<a href="http://selfboot.cn/2015/11/05/dns_theory/">DNS服务器，获得请求站点的 IP 地址</a>。然后发送一个HTTP Request（请求）给拥有该 IP 的主机，接着就会接收到服务器给我们的 HTTP Response（响应），浏览器经过渲染后，以一种较好的效果呈现给我们。这个过程中，正是Web服务器在幕后默默做贡献。</p><p>简单来说，Web服务器是在运行在物理服务器上的一个程序，它永久地等待客户端（主要是浏览器，比如Chrome，Firefox等）发送请求。当收到请求之后，它会生成相应的响应并将其返回至客户端。Web服务器通过HTTP协议与客户端通信，因此也被称为HTTP服务器。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_2.png" alt="Web 服务器"></p><p>Web服务器的工作原理并不复杂，一般可分成如下4个步骤：<code>建立连接、请求过程、应答过程以及关闭连接</code>。</p><ol><li>建立连接：客户机通过TCP&#x2F;IP协议建立到服务器的TCP连接。</li><li>请求过程：客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档。</li><li>应答过程：服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端。由客户端解释HTML文档，在客户端屏幕上渲染图形结果。</li><li>关闭连接：客户机与服务器断开。</li></ol><p>下面我们实现一个简单的 Web 服务器。运行<a href="https://gist.github.com/xuelangZF/19cd52525b64ed3973f480902447a9ea">示例程序</a>后，会监听本地端口 8000，在浏览器访问 <a href="http://localhost:8000/">http://localhost:8000</a> 就能看到响应内容。而我们的程序也能够打印出客户端发来的请求内容，如下图：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_3.png" alt="简单Web服务器"></p><p>这里Request 和 Response 都需要遵守 HTTP 协议，关于 HTTP 协议的详细内容，可以读读《HTTP 权威指南》，或者看我整理的<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Network/HTTP.md">HTTP 部分内容</a>。</p><p>虽然说web服务器的主要工作是根据request返回response，但是实际中的 Web 服务器远远比上面示例的复杂的多，因为要考虑的因素实在是太多了，比如：</p><ul><li>缓存机制：讲一些经常被访问的页面缓存起来，提高响应速度；</li><li>安全：防止黑客的各种攻击，比如 SYN Flood 攻击；</li><li>并发处理：如何响应不同客户端同时发起的请求；</li><li>日志：记录访问日至，方便做一些分析。</li></ul><p>目前在UNIX和LINUX平台下使用最广泛的免费 Web 服务器有Apache和 Nginx 。</p><h1 id="Web-应用程序"><a href="#Web-应用程序" class="headerlink" title="Web 应用程序"></a>Web 应用程序</h1><p>Web 服务器接受 Http Request，返回 Response，很多时候 Response 并不是静态文件，因此需要有一个应用程序根据 Request 生成相应的 Response。这里的应用程序主要用来处理相关业务逻辑，读取或者更新数据库，根据不同 Request 返回相应的 Response。注意这里并不是 Web 服务器本身来做这件事，它只负责 Http 协议层面和一些诸如并发处理，安全，日志等相关的事情。</p><p>应用程序可以用各种语言编写（Java, PHP, Python, Ruby等），这个应用程序会从Web服务器接收客户端的请求，处理完成后，再返回响应给Web服务器，最后由Web服务器返回给客户端。整个架构如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_4.png" alt="Web应用程序"></p><p>以 Python 为例，使用Python开发Web，最原始和直接的办法是使用<a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI标准</a>，在1998年这种方式很流行。首先确保 Web 服务器支持CGI及已经配置了CGI的处理程序，然后设置好CGI目录，在目录里面添加相应的 python 文件，每一个 python 文件处理相应输入，生成一个 html 文件即可，如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Content-type:text/html&quot;</span></span><br><span class="line"><span class="built_in">print</span>  <span class="comment"># 空行，告诉服务器结束头部</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;html&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;head&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;meta charset=&quot;utf-8&quot;&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;/head&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;body&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;h2&gt;Hello Word! 我是一个CGI程序&lt;/h2&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;/body&gt;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&lt;/html&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>这样在浏览器访问该文件就可以得到一个简单的 Hello World 网页内容。直接通过 CGI 写 Web 应用程序看起来很简单，每一个文件处理输入，生成html。但是实际开发中，可能会遇到许多不方便的地方。比如：</p><ul><li>每个独立的CGI脚本可能会重复写数据库连接，关闭的代码；</li><li>后端开发者会看到一堆 Content-Type 等和自己无关的 html 页面元素；</li></ul><h1 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h1><p>早期开发站点确做了许多重复性劳动，后来为了减少重复，避免写出庞杂，混乱的代码，人们将 Web 开发的关键性过程提取出来，开发出了各种 Web 框架。有了框架，就可以专注于编写清晰、易维护的代码，无需关心数据库连接之类的重复性工作。</p><p>其中一种比较经典的Web框架采用了 <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> 架构，如下图所示：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_5.png" alt="MVC 架构"></p><p>用户输入 URL，客户端发送请求，<code>控制器（Controller）</code>首先会拿到请求，然后用<code>模型（Models）</code>从数据库取出所有需要的数据，进行必要的处理，将处理后的结果发送给 <code>视图（View）</code>，视图利用获取到的数据，进行渲染生成 Html Response返回给客户端。</p><p>以 python web 框架 flask 为例，框架本身并不限定我们用哪种架构来组织我们的应用，不过 flask 可以很好地支持以 MVC 方式组织应用。</p><p>控制器：flask 可以用装饰器来添加路由项，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_page</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>模型：主要用来取出需要的数据，如下面函数中操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_page</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Searches the database for entries, then displays them.&quot;&quot;&quot;</span></span><br><span class="line">    db = get_db()</span><br><span class="line">    cur = db.execute(<span class="string">&#x27;select * from entries order by id desc&#x27;</span>)</span><br><span class="line">    entries = cur.fetchall()</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, entries=entries)</span><br></pre></td></tr></table></figure><p>视图：flask 利用 jinja2 来渲染页面，下面的模版文件指定了页面的样式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> entry <span class="keyword">in</span> entries %&#125;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; entry.title &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; entry.text|safe &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">&lt;li&gt;&lt;em&gt;No entries yet. Add some!&lt;/em&gt;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h1 id="Web-服务器网关接口"><a href="#Web-服务器网关接口" class="headerlink" title="Web 服务器网关接口"></a>Web 服务器网关接口</h1><p>我们知道Python有着许多的 Web 框架，而同时又有着许多的 Web 服务器（Apache, Nginx, Gunicorn等），框架和Web服务器之间需要进行通信，如果在设计时它们之间不可以相互匹配的，那么选择了一个框架就会限制对 Web 服务器的选择，这显然是不合理的。</p><p>那么，怎样确保可以在不修改Web服务器代码或网络框架代码的前提下，使用自己选择的服务器，并且匹配多个不同的网络框架呢？答案是接口，设计一套双方都遵守的接口就可以了。对python来说，就是<code>WSGI</code>（Web Server Gateway Interface，Web服务器网关接口）。其他编程语言也拥有类似的接口：例如Java的Servlet API和Ruby的Rack。</p><p>Python WSGI的出现，让开发者可以将 Web 框架与 Web 服务器的选择分隔开来，不再相互限制。现在，你可以真正地将不同的 Web 服务器与Web框架进行混合搭配，选择满足自己需求的组合。例如，可以使用 Gunicorn 或Nginx&#x2F;uWSGI来运行Django、Flask或web.py应用。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160728_forum_design_framework_6.jpeg" alt="WSGI 适配"></p><p><a href="http://selfboot.cn/2016/08/07/forum_design_wsgi/">下一篇</a>我们将会仔细分析 WSGI 接口标准，然后一起来写一个简单的 WSGI Web 服务器。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://codingpy.com/article/build-a-simple-web-server-part-one/">自己动手开发网络服务器（一）</a><br><a href="http://codingpy.com/article/build-a-simple-web-server-part-two/">自己动手开发网络服务器（二）</a><br><a href="http://codingpy.com/article/build-a-simple-web-server-part-three/">自己动手开发网络服务器（三）</a><br><a href="https://www.hitoy.org/principle-of-wsgi.html">Web服务器网关接口实现原理分析</a><br><a href="http://pythonguidecn.readthedocs.io/zh/latest/scenarios/web.html">Python最佳实践指南：Web 应用</a><br><a href="http://feilong.me/2011/01/talk-about-python-web-framework">浅谈Python web框架</a><br><a href="http://www.runoob.com/python/python-cgi.html">Python CGI编程</a><br><a href="https://www.airpair.com/python/posts/django-flask-pyramid">Django vs Flask vs Pyramid: Choosing a Python Web Framework</a><br><a href="https://www.python.org/dev/peps/pep-0333/">PEP 333 – Python Web Server Gateway Interface v1.0</a><br><a href="https://segmentfault.com/a/1190000003069785">WSGI简介</a><br><a href="https://realpython.com/blog/python/the-model-view-controller-mvc-paradigm-summarized-with-legos/">Model-View-Controller (MVC) Explained – With Legos</a></p>]]></content>
    
    
    <summary type="html">本文详细介绍了如何使用Web框架进行论坛设计。从基本概念到实际应用，这篇文章为你提供了全面的指南。如果你正在寻找如何使用Web框架进行项目开发的信息，那么这篇文章是你的理想选择。</summary>
    
    
    
    <category term="项目实践" scheme="https://selfboot.cn/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="Flask" scheme="https://selfboot.cn/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 刷题指南（一）：为什么要刷题</title>
    <link href="https://selfboot.cn/2016/07/24/leetcode_guide_why/"/>
    <id>https://selfboot.cn/2016/07/24/leetcode_guide_why/</id>
    <published>2016-07-24T22:02:50.000Z</published>
    <updated>2023-06-05T12:31:21.467Z</updated>
    
    <content type="html"><![CDATA[<p>虽然刷题一直饱受诟病，不过不可否认刷题确实能锻炼我们的编程能力，相信每个认真刷题的人都会有体会。现在提供在线编程评测的平台有很多，比较有名的有 <a href="http://hihocoder.com/">hihocoder</a>，<a href="http://www.lintcode.com/zh-cn/">LintCode</a>，以及这里我们关注的 <a href="https://leetcode.com/">LeetCode</a>。</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160724_leetcode_guide_1.png" alt="LeetCode"></p><span id="more"></span><p>LeetCode 是一个非常棒的 OJ（Online Judge）平台，收集了许多公司的面试题目。相对其他 OJ 平台而言，有着下面的几个优点：</p><ul><li>题目全部来自业内大公司的真实面试</li><li>不用处理输入输出，精力全放在解决具体问题上</li><li>题目有丰富的讨论，可以参考别人的思路</li><li>精确了解自己代码在所有提交代码中运行效率的排名</li><li>支持多种主流语言：C&#x2F;C++，Python, Java</li><li>可以在线进行测试，方便调试</li></ul><p>下面是我刷 LeetCode 的一些收获，希望能够引诱大家有空时刷刷题目。</p><h1 id="问题：抽象思维"><a href="#问题：抽象思维" class="headerlink" title="问题：抽象思维"></a>问题：抽象思维</h1><p><a href="https://en.wikipedia.org/wiki/George_P%C3%B3lya">波利亚</a>用三本书：《How To Solve It》、《数学的发现》、《数学与猜想》）来试图阐明人类解决问题的一般性的思维方法，总结起来主要有以下几种：</p><ul><li><code>时刻不忘未知量</code>。即时刻别忘记你到底想要求什么，问题是什么。（<a href="https://github.com/xuelangZF/LeetCode/tree/master/DynamicProgramming">动态规划</a>中问题状态的设定）</li><li><code>试错</code>。对题目这里捅捅那里捣捣，用上所有的已知量，或使用所有你想到的操作手法，尝试着看看能不能得到有用的结论，能不能离答案近一步（<a href="https://github.com/xuelangZF/LeetCode/tree/master/Backtracking">回溯算法</a>中走不通就回退）。</li><li><code>求解一个类似的题目</code>。类似的题目也许有类似的结构，类似的性质，类似的解方案。通过考察或回忆一个类似的题目是如何解决的，也许就能够借用一些重要的点子（比较 Ugly Number 的三个题目：<a href="https://leetcode.com/problems/ugly-number/">263. Ugly Number</a>， <a href="https://leetcode.com/problems/ugly-number-ii/">264. Ugly Number II</a>， <a href="https://leetcode.com/problems/super-ugly-number/">313. Super Ugly Number</a>）。</li><li><code>用特例启发思考</code>。通过考虑一个合适的特例，可以方便我们快速寻找出一般问题的解。</li><li><code>反过来推导</code>。对于许多题目而言，其要求的结论本身就隐藏了推论，不管这个推论是充分的还是必要的，都很可能对解题有帮助。</li></ul><p>刷 LeetCode 的最大好处就是可以锻炼解决问题的思维能力，相信我，如何去思考本身也是一个需要不断学习和练习的技能。</p><p>此外，大量高质量的题目可以加深我们对计算机科学中经典数据结构的<code>深刻理解</code>，从而可以快速用合适的数据结构去解决现实中的问题。我们看到很多ACM大牛，拿到题目后立即就能想出解法，大概就是因为他们对于各种数据结构有着深刻的认识吧。LeetCode 上面的题目涵盖了几乎所有常用的数据结构：</p><ul><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/Stack">Stack</a>：简单来说具有后进先出的特性，具体应用起来也是妙不可言，可以看看题目 <a href="https://leetcode.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a>。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/LinkedList">Linked List</a>：链表可以快速地插入、删除，但是查找比较费时（具体操作链表时结合图会简单很多，此外要注意空节点）。通常链表的相关问题可以用双指针巧妙的解决，<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a> 可以帮我们重新审视链表的操作。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/HashTable">Hash Table</a>：利用 Hash 函数来将数据映射到固定的一块区域，方便 O(1) 时间内读取以及修改。<a href="https://leetcode.com/problems/sudoku-solver/">37. Sudoku Solver</a> 数独是一个经典的回溯问题，配合 HashTable 的话，运行时间将大幅减少。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/Tree">Tree</a>：树在计算机学科的应用十分广泛，常用的有二叉搜索树，红黑书，B+树等。树的建立，遍历，删除相对来说比较复杂，通常会用到递归的思路，<a href="https://leetcode.com/problems/path-sum-ii/">113. Path Sum II</a> 是一个不错的开胃菜。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/Heap">Heap</a>：特殊的完全二叉树，“等级森严”，可以用 O(nlogn) 的时间复杂度来进行排序，可以用 O(nlogk) 的时间复杂度找出 n 个数中的最大（小）k个，具体可以看看 <a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a>。</li></ul><h1 id="算法：时间空间"><a href="#算法：时间空间" class="headerlink" title="算法：时间空间"></a>算法：时间空间</h1><p>我们知道，除了数据结构，具体算法在一个程序中也是十分重要的，而算法效率的度量则是时间复杂度和空间复杂度。通常情况下，人们更关注时间复杂度，往往希望找到比 O( n^2 ) 快的算法，在数据量比较大的情况下，算法时间复杂度最好是O(logn)或者O(n)。计算机学科中经典的算法思想就那么多，LeetCode 上面的题目涵盖了其中大部分，下面大致来看下。</p><ul><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/DivideConquer">分而治之</a>：有点类似“大事化小、小事化了”的思想，经典的归并排序和快速排序都用到这种思想，可以看看  <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">Search a 2D Matrix II</a> 来理解这种思想。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/DynamicProgramming">动态规划</a>：有点类似数学中的归纳总结法，找出状态转移方程，然后逐步求解。 <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. Best Time to Buy and Sell Stock with Cooldown</a> 是理解动态规划的一个不错的例子。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/Greedy">贪心算法</a>：有时候只顾局部利益，最终也会有最好的全局收益。<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a> 看看该如何“贪心”。</li><li>搜索算法（<a href="https://github.com/xuelangZF/LeetCode/tree/master/DepthFirstSearch">深度优先</a>，<a href="https://github.com/xuelangZF/LeetCode/tree/master/BreadthFirstSearch">广度优先</a>，<a href="https://github.com/xuelangZF/LeetCode/tree/master/BinarySearch">二分搜索</a>）：在有限的解空间中找出满足条件的解，深度和广度通常比较费时间，二分搜索每次可以将问题规模缩小一半，所以比较高效。</li><li><a href="https://github.com/xuelangZF/LeetCode/tree/master/Backtracking">回溯</a>：不断地去试错，同时要注意回头是岸，走不通就换条路，最终也能找到解决问题方法或者知道问题无解，可以看看 <a href="https://leetcode.com/problems/palindrome-partitioning/">131. Palindrome Partitioning</a>。</li></ul><p>当然，还有一部分问题可能需要一些<a href="https://github.com/xuelangZF/LeetCode/tree/master/Math">数学知识</a>去解决，或者是需要一些<a href="https://github.com/xuelangZF/LeetCode/tree/master/BitManipulation">位运算的技巧</a>去快速解决。总之，我们希望找到时间复杂度低的解决方法。为了达到这个目的，我们可能需要在一个解题方法中融合多种思想，比如在 <a href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a> 中同时用到了动态规划和二分查找的方法，将复杂度控制在 O(nlogn)。如果用其他方法，时间复杂度可能会高很多，这种题目的运行时间统计图也比较有意思，可以看到不同解决方案运行时间的巨大差异，如下：</p><p><img src="https://slefboot-1251736664.cos.ap-beijing.myqcloud.com/20160724_leetcode_guide_2.png" alt="运行时间"></p><p>当然有时候我们会牺牲空间换取时间，比如在动态规划中状态的保存，或者是记忆化搜索，避免在递归中计算重复子问题。<a href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a> 的<a href="https://discuss.leetcode.com/topic/39834/step-by-step-tackling-of-the-problem">一个Discuss</a>会教我们如何用记忆化搜索减少程序执行时间。</p><h1 id="语言：各有千秋"><a href="#语言：各有千秋" class="headerlink" title="语言：各有千秋"></a>语言：各有千秋</h1><p>对一个问题来说，解题逻辑不会因编程语言而不同，但是具体coding起来语言之间的差别还是很大的。用不同语言去解决同一个问题，可以让我们更好地去理解语言之间的差异，以及特定语言的优势。</p><h2 id="速度-VS-代码量"><a href="#速度-VS-代码量" class="headerlink" title="速度 VS 代码量"></a>速度 VS 代码量</h2><p>C++ 以高效灵活著称，LeetCode 很好地印证了这一点。对于绝大多数题目来说，c++ 代码的运行速度要远远超过 python 以及其他语言。和 C++ 相比，Python 允许我们用更少的代码量实现同样的逻辑。通常情况下，Python程序的代码行数只相当于对应的C++代码的行数的三分之一左右。</p><p>以 <a href="https://leetcode.com/problems/top-k-frequent-elements/">347 Top K Frequent Elements</a> 为例，给定一个数组，求数组里出现频率最高的 K 个数字，比如对于数组 [1,1,1,2,2,3]，K&#x3D;2 时，返回 [1,2]。解决该问题的思路比较常规，首先用 hashmap 记录每个数字的出现频率，然后可以用 heap 来求出现频率最高的 k 个数字。</p><p>如果用 python 来实现的话，主要逻辑部分用两行代码就足够了，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_count = collections.Counter(nums)</span><br><span class="line"><span class="keyword">return</span> heapq.nlargest(k, num_count, key=<span class="keyword">lambda</span> x: num_count[x])</span><br></pre></td></tr></table></figure><p>当然了，要想写出短小优雅的 python 代码，需要对 python 思想以及模块有很好的了解。关于 python 的相关知识点讲解，可以参考<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Python.md">这里</a>。</p><p>而用 C++ 实现的话，代码会多很多，带来的好处就是速度的飞跃。具体代码在<a href="https://github.com/xuelangZF/LeetCode/blob/master/Heap/347_TopKFrequentElements.cpp">这里</a>，建立大小为 k 的小顶堆，每次进堆时和堆顶进行比较，核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build the min-heap with size k.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = num_count.<span class="built_in">begin</span>(); it != num_count.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(frequent_heap.<span class="built_in">size</span>() &lt; k)&#123;</span><br><span class="line">        frequent_heap.<span class="built_in">push</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(it-&gt;second &gt;= frequent_heap.<span class="built_in">top</span>().second)&#123;</span><br><span class="line">        frequent_heap.<span class="built_in">pop</span>();</span><br><span class="line">        frequent_heap.<span class="built_in">push</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语言的差异"><a href="#语言的差异" class="headerlink" title="语言的差异"></a>语言的差异</h2><p>我们都知道 c++ 和 python 是不同的语言，它们有着显著的区别，不过一不小心我们就会忘记它们之间的差别，从而写出bug来。不信？来看 <a href="https://leetcode.com/problems/sqrtx/">69 Sqrt(x)</a>，实现 <code>int sqrt(int x)</code>。这题目是经典的二分查找（当然也可以用更高级的牛顿迭代法），用 python 来实现的话很容易写出 <a href="https://github.com/xuelangZF/LeetCode/blob/master/BinarySearch/69_Sqrt_x.py">AC 的代码</a>。</p><p>如果用 C++ 的话，相信很多人也能避开求中间值的整型溢出的坑：<code>int mid = low + (high - low) / 2;</code>，于是写出下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> low = <span class="number">0</span>, high = x;</span><br><span class="line"><span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line"><span class="comment">// int mid = (low+high) / 2,  may overflow.</span></span><br><span class="line">    <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=mid *mid &amp;&amp; x&lt;(mid+<span class="number">1</span>)*(mid+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;mid *mid)</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很可惜，这样的代码仍然存在整型溢出的问题，因为mid*mid 有可能大于 <code>INT_MAX</code>，正确的代码在<a href="https://github.com/xuelangZF/LeetCode/blob/master/BinarySearch/69_Sqrt_x.cpp">这里</a>。当我们被 python 的自动整型转换宠坏后，就很容易忘记c++整型溢出的问题。</p><p>除了臭名昭著的整型溢出问题，c++ 和 python 在位运算上也有着一点不同。以 <a href="https://leetcode.com/problems/sum-of-two-integers/">371 Sum of Two Integers</a> 为例，不用 +, - 实现 int 型的加法 <code>int getSum(int a, int b)</code>。其实就是模拟计算机内部加法的实现，很明显是一个位运算的问题，c++实现起来比较简单，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getSum</span>(a^b, (a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而用 python 的话，情况变的复杂了很多，归根到底还是因为 python 整型的实现机制，具体代码在<a href="https://github.com/xuelangZF/LeetCode/blob/master/BitManipulation/371_SumOfTwoIntegers.py">这里</a>。</p><h1 id="讨论：百家之长"><a href="#讨论：百家之长" class="headerlink" title="讨论：百家之长"></a>讨论：百家之长</h1><p>如果说 LeetCode 上面的题目是一块块金子的话，那么评论区就是一个点缀着钻石的矿山。多少次，当你绞尽脑汁终于 AC，兴致勃发地来到评论区准备吹水。结果迎接你的却是大师级的代码。于是，你高呼：尼玛，竟然可以这样！然后闭关去思考那些优秀的代码，顺便默默鄙视自己。</p><p>除了优秀的代码，有时候还会有直观的解题思路分享，方便看看别人是如何解决这个问题的。<a href="https://discuss.leetcode.com/user/missmary">@MissMary</a>在“两个排序数组中找出中位数”这个题目中，给出了一个很棒的解释：<a href="https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation/2">Share my o(log(min(m,n)) solution with explanation</a>，获得了400多个赞。</p><p>你也可以评论大牛的代码，或者提出改进方案，不过有时候可能并非如你预期一样改进后代码会运行地更好。在 <a href="https://leetcode.com/problems/n-queens/">51. N-Queens</a> 的讨论 <a href="https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand">Accepted 4ms c++ solution use backtracking and bitmask, easy understand</a> 中，@binz 在讨论区中纳闷自己将数组 vector<int> （取值非零即一）改为 vector<bool> 后，运行时间变慢。@prime_tang 随后就给出建议说最好不要用 vector<bool>，并给出了<a href="https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand/16">两个 StackOverflow 答案</a>。</p><p>当你逛讨论区久了，你可能会有那么一两个偶像，比如<a href="https://discuss.leetcode.com/user/stefanpochmann">@StefanPochmann</a>。他的一个粉丝 @agave 曾经问 StefanPochmann 一个问题：</p><blockquote><p>Hi Stefan, I noticed that you use a lot of Python tricks in your solutions, like “v +&#x3D; val,” and so on… Could you share where you found them, or how your learned about them, and maybe where we can find more of that? Thanks!</p></blockquote><p>StefanPochmann 也不厌其烦地给出了自己的答案：</p><blockquote><p>@agave From many places, though I’d say I learned a lot on CheckiO and StackOverflow (when I was very active there for a month). You might also find some by googling python code golf.</p></blockquote><p>原来大神也是在 StackOverflow 上修炼的，看来需要在 <a href="http://selfboot.cn/2016/06/26/why_need_to_read_StackOverflow/">为什么离不开 StackOverflow</a> 中添加一个理由了：因为 StefanPochmann 都混迹于此。</p><p>类似这样友好，充满技术味道的讨论，在 LeetCode 讨论区遍地都是，绝对值得我们去好好探访。</p><h1 id="成长：大有益处"><a href="#成长：大有益处" class="headerlink" title="成长：大有益处"></a>成长：大有益处</h1><p>偶尔会听旁边人说 XX 大牛 LeetCode 刷了3遍，成功进微软，还拿了 special offer！听起来好像刷题就可以解决工作问题，不过要知道还有<a href="http://www.1point3acres.com/bbs/thread-168094-1-1.html">刷5遍 LeetCode 仍然没有找到工作的人</a>呢。所以，不要想着刷了很多遍就可以找到好工作，毕竟比你刷的还疯狂的大有人在（开个玩笑）。</p><p>不过，想想前面列出的那些好处，应该值得大家抽出点时间来刷刷题了吧。</p><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://mindhacks.cn/2008/04/18/learning-from-polya/">跟波利亚学解题</a><br><a href="http://coolshell.cn/articles/8138.html">为什么我反对纯算法面试题</a><br><a href="http://blog.iderzheng.com/coding-is-not-everything/">聊聊刷题</a><br><a href="https://www.zhihu.com/question/35133069">如何看待中国学生为了进 Google、微软等企业疯狂地刷题？</a><br><a href="http://coolshell.cn/articles/12052.html">LeetCode 编程训练</a><br><a href="https://www.zhihu.com/question/25574458">国内有哪些好的刷题网站?</a></p>]]></content>
    
    
    <summary type="html">这篇文章深入探讨了为什么我们需要在LeetCode上刷题。它详细解释了刷题的好处，包括提高抽象思维能力，理解算法的时间和空间复杂度，以及学习不同编程语言的特性。如果你正在寻找提升编程能力的方法，那么这篇文章将为你提供宝贵的建议。</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://selfboot.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://selfboot.cn/tags/Python/"/>
    
    <category term="思考" scheme="https://selfboot.cn/tags/%E6%80%9D%E8%80%83/"/>
    
    <category term="C++" scheme="https://selfboot.cn/tags/C/"/>
    
  </entry>
  
</feed>
